/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
export namespace Components {
    interface SpxAccordion {
        "classContent": string;
        "classContentActive": string;
        "classContentInactive": string;
        "classContentText": string;
        "classContentTextActive": string;
        "classContentTextInactive": string;
        "classHeader": string;
        "classHeaderActive": string;
        "classHeaderIcon": string;
        "classHeaderIconActive": string;
        "classHeaderIconContainer": string;
        "classHeaderIconContainerActive": string;
        "classHeaderIconContainerInactive": string;
        "classHeaderIconInactive": string;
        "classHeaderInactive": string;
        "classHeaderText": string;
        "classHeaderTextActive": string;
        "classHeaderTextInactive": string;
        /**
          * Closes the accordion.
         */
        "close": () => Promise<void>;
        "contentColor": string;
        /**
          * Content text.
         */
        "contentText": string;
        /**
          * Content text tag.
         */
        "contentTextTag": string;
        "contentTransitionDuration": string;
        "contentTransitionTimingFunction": string;
        /**
          * Disables the animation. Set this attribute if the accordion is starting hidden in the DOM.
         */
        "disableAnimation": boolean;
        "fontSize": string;
        "fontSizeMax": number;
        "fontSizeMin": number;
        /**
          * Space between header and content.
          * @CSS
         */
        "gap": string;
        "gapMax": number;
        "gapMin": number;
        "headerColor": string;
        /**
          * Gap between header text and icon.
          * @CSS
         */
        "headerGap": string;
        "headerGapMax": number;
        "headerGapMin": number;
        /**
          * Header text.
         */
        "headerText": string;
        /**
          * Header text when component is closed.
         */
        "headerTextOpen": string;
        /**
          * Header text tag.
         */
        "headerTextTag": string;
        /**
          * Indicator icon.
         */
        "indicatorIcon": string;
        /**
          * Indicator icon transform.
         */
        "indicatorIconTransform": string;
        /**
          * Indicator icon type.
         */
        "indicatorIconType": string;
        /**
          * Sets the ID to link different accordions together.
         */
        "link": string;
        /**
          * Sets the type of link.
          * @choice 'open', 'close', 'toggle'
         */
        "linkType": string;
        /**
          * Opens the accordion.
         */
        "open": () => Promise<void>;
        /**
          * State of accordion.
         */
        "openState": boolean;
        "reload": () => Promise<void>;
        /**
          * Reverse icon positioning.
         */
        "reverse": boolean;
        /**
          * Styling.
          * @choice 'default', 'fluid', 'headless'
         */
        "styling": string;
        /**
          * Toggles the accordion.
         */
        "toggle": () => Promise<void>;
    }
    interface SpxAnimate {
        /**
          * Clip-path value the animation starts from.
         */
        "clipPath": string;
        /**
          * Delay before animation starts.
         */
        "delay": number;
        "display": string;
        /**
          * Animation duration.
         */
        "duration": number;
        /**
          * Ease being used. Accepts all common GSAP options.
         */
        "ease": string;
        /**
          * Filter value the animation starts from.
         */
        "filter": string;
        /**
          * Determines if animation should only play once. (if viewport is true)
         */
        "once": boolean;
        /**
          * Opacity level the animation starts from.
         */
        "opacity": number;
        /**
          * Plays animation.
         */
        "play": (from?: number, suppressEvents?: boolean) => Promise<void>;
        "reload": () => Promise<void>;
        /**
          * Repeats the animation. -1 to repeat indefinitely.
         */
        "repeat": number;
        /**
          * Time to wait between repetitions.
         */
        "repeatDelay": number;
        /**
          * Restarts animation.
         */
        "restart": (includeDelay?: boolean, suppressEvents?: boolean) => Promise<void>;
        /**
          * Reverses the animation.
         */
        "reverse": boolean;
        /**
          * Amount of time elements should be staggered by.
         */
        "stagger": number;
        /**
          * The target element that should be animated inside the component.
         */
        "target": string;
        /**
          * Starts animation when target is in the viewport.
         */
        "viewport": boolean;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginBottom": string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginLeft": string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginRight": string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginTop": string;
        /**
          * X position the animation starts from.
         */
        "x": any;
        /**
          * Y position the animation starts from.
         */
        "y": any;
        /**
          * Causes the animation to go back and forth, alternating backward and forward on each repeat.
         */
        "yoyo": boolean;
    }
    interface SpxClassToggle {
        "display": string;
        /**
          * Specify a local storage item, so the toggle state will be remembered when the user visits the site again.
         */
        "local": string;
        "reload": () => Promise<void>;
        /**
          * Target element. Can take any querySelector value. (id, class, tag etc.) If none is set it will default to the first element inside.
         */
        "target": string;
        /**
          * List of classes that should be toggled.
         */
        "toggle": string;
    }
    interface SpxCode {
        "background": string;
        "borderRadius": string;
        /**
          * Enable clipboard button.
         */
        "clipboard": boolean;
        "clipboardButtonBackground": string;
        "clipboardButtonColor": string;
        "clipboardButtonFontSize": string;
        "clipboardButtonFontWeight": any;
        "clipboardButtonPadding": string;
        "clipboardButtonText": string;
        "clipboardButtonTextCopied": string;
        "clipboardButtonTextTransform": string;
        "display": string;
        "fontSize": string;
        "height": string;
        /**
          * Load component when it enters the viewport.
         */
        "lazy": boolean;
        /**
          * Enable line numbers.
         */
        "lineNumbers": boolean;
        "lineNumbersBackground": string;
        "lineNumbersColor": string;
        /**
          * Start of line number.
         */
        "lineNumbersStart": number;
        "maxWidth": string;
        "overflow": string;
        "padding": string;
        "reload": () => Promise<void>;
        /**
          * Hide scrollbar.
         */
        "scrollbar": boolean;
        /**
          * Colour theme.
          * @choice 'default', 'dracula'
         */
        "theme": string;
        /**
          * Determines the programming language.
          * @choice 'markup', 'css', 'php'
          * @editor 'css'
         */
        "type": string;
    }
    interface SpxDocs {
        "bpMobile": number;
        "contentPadding": string;
        "contentPaddingYMax": number;
        "contentPaddingYMin": number;
        "gap": string;
        "navigationBackground": string;
        "navigationGap": string;
        "navigationGapMax": number;
        "navigationGapMin": number;
        "navigationHeadingTag": string;
        "navigationHeightAdjust": string;
        "navigationLinkColor": string;
        "navigationLinkColorActive": string;
        "navigationLinkFontSize": any;
        "navigationLinkFontSizeMax": number;
        "navigationLinkFontSizeMin": number;
        "navigationLinkFontWeight": string;
        "navigationLinkLetterSpacing": string;
        "navigationLinkLineHeight": string;
        "navigationLinkTextTransform": string;
        "navigationPaddingY": string;
        "navigationPaddingYMax": number;
        "navigationPaddingYMin": number;
        "navigationTitleColor": string;
        "navigationTitleFontSize": any;
        "navigationTitleFontSizeMax": number;
        "navigationTitleFontSizeMin": number;
        "navigationTitleFontWeight": string;
        "navigationTitleLetterSpacing": string;
        "navigationTitleLineHeight": string;
        "navigationTitleMarginBottom": number;
        "navigationTitleMarginBottomMax": number;
        "navigationTitleMarginBottomMin": number;
        "navigationTitleTextTransform": string;
        "navigationTop": string;
        "offsetMarginTop": string;
        /**
          * Activates automatic navigation scrolling and sets the offset.
         */
        "scrolling": number;
        /**
          * Create a separator between sections.
         */
        "separator": string;
        /**
          * Styling.
          * @choice 'default', 'fluid'
         */
        "styling": string;
        "uniqueId": boolean;
    }
    interface SpxEdit {
        "display": string;
        /**
          * Watch editable state.
         */
        "editable": boolean;
        "name": string;
        "outline": string;
        "outlineFocus": string;
        "placeholder": string;
        "placeholderColor": string;
        "placeholderOpacity": string;
        "subfield": boolean;
        "type": string;
    }
    interface SpxEditButton {
        "background": string;
        /**
          * Discard button background.
          * @CSS
         */
        "backgroundDiscard": string;
        "border": string;
        "borderRadius": string;
        "classButton": string;
        "classButtonDiscard": string;
        "classLoader": string;
        "color": string;
        /**
          * Discard button color.
          * @CSS
         */
        "colorDiscard": string;
        /**
          * Discard changes.
         */
        "discard": () => Promise<void>;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "distanceX": string;
        /**
          * Distance to the edge of the viewport on the y-axis.
          * @CSS
         */
        "distanceY": string;
        /**
          * Enable editing.
         */
        "edit": () => Promise<void>;
        /**
          * Corresponding ID for editable fields. This property is needed when multiple edit-button components are used on the page. Simply apply a "data-spx-edit-id" attribute with the same value to editable elements.
         */
        "editId": string;
        "fontFamily": string;
        "fontSize": string;
        "fontSizeMax": number;
        "fontSizeMin": number;
        /**
          * Gap between the buttons.
          * @CSS
         */
        "gap": string;
        "padding": string;
        "paddingXMax": number;
        "paddingXMin": number;
        "paddingYMax": number;
        "paddingYMin": number;
        /**
          * Component position in page.
          * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
         */
        "position": string;
        /**
          * CSS property position of button.
          * @editor 'absolute'
         */
        "positionCss": | 'fixed'
    | 'absolute'
    | 'relative'
    | 'static';
        "reload": () => Promise<void>;
        /**
          * Save changes.
         */
        "save": () => Promise<void>;
        /**
          * Styling.
          * @choice 'default', 'fluid', 'headless'
         */
        "styling": string;
        "test": boolean;
        /**
          * Discard button text.
         */
        "textDiscard": string;
        /**
          * Edit button text.
         */
        "textEdit": string;
        /**
          * Save button text.
         */
        "textSave": string;
        /**
          * Success message.
         */
        "textSuccess": string;
        "zIndex": number;
    }
    interface SpxGroup {
        "display": string;
        "reload": () => Promise<void>;
        /**
          * Specifies a target element.
         */
        "target": string;
    }
    interface SpxIcon {
        "color": string;
        /**
          * Icon code.
         */
        "icon": string;
        /**
          * Icon size.
         */
        "size": string;
        "sizeMax": number;
        "sizeMin": number;
        /**
          * Styling.
          * @choice 'default', 'fluid'
         */
        "styling": string;
        /**
          * Icon type.
          * @choice 'ionicons', 'caret'
         */
        "type": string;
    }
    interface SpxIframe {
        "display": string;
        "documentBorder": string;
        "documentBorderRadius": string;
        "documentHeight": string;
        "documentWidth": string;
        /**
          * Automatically resize iframe to fit content.
         */
        "fit": boolean;
        /**
          * Lazy load content.
         */
        "lazy": boolean;
        "reload": () => Promise<void>;
        /**
          * Screen size of the site shown inside the iframe.
         */
        "size": string;
        /**
          * Source for the iframe.
         */
        "src": string;
        /**
          * Screen size of the site shown inside the iframe.
          * @choice 'resize', 'document', 'default'
         */
        "type": string;
    }
    interface SpxImageComparison {
        "color": string;
        "height": string;
        "iconColor": string;
        /**
          * Lazy load attribute.
         */
        "loading": 'auto' | 'lazy' | 'eager';
        "reload": () => Promise<void>;
        /**
          * Image URL of the before image.
         */
        "srcAfter": string;
        /**
          * Image URL of the after image.
         */
        "srcBefore": string;
        /**
          * Opening state in pixels.
         */
        "start": number;
    }
    interface SpxLightbox {
        "display": string;
        "height": string;
        "overlayColor": string;
        "reload": () => Promise<void>;
        "width": string;
    }
    interface SpxLoader {
        "color": string;
        "speed": string;
    }
    interface SpxMasonry {
        /**
          * Columns for different screen sizes. Example value: 1000:3;600:2 - this will switch to a three column layout when the screen size is under 1000px and to a two column layout under 600px.
         */
        "bpColumns": string;
        /**
          * Number of columns.
         */
        "columns": number;
        /**
          * Gap between images.
          * @CSS
         */
        "gap": string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\Get::gallery($fieldName, $type) ?>
         */
        "images": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc": string;
        /**
          * Recalculates grid.
         */
        "recalc": () => Promise<void>;
        "reload": () => Promise<void>;
    }
    interface SpxMockup {
        /**
          * Samsung S8 color.
          * @choice 'black', 'blue'
         */
        "colorGalaxyS8": string;
        /**
          * Google Pixel color.
          * @choice 'silver', 'black', 'blue'
         */
        "colorGooglePixel": string;
        /**
          * iPad Pro color.
          * @choice 'silver', 'gold', 'rosegold', 'spacegray'
         */
        "colorIpadPro": string;
        /**
          * iPhone 8 color.
          * @choice 'silver', 'gold', 'spacegray'
         */
        "colorIphone8": string;
        /**
          * MacBook color.
          * @choice 'silver', 'gold', 'rosegold', 'spacegray'
         */
        "colorMacbook": string;
        /**
          * MacBook Pro color.
          * @choice 'silver', 'spacegray'
         */
        "colorMacbookPro": string;
        "display": string;
        "imagePosition": string;
        "reload": () => Promise<void>;
        /**
          * Image src if no inner slot is used.
         */
        "src": string;
        /**
          * Device type.
          * @choice 'iphone-8', 'iphone-x', 'google-pixel-2-xl', 'google-pixel', 'galaxy-s8', 'ipad-pro', 'surface-pro', 'surface-book', 'macbook', 'macbook-pro', 'surface-studio', 'imac-pro', 'apple-watch'
         */
        "type": string;
    }
    interface SpxNavigation {
        "childBorder": string;
        /**
          * Child menu border-radius.
          * @CSS
         */
        "childBorderRadius": string;
        /**
          * Child menu box-shadow.
          * @CSS
         */
        "childBoxShadow": string;
        /**
          * Gap between nested child menus.
          * @CSS
         */
        "childChildGap": string;
        /**
          * Gap between top level menu items and child menus.
          * @CSS
         */
        "childGap": string;
        /**
          * Indicator icon..
         */
        "childIcon": string;
        /**
          * Indicator icon type.
         */
        "childIconType": string;
        /**
          * Gap between child menu indicator and text.
          * @CSS
         */
        "childIndicatorGap": string;
        "childItemBackground": string;
        "childItemBackgroundHover": string;
        "childItemColor": string;
        "childItemColorHover": string;
        "childItemPadding": string;
        /**
          * Child menu placement.
          * @CSS 
          * @choice 'start', 'end'
         */
        "childPlacement": string;
        "fontSize": string;
        "itemTransitionDuration": string;
        "itemTransitionTimingFunction": string;
        /**
          * Underlines all links.
         */
        "itemUnderline": boolean;
        /**
          * Underlines all links on hover.
         */
        "itemUnderlineHover": boolean;
        /**
          * Renders a WordPress menu.
          * @helper &lt;?php spx\Get::navigation("myMenu") ?>
         */
        "menu": string;
        /**
          * Mobile breakpoint.
         */
        "mobile": number;
        /**
          * Mobile button icon.
         */
        "mobileIcon": string;
        /**
          * Mobile button icon type.
         */
        "mobileIconType": string;
        "mobileItemBackground": string;
        "mobileItemBackgroundHover": string;
        "mobileItemColor": string;
        "mobileItemColorHover": string;
        "mobileItemNestedMarginLeft": string;
        "mobileItemPadding": string;
        /**
          * Mobile placement.
          * @CSS 
          * @choice 'start', 'end'
         */
        "mobilePlacement": string;
        "parentItemBackground": string;
        "parentItemBackgroundHover": string;
        "parentItemColor": string;
        "parentItemColorHover": string;
        /**
          * Gap between parent menu items.
          * @CSS
         */
        "parentItemGap": string;
        "parentItemPadding": string;
        "reload": () => Promise<void>;
        /**
          * Renders menu vertically.
         */
        "vertical": boolean;
    }
    interface SpxNotation {
        /**
          * Turn animation on or off when animation.
         */
        "animation": boolean;
        /**
          * Animation duration.
         */
        "animationDuration": number;
        /**
          * Autoplay.
         */
        "autoplay": boolean;
        /**
          * Brackets.
         */
        "brackets": string;
        /**
          * Remove the annotation.
         */
        "clear": () => Promise<void>;
        "color": string;
        "delay": number;
        "display": string;
        /**
          * Create a group on annotations by applying a "data-spx-annotation" to elements within.
         */
        "group": boolean;
        /**
          * Hides the annotation. (non animated)
         */
        "hide": () => Promise<void>;
        /**
          * Number of iterations.
         */
        "iterations": number;
        /**
          * Annotate multiline text.
         */
        "multiline": boolean;
        /**
          * Padding around notations.
         */
        "padding": number;
        "reload": () => Promise<void>;
        /**
          * Draws the annotation.
         */
        "show": () => Promise<void>;
        /**
          * Stroke width.
         */
        "strokeWidth": number;
        /**
          * Type of notation.
          * @choice 'underline', 'box', 'circle', 'highlight', 'strike-through', 'crossed-off', 'bracket'
         */
        "type": string;
    }
    interface SpxOffset {
        "display": string;
        /**
          * Recalculate distance.
         */
        "recalc": () => Promise<void>;
        "reload": () => Promise<void>;
        /**
          * Target element.
          * @editor '.header1'
         */
        "target": string;
    }
    interface SpxScrollspy {
        /**
          * Applied class to active content element.
         */
        "contentClass": string;
        "display": string;
        /**
          * Applied class to active navigation element.
         */
        "navClass": string;
        /**
          * Selects the height of an element (any querySelector value) or number that is used for offsetting how far from the top the next section is activated.
         */
        "offset": any;
        "reload": () => Promise<void>;
        /**
          * Activates automatic navigation scrolling and sets the offset.
         */
        "scrolling": number;
        /**
          * Target element. Can take any querySelector value. (id, class, tag etc.)
         */
        "target": string;
        /**
          * Appends the currently active link to the end of the URL.
         */
        "urlChange": boolean;
    }
    interface SpxShare {
        "classItem": string;
        "fontSize": string;
        "fontSizeMax": number;
        "fontSizeMin": number;
        "itemBackground": string;
        "itemBorderRadius": string;
        /**
          * Gap between buttons.
          * @CSS
         */
        "itemColor": string;
        /**
          * Filter hover.
          * @CSS
         */
        "itemFilterHover": string;
        /**
          * Gap between buttons.
          * @CSS
         */
        "itemGap": string;
        "itemGapMax": number;
        "itemGapMin": number;
        "itemPadding": string;
        "itemPaddingMax": number;
        "itemPaddingMin": number;
        "itemSize": string;
        "itemSizeMax": number;
        "itemSizeMin": number;
        "itemTransitionDuration": string;
        "itemTransitionTimingFunction": string;
        "reload": () => Promise<void>;
        /**
          * Styling.
          * @choice 'default', 'fluid', 'headless'
         */
        "styling": string;
        /**
          * Button href target.
         */
        "target": string;
        /**
          * Button theme.
          * @choice 'default', 'outline', 'minimal'
         */
        "theme": string;
        /**
          * Render buttons vertically.
         */
        "vertical": boolean;
    }
    interface SpxSlider {
        /**
          * Automatically adjusts height of slider.
         */
        "autoheight": boolean;
        /**
          * Starts navigating to the next slide when page is loaded.
         */
        "autoplay": boolean;
        /**
          * Autoplay delay.
         */
        "autoplayDelay": number;
        /**
          * Disable autoplay after interaction with slides.
         */
        "autoplayDisableOnInteraction": boolean;
        /**
          * Starts navigating to the next slide when page is loaded.
         */
        "bpTabs": string;
        /**
          * Centers slides in viewport.
         */
        "centeredSlides": boolean;
        /**
          * Slider direction.
          * @choice 'horizontal', 'vertical'
         */
        "direction": string;
        /**
          * Slider effect.
          * @choice 'slide', 'effect'
         */
        "effect": string;
        /**
          * Image object-fit.
          * @choice 'fill', 'contain', 'cover', 'scale-down', 'none'
         */
        "imageObjectFit": string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\Get::gallery($fieldName, $type) ?>
         */
        "images": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc": string;
        /**
          * Loops all slides infinitely.
         */
        "loop": boolean;
        /**
          * Max height.
          * @editor '500px'
         */
        "maxHeight": string;
        /**
          * Max width.
          * @editor '500px'
         */
        "maxWidth": string;
        "navigation": boolean;
        "navigationBackground": string;
        "navigationBorderRadius": string;
        "navigationColor": string;
        /**
          * Navigation distance.
          * @CSS
         */
        "navigationDistanceX": string;
        /**
          * Navigation icon type.
         */
        "navigationIconNext": string;
        /**
          * Navigation icon type.
         */
        "navigationIconPrev": string;
        /**
          * Navigation icon type.
         */
        "navigationIconType": string;
        "navigationPadding": string;
        /**
          * Navigation size.
          * @CSS
         */
        "navigationSize": string;
        /**
          * Pagination type.
          * @choice 'bullets', 'tabs', 'none'
         */
        "pagination": string;
        "paginationBulletsBackground": string;
        "paginationBulletsBackgroundActive": string;
        /**
          * Make bullets clickable.
         */
        "paginationBulletsClickable": boolean;
        /**
          * Will only keep a selected amount of bullets visible.
         */
        "paginationBulletsDynamic": boolean;
        /**
          * Amount of dynamic bullets.
         */
        "paginationBulletsDynamicAmount": number;
        /**
          * Size of the bullets.
          * @CSS
         */
        "paginationBulletsSize": string;
        /**
          * Space between the bullets.
          * @CSS
         */
        "paginationBulletsSpaceBetween": string;
        "paginationTabsGapMax": number;
        "paginationTabsGapMin": number;
        "paginationTabsInnerGapMax": number;
        "paginationTabsInnerGapMin": number;
        "paginationTabsMarginBottomMax": number;
        "paginationTabsMarginBottomMin": number;
        "paginationTabsMaxWidth": string;
        "paginationTabsPaddingMax": number;
        "paginationTabsPaddingMin": number;
        "paginationTransitionDuration": string;
        "paginationTransitionTimingFunction": string;
        /**
          * Filter property for the previous and next elements.
         */
        "prevNextFilter": string;
        "reload": () => Promise<void>;
        /**
          * Screen reader message for first slide.
         */
        "slideMessageFirst": string;
        /**
          * Screen reader message for last slide.
         */
        "slideMessageLast": string;
        /**
          * Screen reader message for next slide.
         */
        "slideMessageNext": string;
        /**
          * Screen reader message for previous slide.
         */
        "slideMessagePrevious": string;
        /**
          * Amount of slides shown at once.
         */
        "slidesPerView": number;
        /**
          * Space between slides.
         */
        "spaceBetween": number;
        /**
          * Sliding speed.
         */
        "speed": number;
    }
    interface SpxSlideshow {
        "display": string;
        /**
          * Duration of slideshow to complete one cycle.
          * @CSS
         */
        "duration": string;
        /**
          * Gap between inner elements.
          * @CSS
         */
        "gap": string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\get::gallery($fieldName, $type) ?>
         */
        "images": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc": string;
        /**
          * Max width of inner elements.
          * @CSS
         */
        "maxWidth": string;
        /**
          * If not set with this attribute, overflow should be set on the parent element.
          * @CSS
         */
        "overflow": string;
    }
    interface SpxSnackbar {
        "animationDelay": string;
        "animationDuration": string;
        "background": string;
        "border": string;
        "borderRadius": string;
        "classButton": string;
        "classText": string;
        /**
          * Adds option to close snackbar after its creation.
         */
        "closeable": boolean;
        "color": string;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "distanceX": string;
        /**
          * Distance to the edge of the viewport on the y-axis.
          * @CSS
         */
        "distanceY": string;
        /**
          * Makes snackbar not removable.
          * @editor '#components'
         */
        "fixed": boolean;
        "fontSize": string;
        "fontSizeMax": number;
        "fontSizeMin": number;
        /**
          * Unique identifier for snackbar instance.
          * @editor '#components'
         */
        "identifier": string;
        "padding": string;
        "paddingMax": number;
        "paddingMin": number;
        /**
          * Component position in page.
          * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
         */
        "position": string;
        /**
          * CSS property position of button.
          * @editor 'absolute'
         */
        "positionCss": | 'fixed'
    | 'absolute'
    | 'relative'
    | 'static';
        "reload": () => Promise<void>;
        /**
          * Reverses the close button if "closable" prop is true.
         */
        "reverse": boolean;
        /**
          * Space between snackbars.
         */
        "spaceBetween": string;
        /**
          * Styling.
          * @choice 'default', 'fluid', 'headless'
         */
        "styling": string;
        /**
          * Element where snackbars should be created in.
          * @editor '#components'
         */
        "target": string;
        /**
          * Text inside snackbar.
         */
        "text": string;
        "zIndex": number;
    }
    interface SpxTextPath {
        /**
          * Text to be shown.
         */
        "text": string;
        /**
          * Text color.
         */
        "textColor": string;
        /**
          * Text rotation amount.
         */
        "textRotate": number;
        /**
          * Text rotation animation duration.
         */
        "textRotationDuration": number;
        /**
          * Text size.
         */
        "textSize": string;
    }
    interface SpxTypewriter {
        /**
          * Automatically starts writing.
         */
        "autoStart": boolean;
        /**
          * Writing delay in ms. Also accepts 'natural' value.
         */
        "delay": any;
        /**
          * Delete delay in ms. Also accepts 'natural' value.
         */
        "deleteSpeed": any;
        "display": string;
        /**
          * Loops the animation.
         */
        "loop": boolean;
        /**
          * Start animation.
         */
        "play": () => Promise<void>;
        /**
          * Stop animation.
         */
        "stop": () => Promise<void>;
        /**
          * Text that should be written.
         */
        "text": string;
    }
}
declare global {
    interface HTMLSpxAccordionElement extends Components.SpxAccordion, HTMLStencilElement {
    }
    var HTMLSpxAccordionElement: {
        prototype: HTMLSpxAccordionElement;
        new (): HTMLSpxAccordionElement;
    };
    interface HTMLSpxAnimateElement extends Components.SpxAnimate, HTMLStencilElement {
    }
    var HTMLSpxAnimateElement: {
        prototype: HTMLSpxAnimateElement;
        new (): HTMLSpxAnimateElement;
    };
    interface HTMLSpxClassToggleElement extends Components.SpxClassToggle, HTMLStencilElement {
    }
    var HTMLSpxClassToggleElement: {
        prototype: HTMLSpxClassToggleElement;
        new (): HTMLSpxClassToggleElement;
    };
    interface HTMLSpxCodeElement extends Components.SpxCode, HTMLStencilElement {
    }
    var HTMLSpxCodeElement: {
        prototype: HTMLSpxCodeElement;
        new (): HTMLSpxCodeElement;
    };
    interface HTMLSpxDocsElement extends Components.SpxDocs, HTMLStencilElement {
    }
    var HTMLSpxDocsElement: {
        prototype: HTMLSpxDocsElement;
        new (): HTMLSpxDocsElement;
    };
    interface HTMLSpxEditElement extends Components.SpxEdit, HTMLStencilElement {
    }
    var HTMLSpxEditElement: {
        prototype: HTMLSpxEditElement;
        new (): HTMLSpxEditElement;
    };
    interface HTMLSpxEditButtonElement extends Components.SpxEditButton, HTMLStencilElement {
    }
    var HTMLSpxEditButtonElement: {
        prototype: HTMLSpxEditButtonElement;
        new (): HTMLSpxEditButtonElement;
    };
    interface HTMLSpxGroupElement extends Components.SpxGroup, HTMLStencilElement {
    }
    var HTMLSpxGroupElement: {
        prototype: HTMLSpxGroupElement;
        new (): HTMLSpxGroupElement;
    };
    interface HTMLSpxIconElement extends Components.SpxIcon, HTMLStencilElement {
    }
    var HTMLSpxIconElement: {
        prototype: HTMLSpxIconElement;
        new (): HTMLSpxIconElement;
    };
    interface HTMLSpxIframeElement extends Components.SpxIframe, HTMLStencilElement {
    }
    var HTMLSpxIframeElement: {
        prototype: HTMLSpxIframeElement;
        new (): HTMLSpxIframeElement;
    };
    interface HTMLSpxImageComparisonElement extends Components.SpxImageComparison, HTMLStencilElement {
    }
    var HTMLSpxImageComparisonElement: {
        prototype: HTMLSpxImageComparisonElement;
        new (): HTMLSpxImageComparisonElement;
    };
    interface HTMLSpxLightboxElement extends Components.SpxLightbox, HTMLStencilElement {
    }
    var HTMLSpxLightboxElement: {
        prototype: HTMLSpxLightboxElement;
        new (): HTMLSpxLightboxElement;
    };
    interface HTMLSpxLoaderElement extends Components.SpxLoader, HTMLStencilElement {
    }
    var HTMLSpxLoaderElement: {
        prototype: HTMLSpxLoaderElement;
        new (): HTMLSpxLoaderElement;
    };
    interface HTMLSpxMasonryElement extends Components.SpxMasonry, HTMLStencilElement {
    }
    var HTMLSpxMasonryElement: {
        prototype: HTMLSpxMasonryElement;
        new (): HTMLSpxMasonryElement;
    };
    interface HTMLSpxMockupElement extends Components.SpxMockup, HTMLStencilElement {
    }
    var HTMLSpxMockupElement: {
        prototype: HTMLSpxMockupElement;
        new (): HTMLSpxMockupElement;
    };
    interface HTMLSpxNavigationElement extends Components.SpxNavigation, HTMLStencilElement {
    }
    var HTMLSpxNavigationElement: {
        prototype: HTMLSpxNavigationElement;
        new (): HTMLSpxNavigationElement;
    };
    interface HTMLSpxNotationElement extends Components.SpxNotation, HTMLStencilElement {
    }
    var HTMLSpxNotationElement: {
        prototype: HTMLSpxNotationElement;
        new (): HTMLSpxNotationElement;
    };
    interface HTMLSpxOffsetElement extends Components.SpxOffset, HTMLStencilElement {
    }
    var HTMLSpxOffsetElement: {
        prototype: HTMLSpxOffsetElement;
        new (): HTMLSpxOffsetElement;
    };
    interface HTMLSpxScrollspyElement extends Components.SpxScrollspy, HTMLStencilElement {
    }
    var HTMLSpxScrollspyElement: {
        prototype: HTMLSpxScrollspyElement;
        new (): HTMLSpxScrollspyElement;
    };
    interface HTMLSpxShareElement extends Components.SpxShare, HTMLStencilElement {
    }
    var HTMLSpxShareElement: {
        prototype: HTMLSpxShareElement;
        new (): HTMLSpxShareElement;
    };
    interface HTMLSpxSliderElement extends Components.SpxSlider, HTMLStencilElement {
    }
    var HTMLSpxSliderElement: {
        prototype: HTMLSpxSliderElement;
        new (): HTMLSpxSliderElement;
    };
    interface HTMLSpxSlideshowElement extends Components.SpxSlideshow, HTMLStencilElement {
    }
    var HTMLSpxSlideshowElement: {
        prototype: HTMLSpxSlideshowElement;
        new (): HTMLSpxSlideshowElement;
    };
    interface HTMLSpxSnackbarElement extends Components.SpxSnackbar, HTMLStencilElement {
    }
    var HTMLSpxSnackbarElement: {
        prototype: HTMLSpxSnackbarElement;
        new (): HTMLSpxSnackbarElement;
    };
    interface HTMLSpxTextPathElement extends Components.SpxTextPath, HTMLStencilElement {
    }
    var HTMLSpxTextPathElement: {
        prototype: HTMLSpxTextPathElement;
        new (): HTMLSpxTextPathElement;
    };
    interface HTMLSpxTypewriterElement extends Components.SpxTypewriter, HTMLStencilElement {
    }
    var HTMLSpxTypewriterElement: {
        prototype: HTMLSpxTypewriterElement;
        new (): HTMLSpxTypewriterElement;
    };
    interface HTMLElementTagNameMap {
        "spx-accordion": HTMLSpxAccordionElement;
        "spx-animate": HTMLSpxAnimateElement;
        "spx-class-toggle": HTMLSpxClassToggleElement;
        "spx-code": HTMLSpxCodeElement;
        "spx-docs": HTMLSpxDocsElement;
        "spx-edit": HTMLSpxEditElement;
        "spx-edit-button": HTMLSpxEditButtonElement;
        "spx-group": HTMLSpxGroupElement;
        "spx-icon": HTMLSpxIconElement;
        "spx-iframe": HTMLSpxIframeElement;
        "spx-image-comparison": HTMLSpxImageComparisonElement;
        "spx-lightbox": HTMLSpxLightboxElement;
        "spx-loader": HTMLSpxLoaderElement;
        "spx-masonry": HTMLSpxMasonryElement;
        "spx-mockup": HTMLSpxMockupElement;
        "spx-navigation": HTMLSpxNavigationElement;
        "spx-notation": HTMLSpxNotationElement;
        "spx-offset": HTMLSpxOffsetElement;
        "spx-scrollspy": HTMLSpxScrollspyElement;
        "spx-share": HTMLSpxShareElement;
        "spx-slider": HTMLSpxSliderElement;
        "spx-slideshow": HTMLSpxSlideshowElement;
        "spx-snackbar": HTMLSpxSnackbarElement;
        "spx-text-path": HTMLSpxTextPathElement;
        "spx-typewriter": HTMLSpxTypewriterElement;
    }
}
declare namespace LocalJSX {
    interface SpxAccordion {
        "classContent"?: string;
        "classContentActive"?: string;
        "classContentInactive"?: string;
        "classContentText"?: string;
        "classContentTextActive"?: string;
        "classContentTextInactive"?: string;
        "classHeader"?: string;
        "classHeaderActive"?: string;
        "classHeaderIcon"?: string;
        "classHeaderIconActive"?: string;
        "classHeaderIconContainer"?: string;
        "classHeaderIconContainerActive"?: string;
        "classHeaderIconContainerInactive"?: string;
        "classHeaderIconInactive"?: string;
        "classHeaderInactive"?: string;
        "classHeaderText"?: string;
        "classHeaderTextActive"?: string;
        "classHeaderTextInactive"?: string;
        "contentColor"?: string;
        /**
          * Content text.
         */
        "contentText"?: string;
        /**
          * Content text tag.
         */
        "contentTextTag"?: string;
        "contentTransitionDuration"?: string;
        "contentTransitionTimingFunction"?: string;
        /**
          * Disables the animation. Set this attribute if the accordion is starting hidden in the DOM.
         */
        "disableAnimation"?: boolean;
        "fontSize"?: string;
        "fontSizeMax"?: number;
        "fontSizeMin"?: number;
        /**
          * Space between header and content.
          * @CSS
         */
        "gap"?: string;
        "gapMax"?: number;
        "gapMin"?: number;
        "headerColor"?: string;
        /**
          * Gap between header text and icon.
          * @CSS
         */
        "headerGap"?: string;
        "headerGapMax"?: number;
        "headerGapMin"?: number;
        /**
          * Header text.
         */
        "headerText"?: string;
        /**
          * Header text when component is closed.
         */
        "headerTextOpen"?: string;
        /**
          * Header text tag.
         */
        "headerTextTag"?: string;
        /**
          * Indicator icon.
         */
        "indicatorIcon"?: string;
        /**
          * Indicator icon transform.
         */
        "indicatorIconTransform"?: string;
        /**
          * Indicator icon type.
         */
        "indicatorIconType"?: string;
        /**
          * Sets the ID to link different accordions together.
         */
        "link"?: string;
        /**
          * Sets the type of link.
          * @choice 'open', 'close', 'toggle'
         */
        "linkType"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxAccordionDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * State of accordion.
         */
        "openState"?: boolean;
        /**
          * Reverse icon positioning.
         */
        "reverse"?: boolean;
        /**
          * Styling.
          * @choice 'default', 'fluid', 'headless'
         */
        "styling"?: string;
    }
    interface SpxAnimate {
        /**
          * Clip-path value the animation starts from.
         */
        "clipPath"?: string;
        /**
          * Delay before animation starts.
         */
        "delay"?: number;
        "display"?: string;
        /**
          * Animation duration.
         */
        "duration"?: number;
        /**
          * Ease being used. Accepts all common GSAP options.
         */
        "ease"?: string;
        /**
          * Filter value the animation starts from.
         */
        "filter"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxAnimateDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Determines if animation should only play once. (if viewport is true)
         */
        "once"?: boolean;
        /**
          * Opacity level the animation starts from.
         */
        "opacity"?: number;
        /**
          * Repeats the animation. -1 to repeat indefinitely.
         */
        "repeat"?: number;
        /**
          * Time to wait between repetitions.
         */
        "repeatDelay"?: number;
        /**
          * Reverses the animation.
         */
        "reverse"?: boolean;
        /**
          * Amount of time elements should be staggered by.
         */
        "stagger"?: number;
        /**
          * The target element that should be animated inside the component.
         */
        "target"?: string;
        /**
          * Starts animation when target is in the viewport.
         */
        "viewport"?: boolean;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginBottom"?: string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginLeft"?: string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginRight"?: string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginTop"?: string;
        /**
          * X position the animation starts from.
         */
        "x"?: any;
        /**
          * Y position the animation starts from.
         */
        "y"?: any;
        /**
          * Causes the animation to go back and forth, alternating backward and forward on each repeat.
         */
        "yoyo"?: boolean;
    }
    interface SpxClassToggle {
        "display"?: string;
        /**
          * Specify a local storage item, so the toggle state will be remembered when the user visits the site again.
         */
        "local"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxClassToggleDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Target element. Can take any querySelector value. (id, class, tag etc.) If none is set it will default to the first element inside.
         */
        "target"?: string;
        /**
          * List of classes that should be toggled.
         */
        "toggle"?: string;
    }
    interface SpxCode {
        "background"?: string;
        "borderRadius"?: string;
        /**
          * Enable clipboard button.
         */
        "clipboard"?: boolean;
        "clipboardButtonBackground"?: string;
        "clipboardButtonColor"?: string;
        "clipboardButtonFontSize"?: string;
        "clipboardButtonFontWeight"?: any;
        "clipboardButtonPadding"?: string;
        "clipboardButtonText"?: string;
        "clipboardButtonTextCopied"?: string;
        "clipboardButtonTextTransform"?: string;
        "display"?: string;
        "fontSize"?: string;
        "height"?: string;
        /**
          * Load component when it enters the viewport.
         */
        "lazy"?: boolean;
        /**
          * Enable line numbers.
         */
        "lineNumbers"?: boolean;
        "lineNumbersBackground"?: string;
        "lineNumbersColor"?: string;
        /**
          * Start of line number.
         */
        "lineNumbersStart"?: number;
        "maxWidth"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxCodeDidLoad"?: (event: CustomEvent<any>) => void;
        "overflow"?: string;
        "padding"?: string;
        /**
          * Hide scrollbar.
         */
        "scrollbar"?: boolean;
        /**
          * Colour theme.
          * @choice 'default', 'dracula'
         */
        "theme"?: string;
        /**
          * Determines the programming language.
          * @choice 'markup', 'css', 'php'
          * @editor 'css'
         */
        "type"?: string;
    }
    interface SpxDocs {
        "bpMobile"?: number;
        "contentPadding"?: string;
        "contentPaddingYMax"?: number;
        "contentPaddingYMin"?: number;
        "gap"?: string;
        "navigationBackground"?: string;
        "navigationGap"?: string;
        "navigationGapMax"?: number;
        "navigationGapMin"?: number;
        "navigationHeadingTag"?: string;
        "navigationHeightAdjust"?: string;
        "navigationLinkColor"?: string;
        "navigationLinkColorActive"?: string;
        "navigationLinkFontSize"?: any;
        "navigationLinkFontSizeMax"?: number;
        "navigationLinkFontSizeMin"?: number;
        "navigationLinkFontWeight"?: string;
        "navigationLinkLetterSpacing"?: string;
        "navigationLinkLineHeight"?: string;
        "navigationLinkTextTransform"?: string;
        "navigationPaddingY"?: string;
        "navigationPaddingYMax"?: number;
        "navigationPaddingYMin"?: number;
        "navigationTitleColor"?: string;
        "navigationTitleFontSize"?: any;
        "navigationTitleFontSizeMax"?: number;
        "navigationTitleFontSizeMin"?: number;
        "navigationTitleFontWeight"?: string;
        "navigationTitleLetterSpacing"?: string;
        "navigationTitleLineHeight"?: string;
        "navigationTitleMarginBottom"?: number;
        "navigationTitleMarginBottomMax"?: number;
        "navigationTitleMarginBottomMin"?: number;
        "navigationTitleTextTransform"?: string;
        "navigationTop"?: string;
        "offsetMarginTop"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxDocsDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Activates automatic navigation scrolling and sets the offset.
         */
        "scrolling"?: number;
        /**
          * Create a separator between sections.
         */
        "separator"?: string;
        /**
          * Styling.
          * @choice 'default', 'fluid'
         */
        "styling"?: string;
        "uniqueId"?: boolean;
    }
    interface SpxEdit {
        "display"?: string;
        /**
          * Watch editable state.
         */
        "editable"?: boolean;
        "name"?: string;
        "outline"?: string;
        "outlineFocus"?: string;
        "placeholder"?: string;
        "placeholderColor"?: string;
        "placeholderOpacity"?: string;
        "subfield"?: boolean;
        "type"?: string;
    }
    interface SpxEditButton {
        "background"?: string;
        /**
          * Discard button background.
          * @CSS
         */
        "backgroundDiscard"?: string;
        "border"?: string;
        "borderRadius"?: string;
        "classButton"?: string;
        "classButtonDiscard"?: string;
        "classLoader"?: string;
        "color"?: string;
        /**
          * Discard button color.
          * @CSS
         */
        "colorDiscard"?: string;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "distanceX"?: string;
        /**
          * Distance to the edge of the viewport on the y-axis.
          * @CSS
         */
        "distanceY"?: string;
        /**
          * Corresponding ID for editable fields. This property is needed when multiple edit-button components are used on the page. Simply apply a "data-spx-edit-id" attribute with the same value to editable elements.
         */
        "editId"?: string;
        "fontFamily"?: string;
        "fontSize"?: string;
        "fontSizeMax"?: number;
        "fontSizeMin"?: number;
        /**
          * Gap between the buttons.
          * @CSS
         */
        "gap"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxEditButtonDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Fires after pressing the discard button.
         */
        "onSpxEditButtonDiscard"?: (event: CustomEvent<any>) => void;
        /**
          * Fires after pressing the save button.
         */
        "onSpxEditButtonSave"?: (event: CustomEvent<any>) => void;
        "padding"?: string;
        "paddingXMax"?: number;
        "paddingXMin"?: number;
        "paddingYMax"?: number;
        "paddingYMin"?: number;
        /**
          * Component position in page.
          * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
         */
        "position"?: string;
        /**
          * CSS property position of button.
          * @editor 'absolute'
         */
        "positionCss"?: | 'fixed'
    | 'absolute'
    | 'relative'
    | 'static';
        /**
          * Styling.
          * @choice 'default', 'fluid', 'headless'
         */
        "styling"?: string;
        "test"?: boolean;
        /**
          * Discard button text.
         */
        "textDiscard"?: string;
        /**
          * Edit button text.
         */
        "textEdit"?: string;
        /**
          * Save button text.
         */
        "textSave"?: string;
        /**
          * Success message.
         */
        "textSuccess"?: string;
        "zIndex"?: number;
    }
    interface SpxGroup {
        "display"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxGroupDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Specifies a target element.
         */
        "target"?: string;
    }
    interface SpxIcon {
        "color"?: string;
        /**
          * Icon code.
         */
        "icon"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxIconDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Icon size.
         */
        "size"?: string;
        "sizeMax"?: number;
        "sizeMin"?: number;
        /**
          * Styling.
          * @choice 'default', 'fluid'
         */
        "styling"?: string;
        /**
          * Icon type.
          * @choice 'ionicons', 'caret'
         */
        "type"?: string;
    }
    interface SpxIframe {
        "display"?: string;
        "documentBorder"?: string;
        "documentBorderRadius"?: string;
        "documentHeight"?: string;
        "documentWidth"?: string;
        /**
          * Automatically resize iframe to fit content.
         */
        "fit"?: boolean;
        /**
          * Lazy load content.
         */
        "lazy"?: boolean;
        /**
          * Fires after component has loaded.
         */
        "onSpxIframeDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Screen size of the site shown inside the iframe.
         */
        "size"?: string;
        /**
          * Source for the iframe.
         */
        "src"?: string;
        /**
          * Screen size of the site shown inside the iframe.
          * @choice 'resize', 'document', 'default'
         */
        "type"?: string;
    }
    interface SpxImageComparison {
        "color"?: string;
        "height"?: string;
        "iconColor"?: string;
        /**
          * Lazy load attribute.
         */
        "loading"?: 'auto' | 'lazy' | 'eager';
        /**
          * Fires after component has loaded.
         */
        "onSpxImageComparisonDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Image URL of the before image.
         */
        "srcAfter"?: string;
        /**
          * Image URL of the after image.
         */
        "srcBefore"?: string;
        /**
          * Opening state in pixels.
         */
        "start"?: number;
    }
    interface SpxLightbox {
        "display"?: string;
        "height"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxLightboxDidLoad"?: (event: CustomEvent<any>) => void;
        "overlayColor"?: string;
        "width"?: string;
    }
    interface SpxLoader {
        "color"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxLoaderDidLoad"?: (event: CustomEvent<any>) => void;
        "speed"?: string;
    }
    interface SpxMasonry {
        /**
          * Columns for different screen sizes. Example value: 1000:3;600:2 - this will switch to a three column layout when the screen size is under 1000px and to a two column layout under 600px.
         */
        "bpColumns"?: string;
        /**
          * Number of columns.
         */
        "columns"?: number;
        /**
          * Gap between images.
          * @CSS
         */
        "gap"?: string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\Get::gallery($fieldName, $type) ?>
         */
        "images"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxMasonryDidLoad"?: (event: CustomEvent<any>) => void;
    }
    interface SpxMockup {
        /**
          * Samsung S8 color.
          * @choice 'black', 'blue'
         */
        "colorGalaxyS8"?: string;
        /**
          * Google Pixel color.
          * @choice 'silver', 'black', 'blue'
         */
        "colorGooglePixel"?: string;
        /**
          * iPad Pro color.
          * @choice 'silver', 'gold', 'rosegold', 'spacegray'
         */
        "colorIpadPro"?: string;
        /**
          * iPhone 8 color.
          * @choice 'silver', 'gold', 'spacegray'
         */
        "colorIphone8"?: string;
        /**
          * MacBook color.
          * @choice 'silver', 'gold', 'rosegold', 'spacegray'
         */
        "colorMacbook"?: string;
        /**
          * MacBook Pro color.
          * @choice 'silver', 'spacegray'
         */
        "colorMacbookPro"?: string;
        "display"?: string;
        "imagePosition"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxMockupDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Image src if no inner slot is used.
         */
        "src"?: string;
        /**
          * Device type.
          * @choice 'iphone-8', 'iphone-x', 'google-pixel-2-xl', 'google-pixel', 'galaxy-s8', 'ipad-pro', 'surface-pro', 'surface-book', 'macbook', 'macbook-pro', 'surface-studio', 'imac-pro', 'apple-watch'
         */
        "type"?: string;
    }
    interface SpxNavigation {
        "childBorder"?: string;
        /**
          * Child menu border-radius.
          * @CSS
         */
        "childBorderRadius"?: string;
        /**
          * Child menu box-shadow.
          * @CSS
         */
        "childBoxShadow"?: string;
        /**
          * Gap between nested child menus.
          * @CSS
         */
        "childChildGap"?: string;
        /**
          * Gap between top level menu items and child menus.
          * @CSS
         */
        "childGap"?: string;
        /**
          * Indicator icon..
         */
        "childIcon"?: string;
        /**
          * Indicator icon type.
         */
        "childIconType"?: string;
        /**
          * Gap between child menu indicator and text.
          * @CSS
         */
        "childIndicatorGap"?: string;
        "childItemBackground"?: string;
        "childItemBackgroundHover"?: string;
        "childItemColor"?: string;
        "childItemColorHover"?: string;
        "childItemPadding"?: string;
        /**
          * Child menu placement.
          * @CSS 
          * @choice 'start', 'end'
         */
        "childPlacement"?: string;
        "fontSize"?: string;
        "itemTransitionDuration"?: string;
        "itemTransitionTimingFunction"?: string;
        /**
          * Underlines all links.
         */
        "itemUnderline"?: boolean;
        /**
          * Underlines all links on hover.
         */
        "itemUnderlineHover"?: boolean;
        /**
          * Renders a WordPress menu.
          * @helper &lt;?php spx\Get::navigation("myMenu") ?>
         */
        "menu"?: string;
        /**
          * Mobile breakpoint.
         */
        "mobile"?: number;
        /**
          * Mobile button icon.
         */
        "mobileIcon"?: string;
        /**
          * Mobile button icon type.
         */
        "mobileIconType"?: string;
        "mobileItemBackground"?: string;
        "mobileItemBackgroundHover"?: string;
        "mobileItemColor"?: string;
        "mobileItemColorHover"?: string;
        "mobileItemNestedMarginLeft"?: string;
        "mobileItemPadding"?: string;
        /**
          * Mobile placement.
          * @CSS 
          * @choice 'start', 'end'
         */
        "mobilePlacement"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxNavigationDidLoad"?: (event: CustomEvent<any>) => void;
        "parentItemBackground"?: string;
        "parentItemBackgroundHover"?: string;
        "parentItemColor"?: string;
        "parentItemColorHover"?: string;
        /**
          * Gap between parent menu items.
          * @CSS
         */
        "parentItemGap"?: string;
        "parentItemPadding"?: string;
        /**
          * Renders menu vertically.
         */
        "vertical"?: boolean;
    }
    interface SpxNotation {
        /**
          * Turn animation on or off when animation.
         */
        "animation"?: boolean;
        /**
          * Animation duration.
         */
        "animationDuration"?: number;
        /**
          * Autoplay.
         */
        "autoplay"?: boolean;
        /**
          * Brackets.
         */
        "brackets"?: string;
        "color"?: string;
        "delay"?: number;
        "display"?: string;
        /**
          * Create a group on annotations by applying a "data-spx-annotation" to elements within.
         */
        "group"?: boolean;
        /**
          * Number of iterations.
         */
        "iterations"?: number;
        /**
          * Annotate multiline text.
         */
        "multiline"?: boolean;
        /**
          * Fires after component has loaded.
         */
        "onSpxNotationDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Padding around notations.
         */
        "padding"?: number;
        /**
          * Stroke width.
         */
        "strokeWidth"?: number;
        /**
          * Type of notation.
          * @choice 'underline', 'box', 'circle', 'highlight', 'strike-through', 'crossed-off', 'bracket'
         */
        "type"?: string;
    }
    interface SpxOffset {
        "display"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxOffsetDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Target element.
          * @editor '.header1'
         */
        "target"?: string;
    }
    interface SpxScrollspy {
        /**
          * Applied class to active content element.
         */
        "contentClass"?: string;
        "display"?: string;
        /**
          * Applied class to active navigation element.
         */
        "navClass"?: string;
        /**
          * Selects the height of an element (any querySelector value) or number that is used for offsetting how far from the top the next section is activated.
         */
        "offset"?: any;
        /**
          * Fires after component has loaded.
         */
        "onSpxScrollspyDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Activates automatic navigation scrolling and sets the offset.
         */
        "scrolling"?: number;
        /**
          * Target element. Can take any querySelector value. (id, class, tag etc.)
         */
        "target"?: string;
        /**
          * Appends the currently active link to the end of the URL.
         */
        "urlChange"?: boolean;
    }
    interface SpxShare {
        "classItem"?: string;
        "fontSize"?: string;
        "fontSizeMax"?: number;
        "fontSizeMin"?: number;
        "itemBackground"?: string;
        "itemBorderRadius"?: string;
        /**
          * Gap between buttons.
          * @CSS
         */
        "itemColor"?: string;
        /**
          * Filter hover.
          * @CSS
         */
        "itemFilterHover"?: string;
        /**
          * Gap between buttons.
          * @CSS
         */
        "itemGap"?: string;
        "itemGapMax"?: number;
        "itemGapMin"?: number;
        "itemPadding"?: string;
        "itemPaddingMax"?: number;
        "itemPaddingMin"?: number;
        "itemSize"?: string;
        "itemSizeMax"?: number;
        "itemSizeMin"?: number;
        "itemTransitionDuration"?: string;
        "itemTransitionTimingFunction"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxShareDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Styling.
          * @choice 'default', 'fluid', 'headless'
         */
        "styling"?: string;
        /**
          * Button href target.
         */
        "target"?: string;
        /**
          * Button theme.
          * @choice 'default', 'outline', 'minimal'
         */
        "theme"?: string;
        /**
          * Render buttons vertically.
         */
        "vertical"?: boolean;
    }
    interface SpxSlider {
        /**
          * Automatically adjusts height of slider.
         */
        "autoheight"?: boolean;
        /**
          * Starts navigating to the next slide when page is loaded.
         */
        "autoplay"?: boolean;
        /**
          * Autoplay delay.
         */
        "autoplayDelay"?: number;
        /**
          * Disable autoplay after interaction with slides.
         */
        "autoplayDisableOnInteraction"?: boolean;
        /**
          * Starts navigating to the next slide when page is loaded.
         */
        "bpTabs"?: string;
        /**
          * Centers slides in viewport.
         */
        "centeredSlides"?: boolean;
        /**
          * Slider direction.
          * @choice 'horizontal', 'vertical'
         */
        "direction"?: string;
        /**
          * Slider effect.
          * @choice 'slide', 'effect'
         */
        "effect"?: string;
        /**
          * Image object-fit.
          * @choice 'fill', 'contain', 'cover', 'scale-down', 'none'
         */
        "imageObjectFit"?: string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\Get::gallery($fieldName, $type) ?>
         */
        "images"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc"?: string;
        /**
          * Loops all slides infinitely.
         */
        "loop"?: boolean;
        /**
          * Max height.
          * @editor '500px'
         */
        "maxHeight"?: string;
        /**
          * Max width.
          * @editor '500px'
         */
        "maxWidth"?: string;
        "navigation"?: boolean;
        "navigationBackground"?: string;
        "navigationBorderRadius"?: string;
        "navigationColor"?: string;
        /**
          * Navigation distance.
          * @CSS
         */
        "navigationDistanceX"?: string;
        /**
          * Navigation icon type.
         */
        "navigationIconNext"?: string;
        /**
          * Navigation icon type.
         */
        "navigationIconPrev"?: string;
        /**
          * Navigation icon type.
         */
        "navigationIconType"?: string;
        "navigationPadding"?: string;
        /**
          * Navigation size.
          * @CSS
         */
        "navigationSize"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxSliderDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Pagination type.
          * @choice 'bullets', 'tabs', 'none'
         */
        "pagination"?: string;
        "paginationBulletsBackground"?: string;
        "paginationBulletsBackgroundActive"?: string;
        /**
          * Make bullets clickable.
         */
        "paginationBulletsClickable"?: boolean;
        /**
          * Will only keep a selected amount of bullets visible.
         */
        "paginationBulletsDynamic"?: boolean;
        /**
          * Amount of dynamic bullets.
         */
        "paginationBulletsDynamicAmount"?: number;
        /**
          * Size of the bullets.
          * @CSS
         */
        "paginationBulletsSize"?: string;
        /**
          * Space between the bullets.
          * @CSS
         */
        "paginationBulletsSpaceBetween"?: string;
        "paginationTabsGapMax"?: number;
        "paginationTabsGapMin"?: number;
        "paginationTabsInnerGapMax"?: number;
        "paginationTabsInnerGapMin"?: number;
        "paginationTabsMarginBottomMax"?: number;
        "paginationTabsMarginBottomMin"?: number;
        "paginationTabsMaxWidth"?: string;
        "paginationTabsPaddingMax"?: number;
        "paginationTabsPaddingMin"?: number;
        "paginationTransitionDuration"?: string;
        "paginationTransitionTimingFunction"?: string;
        /**
          * Filter property for the previous and next elements.
         */
        "prevNextFilter"?: string;
        /**
          * Screen reader message for first slide.
         */
        "slideMessageFirst"?: string;
        /**
          * Screen reader message for last slide.
         */
        "slideMessageLast"?: string;
        /**
          * Screen reader message for next slide.
         */
        "slideMessageNext"?: string;
        /**
          * Screen reader message for previous slide.
         */
        "slideMessagePrevious"?: string;
        /**
          * Amount of slides shown at once.
         */
        "slidesPerView"?: number;
        /**
          * Space between slides.
         */
        "spaceBetween"?: number;
        /**
          * Sliding speed.
         */
        "speed"?: number;
    }
    interface SpxSlideshow {
        "display"?: string;
        /**
          * Duration of slideshow to complete one cycle.
          * @CSS
         */
        "duration"?: string;
        /**
          * Gap between inner elements.
          * @CSS
         */
        "gap"?: string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\get::gallery($fieldName, $type) ?>
         */
        "images"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc"?: string;
        /**
          * Max width of inner elements.
          * @CSS
         */
        "maxWidth"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxSlideshowDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * If not set with this attribute, overflow should be set on the parent element.
          * @CSS
         */
        "overflow"?: string;
    }
    interface SpxSnackbar {
        "animationDelay"?: string;
        "animationDuration"?: string;
        "background"?: string;
        "border"?: string;
        "borderRadius"?: string;
        "classButton"?: string;
        "classText"?: string;
        /**
          * Adds option to close snackbar after its creation.
         */
        "closeable"?: boolean;
        "color"?: string;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "distanceX"?: string;
        /**
          * Distance to the edge of the viewport on the y-axis.
          * @CSS
         */
        "distanceY"?: string;
        /**
          * Makes snackbar not removable.
          * @editor '#components'
         */
        "fixed"?: boolean;
        "fontSize"?: string;
        "fontSizeMax"?: number;
        "fontSizeMin"?: number;
        /**
          * Unique identifier for snackbar instance.
          * @editor '#components'
         */
        "identifier"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxSnackbarDidLoad"?: (event: CustomEvent<any>) => void;
        "padding"?: string;
        "paddingMax"?: number;
        "paddingMin"?: number;
        /**
          * Component position in page.
          * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
         */
        "position"?: string;
        /**
          * CSS property position of button.
          * @editor 'absolute'
         */
        "positionCss"?: | 'fixed'
    | 'absolute'
    | 'relative'
    | 'static';
        /**
          * Reverses the close button if "closable" prop is true.
         */
        "reverse"?: boolean;
        /**
          * Space between snackbars.
         */
        "spaceBetween"?: string;
        /**
          * Styling.
          * @choice 'default', 'fluid', 'headless'
         */
        "styling"?: string;
        /**
          * Element where snackbars should be created in.
          * @editor '#components'
         */
        "target"?: string;
        /**
          * Text inside snackbar.
         */
        "text"?: string;
        "zIndex"?: number;
    }
    interface SpxTextPath {
        "onSpxTextCircleDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Text to be shown.
         */
        "text"?: string;
        /**
          * Text color.
         */
        "textColor"?: string;
        /**
          * Text rotation amount.
         */
        "textRotate"?: number;
        /**
          * Text rotation animation duration.
         */
        "textRotationDuration"?: number;
        /**
          * Text size.
         */
        "textSize"?: string;
    }
    interface SpxTypewriter {
        /**
          * Automatically starts writing.
         */
        "autoStart"?: boolean;
        /**
          * Writing delay in ms. Also accepts 'natural' value.
         */
        "delay"?: any;
        /**
          * Delete delay in ms. Also accepts 'natural' value.
         */
        "deleteSpeed"?: any;
        "display"?: string;
        /**
          * Loops the animation.
         */
        "loop"?: boolean;
        /**
          * Fires after component has loaded.
         */
        "onSpxTypewriterDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Text that should be written.
         */
        "text"?: string;
    }
    interface IntrinsicElements {
        "spx-accordion": SpxAccordion;
        "spx-animate": SpxAnimate;
        "spx-class-toggle": SpxClassToggle;
        "spx-code": SpxCode;
        "spx-docs": SpxDocs;
        "spx-edit": SpxEdit;
        "spx-edit-button": SpxEditButton;
        "spx-group": SpxGroup;
        "spx-icon": SpxIcon;
        "spx-iframe": SpxIframe;
        "spx-image-comparison": SpxImageComparison;
        "spx-lightbox": SpxLightbox;
        "spx-loader": SpxLoader;
        "spx-masonry": SpxMasonry;
        "spx-mockup": SpxMockup;
        "spx-navigation": SpxNavigation;
        "spx-notation": SpxNotation;
        "spx-offset": SpxOffset;
        "spx-scrollspy": SpxScrollspy;
        "spx-share": SpxShare;
        "spx-slider": SpxSlider;
        "spx-slideshow": SpxSlideshow;
        "spx-snackbar": SpxSnackbar;
        "spx-text-path": SpxTextPath;
        "spx-typewriter": SpxTypewriter;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "spx-accordion": LocalJSX.SpxAccordion & JSXBase.HTMLAttributes<HTMLSpxAccordionElement>;
            "spx-animate": LocalJSX.SpxAnimate & JSXBase.HTMLAttributes<HTMLSpxAnimateElement>;
            "spx-class-toggle": LocalJSX.SpxClassToggle & JSXBase.HTMLAttributes<HTMLSpxClassToggleElement>;
            "spx-code": LocalJSX.SpxCode & JSXBase.HTMLAttributes<HTMLSpxCodeElement>;
            "spx-docs": LocalJSX.SpxDocs & JSXBase.HTMLAttributes<HTMLSpxDocsElement>;
            "spx-edit": LocalJSX.SpxEdit & JSXBase.HTMLAttributes<HTMLSpxEditElement>;
            "spx-edit-button": LocalJSX.SpxEditButton & JSXBase.HTMLAttributes<HTMLSpxEditButtonElement>;
            "spx-group": LocalJSX.SpxGroup & JSXBase.HTMLAttributes<HTMLSpxGroupElement>;
            "spx-icon": LocalJSX.SpxIcon & JSXBase.HTMLAttributes<HTMLSpxIconElement>;
            "spx-iframe": LocalJSX.SpxIframe & JSXBase.HTMLAttributes<HTMLSpxIframeElement>;
            "spx-image-comparison": LocalJSX.SpxImageComparison & JSXBase.HTMLAttributes<HTMLSpxImageComparisonElement>;
            "spx-lightbox": LocalJSX.SpxLightbox & JSXBase.HTMLAttributes<HTMLSpxLightboxElement>;
            "spx-loader": LocalJSX.SpxLoader & JSXBase.HTMLAttributes<HTMLSpxLoaderElement>;
            "spx-masonry": LocalJSX.SpxMasonry & JSXBase.HTMLAttributes<HTMLSpxMasonryElement>;
            "spx-mockup": LocalJSX.SpxMockup & JSXBase.HTMLAttributes<HTMLSpxMockupElement>;
            "spx-navigation": LocalJSX.SpxNavigation & JSXBase.HTMLAttributes<HTMLSpxNavigationElement>;
            "spx-notation": LocalJSX.SpxNotation & JSXBase.HTMLAttributes<HTMLSpxNotationElement>;
            "spx-offset": LocalJSX.SpxOffset & JSXBase.HTMLAttributes<HTMLSpxOffsetElement>;
            "spx-scrollspy": LocalJSX.SpxScrollspy & JSXBase.HTMLAttributes<HTMLSpxScrollspyElement>;
            "spx-share": LocalJSX.SpxShare & JSXBase.HTMLAttributes<HTMLSpxShareElement>;
            "spx-slider": LocalJSX.SpxSlider & JSXBase.HTMLAttributes<HTMLSpxSliderElement>;
            "spx-slideshow": LocalJSX.SpxSlideshow & JSXBase.HTMLAttributes<HTMLSpxSlideshowElement>;
            "spx-snackbar": LocalJSX.SpxSnackbar & JSXBase.HTMLAttributes<HTMLSpxSnackbarElement>;
            "spx-text-path": LocalJSX.SpxTextPath & JSXBase.HTMLAttributes<HTMLSpxTextPathElement>;
            "spx-typewriter": LocalJSX.SpxTypewriter & JSXBase.HTMLAttributes<HTMLSpxTypewriterElement>;
        }
    }
}
