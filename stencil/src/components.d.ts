/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
export namespace Components {
    interface SpxAccordion {
        /**
          * Closes the accordion.
         */
        "close": () => Promise<void>;
        "contentColor": string;
        /**
          * Content text.
         */
        "contentText": string;
        /**
          * Content text tag.
         */
        "contentTextTag": string;
        "contentTransitionDuration": string;
        "contentTransitionTimingFunction": string;
        /**
          * Disables the animation. Set this attribute if the accordion is starting hidden in the DOM.
         */
        "disableAnimation": boolean;
        "fontSize": string;
        /**
          * Space between header and content.
          * @CSS
         */
        "gap": string;
        "headerColor": string;
        /**
          * Gap between header text and icon.
          * @CSS
         */
        "headerGap": string;
        /**
          * Header text.
         */
        "headerText": string;
        /**
          * Header text when component is closed.
         */
        "headerTextOpen": string;
        /**
          * Header text tag.
         */
        "headerTextTag": string;
        /**
          * Indicator icon.
         */
        "indicatorIcon": string;
        /**
          * Indicator icon transform.
         */
        "indicatorIconTransform": string;
        /**
          * Indicator icon type.
         */
        "indicatorIconType": string;
        /**
          * Sets the ID to link different accordions together.
         */
        "link": string;
        /**
          * Sets the type of link.
          * @choice 'open', 'close', 'toggle'
         */
        "linkType": string;
        /**
          * Opens the accordion.
         */
        "open": () => Promise<void>;
        /**
          * State of accordion.
         */
        "openState": boolean;
        "reload": () => Promise<void>;
        /**
          * Reverse icon positioning.
         */
        "reverse": boolean;
        /**
          * Toggles the accordion.
         */
        "toggle": () => Promise<void>;
    }
    interface SpxAnimate {
        /**
          * Delay before animation starts.
         */
        "delay": number;
        "display": string;
        /**
          * Animation duration.
         */
        "duration": number;
        /**
          * Ease being used. Accepts all common GSAP options.
         */
        "ease": string;
        /**
          * Determines if animation should only play once. (if viewport is true)
         */
        "once": boolean;
        /**
          * Opacity level the animation starts from.
         */
        "opacity": number;
        /**
          * Plays animation.
         */
        "play": (from?: number, suppressEvents?: boolean) => Promise<void>;
        "reload": () => Promise<void>;
        /**
          * Repeats the animation. -1 to repeat indefinitely.
         */
        "repeat": number;
        /**
          * Time to wait between repetitions.
         */
        "repeatDelay": number;
        /**
          * Restarts animation.
         */
        "restart": (includeDelay?: boolean, suppressEvents?: boolean) => Promise<void>;
        /**
          * Reverses the animation.
         */
        "reverse": boolean;
        /**
          * Amount of time elements should be staggered by.
         */
        "stagger": number;
        /**
          * The target element that should be animated inside the component.
         */
        "target": string;
        /**
          * Starts animation when target is in the viewport.
         */
        "viewport": boolean;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginBottom": string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginLeft": string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginRight": string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginTop": string;
        /**
          * X position the animation starts from.
         */
        "x": number;
        /**
          * Y position the animation starts from.
         */
        "y": number;
        /**
          * Causes the animation to go back and forth, alternating backward and forward on each repeat.
         */
        "yoyo": boolean;
    }
    interface SpxClassToggle {
        "display": string;
        /**
          * Specify a local storage item, so the toggle state will be remembered when the user visits the site again.
         */
        "local": string;
        "reload": () => Promise<void>;
        /**
          * Target element. Can take any querySelector value. (id, class, tag etc.) If none is set it will default to the first element inside.
         */
        "target": string;
        /**
          * List of classes that should be toggled.
         */
        "toggle": string;
    }
    interface SpxCode {
        "background": string;
        "borderRadius": string;
        /**
          * Enable clipboard button.
         */
        "clipboard": boolean;
        "clipboardButtonBackground": string;
        "clipboardButtonColor": string;
        "clipboardButtonFontSize": string;
        "clipboardButtonFontWeight": any;
        "clipboardButtonPadding": string;
        "clipboardButtonText": string;
        "clipboardButtonTextCopied": string;
        "clipboardButtonTextTransform": string;
        "display": string;
        "fontSize": string;
        "height": string;
        /**
          * Hide scrollbar.
         */
        "hideScrollbar": boolean;
        /**
          * Enable line numbers.
         */
        "lineNumbers": boolean;
        "lineNumbersBackground": string;
        "lineNumbersColor": string;
        "maxWidth": string;
        "overflow": string;
        "padding": string;
        "reload": () => Promise<void>;
        /**
          * Colour theme.
          * @choice 'default', 'dracula'
         */
        "theme": string;
        /**
          * Determines the programming language.
          * @choice 'markup', 'css', 'php'
          * @editor 'css'
         */
        "type": string;
    }
    interface SpxContainer {
        /**
          * Mobile breakpoint width.
         */
        "bpMobile": number;
        "buttonBackgroundPrimary": number;
        "buttonBackgroundSecondary": number;
        "buttonBorderRadius": string;
        "buttonColorPrimary": number;
        "buttonColorSecondary": number;
        "buttonFontSizeMax": number;
        "buttonFontSizeMin": number;
        "buttonFontWeight": string;
        "buttonMarginTopMax": number;
        "buttonMarginTopMin": number;
        "buttonMarginXMax": number;
        "buttonMarginXMin": number;
        "buttonPaddingXMax": number;
        "buttonPaddingXMin": number;
        "buttonPaddingYMax": number;
        "buttonPaddingYMin": number;
        "buttonTextTransform": string;
        /**
          * Gray color which will be used for sections and pages.
          * @choice 'blue-gray', 'cool-gray', 'gray', 'true-gray', 'warm-gray', 'red', 'orange', 'amber', 'yellow', 'lime', 'green', 'emerald', 'teal', 'cyan', 'light-blue', 'blue', 'indigo', 'violet', 'purple'; 'fuchsia', 'pink', 'rose'
         */
        "colorGray": string;
        /**
          * Primary color which will be used for sections and pages.
          * @choice 'blue-gray', 'cool-gray', 'gray', 'true-gray', 'warm-gray', 'red', 'orange', 'amber', 'yellow', 'lime', 'green', 'emerald', 'teal', 'cyan', 'light-blue', 'blue', 'indigo', 'violet', 'purple'; 'fuchsia', 'pink', 'rose'
         */
        "colorPrimary": string;
        /**
          * Secondary color which will be used for sections and pages.
          * @choice 'blue-gray', 'cool-gray', 'gray', 'true-gray', 'warm-gray', 'red', 'orange', 'amber', 'yellow', 'lime', 'green', 'emerald', 'teal', 'cyan', 'light-blue', 'blue', 'indigo', 'violet', 'purple'; 'fuchsia', 'pink', 'rose'
         */
        "colorSecondary": string;
        /**
          * Disable color generation.
         */
        "disableColors": boolean;
        "focusColor": string;
        /**
          * Primary font-family.
         */
        "fontFamilyPrimary": string;
        /**
          * Secondary font-family.
         */
        "fontFamilySecondary": string;
        "imageMaxWidth": string;
        /**
          * Linear scaling root number.
         */
        "linearBase": number;
        /**
          * Linear scaling maximum width.
         */
        "linearMaxW": number;
        /**
          * Linear scaling minimum width.
         */
        "linearMinW": number;
        /**
          * Section max-width.
         */
        "maxWidth": string;
        /**
          * Section max-width on mobile.
         */
        "maxWidthMobile": string;
        /**
          * Offsets first section to the height of the header.
         */
        "offsetHeader": boolean;
        /**
          * Space between content and outer edge of the viewport.
          * @CSS
         */
        "paddingX": string;
        /**
          * Space between content and outer edge of the viewport.
          * @CSS
         */
        "paddingXSm": string;
        "paddingYFirstMax": number;
        "paddingYFirstMin": number;
        "paddingYMax": number;
        "paddingYMaxWidth": number;
        "paddingYMin": number;
        "paddingYMultiplier": number;
        "preTitleBackground": string;
        "preTitleBorderRadius": string;
        "preTitleColor": string;
        "preTitleFontSizeMax": number;
        "preTitleFontSizeMin": number;
        "preTitleFontWeight": string;
        "preTitleLetterSpacing": string;
        "preTitleLineHeight": string;
        "preTitleMarginBottomMax": number;
        "preTitleMarginBottomMin": number;
        "preTitlePaddingXMax": number;
        "preTitlePaddingXMin": number;
        "preTitlePaddingYMax": number;
        "preTitlePaddingYMin": number;
        "preTitleTextTransform": string;
        "tabsFirstMarginTopMax": number;
        "tabsFirstMarginTopMin": number;
        "tabsMarginTopMax": number;
        "tabsMarginTopMin": number;
        /**
          * Tabs opacity.
          * @CSS
         */
        "tabsOpacity": number;
        "textColor": string;
        "textFontSizeMax": number;
        "textFontSizeMin": number;
        "textFontWeight": string;
        "textLetterSpacing": string;
        "textLineHeight": string;
        "textLinkDecorationColor": string;
        "textLinkDecorationColorHover": string;
        "textMarginTopMax": number;
        "textMarginTopMin": number;
        "textMaxWidth": string;
        "textTransform": string;
        "titleColor": string;
        "titleFontSizeMax": number;
        "titleFontSizeMin": number;
        "titleFontWeight": number;
        "titleLetterSpacing": string;
        "titleLineHeight": string;
        "titleMaxWidth": string;
        "titleTextTransform": string;
    }
    interface SpxEdit {
        "display": string;
        /**
          * Watch editable state.
         */
        "editable": boolean;
        "name": string;
        "outline": string;
        "outlineFocus": string;
        "placeholder": string;
        "placeholderColor": string;
        "placeholderOpacity": string;
        "subfield": boolean;
        "type": string;
    }
    interface SpxEditButton {
        "background": string;
        /**
          * Discard button background.
          * @CSS
         */
        "backgroundDiscard": string;
        "border": string;
        "borderRadius": string;
        "color": string;
        /**
          * Discard button color.
          * @CSS
         */
        "colorDiscard": string;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "distanceX": string;
        /**
          * Distance to the edge of the viewport on the y-axis.
          * @CSS
         */
        "distanceY": string;
        /**
          * Corresponding ID for editable fields. This property is needed when multiple edit-button components are used on the page. Simply apply a "data-spx-edit-id" attribute with the same value to editable elements.
         */
        "editId": string;
        "fontFamily": string;
        "fontSize": string;
        /**
          * Gap between the buttons.
          * @CSS
         */
        "gap": string;
        "padding": string;
        /**
          * Component position in page.
          * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
         */
        "position": string;
        /**
          * CSS property position of button.
          * @editor 'absolute'
         */
        "positionCss": | 'fixed'
    | 'absolute'
    | 'relative'
    | 'static';
        "reload": () => Promise<void>;
        "test": boolean;
        /**
          * Discard button text.
         */
        "textDiscard": string;
        /**
          * Edit button text.
         */
        "textEdit": string;
        /**
          * Save button text.
         */
        "textSave": string;
        /**
          * Success message.
         */
        "textSuccess": string;
        "zIndex": number;
    }
    interface SpxEditor {
        "fullscreen": boolean;
        "location": string;
    }
    interface SpxGroup {
        "display": string;
        "reload": () => Promise<void>;
        /**
          * Specifies a target element.
         */
        "target": string;
    }
    interface SpxIcon {
        "color": string;
        /**
          * Icon code.
         */
        "icon": string;
        /**
          * Icon size.
         */
        "size": string;
        /**
          * Icon type.
          * @choice 'ionicons', 'caret'
         */
        "type": string;
    }
    interface SpxIframe {
        "display": string;
        "documentBorder": string;
        "documentBorderRadius": string;
        "documentHeight": string;
        "documentWidth": string;
        /**
          * Automatically resize iframe to fit content.
         */
        "fit": boolean;
        /**
          * Lazy load content.
         */
        "lazy": boolean;
        "reload": () => Promise<void>;
        /**
          * Screen size of the site shown inside the iframe.
         */
        "size": string;
        /**
          * Source for the iframe.
         */
        "src": string;
        /**
          * Screen size of the site shown inside the iframe.
          * @choice 'resize', 'document', 'type'
         */
        "type": string;
    }
    interface SpxImageComparison {
        "color": string;
        "height": string;
        "iconColor": string;
        "reload": () => Promise<void>;
        /**
          * Image URL of the before image.
         */
        "srcAfter": string;
        /**
          * Image URL of the after image.
         */
        "srcBefore": string;
        /**
          * Opening state in pixels.
         */
        "start": number;
    }
    interface SpxLightbox {
        "display": string;
        "height": string;
        "overlayColor": string;
        "reload": () => Promise<void>;
        "width": string;
    }
    interface SpxLoader {
        "color": string;
        "speed": string;
    }
    interface SpxMasonry {
        /**
          * Columns for different screen sizes. Example value: 1000:3;600:2 - this will switch to a three column layout when the screen size is under 1000px and to a two column layout under 600px.
         */
        "bpColumns": string;
        /**
          * Number of columns.
         */
        "columns": number;
        /**
          * Gap between images.
          * @CSS
         */
        "gap": string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\Get::gallery($fieldName, $type) ?>
         */
        "images": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc": string;
        /**
          * Recalculate grid.
         */
        "recalc": () => Promise<void>;
        "reload": () => Promise<void>;
    }
    interface SpxMockup {
        /**
          * Samsung S8 color.
          * @choice 'black', 'blue'
         */
        "colorGalaxyS8": string;
        /**
          * Google Pixel color.
          * @choice 'silver', 'black', 'blue'
         */
        "colorGooglePixel": string;
        /**
          * iPad Pro color.
          * @choice 'silver', 'gold', 'rosegold', 'spacegray'
         */
        "colorIpadPro": string;
        /**
          * iPhone 8 color.
          * @choice 'silver', 'gold', 'spacegray'
         */
        "colorIphone8": string;
        /**
          * MacBook color.
          * @choice 'silver', 'gold', 'rosegold', 'spacegray'
         */
        "colorMacbook": string;
        /**
          * MacBook Pro color.
          * @choice 'silver', 'spacegray'
         */
        "colorMacbookPro": string;
        "display": string;
        "imagePosition": string;
        "reload": () => Promise<void>;
        /**
          * Image src if no inner slot is used.
         */
        "src": string;
        /**
          * Device type.
          * @choice 'iphone-8', 'iphone-x', 'google-pixel-2-xl', 'google-pixel', 'galaxy-s8', 'ipad-pro', 'surface-pro', 'surface-book', 'macbook', 'macbook-pro', 'surface-studio', 'imac-pro', 'apple-watch'
         */
        "type": string;
    }
    interface SpxNavigation {
        "childBorder": string;
        /**
          * Child menu border-radius.
          * @CSS
         */
        "childBorderRadius": string;
        /**
          * Child menu box-shadow.
          * @CSS
         */
        "childBoxShadow": string;
        /**
          * Gap between nested child menus.
          * @CSS
         */
        "childChildGap": string;
        /**
          * Gap between top level menu items and child menus.
          * @CSS
         */
        "childGap": string;
        /**
          * Indicator icon..
         */
        "childIcon": string;
        /**
          * Indicator icon type.
         */
        "childIconType": string;
        /**
          * Gap between child menu indicator and text.
          * @CSS
         */
        "childIndicatorGap": string;
        "childItemBackground": string;
        "childItemBackgroundHover": string;
        "childItemColor": string;
        "childItemColorHover": string;
        "childItemPadding": string;
        /**
          * Child menu placement.
          * @CSS 
          * @choice 'start', 'end'
         */
        "childPlacement": string;
        "fontSize": string;
        "itemTransitionDuration": string;
        "itemTransitionTimingFunction": string;
        /**
          * Underlines all links.
         */
        "itemUnderline": boolean;
        /**
          * Underlines all links on hover.
         */
        "itemUnderlineHover": boolean;
        /**
          * Renders a WordPress menu.
          * @helper &lt;?php spx\Get::navigation("myMenu") ?>
         */
        "menu": string;
        /**
          * Mobile breakpoint.
         */
        "mobile": number;
        /**
          * Mobile button icon.
         */
        "mobileIcon": string;
        /**
          * Mobile button icon type.
         */
        "mobileIconType": string;
        "mobileItemBackground": string;
        "mobileItemBackgroundHover": string;
        "mobileItemColor": string;
        "mobileItemColorHover": string;
        "mobileItemNestedMarginLeft": string;
        "mobileItemPadding": string;
        /**
          * Mobile placement.
          * @CSS 
          * @choice 'start', 'end'
         */
        "mobilePlacement": string;
        "parentItemBackground": string;
        "parentItemBackgroundHover": string;
        "parentItemColor": string;
        "parentItemColorHover": string;
        /**
          * Gap between parent menu items.
          * @CSS
         */
        "parentItemGap": string;
        "parentItemPadding": string;
        "reload": () => Promise<void>;
        /**
          * Renders menu vertically.
         */
        "vertical": boolean;
    }
    interface SpxNotation {
        /**
          * Turn animation on or off when animation.
         */
        "animation": boolean;
        /**
          * Animation duration.
         */
        "animationDuration": number;
        /**
          * Remove the annotation.
         */
        "clear": () => Promise<void>;
        "color": string;
        "display": string;
        /**
          * Hides the annotation. (non animated)
         */
        "hide": () => Promise<void>;
        /**
          * Number of iterations.
         */
        "iterations": number;
        /**
          * Annotate multiline text.
         */
        "multiline": boolean;
        "reload": () => Promise<void>;
        /**
          * Draws the annotation.
         */
        "show": () => Promise<void>;
        /**
          * Stroke width.
         */
        "strokeWidth": number;
        /**
          * Type of notation.
          * @choice 'underline', 'box', 'circle', 'highlight', 'strike-through', 'crossed-off', 'bracket'
         */
        "type": string;
    }
    interface SpxOffset {
        "display": string;
        "reload": () => Promise<void>;
        /**
          * Target element.
          * @editor '.header1'
         */
        "target": string;
    }
    interface SpxPageDocs {
        "bpMobile": number;
        "contentHeadingFontFamily": string;
        "navigationBackground": string;
        "navigationFontFamily": string;
        "navigationGapMax": number;
        "navigationGapMin": number;
        "navigationHeadingTag": string;
        "navigationHeightAdjust": string;
        "navigationLinkColor": string;
        "navigationLinkColorActive": string;
        "navigationLinkFontWeight": string;
        "navigationLinkLetterSpacing": string;
        "navigationLinkLineHeight": string;
        "navigationLinkTextTransform": string;
        "navigationSpaceYMax": number;
        "navigationSpaceYMin": number;
        "navigationTitleColor": string;
        "navigationTitleFontWeight": string;
        "navigationTitleLetterSpacing": string;
        "navigationTitleLineHeight": string;
        "navigationTitleMarginBottomMax": number;
        "navigationTitleMarginBottomMin": number;
        "navigationTitleTextTransform": string;
        "navigationTop": string;
        "offsetMarginTopMax": number;
        "offsetMarginTopMin": number;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "paddingX": string;
        "paddingYMax": number;
        "paddingYMin": number;
        "uniqueId": boolean;
    }
    interface SpxPageSingle {
        "authorColor": string;
        "authorFontFamily": string;
        "authorFontSizeMax": number;
        "authorFontSizeMin": number;
        "authorFontWeight": string;
        "authorLetterSpacing": string;
        "authorLineHeight": string;
        "authorMarginTopMax": number;
        "authorMarginTopMin": number;
        "authorTextTransform": string;
        "contentMarginTopMax": number;
        "contentMarginTopMin": number;
        "contentMaxWidth": string;
        "contentPaddingX": string;
        /**
          * Display date.
         */
        "date": boolean;
        "dateColor": string;
        "dateFontFamily": string;
        "dateFontSizeMax": number;
        "dateFontSizeMin": number;
        "dateFontWeight": string;
        "dateLetterSpacing": string;
        "dateLineHeight": string;
        "dateMarginTopMax": number;
        "dateMarginTopMin": number;
        "dateTextTransform": string;
        "headerBorderBottom": string;
        "headerPaddingBottomMax": number;
        "headerPaddingBottomMin": number;
        /**
          * Display image.
         */
        "image": boolean;
        "imageBorderRadius": string;
        "imageHeight": string;
        "imageObjectPosition": string;
        "imagePaddingX": string;
        "imageSpaceYMax": number;
        "imageSpaceYMin": number;
        /**
          * Mobile breakpoint.
         */
        "mobile": number;
        /**
          * Gets a WordPress post to render.
          * @helper &lt;?php spx\Get::post($postId, $dateFormat, $imageSize) ?>
         */
        "post": string;
        /**
          * Space to edge of the viewport.
         */
        "titleColor": string;
        "titleFontFamily": string;
        "titleFontSizeMax": number;
        "titleFontSizeMin": number;
        "titleFontWeight": string;
        "titleLetterSpacing": string;
        "titleLineHeight": string;
        "titleMarginTopMax": number;
        "titleMarginTopMin": number;
        "titleTextTransform": string;
    }
    interface SpxScrollspy {
        /**
          * Applied class to active content element.
         */
        "contentClass": string;
        "display": string;
        /**
          * Applied class to active navigation element.
         */
        "navClass": string;
        /**
          * Selects the height of an element (any querySelector value) or number that is used for offsetting how far from the top the next section is activated.
         */
        "offset": any;
        "reload": () => Promise<void>;
        /**
          * Automatically scroll to the active element
         */
        "scrolling": boolean;
        /**
          * Scrolling offset from the top.
         */
        "scrollingOffset": number;
        /**
          * Target element. Can take any querySelector value. (id, class, tag etc.)
         */
        "target": string;
        /**
          * Appends the currently active link to the end of the URL.
         */
        "urlChange": boolean;
    }
    interface SpxSectionButton {
        /**
          * Link href.
         */
        "href": string;
        /**
          * Icon.
         */
        "icon": string;
        "iconGapMax": number;
        "iconGapMin": number;
        /**
          * Link href.
         */
        "reverse": boolean;
        /**
          * Target.
         */
        "target": string;
        "transitionDuration": string;
        "transitionTimingFunction": string;
        /**
          * Button type.
          * @choice 'primary', 'secondary'
         */
        "type": string;
    }
    interface SpxSectionFooter {
        "background": string;
        /**
          * Gap between columns.
          * @CSS
         */
        "gap": string;
        "imageMaxHeight": string;
        "justifyContent": string;
        "maxWidth": string;
        "paddingYMax": number;
        "paddingYMin": number;
        "spaceBeforeMax": number;
        "spaceBeforeMin": number;
        "textColor": string;
        "textFontSizeMax": number;
        "textFontSizeMin": number;
        "textMarginTopMax": number;
        "textMarginTopMin": number;
        "textMaxWidth": string;
        "titleFontSizeMax": number;
        "titleFontSizeMin": number;
        "titleMarginBottomMax": number;
        "titleMarginBottomMin": number;
    }
    interface SpxSectionHeader {
        "backdropFilter": string;
        "background": string;
        /**
          * Turns on background after scroll.
         */
        "backgroundScroll": number;
        "borderBottom": string;
        /**
          * URL the logo links to.
         */
        "logoLink": string;
        "logoMaxHeight": string;
        /**
          * Logo src.
         */
        "logoSrc": string;
        /**
          * Logo mobile src.
         */
        "logoSrcMobile": string;
        /**
          * Where the navigation should be aligned to.
          * @choice 'center', 'right'
         */
        "navigationAlign": string;
        "paddingYMax": number;
        "paddingYMin": number;
        /**
          * Component positioning.
         */
        "position": 'fixed' | 'static';
        "wrapper": boolean;
        "zIndex": number;
    }
    interface SpxSectionTwoColumn {
        "background": string;
        "backgroundImage": string;
        /**
          * Column size.
          * @CSS
         */
        "columnSize": string;
        /**
          * If set, component will transform the header offset to the top-padding value.
         */
        "first": boolean;
        "gapMax": number;
        "gapMin": number;
        /**
          * Hides the media column.
         */
        "hideMedia": boolean;
        "imagesGapMax": number;
        "imagesGapMin": number;
        /**
          * Layout of the section.
          * @choice 'horizontal', 'vertical'
         */
        "layout": string;
        /**
          * Background color for the media column.
          * @CSS
         */
        "mediaBackground": string;
        /**
          * Overlaps the background with the media column.
         */
        "mediaBackgroundOverlap": boolean;
        /**
          * Removes the outer spacing for the media column.
         */
        "mediaFull": boolean;
        /**
          * Adds padding to the media column on mobile.
         */
        "mediaFullMobileFix": boolean;
        "mediaMargin": string;
        "mediaPaddingMax": number;
        "mediaPaddingMin": number;
        /**
          * Reverses the column order.
         */
        "reverse": boolean;
        /**
          * Reverses the column order on mobile.
         */
        "reverseMobile": boolean;
        "tabsAnimation": boolean;
        "tabsAnimationColor": string;
        "tabsAnimationDuration": number;
        /**
          * Alignment for the inner text wrapper.
         */
        "textAlignInner": 'left' | 'center' | 'right';
        /**
          * Alignment for the outer text wrapper.
         */
        "textAlignOuter": 'left' | 'center' | 'right';
        /**
          * Background color for the text column.
          * @CSS
         */
        "textBackground": string;
        /**
          * Overlaps the background with the text column.
         */
        "textBackgroundOverlap": boolean;
    }
    interface SpxShare {
        "fontSize": string;
        "itemBackground": string;
        "itemBorderRadius": string;
        /**
          * Gap between buttons.
          * @CSS
         */
        "itemColor": string;
        /**
          * Filter hover.
          * @CSS
         */
        "itemFilterHover": string;
        /**
          * Gap between buttons.
          * @CSS
         */
        "itemGap": string;
        "itemPadding": string;
        "itemSize": string;
        "itemTransitionDuration": string;
        "itemTransitionTimingFunction": string;
        "reload": () => Promise<void>;
        /**
          * Button href target.
         */
        "target": string;
        /**
          * Button theme.
          * @choice 'default', 'outline', 'minimal'
         */
        "theme": string;
        /**
          * Render buttons vertically.
         */
        "vertical": boolean;
    }
    interface SpxSlider {
        /**
          * Automatically adjusts height of slider.
         */
        "autoheight": boolean;
        /**
          * Starts navigating to the next slide when page is loaded.
         */
        "autoplay": boolean;
        /**
          * Autoplay delay.
         */
        "autoplayDelay": number;
        /**
          * Disable autoplay after interaction with slides.
         */
        "autoplayDisableOnInteraction": boolean;
        /**
          * Starts navigating to the next slide when page is loaded.
         */
        "bpTabs": string;
        /**
          * Centers slides in viewport.
         */
        "centeredSlides": boolean;
        /**
          * Slider direction.
          * @choice 'horizontal', 'vertical'
         */
        "direction": string;
        /**
          * Slider effect.
          * @choice 'slide', 'effect'
         */
        "effect": string;
        /**
          * Image object-fit.
          * @choice 'fill', 'contain', 'cover', 'scale-down', 'none'
         */
        "imageObjectFit": string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\Get::gallery($fieldName, $type) ?>
         */
        "images": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc": string;
        /**
          * Loops all slides infinitely.
         */
        "loop": boolean;
        /**
          * Max height.
          * @editor '500px'
         */
        "maxHeight": string;
        /**
          * Max width.
          * @editor '500px'
         */
        "maxWidth": string;
        "navigation": boolean;
        "navigationBackground": string;
        "navigationBorderRadius": string;
        "navigationColor": string;
        /**
          * Navigation distance.
          * @CSS
         */
        "navigationDistanceX": string;
        /**
          * Navigation icon type.
         */
        "navigationIconNext": string;
        /**
          * Navigation icon type.
         */
        "navigationIconPrev": string;
        /**
          * Navigation icon type.
         */
        "navigationIconType": string;
        "navigationPadding": string;
        /**
          * Navigation size.
          * @CSS
         */
        "navigationSize": string;
        /**
          * Pagination type.
          * @choice 'bullets', 'tabs', 'none'
         */
        "pagination": string;
        "paginationBulletsBackground": string;
        "paginationBulletsBackgroundActive": string;
        /**
          * Make bullets clickable.
         */
        "paginationBulletsClickable": boolean;
        /**
          * Will only keep a selected amount of bullets visible.
         */
        "paginationBulletsDynamic": boolean;
        /**
          * Amount of dynamic bullets.
         */
        "paginationBulletsDynamicAmount": number;
        /**
          * Size of the bullets.
          * @CSS
         */
        "paginationBulletsSize": string;
        /**
          * Space between the bullets.
          * @CSS
         */
        "paginationBulletsSpaceBetween": string;
        "paginationTabsGapMax": number;
        "paginationTabsGapMin": number;
        "paginationTabsInnerGapMax": number;
        "paginationTabsInnerGapMin": number;
        "paginationTabsMarginBottomMax": number;
        "paginationTabsMarginBottomMin": number;
        "paginationTabsMaxWidth": string;
        "paginationTabsPaddingMax": number;
        "paginationTabsPaddingMin": number;
        "paginationTransitionDuration": string;
        "paginationTransitionTimingFunction": string;
        /**
          * Filter property for the previous and next elements.
         */
        "prevNextFilter": string;
        "reload": () => Promise<void>;
        /**
          * Screen reader message for first slide.
         */
        "slideMessageFirst": string;
        /**
          * Screen reader message for last slide.
         */
        "slideMessageLast": string;
        /**
          * Screen reader message for next slide.
         */
        "slideMessageNext": string;
        /**
          * Screen reader message for previous slide.
         */
        "slideMessagePrevious": string;
        /**
          * Amount of slides shown at once.
         */
        "slidesPerView": number;
        /**
          * Space between slides.
         */
        "spaceBetween": number;
        /**
          * Sliding speed.
         */
        "speed": number;
    }
    interface SpxSlideshow {
        "display": string;
        /**
          * Duration of slideshow to complete one cycle.
          * @CSS
         */
        "duration": string;
        /**
          * Gap between inner elements.
          * @CSS
         */
        "gap": string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\get::gallery($fieldName, $type) ?>
         */
        "images": string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc": string;
        /**
          * Max width of inner elements.
          * @CSS
         */
        "maxWidth": string;
        /**
          * If not set with this attribute, overflow should be set on the parent element.
          * @CSS
         */
        "overflow": string;
    }
    interface SpxSnackbar {
        "animationDelay": string;
        "animationDuration": string;
        "background": string;
        "border": string;
        "borderRadius": string;
        /**
          * Adds option to close snackbar after its creation.
         */
        "closeable": boolean;
        "color": string;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "distanceX": string;
        /**
          * Distance to the edge of the viewport on the y-axis.
          * @CSS
         */
        "distanceY": string;
        /**
          * Makes snackbar not removable.
          * @editor '#components'
         */
        "fixed": boolean;
        "fontSize": string;
        /**
          * Unique identifier for snackbar instance.
          * @editor '#components'
         */
        "identifier": string;
        "padding": string;
        /**
          * Component position in page.
          * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
         */
        "position": string;
        /**
          * CSS property position of button.
          * @editor 'absolute'
         */
        "positionCss": | 'fixed'
    | 'absolute'
    | 'relative'
    | 'static';
        "reload": () => Promise<void>;
        /**
          * Reverses the close button if "closable" prop is true.
         */
        "reverse": boolean;
        /**
          * Space between snackbars.
         */
        "spaceBetween": string;
        /**
          * Element where snackbars should be created in.
          * @editor '#components'
         */
        "target": string;
        /**
          * Text inside snackbar.
         */
        "text": string;
        "zIndex": number;
    }
    interface SpxText {
        "h1FontSizeMax": number;
        "h1FontSizeMin": number;
        "h2FontSizeMax": number;
        "h2FontSizeMin": number;
        "h3FontSizeMax": number;
        "h3FontSizeMin": number;
        "h4FontSizeMax": number;
        "h4FontSizeMin": number;
        "headingColor": string;
        "headingFontFamily": string;
        "headingFontWeight": string;
        "headingLetterSpacing": string;
        "headingLineHeight": string;
        "headingTextTransform": string;
        "linkDecorationColor": string;
        /**
          * Parse markdown.
         */
        "markdown": boolean;
        "maxWidth": string;
        "paddingFigureMax": number;
        "paddingFigureMin": number;
        "spaceBeforeH1Max": number;
        "spaceBeforeH1Min": number;
        "spaceBetweenMax": number;
        "spaceBetweenMin": number;
        "spaceBetweenPMax": number;
        "spaceBetweenPMin": number;
        "textColor": string;
        "textFontFamily": string;
        "textFontSizeMax": number;
        "textFontSizeMin": number;
        "textFontWeight": string;
        "textLetterSpacing": string;
        "textLineHeight": string;
        "textTextTransform": string;
    }
    interface SpxTypewriter {
        /**
          * Automatically starts writing.
         */
        "autoStart": boolean;
        /**
          * Writing delay in ms. Also accepts 'natural' value.
         */
        "delay": any;
        /**
          * Delete delay in ms. Also accepts 'natural' value.
         */
        "deleteSpeed": any;
        "display": string;
        /**
          * Loops the animation.
         */
        "loop": boolean;
        /**
          * Start animation.
         */
        "play": () => Promise<void>;
        /**
          * Stop animation.
         */
        "stop": () => Promise<void>;
        /**
          * Text that should be written.
         */
        "text": string;
    }
}
declare global {
    interface HTMLSpxAccordionElement extends Components.SpxAccordion, HTMLStencilElement {
    }
    var HTMLSpxAccordionElement: {
        prototype: HTMLSpxAccordionElement;
        new (): HTMLSpxAccordionElement;
    };
    interface HTMLSpxAnimateElement extends Components.SpxAnimate, HTMLStencilElement {
    }
    var HTMLSpxAnimateElement: {
        prototype: HTMLSpxAnimateElement;
        new (): HTMLSpxAnimateElement;
    };
    interface HTMLSpxClassToggleElement extends Components.SpxClassToggle, HTMLStencilElement {
    }
    var HTMLSpxClassToggleElement: {
        prototype: HTMLSpxClassToggleElement;
        new (): HTMLSpxClassToggleElement;
    };
    interface HTMLSpxCodeElement extends Components.SpxCode, HTMLStencilElement {
    }
    var HTMLSpxCodeElement: {
        prototype: HTMLSpxCodeElement;
        new (): HTMLSpxCodeElement;
    };
    interface HTMLSpxContainerElement extends Components.SpxContainer, HTMLStencilElement {
    }
    var HTMLSpxContainerElement: {
        prototype: HTMLSpxContainerElement;
        new (): HTMLSpxContainerElement;
    };
    interface HTMLSpxEditElement extends Components.SpxEdit, HTMLStencilElement {
    }
    var HTMLSpxEditElement: {
        prototype: HTMLSpxEditElement;
        new (): HTMLSpxEditElement;
    };
    interface HTMLSpxEditButtonElement extends Components.SpxEditButton, HTMLStencilElement {
    }
    var HTMLSpxEditButtonElement: {
        prototype: HTMLSpxEditButtonElement;
        new (): HTMLSpxEditButtonElement;
    };
    interface HTMLSpxEditorElement extends Components.SpxEditor, HTMLStencilElement {
    }
    var HTMLSpxEditorElement: {
        prototype: HTMLSpxEditorElement;
        new (): HTMLSpxEditorElement;
    };
    interface HTMLSpxGroupElement extends Components.SpxGroup, HTMLStencilElement {
    }
    var HTMLSpxGroupElement: {
        prototype: HTMLSpxGroupElement;
        new (): HTMLSpxGroupElement;
    };
    interface HTMLSpxIconElement extends Components.SpxIcon, HTMLStencilElement {
    }
    var HTMLSpxIconElement: {
        prototype: HTMLSpxIconElement;
        new (): HTMLSpxIconElement;
    };
    interface HTMLSpxIframeElement extends Components.SpxIframe, HTMLStencilElement {
    }
    var HTMLSpxIframeElement: {
        prototype: HTMLSpxIframeElement;
        new (): HTMLSpxIframeElement;
    };
    interface HTMLSpxImageComparisonElement extends Components.SpxImageComparison, HTMLStencilElement {
    }
    var HTMLSpxImageComparisonElement: {
        prototype: HTMLSpxImageComparisonElement;
        new (): HTMLSpxImageComparisonElement;
    };
    interface HTMLSpxLightboxElement extends Components.SpxLightbox, HTMLStencilElement {
    }
    var HTMLSpxLightboxElement: {
        prototype: HTMLSpxLightboxElement;
        new (): HTMLSpxLightboxElement;
    };
    interface HTMLSpxLoaderElement extends Components.SpxLoader, HTMLStencilElement {
    }
    var HTMLSpxLoaderElement: {
        prototype: HTMLSpxLoaderElement;
        new (): HTMLSpxLoaderElement;
    };
    interface HTMLSpxMasonryElement extends Components.SpxMasonry, HTMLStencilElement {
    }
    var HTMLSpxMasonryElement: {
        prototype: HTMLSpxMasonryElement;
        new (): HTMLSpxMasonryElement;
    };
    interface HTMLSpxMockupElement extends Components.SpxMockup, HTMLStencilElement {
    }
    var HTMLSpxMockupElement: {
        prototype: HTMLSpxMockupElement;
        new (): HTMLSpxMockupElement;
    };
    interface HTMLSpxNavigationElement extends Components.SpxNavigation, HTMLStencilElement {
    }
    var HTMLSpxNavigationElement: {
        prototype: HTMLSpxNavigationElement;
        new (): HTMLSpxNavigationElement;
    };
    interface HTMLSpxNotationElement extends Components.SpxNotation, HTMLStencilElement {
    }
    var HTMLSpxNotationElement: {
        prototype: HTMLSpxNotationElement;
        new (): HTMLSpxNotationElement;
    };
    interface HTMLSpxOffsetElement extends Components.SpxOffset, HTMLStencilElement {
    }
    var HTMLSpxOffsetElement: {
        prototype: HTMLSpxOffsetElement;
        new (): HTMLSpxOffsetElement;
    };
    interface HTMLSpxPageDocsElement extends Components.SpxPageDocs, HTMLStencilElement {
    }
    var HTMLSpxPageDocsElement: {
        prototype: HTMLSpxPageDocsElement;
        new (): HTMLSpxPageDocsElement;
    };
    interface HTMLSpxPageSingleElement extends Components.SpxPageSingle, HTMLStencilElement {
    }
    var HTMLSpxPageSingleElement: {
        prototype: HTMLSpxPageSingleElement;
        new (): HTMLSpxPageSingleElement;
    };
    interface HTMLSpxScrollspyElement extends Components.SpxScrollspy, HTMLStencilElement {
    }
    var HTMLSpxScrollspyElement: {
        prototype: HTMLSpxScrollspyElement;
        new (): HTMLSpxScrollspyElement;
    };
    interface HTMLSpxSectionButtonElement extends Components.SpxSectionButton, HTMLStencilElement {
    }
    var HTMLSpxSectionButtonElement: {
        prototype: HTMLSpxSectionButtonElement;
        new (): HTMLSpxSectionButtonElement;
    };
    interface HTMLSpxSectionFooterElement extends Components.SpxSectionFooter, HTMLStencilElement {
    }
    var HTMLSpxSectionFooterElement: {
        prototype: HTMLSpxSectionFooterElement;
        new (): HTMLSpxSectionFooterElement;
    };
    interface HTMLSpxSectionHeaderElement extends Components.SpxSectionHeader, HTMLStencilElement {
    }
    var HTMLSpxSectionHeaderElement: {
        prototype: HTMLSpxSectionHeaderElement;
        new (): HTMLSpxSectionHeaderElement;
    };
    interface HTMLSpxSectionTwoColumnElement extends Components.SpxSectionTwoColumn, HTMLStencilElement {
    }
    var HTMLSpxSectionTwoColumnElement: {
        prototype: HTMLSpxSectionTwoColumnElement;
        new (): HTMLSpxSectionTwoColumnElement;
    };
    interface HTMLSpxShareElement extends Components.SpxShare, HTMLStencilElement {
    }
    var HTMLSpxShareElement: {
        prototype: HTMLSpxShareElement;
        new (): HTMLSpxShareElement;
    };
    interface HTMLSpxSliderElement extends Components.SpxSlider, HTMLStencilElement {
    }
    var HTMLSpxSliderElement: {
        prototype: HTMLSpxSliderElement;
        new (): HTMLSpxSliderElement;
    };
    interface HTMLSpxSlideshowElement extends Components.SpxSlideshow, HTMLStencilElement {
    }
    var HTMLSpxSlideshowElement: {
        prototype: HTMLSpxSlideshowElement;
        new (): HTMLSpxSlideshowElement;
    };
    interface HTMLSpxSnackbarElement extends Components.SpxSnackbar, HTMLStencilElement {
    }
    var HTMLSpxSnackbarElement: {
        prototype: HTMLSpxSnackbarElement;
        new (): HTMLSpxSnackbarElement;
    };
    interface HTMLSpxTextElement extends Components.SpxText, HTMLStencilElement {
    }
    var HTMLSpxTextElement: {
        prototype: HTMLSpxTextElement;
        new (): HTMLSpxTextElement;
    };
    interface HTMLSpxTypewriterElement extends Components.SpxTypewriter, HTMLStencilElement {
    }
    var HTMLSpxTypewriterElement: {
        prototype: HTMLSpxTypewriterElement;
        new (): HTMLSpxTypewriterElement;
    };
    interface HTMLElementTagNameMap {
        "spx-accordion": HTMLSpxAccordionElement;
        "spx-animate": HTMLSpxAnimateElement;
        "spx-class-toggle": HTMLSpxClassToggleElement;
        "spx-code": HTMLSpxCodeElement;
        "spx-container": HTMLSpxContainerElement;
        "spx-edit": HTMLSpxEditElement;
        "spx-edit-button": HTMLSpxEditButtonElement;
        "spx-editor": HTMLSpxEditorElement;
        "spx-group": HTMLSpxGroupElement;
        "spx-icon": HTMLSpxIconElement;
        "spx-iframe": HTMLSpxIframeElement;
        "spx-image-comparison": HTMLSpxImageComparisonElement;
        "spx-lightbox": HTMLSpxLightboxElement;
        "spx-loader": HTMLSpxLoaderElement;
        "spx-masonry": HTMLSpxMasonryElement;
        "spx-mockup": HTMLSpxMockupElement;
        "spx-navigation": HTMLSpxNavigationElement;
        "spx-notation": HTMLSpxNotationElement;
        "spx-offset": HTMLSpxOffsetElement;
        "spx-page-docs": HTMLSpxPageDocsElement;
        "spx-page-single": HTMLSpxPageSingleElement;
        "spx-scrollspy": HTMLSpxScrollspyElement;
        "spx-section-button": HTMLSpxSectionButtonElement;
        "spx-section-footer": HTMLSpxSectionFooterElement;
        "spx-section-header": HTMLSpxSectionHeaderElement;
        "spx-section-two-column": HTMLSpxSectionTwoColumnElement;
        "spx-share": HTMLSpxShareElement;
        "spx-slider": HTMLSpxSliderElement;
        "spx-slideshow": HTMLSpxSlideshowElement;
        "spx-snackbar": HTMLSpxSnackbarElement;
        "spx-text": HTMLSpxTextElement;
        "spx-typewriter": HTMLSpxTypewriterElement;
    }
}
declare namespace LocalJSX {
    interface SpxAccordion {
        "contentColor"?: string;
        /**
          * Content text.
         */
        "contentText"?: string;
        /**
          * Content text tag.
         */
        "contentTextTag"?: string;
        "contentTransitionDuration"?: string;
        "contentTransitionTimingFunction"?: string;
        /**
          * Disables the animation. Set this attribute if the accordion is starting hidden in the DOM.
         */
        "disableAnimation"?: boolean;
        "fontSize"?: string;
        /**
          * Space between header and content.
          * @CSS
         */
        "gap"?: string;
        "headerColor"?: string;
        /**
          * Gap between header text and icon.
          * @CSS
         */
        "headerGap"?: string;
        /**
          * Header text.
         */
        "headerText"?: string;
        /**
          * Header text when component is closed.
         */
        "headerTextOpen"?: string;
        /**
          * Header text tag.
         */
        "headerTextTag"?: string;
        /**
          * Indicator icon.
         */
        "indicatorIcon"?: string;
        /**
          * Indicator icon transform.
         */
        "indicatorIconTransform"?: string;
        /**
          * Indicator icon type.
         */
        "indicatorIconType"?: string;
        /**
          * Sets the ID to link different accordions together.
         */
        "link"?: string;
        /**
          * Sets the type of link.
          * @choice 'open', 'close', 'toggle'
         */
        "linkType"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxAccordionDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * State of accordion.
         */
        "openState"?: boolean;
        /**
          * Reverse icon positioning.
         */
        "reverse"?: boolean;
    }
    interface SpxAnimate {
        /**
          * Delay before animation starts.
         */
        "delay"?: number;
        "display"?: string;
        /**
          * Animation duration.
         */
        "duration"?: number;
        /**
          * Ease being used. Accepts all common GSAP options.
         */
        "ease"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxAnimateDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Determines if animation should only play once. (if viewport is true)
         */
        "once"?: boolean;
        /**
          * Opacity level the animation starts from.
         */
        "opacity"?: number;
        /**
          * Repeats the animation. -1 to repeat indefinitely.
         */
        "repeat"?: number;
        /**
          * Time to wait between repetitions.
         */
        "repeatDelay"?: number;
        /**
          * Reverses the animation.
         */
        "reverse"?: boolean;
        /**
          * Amount of time elements should be staggered by.
         */
        "stagger"?: number;
        /**
          * The target element that should be animated inside the component.
         */
        "target"?: string;
        /**
          * Starts animation when target is in the viewport.
         */
        "viewport"?: boolean;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginBottom"?: string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginLeft"?: string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginRight"?: string;
        /**
          * Adjust the root margin of the animation start.
         */
        "viewportMarginTop"?: string;
        /**
          * X position the animation starts from.
         */
        "x"?: number;
        /**
          * Y position the animation starts from.
         */
        "y"?: number;
        /**
          * Causes the animation to go back and forth, alternating backward and forward on each repeat.
         */
        "yoyo"?: boolean;
    }
    interface SpxClassToggle {
        "display"?: string;
        /**
          * Specify a local storage item, so the toggle state will be remembered when the user visits the site again.
         */
        "local"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxClassToggleDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Target element. Can take any querySelector value. (id, class, tag etc.) If none is set it will default to the first element inside.
         */
        "target"?: string;
        /**
          * List of classes that should be toggled.
         */
        "toggle"?: string;
    }
    interface SpxCode {
        "background"?: string;
        "borderRadius"?: string;
        /**
          * Enable clipboard button.
         */
        "clipboard"?: boolean;
        "clipboardButtonBackground"?: string;
        "clipboardButtonColor"?: string;
        "clipboardButtonFontSize"?: string;
        "clipboardButtonFontWeight"?: any;
        "clipboardButtonPadding"?: string;
        "clipboardButtonText"?: string;
        "clipboardButtonTextCopied"?: string;
        "clipboardButtonTextTransform"?: string;
        "display"?: string;
        "fontSize"?: string;
        "height"?: string;
        /**
          * Hide scrollbar.
         */
        "hideScrollbar"?: boolean;
        /**
          * Enable line numbers.
         */
        "lineNumbers"?: boolean;
        "lineNumbersBackground"?: string;
        "lineNumbersColor"?: string;
        "maxWidth"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxCodeDidLoad"?: (event: CustomEvent<any>) => void;
        "overflow"?: string;
        "padding"?: string;
        /**
          * Colour theme.
          * @choice 'default', 'dracula'
         */
        "theme"?: string;
        /**
          * Determines the programming language.
          * @choice 'markup', 'css', 'php'
          * @editor 'css'
         */
        "type"?: string;
    }
    interface SpxContainer {
        /**
          * Mobile breakpoint width.
         */
        "bpMobile"?: number;
        "buttonBackgroundPrimary"?: number;
        "buttonBackgroundSecondary"?: number;
        "buttonBorderRadius"?: string;
        "buttonColorPrimary"?: number;
        "buttonColorSecondary"?: number;
        "buttonFontSizeMax"?: number;
        "buttonFontSizeMin"?: number;
        "buttonFontWeight"?: string;
        "buttonMarginTopMax"?: number;
        "buttonMarginTopMin"?: number;
        "buttonMarginXMax"?: number;
        "buttonMarginXMin"?: number;
        "buttonPaddingXMax"?: number;
        "buttonPaddingXMin"?: number;
        "buttonPaddingYMax"?: number;
        "buttonPaddingYMin"?: number;
        "buttonTextTransform"?: string;
        /**
          * Gray color which will be used for sections and pages.
          * @choice 'blue-gray', 'cool-gray', 'gray', 'true-gray', 'warm-gray', 'red', 'orange', 'amber', 'yellow', 'lime', 'green', 'emerald', 'teal', 'cyan', 'light-blue', 'blue', 'indigo', 'violet', 'purple'; 'fuchsia', 'pink', 'rose'
         */
        "colorGray"?: string;
        /**
          * Primary color which will be used for sections and pages.
          * @choice 'blue-gray', 'cool-gray', 'gray', 'true-gray', 'warm-gray', 'red', 'orange', 'amber', 'yellow', 'lime', 'green', 'emerald', 'teal', 'cyan', 'light-blue', 'blue', 'indigo', 'violet', 'purple'; 'fuchsia', 'pink', 'rose'
         */
        "colorPrimary"?: string;
        /**
          * Secondary color which will be used for sections and pages.
          * @choice 'blue-gray', 'cool-gray', 'gray', 'true-gray', 'warm-gray', 'red', 'orange', 'amber', 'yellow', 'lime', 'green', 'emerald', 'teal', 'cyan', 'light-blue', 'blue', 'indigo', 'violet', 'purple'; 'fuchsia', 'pink', 'rose'
         */
        "colorSecondary"?: string;
        /**
          * Disable color generation.
         */
        "disableColors"?: boolean;
        "focusColor"?: string;
        /**
          * Primary font-family.
         */
        "fontFamilyPrimary"?: string;
        /**
          * Secondary font-family.
         */
        "fontFamilySecondary"?: string;
        "imageMaxWidth"?: string;
        /**
          * Linear scaling root number.
         */
        "linearBase"?: number;
        /**
          * Linear scaling maximum width.
         */
        "linearMaxW"?: number;
        /**
          * Linear scaling minimum width.
         */
        "linearMinW"?: number;
        /**
          * Section max-width.
         */
        "maxWidth"?: string;
        /**
          * Section max-width on mobile.
         */
        "maxWidthMobile"?: string;
        /**
          * Offsets first section to the height of the header.
         */
        "offsetHeader"?: boolean;
        /**
          * Fires after component has loaded.
         */
        "onSpxContainerDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Space between content and outer edge of the viewport.
          * @CSS
         */
        "paddingX"?: string;
        /**
          * Space between content and outer edge of the viewport.
          * @CSS
         */
        "paddingXSm"?: string;
        "paddingYFirstMax"?: number;
        "paddingYFirstMin"?: number;
        "paddingYMax"?: number;
        "paddingYMaxWidth"?: number;
        "paddingYMin"?: number;
        "paddingYMultiplier"?: number;
        "preTitleBackground"?: string;
        "preTitleBorderRadius"?: string;
        "preTitleColor"?: string;
        "preTitleFontSizeMax"?: number;
        "preTitleFontSizeMin"?: number;
        "preTitleFontWeight"?: string;
        "preTitleLetterSpacing"?: string;
        "preTitleLineHeight"?: string;
        "preTitleMarginBottomMax"?: number;
        "preTitleMarginBottomMin"?: number;
        "preTitlePaddingXMax"?: number;
        "preTitlePaddingXMin"?: number;
        "preTitlePaddingYMax"?: number;
        "preTitlePaddingYMin"?: number;
        "preTitleTextTransform"?: string;
        "tabsFirstMarginTopMax"?: number;
        "tabsFirstMarginTopMin"?: number;
        "tabsMarginTopMax"?: number;
        "tabsMarginTopMin"?: number;
        /**
          * Tabs opacity.
          * @CSS
         */
        "tabsOpacity"?: number;
        "textColor"?: string;
        "textFontSizeMax"?: number;
        "textFontSizeMin"?: number;
        "textFontWeight"?: string;
        "textLetterSpacing"?: string;
        "textLineHeight"?: string;
        "textLinkDecorationColor"?: string;
        "textLinkDecorationColorHover"?: string;
        "textMarginTopMax"?: number;
        "textMarginTopMin"?: number;
        "textMaxWidth"?: string;
        "textTransform"?: string;
        "titleColor"?: string;
        "titleFontSizeMax"?: number;
        "titleFontSizeMin"?: number;
        "titleFontWeight"?: number;
        "titleLetterSpacing"?: string;
        "titleLineHeight"?: string;
        "titleMaxWidth"?: string;
        "titleTextTransform"?: string;
    }
    interface SpxEdit {
        "display"?: string;
        /**
          * Watch editable state.
         */
        "editable"?: boolean;
        "name"?: string;
        "outline"?: string;
        "outlineFocus"?: string;
        "placeholder"?: string;
        "placeholderColor"?: string;
        "placeholderOpacity"?: string;
        "subfield"?: boolean;
        "type"?: string;
    }
    interface SpxEditButton {
        "background"?: string;
        /**
          * Discard button background.
          * @CSS
         */
        "backgroundDiscard"?: string;
        "border"?: string;
        "borderRadius"?: string;
        "color"?: string;
        /**
          * Discard button color.
          * @CSS
         */
        "colorDiscard"?: string;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "distanceX"?: string;
        /**
          * Distance to the edge of the viewport on the y-axis.
          * @CSS
         */
        "distanceY"?: string;
        /**
          * Corresponding ID for editable fields. This property is needed when multiple edit-button components are used on the page. Simply apply a "data-spx-edit-id" attribute with the same value to editable elements.
         */
        "editId"?: string;
        "fontFamily"?: string;
        "fontSize"?: string;
        /**
          * Gap between the buttons.
          * @CSS
         */
        "gap"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxEditButtonDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Fires after pressing the discard button.
         */
        "onSpxEditButtonDiscard"?: (event: CustomEvent<any>) => void;
        /**
          * Fires after pressing the save button.
         */
        "onSpxEditButtonSave"?: (event: CustomEvent<any>) => void;
        "padding"?: string;
        /**
          * Component position in page.
          * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
         */
        "position"?: string;
        /**
          * CSS property position of button.
          * @editor 'absolute'
         */
        "positionCss"?: | 'fixed'
    | 'absolute'
    | 'relative'
    | 'static';
        "test"?: boolean;
        /**
          * Discard button text.
         */
        "textDiscard"?: string;
        /**
          * Edit button text.
         */
        "textEdit"?: string;
        /**
          * Save button text.
         */
        "textSave"?: string;
        /**
          * Success message.
         */
        "textSuccess"?: string;
        "zIndex"?: number;
    }
    interface SpxEditor {
        "fullscreen"?: boolean;
        "location"?: string;
    }
    interface SpxGroup {
        "display"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxGroupDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Specifies a target element.
         */
        "target"?: string;
    }
    interface SpxIcon {
        "color"?: string;
        /**
          * Icon code.
         */
        "icon"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxIconDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Icon size.
         */
        "size"?: string;
        /**
          * Icon type.
          * @choice 'ionicons', 'caret'
         */
        "type"?: string;
    }
    interface SpxIframe {
        "display"?: string;
        "documentBorder"?: string;
        "documentBorderRadius"?: string;
        "documentHeight"?: string;
        "documentWidth"?: string;
        /**
          * Automatically resize iframe to fit content.
         */
        "fit"?: boolean;
        /**
          * Lazy load content.
         */
        "lazy"?: boolean;
        /**
          * Fires after component has loaded.
         */
        "onSpxIFrameDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Screen size of the site shown inside the iframe.
         */
        "size"?: string;
        /**
          * Source for the iframe.
         */
        "src"?: string;
        /**
          * Screen size of the site shown inside the iframe.
          * @choice 'resize', 'document', 'type'
         */
        "type"?: string;
    }
    interface SpxImageComparison {
        "color"?: string;
        "height"?: string;
        "iconColor"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxImageComparisonDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Image URL of the before image.
         */
        "srcAfter"?: string;
        /**
          * Image URL of the after image.
         */
        "srcBefore"?: string;
        /**
          * Opening state in pixels.
         */
        "start"?: number;
    }
    interface SpxLightbox {
        "display"?: string;
        "height"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxLightboxDidLoad"?: (event: CustomEvent<any>) => void;
        "overlayColor"?: string;
        "width"?: string;
    }
    interface SpxLoader {
        "color"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxLoaderDidLoad"?: (event: CustomEvent<any>) => void;
        "speed"?: string;
    }
    interface SpxMasonry {
        /**
          * Columns for different screen sizes. Example value: 1000:3;600:2 - this will switch to a three column layout when the screen size is under 1000px and to a two column layout under 600px.
         */
        "bpColumns"?: string;
        /**
          * Number of columns.
         */
        "columns"?: number;
        /**
          * Gap between images.
          * @CSS
         */
        "gap"?: string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\Get::gallery($fieldName, $type) ?>
         */
        "images"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxMasonryDidLoad"?: (event: CustomEvent<any>) => void;
    }
    interface SpxMockup {
        /**
          * Samsung S8 color.
          * @choice 'black', 'blue'
         */
        "colorGalaxyS8"?: string;
        /**
          * Google Pixel color.
          * @choice 'silver', 'black', 'blue'
         */
        "colorGooglePixel"?: string;
        /**
          * iPad Pro color.
          * @choice 'silver', 'gold', 'rosegold', 'spacegray'
         */
        "colorIpadPro"?: string;
        /**
          * iPhone 8 color.
          * @choice 'silver', 'gold', 'spacegray'
         */
        "colorIphone8"?: string;
        /**
          * MacBook color.
          * @choice 'silver', 'gold', 'rosegold', 'spacegray'
         */
        "colorMacbook"?: string;
        /**
          * MacBook Pro color.
          * @choice 'silver', 'spacegray'
         */
        "colorMacbookPro"?: string;
        "display"?: string;
        "imagePosition"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxMockupDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Image src if no inner slot is used.
         */
        "src"?: string;
        /**
          * Device type.
          * @choice 'iphone-8', 'iphone-x', 'google-pixel-2-xl', 'google-pixel', 'galaxy-s8', 'ipad-pro', 'surface-pro', 'surface-book', 'macbook', 'macbook-pro', 'surface-studio', 'imac-pro', 'apple-watch'
         */
        "type"?: string;
    }
    interface SpxNavigation {
        "childBorder"?: string;
        /**
          * Child menu border-radius.
          * @CSS
         */
        "childBorderRadius"?: string;
        /**
          * Child menu box-shadow.
          * @CSS
         */
        "childBoxShadow"?: string;
        /**
          * Gap between nested child menus.
          * @CSS
         */
        "childChildGap"?: string;
        /**
          * Gap between top level menu items and child menus.
          * @CSS
         */
        "childGap"?: string;
        /**
          * Indicator icon..
         */
        "childIcon"?: string;
        /**
          * Indicator icon type.
         */
        "childIconType"?: string;
        /**
          * Gap between child menu indicator and text.
          * @CSS
         */
        "childIndicatorGap"?: string;
        "childItemBackground"?: string;
        "childItemBackgroundHover"?: string;
        "childItemColor"?: string;
        "childItemColorHover"?: string;
        "childItemPadding"?: string;
        /**
          * Child menu placement.
          * @CSS 
          * @choice 'start', 'end'
         */
        "childPlacement"?: string;
        "fontSize"?: string;
        "itemTransitionDuration"?: string;
        "itemTransitionTimingFunction"?: string;
        /**
          * Underlines all links.
         */
        "itemUnderline"?: boolean;
        /**
          * Underlines all links on hover.
         */
        "itemUnderlineHover"?: boolean;
        /**
          * Renders a WordPress menu.
          * @helper &lt;?php spx\Get::navigation("myMenu") ?>
         */
        "menu"?: string;
        /**
          * Mobile breakpoint.
         */
        "mobile"?: number;
        /**
          * Mobile button icon.
         */
        "mobileIcon"?: string;
        /**
          * Mobile button icon type.
         */
        "mobileIconType"?: string;
        "mobileItemBackground"?: string;
        "mobileItemBackgroundHover"?: string;
        "mobileItemColor"?: string;
        "mobileItemColorHover"?: string;
        "mobileItemNestedMarginLeft"?: string;
        "mobileItemPadding"?: string;
        /**
          * Mobile placement.
          * @CSS 
          * @choice 'start', 'end'
         */
        "mobilePlacement"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxNavigationDidLoad"?: (event: CustomEvent<any>) => void;
        "parentItemBackground"?: string;
        "parentItemBackgroundHover"?: string;
        "parentItemColor"?: string;
        "parentItemColorHover"?: string;
        /**
          * Gap between parent menu items.
          * @CSS
         */
        "parentItemGap"?: string;
        "parentItemPadding"?: string;
        /**
          * Renders menu vertically.
         */
        "vertical"?: boolean;
    }
    interface SpxNotation {
        /**
          * Turn animation on or off when animation.
         */
        "animation"?: boolean;
        /**
          * Animation duration.
         */
        "animationDuration"?: number;
        "color"?: string;
        "display"?: string;
        /**
          * Number of iterations.
         */
        "iterations"?: number;
        /**
          * Annotate multiline text.
         */
        "multiline"?: boolean;
        /**
          * Fires after component has loaded.
         */
        "onSpxNotationDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Stroke width.
         */
        "strokeWidth"?: number;
        /**
          * Type of notation.
          * @choice 'underline', 'box', 'circle', 'highlight', 'strike-through', 'crossed-off', 'bracket'
         */
        "type"?: string;
    }
    interface SpxOffset {
        "display"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxOffsetDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Target element.
          * @editor '.header1'
         */
        "target"?: string;
    }
    interface SpxPageDocs {
        "bpMobile"?: number;
        "contentHeadingFontFamily"?: string;
        "navigationBackground"?: string;
        "navigationFontFamily"?: string;
        "navigationGapMax"?: number;
        "navigationGapMin"?: number;
        "navigationHeadingTag"?: string;
        "navigationHeightAdjust"?: string;
        "navigationLinkColor"?: string;
        "navigationLinkColorActive"?: string;
        "navigationLinkFontWeight"?: string;
        "navigationLinkLetterSpacing"?: string;
        "navigationLinkLineHeight"?: string;
        "navigationLinkTextTransform"?: string;
        "navigationSpaceYMax"?: number;
        "navigationSpaceYMin"?: number;
        "navigationTitleColor"?: string;
        "navigationTitleFontWeight"?: string;
        "navigationTitleLetterSpacing"?: string;
        "navigationTitleLineHeight"?: string;
        "navigationTitleMarginBottomMax"?: number;
        "navigationTitleMarginBottomMin"?: number;
        "navigationTitleTextTransform"?: string;
        "navigationTop"?: string;
        "offsetMarginTopMax"?: number;
        "offsetMarginTopMin"?: number;
        /**
          * Fires after component has loaded.
         */
        "onSpxPageDocsDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "paddingX"?: string;
        "paddingYMax"?: number;
        "paddingYMin"?: number;
        "uniqueId"?: boolean;
    }
    interface SpxPageSingle {
        "authorColor"?: string;
        "authorFontFamily"?: string;
        "authorFontSizeMax"?: number;
        "authorFontSizeMin"?: number;
        "authorFontWeight"?: string;
        "authorLetterSpacing"?: string;
        "authorLineHeight"?: string;
        "authorMarginTopMax"?: number;
        "authorMarginTopMin"?: number;
        "authorTextTransform"?: string;
        "contentMarginTopMax"?: number;
        "contentMarginTopMin"?: number;
        "contentMaxWidth"?: string;
        "contentPaddingX"?: string;
        /**
          * Display date.
         */
        "date"?: boolean;
        "dateColor"?: string;
        "dateFontFamily"?: string;
        "dateFontSizeMax"?: number;
        "dateFontSizeMin"?: number;
        "dateFontWeight"?: string;
        "dateLetterSpacing"?: string;
        "dateLineHeight"?: string;
        "dateMarginTopMax"?: number;
        "dateMarginTopMin"?: number;
        "dateTextTransform"?: string;
        "headerBorderBottom"?: string;
        "headerPaddingBottomMax"?: number;
        "headerPaddingBottomMin"?: number;
        /**
          * Display image.
         */
        "image"?: boolean;
        "imageBorderRadius"?: string;
        "imageHeight"?: string;
        "imageObjectPosition"?: string;
        "imagePaddingX"?: string;
        "imageSpaceYMax"?: number;
        "imageSpaceYMin"?: number;
        /**
          * Mobile breakpoint.
         */
        "mobile"?: number;
        /**
          * Fires after component has loaded.
         */
        "onSpxPageSingleDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Gets a WordPress post to render.
          * @helper &lt;?php spx\Get::post($postId, $dateFormat, $imageSize) ?>
         */
        "post"?: string;
        /**
          * Space to edge of the viewport.
         */
        "titleColor"?: string;
        "titleFontFamily"?: string;
        "titleFontSizeMax"?: number;
        "titleFontSizeMin"?: number;
        "titleFontWeight"?: string;
        "titleLetterSpacing"?: string;
        "titleLineHeight"?: string;
        "titleMarginTopMax"?: number;
        "titleMarginTopMin"?: number;
        "titleTextTransform"?: string;
    }
    interface SpxScrollspy {
        /**
          * Applied class to active content element.
         */
        "contentClass"?: string;
        "display"?: string;
        /**
          * Applied class to active navigation element.
         */
        "navClass"?: string;
        /**
          * Selects the height of an element (any querySelector value) or number that is used for offsetting how far from the top the next section is activated.
         */
        "offset"?: any;
        /**
          * Fires after component has loaded.
         */
        "onSpxScrollspyDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Automatically scroll to the active element
         */
        "scrolling"?: boolean;
        /**
          * Scrolling offset from the top.
         */
        "scrollingOffset"?: number;
        /**
          * Target element. Can take any querySelector value. (id, class, tag etc.)
         */
        "target"?: string;
        /**
          * Appends the currently active link to the end of the URL.
         */
        "urlChange"?: boolean;
    }
    interface SpxSectionButton {
        /**
          * Link href.
         */
        "href"?: string;
        /**
          * Icon.
         */
        "icon"?: string;
        "iconGapMax"?: number;
        "iconGapMin"?: number;
        /**
          * Fires after component has loaded.
         */
        "onSpxSectionButtonDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Link href.
         */
        "reverse"?: boolean;
        /**
          * Target.
         */
        "target"?: string;
        "transitionDuration"?: string;
        "transitionTimingFunction"?: string;
        /**
          * Button type.
          * @choice 'primary', 'secondary'
         */
        "type"?: string;
    }
    interface SpxSectionFooter {
        "background"?: string;
        /**
          * Gap between columns.
          * @CSS
         */
        "gap"?: string;
        "imageMaxHeight"?: string;
        "justifyContent"?: string;
        "maxWidth"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxSectionFooterDidLoad"?: (event: CustomEvent<any>) => void;
        "paddingYMax"?: number;
        "paddingYMin"?: number;
        "spaceBeforeMax"?: number;
        "spaceBeforeMin"?: number;
        "textColor"?: string;
        "textFontSizeMax"?: number;
        "textFontSizeMin"?: number;
        "textMarginTopMax"?: number;
        "textMarginTopMin"?: number;
        "textMaxWidth"?: string;
        "titleFontSizeMax"?: number;
        "titleFontSizeMin"?: number;
        "titleMarginBottomMax"?: number;
        "titleMarginBottomMin"?: number;
    }
    interface SpxSectionHeader {
        "backdropFilter"?: string;
        "background"?: string;
        /**
          * Turns on background after scroll.
         */
        "backgroundScroll"?: number;
        "borderBottom"?: string;
        /**
          * URL the logo links to.
         */
        "logoLink"?: string;
        "logoMaxHeight"?: string;
        /**
          * Logo src.
         */
        "logoSrc"?: string;
        /**
          * Logo mobile src.
         */
        "logoSrcMobile"?: string;
        /**
          * Where the navigation should be aligned to.
          * @choice 'center', 'right'
         */
        "navigationAlign"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxSectionHeaderDidLoad"?: (event: CustomEvent<any>) => void;
        "paddingYMax"?: number;
        "paddingYMin"?: number;
        /**
          * Component positioning.
         */
        "position"?: 'fixed' | 'static';
        "wrapper"?: boolean;
        "zIndex"?: number;
    }
    interface SpxSectionTwoColumn {
        "background"?: string;
        "backgroundImage"?: string;
        /**
          * Column size.
          * @CSS
         */
        "columnSize"?: string;
        /**
          * If set, component will transform the header offset to the top-padding value.
         */
        "first"?: boolean;
        "gapMax"?: number;
        "gapMin"?: number;
        /**
          * Hides the media column.
         */
        "hideMedia"?: boolean;
        "imagesGapMax"?: number;
        "imagesGapMin"?: number;
        /**
          * Layout of the section.
          * @choice 'horizontal', 'vertical'
         */
        "layout"?: string;
        /**
          * Background color for the media column.
          * @CSS
         */
        "mediaBackground"?: string;
        /**
          * Overlaps the background with the media column.
         */
        "mediaBackgroundOverlap"?: boolean;
        /**
          * Removes the outer spacing for the media column.
         */
        "mediaFull"?: boolean;
        /**
          * Adds padding to the media column on mobile.
         */
        "mediaFullMobileFix"?: boolean;
        "mediaMargin"?: string;
        "mediaPaddingMax"?: number;
        "mediaPaddingMin"?: number;
        /**
          * Fires after component has loaded.
         */
        "onSpxSectionTwoColumnDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Reverses the column order.
         */
        "reverse"?: boolean;
        /**
          * Reverses the column order on mobile.
         */
        "reverseMobile"?: boolean;
        "tabsAnimation"?: boolean;
        "tabsAnimationColor"?: string;
        "tabsAnimationDuration"?: number;
        /**
          * Alignment for the inner text wrapper.
         */
        "textAlignInner"?: 'left' | 'center' | 'right';
        /**
          * Alignment for the outer text wrapper.
         */
        "textAlignOuter"?: 'left' | 'center' | 'right';
        /**
          * Background color for the text column.
          * @CSS
         */
        "textBackground"?: string;
        /**
          * Overlaps the background with the text column.
         */
        "textBackgroundOverlap"?: boolean;
    }
    interface SpxShare {
        "fontSize"?: string;
        "itemBackground"?: string;
        "itemBorderRadius"?: string;
        /**
          * Gap between buttons.
          * @CSS
         */
        "itemColor"?: string;
        /**
          * Filter hover.
          * @CSS
         */
        "itemFilterHover"?: string;
        /**
          * Gap between buttons.
          * @CSS
         */
        "itemGap"?: string;
        "itemPadding"?: string;
        "itemSize"?: string;
        "itemTransitionDuration"?: string;
        "itemTransitionTimingFunction"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxShareDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Button href target.
         */
        "target"?: string;
        /**
          * Button theme.
          * @choice 'default', 'outline', 'minimal'
         */
        "theme"?: string;
        /**
          * Render buttons vertically.
         */
        "vertical"?: boolean;
    }
    interface SpxSlider {
        /**
          * Automatically adjusts height of slider.
         */
        "autoheight"?: boolean;
        /**
          * Starts navigating to the next slide when page is loaded.
         */
        "autoplay"?: boolean;
        /**
          * Autoplay delay.
         */
        "autoplayDelay"?: number;
        /**
          * Disable autoplay after interaction with slides.
         */
        "autoplayDisableOnInteraction"?: boolean;
        /**
          * Starts navigating to the next slide when page is loaded.
         */
        "bpTabs"?: string;
        /**
          * Centers slides in viewport.
         */
        "centeredSlides"?: boolean;
        /**
          * Slider direction.
          * @choice 'horizontal', 'vertical'
         */
        "direction"?: string;
        /**
          * Slider effect.
          * @choice 'slide', 'effect'
         */
        "effect"?: string;
        /**
          * Image object-fit.
          * @choice 'fill', 'contain', 'cover', 'scale-down', 'none'
         */
        "imageObjectFit"?: string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\Get::gallery($fieldName, $type) ?>
         */
        "images"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc"?: string;
        /**
          * Loops all slides infinitely.
         */
        "loop"?: boolean;
        /**
          * Max height.
          * @editor '500px'
         */
        "maxHeight"?: string;
        /**
          * Max width.
          * @editor '500px'
         */
        "maxWidth"?: string;
        "navigation"?: boolean;
        "navigationBackground"?: string;
        "navigationBorderRadius"?: string;
        "navigationColor"?: string;
        /**
          * Navigation distance.
          * @CSS
         */
        "navigationDistanceX"?: string;
        /**
          * Navigation icon type.
         */
        "navigationIconNext"?: string;
        /**
          * Navigation icon type.
         */
        "navigationIconPrev"?: string;
        /**
          * Navigation icon type.
         */
        "navigationIconType"?: string;
        "navigationPadding"?: string;
        /**
          * Navigation size.
          * @CSS
         */
        "navigationSize"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxSliderDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Pagination type.
          * @choice 'bullets', 'tabs', 'none'
         */
        "pagination"?: string;
        "paginationBulletsBackground"?: string;
        "paginationBulletsBackgroundActive"?: string;
        /**
          * Make bullets clickable.
         */
        "paginationBulletsClickable"?: boolean;
        /**
          * Will only keep a selected amount of bullets visible.
         */
        "paginationBulletsDynamic"?: boolean;
        /**
          * Amount of dynamic bullets.
         */
        "paginationBulletsDynamicAmount"?: number;
        /**
          * Size of the bullets.
          * @CSS
         */
        "paginationBulletsSize"?: string;
        /**
          * Space between the bullets.
          * @CSS
         */
        "paginationBulletsSpaceBetween"?: string;
        "paginationTabsGapMax"?: number;
        "paginationTabsGapMin"?: number;
        "paginationTabsInnerGapMax"?: number;
        "paginationTabsInnerGapMin"?: number;
        "paginationTabsMarginBottomMax"?: number;
        "paginationTabsMarginBottomMin"?: number;
        "paginationTabsMaxWidth"?: string;
        "paginationTabsPaddingMax"?: number;
        "paginationTabsPaddingMin"?: number;
        "paginationTransitionDuration"?: string;
        "paginationTransitionTimingFunction"?: string;
        /**
          * Filter property for the previous and next elements.
         */
        "prevNextFilter"?: string;
        /**
          * Screen reader message for first slide.
         */
        "slideMessageFirst"?: string;
        /**
          * Screen reader message for last slide.
         */
        "slideMessageLast"?: string;
        /**
          * Screen reader message for next slide.
         */
        "slideMessageNext"?: string;
        /**
          * Screen reader message for previous slide.
         */
        "slideMessagePrevious"?: string;
        /**
          * Amount of slides shown at once.
         */
        "slidesPerView"?: number;
        /**
          * Space between slides.
         */
        "spaceBetween"?: number;
        /**
          * Sliding speed.
         */
        "speed"?: number;
    }
    interface SpxSlideshow {
        "display"?: string;
        /**
          * Duration of slideshow to complete one cycle.
          * @CSS
         */
        "duration"?: string;
        /**
          * Gap between inner elements.
          * @CSS
         */
        "gap"?: string;
        /**
          * WordPress media size when using the helper function..
         */
        "imageSize"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @helper &lt;?php spx\get::gallery($fieldName, $type) ?>
         */
        "images"?: string;
        /**
          * Gets images from an ACF or Metabox field.
          * @choice 'acf', 'mb'
         */
        "imagesSrc"?: string;
        /**
          * Max width of inner elements.
          * @CSS
         */
        "maxWidth"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxSlideshowDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * If not set with this attribute, overflow should be set on the parent element.
          * @CSS
         */
        "overflow"?: string;
    }
    interface SpxSnackbar {
        "animationDelay"?: string;
        "animationDuration"?: string;
        "background"?: string;
        "border"?: string;
        "borderRadius"?: string;
        /**
          * Adds option to close snackbar after its creation.
         */
        "closeable"?: boolean;
        "color"?: string;
        /**
          * Distance to the edge of the viewport on the x-axis.
          * @CSS
         */
        "distanceX"?: string;
        /**
          * Distance to the edge of the viewport on the y-axis.
          * @CSS
         */
        "distanceY"?: string;
        /**
          * Makes snackbar not removable.
          * @editor '#components'
         */
        "fixed"?: boolean;
        "fontSize"?: string;
        /**
          * Unique identifier for snackbar instance.
          * @editor '#components'
         */
        "identifier"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxSnackbarDidLoad"?: (event: CustomEvent<any>) => void;
        "padding"?: string;
        /**
          * Component position in page.
          * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
         */
        "position"?: string;
        /**
          * CSS property position of button.
          * @editor 'absolute'
         */
        "positionCss"?: | 'fixed'
    | 'absolute'
    | 'relative'
    | 'static';
        /**
          * Reverses the close button if "closable" prop is true.
         */
        "reverse"?: boolean;
        /**
          * Space between snackbars.
         */
        "spaceBetween"?: string;
        /**
          * Element where snackbars should be created in.
          * @editor '#components'
         */
        "target"?: string;
        /**
          * Text inside snackbar.
         */
        "text"?: string;
        "zIndex"?: number;
    }
    interface SpxText {
        "h1FontSizeMax"?: number;
        "h1FontSizeMin"?: number;
        "h2FontSizeMax"?: number;
        "h2FontSizeMin"?: number;
        "h3FontSizeMax"?: number;
        "h3FontSizeMin"?: number;
        "h4FontSizeMax"?: number;
        "h4FontSizeMin"?: number;
        "headingColor"?: string;
        "headingFontFamily"?: string;
        "headingFontWeight"?: string;
        "headingLetterSpacing"?: string;
        "headingLineHeight"?: string;
        "headingTextTransform"?: string;
        "linkDecorationColor"?: string;
        /**
          * Parse markdown.
         */
        "markdown"?: boolean;
        "maxWidth"?: string;
        /**
          * Fires after component has loaded.
         */
        "onSpxTextDidLoad"?: (event: CustomEvent<any>) => void;
        "paddingFigureMax"?: number;
        "paddingFigureMin"?: number;
        "spaceBeforeH1Max"?: number;
        "spaceBeforeH1Min"?: number;
        "spaceBetweenMax"?: number;
        "spaceBetweenMin"?: number;
        "spaceBetweenPMax"?: number;
        "spaceBetweenPMin"?: number;
        "textColor"?: string;
        "textFontFamily"?: string;
        "textFontSizeMax"?: number;
        "textFontSizeMin"?: number;
        "textFontWeight"?: string;
        "textLetterSpacing"?: string;
        "textLineHeight"?: string;
        "textTextTransform"?: string;
    }
    interface SpxTypewriter {
        /**
          * Automatically starts writing.
         */
        "autoStart"?: boolean;
        /**
          * Writing delay in ms. Also accepts 'natural' value.
         */
        "delay"?: any;
        /**
          * Delete delay in ms. Also accepts 'natural' value.
         */
        "deleteSpeed"?: any;
        "display"?: string;
        /**
          * Loops the animation.
         */
        "loop"?: boolean;
        /**
          * Fires after component has loaded.
         */
        "onSpxTypewriterDidLoad"?: (event: CustomEvent<any>) => void;
        /**
          * Text that should be written.
         */
        "text"?: string;
    }
    interface IntrinsicElements {
        "spx-accordion": SpxAccordion;
        "spx-animate": SpxAnimate;
        "spx-class-toggle": SpxClassToggle;
        "spx-code": SpxCode;
        "spx-container": SpxContainer;
        "spx-edit": SpxEdit;
        "spx-edit-button": SpxEditButton;
        "spx-editor": SpxEditor;
        "spx-group": SpxGroup;
        "spx-icon": SpxIcon;
        "spx-iframe": SpxIframe;
        "spx-image-comparison": SpxImageComparison;
        "spx-lightbox": SpxLightbox;
        "spx-loader": SpxLoader;
        "spx-masonry": SpxMasonry;
        "spx-mockup": SpxMockup;
        "spx-navigation": SpxNavigation;
        "spx-notation": SpxNotation;
        "spx-offset": SpxOffset;
        "spx-page-docs": SpxPageDocs;
        "spx-page-single": SpxPageSingle;
        "spx-scrollspy": SpxScrollspy;
        "spx-section-button": SpxSectionButton;
        "spx-section-footer": SpxSectionFooter;
        "spx-section-header": SpxSectionHeader;
        "spx-section-two-column": SpxSectionTwoColumn;
        "spx-share": SpxShare;
        "spx-slider": SpxSlider;
        "spx-slideshow": SpxSlideshow;
        "spx-snackbar": SpxSnackbar;
        "spx-text": SpxText;
        "spx-typewriter": SpxTypewriter;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "spx-accordion": LocalJSX.SpxAccordion & JSXBase.HTMLAttributes<HTMLSpxAccordionElement>;
            "spx-animate": LocalJSX.SpxAnimate & JSXBase.HTMLAttributes<HTMLSpxAnimateElement>;
            "spx-class-toggle": LocalJSX.SpxClassToggle & JSXBase.HTMLAttributes<HTMLSpxClassToggleElement>;
            "spx-code": LocalJSX.SpxCode & JSXBase.HTMLAttributes<HTMLSpxCodeElement>;
            "spx-container": LocalJSX.SpxContainer & JSXBase.HTMLAttributes<HTMLSpxContainerElement>;
            "spx-edit": LocalJSX.SpxEdit & JSXBase.HTMLAttributes<HTMLSpxEditElement>;
            "spx-edit-button": LocalJSX.SpxEditButton & JSXBase.HTMLAttributes<HTMLSpxEditButtonElement>;
            "spx-editor": LocalJSX.SpxEditor & JSXBase.HTMLAttributes<HTMLSpxEditorElement>;
            "spx-group": LocalJSX.SpxGroup & JSXBase.HTMLAttributes<HTMLSpxGroupElement>;
            "spx-icon": LocalJSX.SpxIcon & JSXBase.HTMLAttributes<HTMLSpxIconElement>;
            "spx-iframe": LocalJSX.SpxIframe & JSXBase.HTMLAttributes<HTMLSpxIframeElement>;
            "spx-image-comparison": LocalJSX.SpxImageComparison & JSXBase.HTMLAttributes<HTMLSpxImageComparisonElement>;
            "spx-lightbox": LocalJSX.SpxLightbox & JSXBase.HTMLAttributes<HTMLSpxLightboxElement>;
            "spx-loader": LocalJSX.SpxLoader & JSXBase.HTMLAttributes<HTMLSpxLoaderElement>;
            "spx-masonry": LocalJSX.SpxMasonry & JSXBase.HTMLAttributes<HTMLSpxMasonryElement>;
            "spx-mockup": LocalJSX.SpxMockup & JSXBase.HTMLAttributes<HTMLSpxMockupElement>;
            "spx-navigation": LocalJSX.SpxNavigation & JSXBase.HTMLAttributes<HTMLSpxNavigationElement>;
            "spx-notation": LocalJSX.SpxNotation & JSXBase.HTMLAttributes<HTMLSpxNotationElement>;
            "spx-offset": LocalJSX.SpxOffset & JSXBase.HTMLAttributes<HTMLSpxOffsetElement>;
            "spx-page-docs": LocalJSX.SpxPageDocs & JSXBase.HTMLAttributes<HTMLSpxPageDocsElement>;
            "spx-page-single": LocalJSX.SpxPageSingle & JSXBase.HTMLAttributes<HTMLSpxPageSingleElement>;
            "spx-scrollspy": LocalJSX.SpxScrollspy & JSXBase.HTMLAttributes<HTMLSpxScrollspyElement>;
            "spx-section-button": LocalJSX.SpxSectionButton & JSXBase.HTMLAttributes<HTMLSpxSectionButtonElement>;
            "spx-section-footer": LocalJSX.SpxSectionFooter & JSXBase.HTMLAttributes<HTMLSpxSectionFooterElement>;
            "spx-section-header": LocalJSX.SpxSectionHeader & JSXBase.HTMLAttributes<HTMLSpxSectionHeaderElement>;
            "spx-section-two-column": LocalJSX.SpxSectionTwoColumn & JSXBase.HTMLAttributes<HTMLSpxSectionTwoColumnElement>;
            "spx-share": LocalJSX.SpxShare & JSXBase.HTMLAttributes<HTMLSpxShareElement>;
            "spx-slider": LocalJSX.SpxSlider & JSXBase.HTMLAttributes<HTMLSpxSliderElement>;
            "spx-slideshow": LocalJSX.SpxSlideshow & JSXBase.HTMLAttributes<HTMLSpxSlideshowElement>;
            "spx-snackbar": LocalJSX.SpxSnackbar & JSXBase.HTMLAttributes<HTMLSpxSnackbarElement>;
            "spx-text": LocalJSX.SpxText & JSXBase.HTMLAttributes<HTMLSpxTextElement>;
            "spx-typewriter": LocalJSX.SpxTypewriter & JSXBase.HTMLAttributes<HTMLSpxTypewriterElement>;
        }
    }
}
