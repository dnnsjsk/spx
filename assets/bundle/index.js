import { getAssetPath, attachShadow, Build, h as h$4, Host, getRenderingRef, forceUpdate, createEvent, proxyCustomElement } from '@stencil/core/internal/client';
export { setAssetPath, setPlatformOptions } from '@stencil/core/internal/client';

let CACHED_MAP;
const getIconMap = () => {
  if (typeof window === 'undefined') {
    return new Map();
  }
  else {
    if (!CACHED_MAP) {
      const win = window;
      win.Ionicons = win.Ionicons || {};
      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();
    }
    return CACHED_MAP;
  }
};
const getUrl = (i) => {
  let url = getSrc(i.src);
  if (url) {
    return url;
  }
  url = getName(i.name, i.icon, i.mode, i.ios, i.md);
  if (url) {
    return getNamedUrl(url);
  }
  if (i.icon) {
    url = getSrc(i.icon);
    if (url) {
      return url;
    }
    url = getSrc(i.icon[i.mode]);
    if (url) {
      return url;
    }
  }
  return null;
};
const getNamedUrl = (iconName) => {
  const url = getIconMap().get(iconName);
  if (url) {
    return url;
  }
  return getAssetPath(`svg/${iconName}.svg`);
};
const getName = (iconName, icon, mode, ios, md) => {
  // default to "md" if somehow the mode wasn't set
  mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';
  // if an icon was passed in using the ios or md attributes
  // set the iconName to whatever was passed in
  if (ios && mode === 'ios') {
    iconName = toLower(ios);
  }
  else if (md && mode === 'md') {
    iconName = toLower(md);
  }
  else {
    if (!iconName && icon && !isSrc(icon)) {
      iconName = icon;
    }
    if (isStr(iconName)) {
      iconName = toLower(iconName);
    }
  }
  if (!isStr(iconName) || iconName.trim() === '') {
    return null;
  }
  // only allow alpha characters and dash
  const invalidChars = iconName.replace(/[a-z]|-|\d/gi, '');
  if (invalidChars !== '') {
    return null;
  }
  return iconName;
};
const getSrc = (src) => {
  if (isStr(src)) {
    src = src.trim();
    if (isSrc(src)) {
      return src;
    }
  }
  return null;
};
const isSrc = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr = (val) => typeof val === 'string';
const toLower = (val) => val.toLowerCase();

const validateContent = (svgContent) => {
  const div = document.createElement('div');
  div.innerHTML = svgContent;
  // setup this way to ensure it works on our buddy IE
  for (let i = div.childNodes.length - 1; i >= 0; i--) {
    if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {
      div.removeChild(div.childNodes[i]);
    }
  }
  // must only have 1 root element
  const svgElm = div.firstElementChild;
  if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {
    const svgClass = svgElm.getAttribute('class') || '';
    svgElm.setAttribute('class', (svgClass + ' s-ion-icon').trim());
    // root element must be an svg
    // lets double check we've got valid elements
    // do not allow scripts
    if (isValid(svgElm)) {
      return div.innerHTML;
    }
  }
  return '';
};
const isValid = (elm) => {
  if (elm.nodeType === 1) {
    if (elm.nodeName.toLowerCase() === 'script') {
      return false;
    }
    for (let i = 0; i < elm.attributes.length; i++) {
      const val = elm.attributes[i].value;
      if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {
        return false;
      }
    }
    for (let i = 0; i < elm.childNodes.length; i++) {
      if (!isValid(elm.childNodes[i])) {
        return false;
      }
    }
  }
  return true;
};

const ioniconContent = new Map();
const requests = new Map();
const getSvgContent = (url, sanitize) => {
  // see if we already have a request for this url
  let req = requests.get(url);
  if (!req) {
    if (typeof fetch !== 'undefined' && typeof document !== 'undefined') {
      // we don't already have a request
      req = fetch(url).then((rsp) => {
        if (rsp.ok) {
          return rsp.text().then((svgContent) => {
            if (svgContent && sanitize !== false) {
              svgContent = validateContent(svgContent);
            }
            ioniconContent.set(url, svgContent || '');
          });
        }
        ioniconContent.set(url, '');
      });
      // cache for the same requests
      requests.set(url, req);
    }
    else {
      // set to empty for ssr scenarios and resolve promise
      ioniconContent.set(url, '');
      return Promise.resolve();
    }
  }
  return req;
};

const iconCss = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";

const Icon = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.iconName = null;
    this.isVisible = false;
    /**
     * The mode determines which platform styles to use.
     */
    this.mode = getIonMode();
    /**
     * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.
     * Default, `false`.
     */
    this.lazy = false;
    /**
     * When set to `false`, SVG content that is HTTP fetched will not be checked
     * if the response SVG content has any `<script>` elements, or any attributes
     * that start with `on`, such as `onclick`.
     * @default true
     */
    this.sanitize = true;
  }
  connectedCallback() {
    // purposely do not return the promise here because loading
    // the svg file should not hold up loading the app
    // only load the svg if it's visible
    this.waitUntilVisible(this.el, '50px', () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = undefined;
    }
  }
  waitUntilVisible(el, rootMargin, cb) {
    if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {
      const io = (this.io = new window.IntersectionObserver((data) => {
        if (data[0].isIntersecting) {
          io.disconnect();
          this.io = undefined;
          cb();
        }
      }, { rootMargin }));
      io.observe(el);
    }
    else {
      // browser doesn't support IntersectionObserver
      // so just fallback to always show it
      cb();
    }
  }
  loadIcon() {
    if (Build.isBrowser && this.isVisible) {
      const url = getUrl(this);
      if (url) {
        if (ioniconContent.has(url)) {
          // sync if it's already loaded
          this.svgContent = ioniconContent.get(url);
        }
        else {
          // async if it hasn't been loaded
          getSvgContent(url, this.sanitize).then(() => (this.svgContent = ioniconContent.get(url)));
        }
      }
    }
    const label = this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);
    if (!this.ariaLabel && this.ariaHidden !== 'true') {
      // user did not provide a label
      // come up with the label based on the icon name
      if (label) {
        this.ariaLabel = label.replace(/\-/g, ' ');
      }
    }
  }
  render() {
    const { iconName } = this;
    const mode = this.mode || 'md';
    const flipRtl = this.flipRtl ||
      (iconName &&
        (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) &&
        this.flipRtl !== false);
    return (h$4(Host, { role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, 'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl' }) }, Build.isBrowser && this.svgContent ? (h$4("div", { class: "icon-inner", innerHTML: this.svgContent })) : (h$4("div", { class: "icon-inner" }))));
  }
  static get assetsDirs() { return ["svg"]; }
  get el() { return this; }
  static get watchers() { return {
    "name": ["loadIcon"],
    "src": ["loadIcon"],
    "icon": ["loadIcon"]
  }; }
  static get style() { return iconCss; }
};
const getIonMode = () => (Build.isBrowser && typeof document !== 'undefined' && document.documentElement.getAttribute('mode')) || 'md';
const createColorClasses = (color) => {
  return color
    ? {
      'ion-color': true,
      [`ion-color-${color}`]: true,
    }
    : null;
};

/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        before = _this.prepend ? _this.container.firstChild : _this.before;
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };

  return StyleSheet;
}();

var e$4="-ms-";var r$5="-moz-";var a$4="-webkit-";var c$4="comm";var n$5="rule";var t$5="decl";var i$5="@import";var p$3="@keyframes";var k$3=Math.abs;var d$4=String.fromCharCode;function m$4(e,r){return (((r<<2^z$3(e,0))<<2^z$3(e,1))<<2^z$3(e,2))<<2^z$3(e,3)}function g$4(e){return e.trim()}function x$3(e,r){return (e=r.exec(e))?e[0]:e}function y$3(e,r,a){return e.replace(r,a)}function j$3(e,r){return e.indexOf(r)}function z$3(e,r){return e.charCodeAt(r)|0}function C$3(e,r,a){return e.slice(r,a)}function A$3(e){return e.length}function M$2(e){return e.length}function O$2(e,r){return r.push(e),e}function S$2(e,r){return e.map(r).join("")}var q$2=1;var B$2=1;var D$3=0;var E$2=0;var F$2=0;var G$2="";function H$3(e,r,a,c,n,t,s){return {value:e,root:r,parent:a,type:c,props:n,children:t,line:q$2,column:B$2,length:s,return:""}}function I$3(e,r,a){return H$3(e,r.root,r.parent,a,r.props,r.children,0)}function J$2(){return F$2}function K$2(){F$2=E$2>0?z$3(G$2,--E$2):0;if(B$2--,F$2===10)B$2=1,q$2--;return F$2}function L$2(){F$2=E$2<D$3?z$3(G$2,E$2++):0;if(B$2++,F$2===10)B$2=1,q$2++;return F$2}function N$3(){return z$3(G$2,E$2)}function P$3(){return E$2}function Q$2(e,r){return C$3(G$2,e,r)}function R$2(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function T$3(e){return q$2=B$2=1,D$3=A$3(G$2=e),E$2=0,[]}function U$2(e){return G$2="",e}function V$2(e){return g$4(Q$2(E$2-1,_$5(e===91?e+2:e===40?e+1:e)))}function X$2(e){while(F$2=N$3())if(F$2<33)L$2();else break;return R$2(e)>2||R$2(F$2)>3?"":" "}function Z$2(e,r){while(--r&&L$2())if(F$2<48||F$2>102||F$2>57&&F$2<65||F$2>70&&F$2<97)break;return Q$2(e,P$3()+(r<6&&N$3()==32&&L$2()==32))}function _$5(e){while(L$2())switch(F$2){case e:return E$2;case 34:case 39:return _$5(e===34||e===39?e:F$2);case 40:if(e===41)_$5(e);break;case 92:L$2();break}return E$2}function ee$2(e,r){while(L$2())if(e+F$2===47+10)break;else if(e+F$2===42+42&&N$3()===47)break;return "/*"+Q$2(r,E$2-1)+"*"+d$4(e===47?e:L$2())}function re$2(e){while(!R$2(N$3()))L$2();return Q$2(e,E$2)}function ae$2(e){return U$2(ce$2("",null,null,null,[""],e=T$3(e),0,[0],e))}function ce$2(e,r,a,c,n,t,s,u,i){var f=0;var o=0;var l=s;var v=0;var h=0;var p=0;var b=1;var w=1;var $=1;var k=0;var m="";var g=n;var x=t;var j=c;var z=m;while(w)switch(p=k,k=L$2()){case 34:case 39:case 91:case 40:z+=V$2(k);break;case 9:case 10:case 13:case 32:z+=X$2(p);break;case 92:z+=Z$2(P$3()-1,7);continue;case 47:switch(N$3()){case 42:case 47:O$2(te$2(ee$2(L$2(),P$3()),r,a),i);break;default:z+="/";}break;case 123*b:u[f++]=A$3(z)*$;case 125*b:case 59:case 0:switch(k){case 0:case 125:w=0;case 59+o:if(h>0&&A$3(z)-l)O$2(h>32?se$2(z+";",c,a,l-1):se$2(y$3(z," ","")+";",c,a,l-2),i);break;case 59:z+=";";default:O$2(j=ne$2(z,r,a,f,o,n,u,m,g=[],x=[],l),t);if(k===123)if(o===0)ce$2(z,r,j,j,g,t,l,u,x);else switch(v){case 100:case 109:case 115:ce$2(e,j,j,c&&O$2(ne$2(e,j,j,0,0,n,u,m,n,g=[],l),x),n,x,l,u,c?g:x);break;default:ce$2(z,j,j,j,[""],x,l,u,x);}}f=o=h=0,b=$=1,m=z="",l=s;break;case 58:l=1+A$3(z),h=p;default:if(b<1)if(k==123)--b;else if(k==125&&b++==0&&K$2()==125)continue;switch(z+=d$4(k),k*b){case 38:$=o>0?1:(z+="\f",-1);break;case 44:u[f++]=(A$3(z)-1)*$,$=1;break;case 64:if(N$3()===45)z+=V$2(L$2());v=N$3(),o=A$3(m=z+=re$2(P$3())),k++;break;case 45:if(p===45&&A$3(z)==2)b=0;}}return t}function ne$2(e,r,a,c,t,s,u,i,f,o,l){var v=t-1;var h=t===0?s:[""];var p=M$2(h);for(var b=0,w=0,$=0;b<c;++b)for(var d=0,m=C$3(e,v+1,v=k$3(w=u[b])),x=e;d<p;++d)if(x=g$4(w>0?h[d]+" "+m:y$3(m,/&\f/g,h[d])))f[$++]=x;return H$3(e,r,a,t===0?n$5:i,f,o,l)}function te$2(e,r,a){return H$3(e,r,a,c$4,d$4(J$2()),C$3(e,2,-2),0)}function se$2(e,r,a,c){return H$3(e,r,a,t$5,C$3(e,0,c),C$3(e,c+1,-1),c)}function ue$2(c,n){switch(m$4(c,n)){case 5103:return a$4+"print-"+c+c;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return a$4+c+c;case 5349:case 4246:case 4810:case 6968:case 2756:return a$4+c+r$5+c+e$4+c+c;case 6828:case 4268:return a$4+c+e$4+c+c;case 6165:return a$4+c+e$4+"flex-"+c+c;case 5187:return a$4+c+y$3(c,/(\w+).+(:[^]+)/,a$4+"box-$1$2"+e$4+"flex-$1$2")+c;case 5443:return a$4+c+e$4+"flex-item-"+y$3(c,/flex-|-self/,"")+c;case 4675:return a$4+c+e$4+"flex-line-pack"+y$3(c,/align-content|flex-|-self/,"")+c;case 5548:return a$4+c+e$4+y$3(c,"shrink","negative")+c;case 5292:return a$4+c+e$4+y$3(c,"basis","preferred-size")+c;case 6060:return a$4+"box-"+y$3(c,"-grow","")+a$4+c+e$4+y$3(c,"grow","positive")+c;case 4554:return a$4+y$3(c,/([^-])(transform)/g,"$1"+a$4+"$2")+c;case 6187:return y$3(y$3(y$3(c,/(zoom-|grab)/,a$4+"$1"),/(image-set)/,a$4+"$1"),c,"")+c;case 5495:case 3959:return y$3(c,/(image-set\([^]*)/,a$4+"$1"+"$`$1");case 4968:return y$3(y$3(c,/(.+:)(flex-)?(.*)/,a$4+"box-pack:$3"+e$4+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+a$4+c+c;case 4095:case 3583:case 4068:case 2532:return y$3(c,/(.+)-inline(.+)/,a$4+"$1$2")+c;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(A$3(c)-1-n>6)switch(z$3(c,n+1)){case 109:if(z$3(c,n+4)!==45)break;case 102:return y$3(c,/(.+:)(.+)-([^]+)/,"$1"+a$4+"$2-$3"+"$1"+r$5+(z$3(c,n+3)==108?"$3":"$2-$3"))+c;case 115:return ~j$3(c,"stretch")?ue$2(y$3(c,"stretch","fill-available"),n)+c:c}break;case 4949:if(z$3(c,n+1)!==115)break;case 6444:switch(z$3(c,A$3(c)-3-(~j$3(c,"!important")&&10))){case 107:return y$3(c,":",":"+a$4)+c;case 101:return y$3(c,/(.+:)([^;!]+)(;|!.+)?/,"$1"+a$4+(z$3(c,14)===45?"inline-":"")+"box$3"+"$1"+a$4+"$2$3"+"$1"+e$4+"$2box$3")+c}break;case 5936:switch(z$3(c,n+11)){case 114:return a$4+c+e$4+y$3(c,/[svh]\w+-[tblr]{2}/,"tb")+c;case 108:return a$4+c+e$4+y$3(c,/[svh]\w+-[tblr]{2}/,"tb-rl")+c;case 45:return a$4+c+e$4+y$3(c,/[svh]\w+-[tblr]{2}/,"lr")+c}return a$4+c+e$4+c+c}return c}function ie$2(e,r){var a="";var c=M$2(e);for(var n=0;n<c;n++)a+=r(e[n],n,e,r)||"";return a}function fe$2(e,r,a,s){switch(e.type){case i$5:case t$5:return e.return=e.return||e.value;case c$4:return "";case n$5:e.value=e.props.join(",");}return A$3(a=ie$2(e.children,s))?e.return=e.value+"{"+a+"}":""}function oe$2(e){var r=M$2(e);return function(a,c,n,t){var s="";for(var u=0;u<r;u++)s+=e[u](a,c,n,t)||"";return s}}function le$2(e){return function(r){if(!r.root)if(r=r.return)e(r);}}function ve$2(c,s,u,i){if(!c.return)switch(c.type){case t$5:c.return=ue$2(c.value,c.length);break;case p$3:return ie$2([I$3(y$3(c.value,"@","@"+a$4),c,"")],i);case n$5:if(c.length)return S$2(c.props,(function(n){switch(x$3(n,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return ie$2([I$3(y$3(n,/:(read-\w+)/,":"+r$5+"$1"),c,"")],i);case"::placeholder":return ie$2([I$3(y$3(n,/:(plac\w+)/,":"+a$4+"input-$1"),c,""),I$3(y$3(n,/:(plac\w+)/,":"+r$5+"$1"),c,""),I$3(y$3(n,/:(plac\w+)/,e$4+"input-$1"),c,"")],i)}return ""}))}}

function memoize$1(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (R$2(character)) {
      case 0:
        // &\f
        if (character === 38 && N$3() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += re$2(E$2 - 1);
        break;

      case 2:
        parsed[index] += V$2(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = N$3() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += d$4(character);
    }
  } while (character = L$2());

  return parsed;
};

var getRules = function getRules(value, points) {
  return U$2(toRules(T$3(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // .length indicates if this rule contains pseudo or not
  !element.length) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};

var defaultStylisPlugins = [ve$2];

var createCache = function createCache(options) {
  var key = options.key;

  if ( key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  var inserted = {}; // $FlowFixMe

  var container;
  var nodesToHydrate = [];

  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  {
    var currentSheet;
    var finalizingPlugins = [fe$2, le$2(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = oe$2(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return ie$2(ae$2(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */memoize$1(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }

        break;
      }
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
          throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {

      styles += strings[i];
    }
  }


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = murmur2(styles) + identifierName;

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};

var isBrowser = "object" !== 'undefined';
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false ) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};

function insertWithoutScoping(cache, serialized) {
  if (cache.inserted[serialized.name] === undefined) {
    return cache.insert('', serialized, cache.sheet, true);
  }
}

function merge$3(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);

  if (registeredStyles.length < 2) {
    return className;
  }

  return rawClassName + css(registeredStyles);
}

var createEmotion = function createEmotion(options) {
  var cache = createCache(options); // $FlowFixMe

  cache.sheet.speedy = function (value) {

    this.isSpeedy = value;
  };

  cache.compat = true;

  var css = function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var serialized = serializeStyles(args, cache.registered, undefined);
    insertStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };

  var keyframes = function keyframes() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var serialized = serializeStyles(args, cache.registered);
    var animation = "animation-" + serialized.name;
    insertWithoutScoping(cache, {
      name: serialized.name,
      styles: "@keyframes " + animation + "{" + serialized.styles + "}"
    });
    return animation;
  };

  var injectGlobal = function injectGlobal() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var serialized = serializeStyles(args, cache.registered);
    insertWithoutScoping(cache, serialized);
  };

  var cx = function cx() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return merge$3(cache.registered, css, classnames(args));
  };

  return {
    css: css,
    cx: cx,
    injectGlobal: injectGlobal,
    keyframes: keyframes,
    hydrate: function hydrate(ids) {
      ids.forEach(function (key) {
        cache.inserted[key] = true;
      });
    },
    flush: function flush() {
      cache.registered = {};
      cache.inserted = {};
      cache.sheet.flush();
    },
    // $FlowFixMe
    sheet: cache.sheet,
    cache: cache,
    getRegisteredStyles: getRegisteredStyles.bind(null, cache.registered),
    merge: merge$3.bind(null, cache.registered, css)
  };
};

var classnames = function classnames(args) {
  var cls = '';

  for (var i = 0; i < args.length; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;

    switch (typeof arg) {
      case 'boolean':
        break;

      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            toAdd = '';

            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }

          break;
        }

      default:
        {
          toAdd = arg;
        }
    }

    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }

  return cls;
};

var _createEmotion = createEmotion({
  key: 'css'
}),
    cx$1 = _createEmotion.cx,
    css$2 = _createEmotion.css;

/**
 * Set CSS variable.
 *
 * @param {string} tag HTML Element tag (without spx).
 * @param {string} type Property type.
 * @param {string} value CSS value.
 * @param {boolean} global If value should be applied globally (to body).
 * @returns {string} CSS variable.
 */
function setVar(tag, type, value, global = false) {
  if (global) {
    document.body.classList.add(css$2 `
      --${tag}-${type}: var(--${tag}-token-${type},${value});
    `);
  }
  return `var(--${tag}-${type}${value ? ', ' + value : ''})`;
}

const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce$1 = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce$1((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = ({ on }) => {
    const elmsToUpdate = new Map();
    if (typeof getRenderingRef === 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        on('dispose', () => {
            elmsToUpdate.clear();
        });
        on('get', (propName) => {
            const elm = getRenderingRef();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        });
        on('set', (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(forceUpdate));
            }
            cleanupElements(elmsToUpdate);
        });
        on('reset', () => {
            elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));
            cleanupElements(elmsToUpdate);
        });
    }
};

const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    let states = new Map(Object.entries(defaultState !== null && defaultState !== void 0 ? defaultState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        states = new Map(Object.entries(defaultState !== null && defaultState !== void 0 ? defaultState : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(defaultState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        const unReset = on('reset', () => cb(defaultState[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => subscriptions.forEach((subscription) => {
        if (subscription.set) {
            on('set', subscription.set);
        }
        if (subscription.get) {
            on('get', subscription.get);
        }
        if (subscription.reset) {
            on('reset', subscription.reset);
        }
    });
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    stencilSubscription(map);
    return map;
};

const { state, onChange } = createStore({
  base: 16,
  minWidthPx: 640,
  maxWidthPx: 1536,
});
onChange('base', (value) => {
  state.base = value;
});
onChange('minWidthPx', (value) => {
  state.minWidthPx = value;
});
onChange('maxWidthPx', (value) => {
  state.maxWidthPx = value;
});

/**
 * Set clamp.
 *
 * @param {string} tag HTML Element tag (without spx).
 * @param {string} type Property type.
 * @param {string} minValue Minimum value.
 * @param {string} maxValue Maximum value.
 * @param {string} unitless If returned variable should be unitless
 * @param {number} base Base size.
 * @param {number} minWidthPx Minimum width of screen size to scale down to.
 * @param {number} maxWidthPx Maximum width of screen size to scale up to.
 * @returns {string} CSS value.
 */
function setClamp(tag, type, minValue, maxValue, unitless = false, base = state.base, minWidthPx = state.minWidthPx, maxWidthPx = state.maxWidthPx) {
  const pixelsPerRem = base;
  const minWidth = minWidthPx / pixelsPerRem;
  const maxWidth = maxWidthPx / pixelsPerRem;
  const slope = (maxValue - minValue) / (maxWidth - minWidth);
  const yAxisIntersection = -minWidth * slope + minValue;
  return `clamp(var(--${tag}-${type}-min, ${minValue}${!unitless ? 'rem' : ''}), ${yAxisIntersection}${!unitless ? 'rem' : ''} + ${slope * 100}vw, var(--${tag}-${type}-max, ${maxValue}${!unitless ? 'rem' : ''}))`;
}

/**
 * Sets clamp or var.
 *
 * @param {string} tag HTML Element tag (without spx).
 * @param {string} type Property type.
 * @param {string} size Var size.
 * @param {number} min Minimum clamp size.
 * @param {number} max Maximum clamp size.
 * @param {boolean} condition Condition.
 * @returns {Function} Var or Clamp function.
 */
function setStyle(tag, type, size, min, max, condition) {
  if (condition === 'default') {
    return setVar(tag, type, size);
  }
  else if (condition === 'fluid') {
    return setClamp(tag, type, min, max);
  }
}

/** Defaults. */
const backdropFilter = 'var(--spx-backdrop-filter)';
const borderRadius = 'var(--spx-border-radius)';
const bpMobileWidth = 768;
const display$1 = 'var(--spx-display)';
const focus = {
  '&:focus': {
    outline: 'none',
  },
  '&:focus-visible': {
    outline: 'none',
    boxShadow: 'var(--spx-focus)',
  },
};
const fontFamily = 'var(--spx-font-family)';
const fontSize = 'var(--spx-font-size)';
const transitionDuration = 'var(--spx-transition-duration)';
const transitionTimingFunction = 'var(--spx-transition-timing-function)';
/**
 * Positioning properties.
 *
 * @param {string} tag Name of the component.
 * @param {Array} array Positioning.
 * @param {string} distanceX Value of the X distance.
 * @param {string} distanceY Value of the X distance.
 * @returns {object} CSS object.
 */
const position$1 = (tag, array, distanceX, distanceY) => ({
  top: array[0] === 'top' &&
    'var(--spx-' + tag + '-distance-y, ' + distanceY + ')',
  right: array[1] === 'right'
    ? 'var(--spx-' + tag + '-distance-x, ' + distanceX + ')'
    : null,
  bottom: array[0] === 'bottom' &&
    'var(--spx-' + tag + '-distance-y, ' + distanceY + ')',
  left: array[1] === 'center'
    ? '50%'
    : array[1] === 'left'
      ? 'var(--spx-' + tag + '-distance-x, ' + distanceX + ')'
      : null,
  transform: array[1] === 'center' && 'translate(-50%, 0)',
});
/**
 * Text constants.
 *
 * @param {string} tag Tag name.
 * @param {string} type Variable name.
 * @param {string} color Color.
 * @param {string} size Size.
 * @param {string} min Minimum font-size.
 * @param {string} max Maximum font-size.
 * @param {string} weight Font weight.
 * @param {string} letterSpacing Letter spacing.
 * @param {string} lineHeight Line height.
 * @param {string} transform Transform.
 * @param {string} condition Condition.
 * @returns {object} CSS object.
 */
const text$1 = (tag, type, color, size, min, max, weight, letterSpacing, lineHeight, transform, condition) => ({
  color: setVar(tag, '' + type + '-color', color),
  fontSize: setStyle(tag, '' + type + '-font-size', size, min, max, condition),
  fontWeight: setVar(tag, '' + type + '-font-weight', weight),
  letterSpacing: setVar(tag, '' + type + '-letter-spacing', letterSpacing),
  lineHeight: setVar(tag, '' + type + '-line-height', lineHeight),
  textTransform: setVar(tag, '' + type + '-text-transform', transform),
});

/**
 * Set up a mutation observer.
 *
 * @param {HTMLElement} el HTML element to watch.
 * @param {object} options Settings.
 * @param {Function} functionToRun Callback to run once element is in view.
 * @param {boolean} runOnce Disconnect observer after changes.
 */
function mutationObserver(el, options, functionToRun, runOnce = false) {
  const callback = (mutationsList) => {
    mutationsList.forEach(() => {
      functionToRun();
      if (runOnce) {
        observer.disconnect();
      }
    });
  };
  const observer = new MutationObserver(callback);
  observer.observe(el, options);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire();
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var lazyload_min = createCommonjsModule(function (module, exports) {
!function(t,n){module.exports=n();}(commonjsGlobal,(function(){function t(){return (t=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);}return t}).apply(this,arguments)}var n="undefined"!=typeof window,e=n&&!("onscroll"in window)||"undefined"!=typeof navigator&&/(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent),i=n&&"IntersectionObserver"in window,o=n&&"classList"in document.createElement("p"),r=n&&window.devicePixelRatio>1,a={elements_selector:".lazy",container:e||n?document:null,threshold:300,thresholds:null,data_src:"src",data_srcset:"srcset",data_sizes:"sizes",data_bg:"bg",data_bg_hidpi:"bg-hidpi",data_bg_multi:"bg-multi",data_bg_multi_hidpi:"bg-multi-hidpi",data_poster:"poster",class_applied:"applied",class_loading:"loading",class_loaded:"loaded",class_error:"error",class_entered:"entered",class_exited:"exited",unobserve_completed:!0,unobserve_entered:!1,cancel_on_exit:!0,callback_enter:null,callback_exit:null,callback_applied:null,callback_loading:null,callback_loaded:null,callback_error:null,callback_finish:null,callback_cancel:null,use_native:!1},c=function(n){return t({},a,n)},s=function(t,n){var e,i="LazyLoad::Initialized",o=new t(n);try{e=new CustomEvent(i,{detail:{instance:o}});}catch(t){(e=document.createEvent("CustomEvent")).initCustomEvent(i,!1,!1,{instance:o});}window.dispatchEvent(e);},l="loading",u="loaded",d="applied",f="error",_="native",g="data-",v="ll-status",b=function(t,n){return t.getAttribute(g+n)},p=function(t){return b(t,v)},h=function(t,n){return function(t,n,e){var i="data-ll-status";null!==e?t.setAttribute(i,e):t.removeAttribute(i);}(t,0,n)},m=function(t){return h(t,null)},E=function(t){return null===p(t)},y=function(t){return p(t)===_},I=[l,u,d,f],A=function(t,n,e,i){t&&(void 0===i?void 0===e?t(n):t(n,e):t(n,e,i));},L=function(t,n){o?t.classList.add(n):t.className+=(t.className?" ":"")+n;},w=function(t,n){o?t.classList.remove(n):t.className=t.className.replace(new RegExp("(^|\\s+)"+n+"(\\s+|$)")," ").replace(/^\s+/,"").replace(/\s+$/,"");},k=function(t){return t.llTempImage},O=function(t,n){if(n){var e=n._observer;e&&e.unobserve(t);}},x=function(t,n){t&&(t.loadingCount+=n);},z=function(t,n){t&&(t.toLoadCount=n);},C=function(t){for(var n,e=[],i=0;n=t.children[i];i+=1)"SOURCE"===n.tagName&&e.push(n);return e},N=function(t,n,e){e&&t.setAttribute(n,e);},M=function(t,n){t.removeAttribute(n);},R=function(t){return !!t.llOriginalAttrs},T=function(t){if(!R(t)){var n={};n.src=t.getAttribute("src"),n.srcset=t.getAttribute("srcset"),n.sizes=t.getAttribute("sizes"),t.llOriginalAttrs=n;}},G=function(t){if(R(t)){var n=t.llOriginalAttrs;N(t,"src",n.src),N(t,"srcset",n.srcset),N(t,"sizes",n.sizes);}},D=function(t,n){N(t,"sizes",b(t,n.data_sizes)),N(t,"srcset",b(t,n.data_srcset)),N(t,"src",b(t,n.data_src));},V=function(t){M(t,"src"),M(t,"srcset"),M(t,"sizes");},j=function(t,n){var e=t.parentNode;e&&"PICTURE"===e.tagName&&C(e).forEach(n);},F={IMG:function(t,n){j(t,(function(t){T(t),D(t,n);})),T(t),D(t,n);},IFRAME:function(t,n){N(t,"src",b(t,n.data_src));},VIDEO:function(t,n){!function(t,e){C(t).forEach((function(t){N(t,"src",b(t,n.data_src));}));}(t),N(t,"poster",b(t,n.data_poster)),N(t,"src",b(t,n.data_src)),t.load();}},P=function(t,n){var e=F[t.tagName];e&&e(t,n);},S=function(t,n,e){x(e,1),L(t,n.class_loading),h(t,l),A(n.callback_loading,t,e);},U=["IMG","IFRAME","VIDEO"],$=function(t,n){!n||function(t){return t.loadingCount>0}(n)||function(t){return t.toLoadCount>0}(n)||A(t.callback_finish,n);},q=function(t,n,e){t.addEventListener(n,e),t.llEvLisnrs[n]=e;},H=function(t,n,e){t.removeEventListener(n,e);},B=function(t){return !!t.llEvLisnrs},J=function(t){if(B(t)){var n=t.llEvLisnrs;for(var e in n){var i=n[e];H(t,e,i);}delete t.llEvLisnrs;}},K=function(t,n,e){!function(t){delete t.llTempImage;}(t),x(e,-1),function(t){t&&(t.toLoadCount-=1);}(e),w(t,n.class_loading),n.unobserve_completed&&O(t,e);},Q=function(t,n,e){var i=k(t)||t;B(i)||function(t,n,e){B(t)||(t.llEvLisnrs={});var i="VIDEO"===t.tagName?"loadeddata":"load";q(t,i,n),q(t,"error",e);}(i,(function(o){!function(t,n,e,i){var o=y(n);K(n,e,i),L(n,e.class_loaded),h(n,u),A(e.callback_loaded,n,i),o||$(e,i);}(0,t,n,e),J(i);}),(function(o){!function(t,n,e,i){var o=y(n);K(n,e,i),L(n,e.class_error),h(n,f),A(e.callback_error,n,i),o||$(e,i);}(0,t,n,e),J(i);}));},W=function(t,n,e){!function(t){t.llTempImage=document.createElement("IMG");}(t),Q(t,n,e),function(t,n,e){var i=b(t,n.data_bg),o=b(t,n.data_bg_hidpi),a=r&&o?o:i;a&&(t.style.backgroundImage='url("'.concat(a,'")'),k(t).setAttribute("src",a),S(t,n,e));}(t,n,e),function(t,n,e){var i=b(t,n.data_bg_multi),o=b(t,n.data_bg_multi_hidpi),a=r&&o?o:i;a&&(t.style.backgroundImage=a,function(t,n,e){L(t,n.class_applied),h(t,d),n.unobserve_completed&&O(t,n),A(n.callback_applied,t,e);}(t,n,e));}(t,n,e);},X=function(t,n,e){!function(t){return U.indexOf(t.tagName)>-1}(t)?W(t,n,e):function(t,n,e){Q(t,n,e),P(t,n),S(t,n,e);}(t,n,e);},Y=["IMG","IFRAME","VIDEO"],Z=function(t){return t.use_native&&"loading"in HTMLImageElement.prototype},tt=function(t,n,e){t.forEach((function(t){return function(t){return t.isIntersecting||t.intersectionRatio>0}(t)?function(t,n,e,i){var o=function(t){return I.indexOf(p(t))>=0}(t);h(t,"entered"),L(t,e.class_entered),w(t,e.class_exited),function(t,n,e){n.unobserve_entered&&O(t,e);}(t,e,i),A(e.callback_enter,t,n,i),o||X(t,e,i);}(t.target,t,n,e):function(t,n,e,i){E(t)||(L(t,e.class_exited),function(t,n,e,i){e.cancel_on_exit&&function(t){return p(t)===l}(t)&&"IMG"===t.tagName&&(J(t),function(t){j(t,(function(t){V(t);})),V(t);}(t),function(t){j(t,(function(t){G(t);})),G(t);}(t),w(t,e.class_loading),x(i,-1),m(t),A(e.callback_cancel,t,n,i));}(t,n,e,i),A(e.callback_exit,t,n,i));}(t.target,t,n,e)}));},nt=function(t){return Array.prototype.slice.call(t)},et=function(t){return t.container.querySelectorAll(t.elements_selector)},it=function(t){return function(t){return p(t)===f}(t)},ot=function(t,n){return function(t){return nt(t).filter(E)}(t||et(n))},rt=function(t,e){var o=c(t);this._settings=o,this.loadingCount=0,function(t,n){i&&!Z(t)&&(n._observer=new IntersectionObserver((function(e){tt(e,t,n);}),function(t){return {root:t.container===document?null:t.container,rootMargin:t.thresholds||t.threshold+"px"}}(t)));}(o,this),function(t,e){n&&window.addEventListener("online",(function(){!function(t,n){var e;(e=et(t),nt(e).filter(it)).forEach((function(n){w(n,t.class_error),m(n);})),n.update();}(t,e);}));}(o,this),this.update(e);};return rt.prototype={update:function(t){var n,o,r=this._settings,a=ot(t,r);z(this,a.length),!e&&i?Z(r)?function(t,n,e){t.forEach((function(t){-1!==Y.indexOf(t.tagName)&&function(t,n,e){t.setAttribute("loading","lazy"),Q(t,n,e),P(t,n),h(t,_);}(t,n,e);})),z(e,0);}(a,r,this):(o=a,function(t){t.disconnect();}(n=this._observer),function(t,n){n.forEach((function(n){t.observe(n);}));}(n,o)):this.loadAll(a);},destroy:function(){this._observer&&this._observer.disconnect(),et(this._settings).forEach((function(t){delete t.llOriginalAttrs;})),delete this._observer,delete this._settings,delete this.loadingCount,delete this.toLoadCount;},loadAll:function(t){var n=this,e=this._settings;ot(t,e).forEach((function(t){O(t,n),X(t,e,n);}));}},rt.load=function(t,n){var e=c(n);X(t,e);},rt.resetStatus=function(t){m(t);},n&&function(t,n){if(n)if(n.length)for(var e,i=0;e=n[i];i+=1)s(t,e);else s(t,n);}(rt,window.lazyLoadOptions),rt}));
});

/**
 * Set lazy loading.
 *
 * @param {object} obj Lazy object.
 */
function lazy(obj) {
  if (obj.condition) {
    // @ts-ignore
    // eslint-disable-next-line no-unused-vars
    new lazyload_min({
      unobserve_entered: true,
      unobserve_completed: true,
    }, obj.el.shadowRoot.querySelectorAll('[data-src]'));
  }
}

/**
 * Global componentDidLoad function for all components.
 *
 * @param {object} obj Settings
 */
function globalComponentDidLoad(obj) {
  /** Mark that component has been loaded. */
  obj.el.setAttribute('has-loaded', '');
  /**
   * Setup mutation observer to check if child elements have been added and
   * reload component.
   */
  if (obj.cb) {
    mutationObserver(obj.el, {
      childList: true,
      subtree: true,
      characterData: true,
    }, function () {
      obj.cb();
    });
  }
  /** Lazy loading for image components. */
  lazy({
    el: obj.el,
    condition: obj.lazy,
  });
}

// eslint-disable-next-line no-unused-vars
/**
 * Tag selector.
 *
 * @param {boolean} condition Check if create node or use slot instead.
 * @param {string} tag Tag name.
 * @param {string} text Inner text.
 * @param {string} slot Slot name.
 * @param {string} style Class name.
 * @returns {HTMLElement} Returns a HTML element.
 */
function tagSelector(condition, tag, text, slot, style = null) {
  return condition ? (tag === 'h1' ? (h$4("h1", { class: style }, text)) : tag === 'h2' ? (h$4("h2", { class: style }, text)) : tag === 'h3' ? (h$4("h3", { class: style }, text)) : tag === 'h4' ? (h$4("h4", { class: style }, text)) : tag === 'h5' ? (h$4("h5", { class: style }, text)) : tag === 'h6' ? (h$4("h6", { class: style }, text)) : tag === 'p' ? (h$4("p", { class: style }, text)) : (h$4("span", { class: style }, text))) : (h$4("slot", { name: slot }));
}

/**
 * Global componentWillLoad function for all components.
 *
 * @param {HTMLElement} obj HTML element to apply function to.
 */
function globalComponentWillUpdate(obj) {
  var _a;
  if ((_a = obj === null || obj === void 0 ? void 0 : obj.el) === null || _a === void 0 ? void 0 : _a.shadowRoot) {
    obj.el.shadowRoot
      .querySelectorAll('style[data-emotion]')
      .forEach((item) => item.remove());
  }
}

/**
 * Create custom Emotion instance.
 *
 * @param {HTMLElement} el HTML element.
 * @returns {object} Emotion object.
 */
function cssEmotion(el) {
  return createEmotion({
    key: 'spx',
    container: el,
  });
}

var i$4=new Map([["align-self","-ms-grid-row-align"],["color-adjust","-webkit-print-color-adjust"],["column-gap","grid-column-gap"],["gap","grid-gap"],["grid-template-columns","-ms-grid-columns"],["grid-template-rows","-ms-grid-rows"],["justify-self","-ms-grid-column-align"],["margin-inline-end","-webkit-margin-end"],["margin-inline-start","-webkit-margin-start"],["overflow-wrap","word-wrap"],["padding-inline-end","-webkit-padding-end"],["padding-inline-start","-webkit-padding-start"],["row-gap","grid-row-gap"],["scroll-margin-bottom","scroll-snap-margin-bottom"],["scroll-margin-left","scroll-snap-margin-left"],["scroll-margin-right","scroll-snap-margin-right"],["scroll-margin-top","scroll-snap-margin-top"],["scroll-margin","scroll-snap-margin"],["text-combine-upright","-ms-text-combine-horizontal"]]);function r$4(r){return i$4.get(r)}function n$4(i){var r=/^(?:(text-(?:decoration$|e|or|si)|back(?:ground-cl|d|f)|box-d|(?:mask(?:$|-[ispro]|-cl)))|(tab-|column(?!-s)|text-align-l)|(ap)|(u|hy))/i.exec(i);return r?r[1]?1:r[2]?2:r[3]?3:5:0}function t$4(i,r){var n=/^(?:(pos)|(background-i)|((?:max-|min-)?(?:block-s|inl|he|widt))|(dis))/i.exec(i);return n?n[1]?/^sti/i.test(r)?1:0:n[2]?/^image-/i.test(r)?1:0:n[3]?"-"===r[3]?2:0:/^(inline-)?grid$/i.test(r)?4:0:0}

// src/internal/util.ts
var includes$1 = (value, search) => !!~value.indexOf(search);
var join = (parts, separator = "-") => parts.join(separator);
var joinTruthy = (parts, separator) => join(parts.filter(Boolean), separator);
var tail = (array, startIndex = 1) => array.slice(startIndex);
var identity$1 = (value) => value;
var noop = () => {
};
var capitalize$1 = (value) => value[0].toUpperCase() + tail(value);
var hyphenate$1 = (value) => value.replace(/[A-Z]/g, "-$&").toLowerCase();
var evalThunk$1 = (value, context) => {
  while (typeof value == "function") {
    value = value(context);
  }
  return value;
};
var ensureMaxSize = (map, max) => {
  if (map.size > max) {
    map.delete(map.keys().next().value);
  }
};
var isCSSProperty$1 = (key, value) => !includes$1("@:&", key[0]) && (includes$1("rg", (typeof value)[5]) || Array.isArray(value));
var merge$2 = (target, source, context) => source ? Object.keys(source).reduce((target2, key) => {
  const value = evalThunk$1(source[key], context);
  if (isCSSProperty$1(key, value)) {
    target2[hyphenate$1(key)] = value;
  } else {
    target2[key] = key[0] == "@" && includes$1("figa", key[1]) ? (target2[key] || []).concat(value) : merge$2(target2[key] || {}, value, context);
  }
  return target2;
}, target) : target;
var escape = typeof CSS !== "undefined" && CSS.escape || ((className) => className.replace(/[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]/g, "\\$&").replace(/^\d/, "\\3$& "));
var buildMediaQuery = (screen) => {
  if (!Array.isArray(screen)) {
    screen = [screen];
  }
  return "@media " + join(screen.map((screen2) => {
    if (typeof screen2 == "string") {
      screen2 = {min: screen2};
    }
    return screen2.raw || join(Object.keys(screen2).map((feature) => `(${feature}-width:${screen2[feature]})`), " and ");
  }), ",");
};
var cyrb32 = (value) => {
  for (var h = 9, index = value.length; index--; ) {
    h = Math.imul(h ^ value.charCodeAt(index), 1597334677);
  }
  return "tw-" + ((h ^ h >>> 9) >>> 0).toString(36);
};
var sortedInsertionIndex = (array, element) => {
  for (var low = 0, high = array.length; low < high; ) {
    const pivot = high + low >> 1;
    if (array[pivot] <= element) {
      low = pivot + 1;
    } else {
      high = pivot;
    }
  }
  return high;
};

// src/twind/parse.ts
var groupings;
var rules;
var startGrouping = (value = "") => {
  groupings.push(value);
  return "";
};
var endGrouping = (isWhitespace) => {
  groupings.length = Math.max(groupings.lastIndexOf("") + ~~isWhitespace, 0);
};
var onlyPrefixes = (s) => s && !includes$1("!:", s[0]);
var onlyVariants = (s) => s[0] == ":";
var addRule = (directive2, negate) => {
  rules.push({
    v: groupings.filter(onlyVariants),
    d: directive2,
    n: negate,
    i: includes$1(groupings, "!"),
    $: ""
  });
};
var saveRule = (buffer) => {
  const negate = buffer[0] == "-";
  if (negate) {
    buffer = tail(buffer);
  }
  const prefix = join(groupings.filter(onlyPrefixes));
  addRule(buffer == "&" ? prefix : (prefix && prefix + "-") + buffer, negate);
  return "";
};
var parseString = (token, isVariant) => {
  let buffer = "";
  for (let char, dynamic = false, position2 = 0; char = token[position2++]; ) {
    if (dynamic || char == "[") {
      buffer += char;
      dynamic = char != "]";
      continue;
    }
    switch (char) {
      case ":":
        buffer = buffer && startGrouping(":" + (token[position2] == char ? token[position2++] : "") + buffer);
        break;
      case "(":
        buffer = buffer && startGrouping(buffer);
        startGrouping();
        break;
      case "!":
        startGrouping(char);
        break;
      case ")":
      case " ":
      case "	":
      case "\n":
      case "\r":
        buffer = buffer && saveRule(buffer);
        endGrouping(char !== ")");
        break;
      default:
        buffer += char;
    }
  }
  if (buffer) {
    if (isVariant) {
      startGrouping(":" + buffer);
    } else if (buffer.slice(-1) == "-") {
      startGrouping(buffer.slice(0, -1));
    } else {
      saveRule(buffer);
    }
  }
};
var parseGroupedToken = (token) => {
  startGrouping();
  parseToken(token);
  endGrouping();
};
var parseGroup = (key, token) => {
  if (token) {
    startGrouping();
    const isVariant = includes$1("tbu", (typeof token)[1]);
    parseString(key, isVariant);
    if (isVariant) {
      parseGroupedToken(token);
    }
    endGrouping();
  }
};
var parseToken = (token) => {
  switch (typeof token) {
    case "string":
      parseString(token);
      break;
    case "function":
      addRule(token);
      break;
    case "object":
      if (Array.isArray(token)) {
        token.forEach(parseGroupedToken);
      } else if (token) {
        Object.keys(token).forEach((key) => {
          parseGroup(key, token[key]);
        });
      }
  }
};
var staticsCaches = new WeakMap();
var buildStatics = (strings) => {
  let statics = staticsCaches.get(strings);
  if (!statics) {
    let slowModeIndex = NaN;
    let buffer = "";
    statics = strings.map((token, index) => {
      if (slowModeIndex !== slowModeIndex && (token.slice(-1) == "[" || includes$1(":-(", (strings[index + 1] || "")[0]))) {
        slowModeIndex = index;
      }
      if (index >= slowModeIndex) {
        return (interpolation) => {
          if (index == slowModeIndex) {
            buffer = "";
          }
          buffer += token;
          if (includes$1("rg", (typeof interpolation)[5])) {
            buffer += interpolation;
          } else if (interpolation) {
            parseString(buffer);
            buffer = "";
            parseToken(interpolation);
          }
          if (index == strings.length - 1) {
            parseString(buffer);
          }
        };
      }
      const staticRules = rules = [];
      parseString(token);
      const activeGroupings = [...groupings];
      rules = [];
      return (interpolation) => {
        rules.push(...staticRules);
        groupings = [...activeGroupings];
        if (interpolation) {
          parseToken(interpolation);
        }
      };
    });
    staticsCaches.set(strings, statics);
  }
  return statics;
};
var parse = (tokens) => {
  groupings = [];
  rules = [];
  if (Array.isArray(tokens[0]) && Array.isArray(tokens[0].raw)) {
    buildStatics(tokens[0]).forEach((apply2, index) => apply2(tokens[index + 1]));
  } else {
    parseToken(tokens);
  }
  return rules;
};

// src/twind/directive.ts
var isFunctionFree;
var detectFunction = (key, value) => {
  if (typeof value == "function") {
    isFunctionFree = false;
  }
  return value;
};
var stringify = (data) => {
  isFunctionFree = true;
  const key = JSON.stringify(data, detectFunction);
  return isFunctionFree && key;
};
var cacheByFactory = new WeakMap();
var directive = (factory, data) => {
  const key = stringify(data);
  let directive2;
  if (key) {
    var cache = cacheByFactory.get(factory);
    if (!cache) {
      cacheByFactory.set(factory, cache = new Map());
    }
    directive2 = cache.get(key);
  }
  if (!directive2) {
    directive2 = Object.defineProperty((params, context) => {
      context = Array.isArray(params) ? context : params;
      return evalThunk$1(factory(data, context), context);
    }, "toJSON", {
      value: () => key || data
    });
    if (cache) {
      cache.set(key, directive2);
      ensureMaxSize(cache, 1e4);
    }
  }
  return directive2;
};

// src/twind/apply.ts
var applyFactory = (tokens, {css}) => css(parse(tokens));
var apply$1 = (...tokens) => directive(applyFactory, tokens);

// src/twind/helpers.ts
var positions = (resolve) => (value, position2, prefix, suffix) => {
  if (value) {
    const properties = position2 && resolve(position2);
    if (properties && properties.length > 0) {
      return properties.reduce((declarations, property2) => {
        declarations[joinTruthy([prefix, property2, suffix])] = value;
        return declarations;
      }, {});
    }
  }
};
var corners = /* @__PURE__ */ positions((key) => ({
  t: ["top-left", "top-right"],
  r: ["top-right", "bottom-right"],
  b: ["bottom-left", "bottom-right"],
  l: ["bottom-left", "top-left"],
  tl: ["top-left"],
  tr: ["top-right"],
  bl: ["bottom-left"],
  br: ["bottom-right"]
})[key]);
var expandEdges = (key) => {
  const parts = ({x: "lr", y: "tb"}[key] || key || "").split("").sort();
  for (let index = parts.length; index--; ) {
    if (!(parts[index] = {
      t: "top",
      r: "right",
      b: "bottom",
      l: "left"
    }[parts[index]]))
      return;
  }
  if (parts.length)
    return parts;
};
var edges = /* @__PURE__ */ positions(expandEdges);

// src/twind/plugins.ts
var _$4;
var __$1;
var $$4;
var toColumnsOrRows = (x) => x == "cols" ? "columns" : "rows";
var property$1 = (property2) => (params, context, id) => ({
  [property2]: id + ((_$4 = join(params)) && "-" + _$4)
});
var propertyValue = (property2, separator) => (params, context, id) => (_$4 = join(params, separator)) && {
  [property2 || id]: _$4
};
var themeProperty = (section) => (params, {theme: theme2}, id) => (_$4 = theme2(section || id, params)) && {
  [section || id]: _$4
};
var themePropertyFallback = (section, separator) => (params, {theme: theme2}, id) => (_$4 = theme2(section || id, params, join(params, separator))) && {
  [section || id]: _$4
};
var alias = (handler, name) => (params, context) => handler(params, context, name);
var display = property$1("display");
var position = property$1("position");
var textTransform = property$1("textTransform");
var textDecoration = property$1("textDecoration");
var fontStyle = property$1("fontStyle");
var fontVariantNumeric = (key) => (params, context, id) => ({
  ["--tw-" + key]: id,
  fontVariantNumeric: "var(--tw-ordinal,/*!*/ /*!*/) var(--tw-slashed-zero,/*!*/ /*!*/) var(--tw-numeric-figure,/*!*/ /*!*/) var(--tw-numeric-spacing,/*!*/ /*!*/) var(--tw-numeric-fraction,/*!*/ /*!*/)"
});
var inset = (params, {theme: theme2}, id) => (_$4 = theme2("inset", params)) && {[id]: _$4};
var opacityProperty = (params, theme2, id, section = id) => (_$4 = theme2(section + "Opacity", tail(params))) && {
  [`--tw-${id}-opacity`]: _$4
};
var parseColorComponent = (chars, factor) => Math.round(parseInt(chars, 16) * factor);
var asRGBA = (color, opacityProperty2, opacityDefault) => {
  if (color && color[0] == "#" && (_$4 = (color.length - 1) / 3) && ($$4 = [17, 1, 0.062272][_$4 - 1])) {
    return `rgba(${parseColorComponent(color.substr(1, _$4), $$4)},${parseColorComponent(color.substr(1 + _$4, _$4), $$4)},${parseColorComponent(color.substr(1 + 2 * _$4, _$4), $$4)},${opacityProperty2 ? `var(--tw-${opacityProperty2}${opacityDefault ? "," + opacityDefault : ""})` : opacityDefault || 1})`;
  }
  return color;
};
var withOpacityFallback = (property2, kind, color) => color && typeof color == "string" ? (_$4 = asRGBA(color, kind + "-opacity")) && _$4 !== color ? {
  [`--tw-${kind}-opacity`]: "1",
  [property2]: [color, _$4]
} : {[property2]: color} : void 0;
var transparentTo = (color) => ($$4 = asRGBA(color, "", "0")) == _$4 ? "transparent" : $$4;
var reversableEdge = (params, {theme: theme2}, id, section, prefix, suffix) => (_$4 = {x: ["right", "left"], y: ["bottom", "top"]}[params[0]]) && ($$4 = `--tw-${id}-${params[0]}-reverse`) ? params[1] == "reverse" ? {
  [$$4]: "1"
} : {
  [$$4]: "0",
  [joinTruthy([prefix, _$4[0], suffix])]: (__$1 = theme2(section, tail(params))) && `calc(${__$1} * var(${$$4}))`,
  [joinTruthy([prefix, _$4[1], suffix])]: __$1 && [__$1, `calc(${__$1} * calc(1 - var(${$$4})))`]
} : void 0;
var placeHelper = (property2, params) => params[0] && {
  [property2]: (includes$1("wun", (params[0] || "")[3]) ? "space-" : "") + params[0]
};
var contentPluginFor = (property2) => (params) => includes$1(["start", "end"], params[0]) ? {[property2]: "flex-" + params[0]} : placeHelper(property2, params);
var gridPlugin = (kind) => (params, {theme: theme2}) => {
  if (_$4 = theme2("grid" + capitalize$1(kind), params, "")) {
    return {["grid-" + kind]: _$4};
  }
  switch (params[0]) {
    case "span":
      return params[1] && {
        ["grid-" + kind]: `span ${params[1]} / span ${params[1]}`
      };
    case "start":
    case "end":
      return (_$4 = theme2("grid" + capitalize$1(kind) + capitalize$1(params[0]), tail(params), join(tail(params)))) && {
        [`grid-${kind}-${params[0]}`]: _$4
      };
  }
};
var border = (params, {theme: theme2}, id) => {
  switch (params[0]) {
    case "solid":
    case "dashed":
    case "dotted":
    case "double":
    case "none":
      return propertyValue("borderStyle")(params);
    case "collapse":
    case "separate":
      return propertyValue("borderCollapse")(params);
    case "opacity":
      return opacityProperty(params, theme2, id);
  }
  return (_$4 = theme2(id + "Width", params, "")) ? {borderWidth: _$4} : withOpacityFallback("borderColor", id, theme2(id + "Color", params));
};
var transform$1 = (gpu) => (gpu ? "translate3d(var(--tw-translate-x,0),var(--tw-translate-y,0),0)" : "translateX(var(--tw-translate-x,0)) translateY(var(--tw-translate-y,0))") + " rotate(var(--tw-rotate,0)) skewX(var(--tw-skew-x,0)) skewY(var(--tw-skew-y,0)) scaleX(var(--tw-scale-x,1)) scaleY(var(--tw-scale-y,1))";
var transformXYFunction = (params, context, id) => params[0] && (_$4 = context.theme(id, params[1] || params[0])) && {
  [`--tw-${id}-x`]: params[0] !== "y" && _$4,
  [`--tw-${id}-y`]: params[0] !== "x" && _$4,
  transform: [`${id}${params[1] ? params[0].toUpperCase() : ""}(${_$4})`, transform$1()]
};
var edgesPluginFor = (key) => (params, context, id) => id[1] ? edges(context.theme(key, params), id[1], key) : themeProperty(key)(params, context, id);
var padding = edgesPluginFor("padding");
var margin = edgesPluginFor("margin");
var minMax = (params, {theme: theme2}, id) => (_$4 = {w: "width", h: "height"}[params[0]]) && {
  [_$4 = `${id}${capitalize$1(_$4)}`]: theme2(_$4, tail(params))
};
var filter$2 = (params, {theme: theme2}, id) => {
  const parts = id.split("-");
  const prefix = parts[0] == "backdrop" ? parts[0] + "-" : "";
  if (!prefix) {
    params.unshift(...parts);
  }
  if (params[0] == "filter") {
    const filters = [
      "blur",
      "brightness",
      "contrast",
      "grayscale",
      "hue-rotate",
      "invert",
      prefix && "opacity",
      "saturate",
      "sepia",
      !prefix && "drop-shadow"
    ].filter(Boolean);
    return params[1] == "none" ? {[prefix + "filter"]: "none"} : filters.reduce((css, key) => {
      css["--tw-" + prefix + key] = "var(--tw-empty,/*!*/ /*!*/)";
      return css;
    }, {
      [prefix + "filter"]: filters.map((key) => `var(--tw-${prefix}${key})`).join(" ")
    });
  }
  $$4 = params.shift();
  if (includes$1(["hue", "drop"], $$4))
    $$4 += capitalize$1(params.shift());
  return (_$4 = theme2(prefix ? "backdrop" + capitalize$1($$4) : $$4, params)) && {
    ["--tw-" + prefix + $$4]: (Array.isArray(_$4) ? _$4 : [_$4]).map((_4) => `${hyphenate$1($$4)}(${_4})`).join(" ")
  };
};
var corePlugins = {
  group: (params, {tag}, id) => tag(join([id, ...params])),
  hidden: alias(display, "none"),
  inline: display,
  block: display,
  contents: display,
  flow: display,
  table: (params, context, id) => includes$1(["auto", "fixed"], params[0]) ? {tableLayout: params[0]} : display(params, context, id),
  flex(params, context, id) {
    switch (params[0]) {
      case "row":
      case "col":
        return {
          flexDirection: join(params[0] == "col" ? ["column", ...tail(params)] : params)
        };
      case "nowrap":
      case "wrap":
        return {flexWrap: join(params)};
      case "grow":
      case "shrink":
        _$4 = context.theme("flex" + capitalize$1(params[0]), tail(params), params[1] || 1);
        return _$4 != null && {
          ["flex-" + params[0]]: "" + _$4
        };
    }
    return (_$4 = context.theme("flex", params, "")) ? {flex: _$4} : display(params, context, id);
  },
  grid(params, context, id) {
    switch (params[0]) {
      case "cols":
      case "rows":
        return (_$4 = context.theme("gridTemplate" + capitalize$1(toColumnsOrRows(params[0])), tail(params), params.length == 2 && Number(params[1]) ? `repeat(${params[1]},minmax(0,1fr))` : join(tail(params)))) && {
          ["gridTemplate-" + toColumnsOrRows(params[0])]: _$4
        };
      case "flow":
        return params.length > 1 && {
          gridAutoFlow: join(params[1] == "col" ? ["column", ...tail(params, 2)] : tail(params), " ")
        };
    }
    return display(params, context, id);
  },
  auto: (params, {theme: theme2}) => includes$1(["cols", "rows"], params[0]) && (_$4 = theme2("gridAuto" + capitalize$1(toColumnsOrRows(params[0])), tail(params), join(tail(params)))) && {
    ["gridAuto-" + toColumnsOrRows(params[0])]: _$4
  },
  static: position,
  fixed: position,
  absolute: position,
  relative: position,
  sticky: position,
  visible: {visibility: "visible"},
  invisible: {visibility: "hidden"},
  antialiased: {
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale"
  },
  "subpixel-antialiased": {
    WebkitFontSmoothing: "auto",
    MozOsxFontSmoothing: "auto"
  },
  truncate: {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  },
  "sr-only": {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    clip: "rect(0,0,0,0)",
    borderWidth: "0"
  },
  "not-sr-only": {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    whiteSpace: "normal",
    clip: "auto"
  },
  resize: (params) => ({
    resize: {x: "horizontal", y: "vertical"}[params[0]] || params[0] || "both"
  }),
  box: (params) => params[0] && {boxSizing: params[0] + "-box"},
  appearance: propertyValue(),
  cursor: themePropertyFallback(),
  float: propertyValue(),
  clear: propertyValue(),
  decoration: propertyValue("boxDecorationBreak"),
  isolate: {isolation: "isolate"},
  isolation: propertyValue(),
  "mix-blend": propertyValue("mixBlendMode"),
  top: inset,
  right: inset,
  bottom: inset,
  left: inset,
  inset: (params, {theme: theme2}) => (_$4 = expandEdges(params[0])) ? edges(theme2("inset", tail(params)), params[0]) : (_$4 = theme2("inset", params)) && {
    top: _$4,
    right: _$4,
    bottom: _$4,
    left: _$4
  },
  underline: textDecoration,
  "line-through": textDecoration,
  "no-underline": alias(textDecoration, "none"),
  "text-underline": alias(textDecoration, "underline"),
  "text-no-underline": alias(textDecoration, "none"),
  "text-line-through": alias(textDecoration, "line-through"),
  uppercase: textTransform,
  lowercase: textTransform,
  capitalize: textTransform,
  "normal-case": alias(textTransform, "none"),
  "text-normal-case": alias(textTransform, "none"),
  italic: fontStyle,
  "not-italic": alias(fontStyle, "normal"),
  "font-italic": alias(fontStyle, "italic"),
  "font-not-italic": alias(fontStyle, "normal"),
  font: (params, context, id) => (_$4 = context.theme("fontFamily", params, "")) ? {fontFamily: _$4} : themeProperty("fontWeight")(params, context, id),
  items: (params) => params[0] && {
    alignItems: includes$1(["start", "end"], params[0]) ? "flex-" + params[0] : join(params)
  },
  "justify-self": propertyValue(),
  "justify-items": propertyValue(),
  justify: contentPluginFor("justifyContent"),
  content: contentPluginFor("alignContent"),
  self: contentPluginFor("alignSelf"),
  place: (params) => params[0] && placeHelper("place-" + params[0], tail(params)),
  overscroll: (params) => params[0] && {
    ["overscrollBehavior" + (params[1] ? "-" + params[0] : "")]: params[1] || params[0]
  },
  col: gridPlugin("column"),
  row: gridPlugin("row"),
  duration: themeProperty("transitionDuration"),
  delay: themeProperty("transitionDelay"),
  tracking: themeProperty("letterSpacing"),
  leading: themeProperty("lineHeight"),
  z: themeProperty("zIndex"),
  opacity: themeProperty(),
  ease: themeProperty("transitionTimingFunction"),
  p: padding,
  py: padding,
  px: padding,
  pt: padding,
  pr: padding,
  pb: padding,
  pl: padding,
  m: margin,
  my: margin,
  mx: margin,
  mt: margin,
  mr: margin,
  mb: margin,
  ml: margin,
  w: themeProperty("width"),
  h: themeProperty("height"),
  min: minMax,
  max: minMax,
  fill: themeProperty(),
  order: themeProperty(),
  origin: themePropertyFallback("transformOrigin", " "),
  select: propertyValue("userSelect"),
  "pointer-events": propertyValue(),
  align: propertyValue("verticalAlign"),
  whitespace: propertyValue("whiteSpace"),
  "normal-nums": {fontVariantNumeric: "normal"},
  ordinal: fontVariantNumeric("ordinal"),
  "slashed-zero": fontVariantNumeric("slashed-zero"),
  "lining-nums": fontVariantNumeric("numeric-figure"),
  "oldstyle-nums": fontVariantNumeric("numeric-figure"),
  "proportional-nums": fontVariantNumeric("numeric-spacing"),
  "tabular-nums": fontVariantNumeric("numeric-spacing"),
  "diagonal-fractions": fontVariantNumeric("numeric-fraction"),
  "stacked-fractions": fontVariantNumeric("numeric-fraction"),
  overflow: (params, context, id) => includes$1(["ellipsis", "clip"], params[0]) ? propertyValue("textOverflow")(params) : params[1] ? {["overflow-" + params[0]]: params[1]} : propertyValue()(params, context, id),
  transform: (params) => params[0] == "none" ? {transform: "none"} : {
    "--tw-translate-x": "0",
    "--tw-translate-y": "0",
    "--tw-rotate": "0",
    "--tw-skew-x": "0",
    "--tw-skew-y": "0",
    "--tw-scale-x": "1",
    "--tw-scale-y": "1",
    transform: transform$1(params[0] == "gpu")
  },
  rotate: (params, {theme: theme2}) => (_$4 = theme2("rotate", params)) && {
    "--tw-rotate": _$4,
    transform: [`rotate(${_$4})`, transform$1()]
  },
  scale: transformXYFunction,
  translate: transformXYFunction,
  skew: transformXYFunction,
  gap: (params, context, id) => (_$4 = {x: "column", y: "row"}[params[0]]) ? {[_$4 + "Gap"]: context.theme("gap", tail(params))} : themeProperty("gap")(params, context, id),
  stroke: (params, context, id) => (_$4 = context.theme("stroke", params, "")) ? {stroke: _$4} : themeProperty("strokeWidth")(params, context, id),
  outline: (params, {theme: theme2}) => (_$4 = theme2("outline", params)) && {
    outline: _$4[0],
    outlineOffset: _$4[1]
  },
  "break-normal": {
    wordBreak: "normal",
    overflowWrap: "normal"
  },
  "break-words": {overflowWrap: "break-word"},
  "break-all": {wordBreak: "break-all"},
  text(params, {theme: theme2}, id) {
    switch (params[0]) {
      case "left":
      case "center":
      case "right":
      case "justify":
        return {textAlign: params[0]};
      case "uppercase":
      case "lowercase":
      case "capitalize":
        return textTransform([], _$4, params[0]);
      case "opacity":
        return opacityProperty(params, theme2, id);
    }
    const fontSize = theme2("fontSize", params, "");
    if (fontSize) {
      return typeof fontSize == "string" ? {fontSize} : {
        fontSize: fontSize[0],
        ...typeof fontSize[1] == "string" ? {lineHeight: fontSize[1]} : fontSize[1]
      };
    }
    return withOpacityFallback("color", "text", theme2("textColor", params));
  },
  bg(params, {theme: theme2}, id) {
    switch (params[0]) {
      case "fixed":
      case "local":
      case "scroll":
        return propertyValue("backgroundAttachment", ",")(params);
      case "bottom":
      case "center":
      case "left":
      case "right":
      case "top":
        return propertyValue("backgroundPosition", " ")(params);
      case "no":
        return params[1] == "repeat" && propertyValue("backgroundRepeat")(params);
      case "repeat":
        return includes$1("xy", params[1]) ? propertyValue("backgroundRepeat")(params) : {backgroundRepeat: params[1] || params[0]};
      case "opacity":
        return opacityProperty(params, theme2, id, "background");
      case "clip":
      case "origin":
        return params[1] && {
          ["background-" + params[0]]: params[1] + (params[1] == "text" ? "" : "-box")
        };
      case "blend":
        return propertyValue("background-blend-mode")(tail(params));
      case "gradient":
        if (params[1] == "to" && (_$4 = expandEdges(params[2]))) {
          return {
            backgroundImage: `linear-gradient(to ${join(_$4, " ")},var(--tw-gradient-stops))`
          };
        }
    }
    return (_$4 = theme2("backgroundPosition", params, "")) ? {backgroundPosition: _$4} : (_$4 = theme2("backgroundSize", params, "")) ? {backgroundSize: _$4} : (_$4 = theme2("backgroundImage", params, "")) ? {backgroundImage: _$4} : withOpacityFallback("backgroundColor", "bg", theme2("backgroundColor", params));
  },
  from: (params, {theme: theme2}) => (_$4 = theme2("gradientColorStops", params)) && {
    "--tw-gradient-from": _$4,
    "--tw-gradient-stops": `var(--tw-gradient-from),var(--tw-gradient-to,${transparentTo(_$4)})`
  },
  via: (params, {theme: theme2}) => (_$4 = theme2("gradientColorStops", params)) && {
    "--tw-gradient-stops": `var(--tw-gradient-from),${_$4},var(--tw-gradient-to,${transparentTo(_$4)})`
  },
  to: (params, {theme: theme2}) => (_$4 = theme2("gradientColorStops", params)) && {
    "--tw-gradient-to": _$4
  },
  border: (params, context, id) => expandEdges(params[0]) ? edges(context.theme("borderWidth", tail(params)), params[0], "border", "width") : border(params, context, id),
  divide: (params, context, id) => (_$4 = reversableEdge(params, context, id, "divideWidth", "border", "width") || border(params, context, id)) && {
    "&>:not([hidden])~:not([hidden])": _$4
  },
  space: (params, context, id) => (_$4 = reversableEdge(params, context, id, "space", "margin")) && {
    "&>:not([hidden])~:not([hidden])": _$4
  },
  placeholder: (params, {theme: theme2}, id) => (_$4 = params[0] == "opacity" ? opacityProperty(params, theme2, id) : withOpacityFallback("color", "placeholder", theme2("placeholderColor", params))) && {
    "&::placeholder": _$4
  },
  shadow: (params, {theme: theme2}) => (_$4 = theme2("boxShadow", params)) && {
    ":global": {
      "*": {
        "--tw-shadow": "0 0 transparent"
      }
    },
    "--tw-shadow": _$4 == "none" ? "0 0 transparent" : _$4,
    boxShadow: [
      _$4,
      `var(--tw-ring-offset-shadow,0 0 transparent),var(--tw-ring-shadow,0 0 transparent),var(--tw-shadow)`
    ]
  },
  animate: (params, {theme: theme2, tag}) => {
    if ($$4 = theme2("animation", params)) {
      const parts = $$4.split(" ");
      if ((_$4 = theme2("keyframes", parts[0], __$1 = {})) !== __$1) {
        return ($$4 = tag(parts[0])) && {
          animation: $$4 + " " + join(tail(parts), " "),
          ["@keyframes " + $$4]: _$4
        };
      }
      return {animation: $$4};
    }
  },
  ring(params, {theme: theme2}, id) {
    switch (params[0]) {
      case "inset":
        return {"--tw-ring-inset": "inset"};
      case "opacity":
        return opacityProperty(params, theme2, id);
      case "offset":
        return (_$4 = theme2("ringOffsetWidth", tail(params), "")) ? {
          "--tw-ring-offset-width": _$4
        } : {
          "--tw-ring-offset-color": theme2("ringOffsetColor", tail(params))
        };
    }
    return (_$4 = theme2("ringWidth", params, "")) ? {
      "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
      "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${_$4} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
      boxShadow: `var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 transparent)`,
      ":global": {
        "*": {
          "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
          "--tw-ring-offset-width": theme2("ringOffsetWidth", "", "0px"),
          "--tw-ring-offset-color": theme2("ringOffsetColor", "", "#fff"),
          "--tw-ring-color": asRGBA(theme2("ringColor", "", "#93c5fd"), "ring-opacity", theme2("ringOpacity", "", "0.5")),
          "--tw-ring-offset-shadow": "0 0 transparent",
          "--tw-ring-shadow": "0 0 transparent"
        }
      }
    } : {
      "--tw-ring-opacity": "1",
      "--tw-ring-color": asRGBA(theme2("ringColor", params), "ring-opacity")
    };
  },
  object: (params, context, id) => includes$1(["contain", "cover", "fill", "none", "scale-down"], join(params)) ? {objectFit: join(params)} : themePropertyFallback("objectPosition", " ")(params, context, id),
  list: (params, context, id) => join(params) == "item" ? display(params, context, id) : includes$1(["inside", "outside"], join(params)) ? {listStylePosition: params[0]} : themePropertyFallback("listStyleType")(params, context, id),
  rounded: (params, context, id) => corners(context.theme("borderRadius", tail(params), ""), params[0], "border", "radius") || themeProperty("borderRadius")(params, context, id),
  "transition-none": {transitionProperty: "none"},
  transition: (params, {theme: theme2}) => ({
    transitionProperty: theme2("transitionProperty", params),
    transitionTimingFunction: theme2("transitionTimingFunction", ""),
    transitionDuration: theme2("transitionDuration", "")
  }),
  container: (params, {theme: theme2}) => {
    const {screens = theme2("screens"), center, padding: padding2} = theme2("container");
    const paddingFor = (screen) => (_$4 = padding2 && (typeof padding2 == "string" ? padding2 : padding2[screen] || padding2.DEFAULT)) ? {
      paddingRight: _$4,
      paddingLeft: _$4
    } : {};
    return Object.keys(screens).reduce((rules2, screen) => {
      if (($$4 = screens[screen]) && typeof $$4 == "string") {
        rules2[buildMediaQuery($$4)] = {
          "&": {
            "max-width": $$4,
            ...paddingFor(screen)
          }
        };
      }
      return rules2;
    }, {
      width: "100%",
      ...center ? {marginRight: "auto", marginLeft: "auto"} : {},
      ...paddingFor("xs")
    });
  },
  filter: filter$2,
  blur: filter$2,
  brightness: filter$2,
  contrast: filter$2,
  grayscale: filter$2,
  "hue-rotate": filter$2,
  invert: filter$2,
  saturate: filter$2,
  sepia: filter$2,
  "drop-shadow": filter$2,
  backdrop: filter$2
};

// src/twind/preflight.ts
var createPreflight = (theme2) => ({
  ":root": {tabSize: 4},
  "body,blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre,fieldset,ol,ul": {margin: "0"},
  button: {backgroundColor: "transparent", backgroundImage: "none"},
  'button,[type="button"],[type="reset"],[type="submit"]': {WebkitAppearance: "button"},
  "button:focus": {outline: ["1px dotted", "5px auto -webkit-focus-ring-color"]},
  "fieldset,ol,ul,legend": {padding: "0"},
  "ol,ul": {listStyle: "none"},
  html: {
    lineHeight: "1.5",
    WebkitTextSizeAdjust: "100%",
    fontFamily: theme2("fontFamily.sans", "ui-sans-serif,system-ui,sans-serif")
  },
  body: {fontFamily: "inherit", lineHeight: "inherit"},
  "*,::before,::after": {
    boxSizing: "border-box",
    border: `0 solid ${theme2("borderColor.DEFAULT", "currentColor")}`
  },
  hr: {height: "0", color: "inherit", borderTopWidth: "1px"},
  img: {borderStyle: "solid"},
  textarea: {resize: "vertical"},
  "input::placeholder,textarea::placeholder": {
    opacity: "1",
    color: theme2("placeholderColor.DEFAULT", theme2("colors.gray.400", "#a1a1aa"))
  },
  'button,[role="button"]': {cursor: "pointer"},
  table: {textIndent: "0", borderColor: "inherit", borderCollapse: "collapse"},
  "h1,h2,h3,h4,h5,h6": {fontSize: "inherit", fontWeight: "inherit"},
  a: {color: "inherit", textDecoration: "inherit"},
  "button,input,optgroup,select,textarea": {
    fontFamily: "inherit",
    fontSize: "100%",
    margin: "0",
    padding: "0",
    lineHeight: "inherit",
    color: "inherit"
  },
  "button,select": {textTransform: "none"},
  "::-moz-focus-inner": {borderStyle: "none", padding: "0"},
  ":-moz-focusring": {outline: "1px dotted ButtonText"},
  ":-moz-ui-invalid": {boxShadow: "none"},
  progress: {verticalAlign: "baseline"},
  "::-webkit-inner-spin-button,::-webkit-outer-spin-button": {height: "auto"},
  '[type="search"]': {WebkitAppearance: "textfield", outlineOffset: "-2px"},
  "::-webkit-search-decoration": {WebkitAppearance: "none"},
  "::-webkit-file-upload-button": {WebkitAppearance: "button", font: "inherit"},
  summary: {display: "list-item"},
  "abbr[title]": {textDecoration: "underline dotted"},
  "b,strong": {fontWeight: "bolder"},
  "pre,code,kbd,samp": {
    fontFamily: theme2("fontFamily", "mono", "ui-monospace,monospace"),
    fontSize: "1em"
  },
  "sub,sup": {fontSize: "75%", lineHeight: "0", position: "relative", verticalAlign: "baseline"},
  sub: {bottom: "-0.25em"},
  sup: {top: "-0.5em"},
  "img,svg,video,canvas,audio,iframe,embed,object": {display: "block", verticalAlign: "middle"},
  "img,video": {maxWidth: "100%", height: "auto"}
});

// src/twind/variants.ts
var coreVariants = {
  dark: "@media (prefers-color-scheme:dark)",
  sticky: "@supports ((position: -webkit-sticky) or (position:sticky))",
  "motion-reduce": "@media (prefers-reduced-motion:reduce)",
  "motion-safe": "@media (prefers-reduced-motion:no-preference)",
  first: "&:first-child",
  last: "&:last-child",
  even: "&:nth-child(2n)",
  odd: "&:nth-child(odd)",
  children: "&>*",
  siblings: "&~*",
  sibling: "&+*",
  override: "&&"
};

// src/internal/dom.ts
var STYLE_ELEMENT_ID$1 = "__twind";
var getStyleElement = (nonce) => {
  let element = self[STYLE_ELEMENT_ID$1];
  if (!element) {
    element = document.head.appendChild(document.createElement("style"));
    element.id = STYLE_ELEMENT_ID$1;
    nonce && (element.nonce = nonce);
    element.appendChild(document.createTextNode(""));
  }
  return element;
};

// src/twind/sheets.ts
var cssomSheet = ({
  nonce,
  target = getStyleElement(nonce).sheet
} = {}) => {
  const offset = target.cssRules.length;
  return {
    target,
    insert: (rule, index) => target.insertRule(rule, offset + index)
  };
};
var voidSheet = () => ({
  target: null,
  insert: noop
});

// src/twind/modes.ts
var mode = (report) => ({
  unknown(section, key = [], optional, context) {
    if (!optional) {
      this.report({id: "UNKNOWN_THEME_VALUE", key: section + "." + join(key)}, context);
    }
  },
  report({id, ...info}) {
    return report(`[${id}] ${JSON.stringify(info)}`);
  }
});
var warn = /* @__PURE__ */ mode((message) => console.warn(message));
var strict = /* @__PURE__ */ mode((message) => {
  throw new Error(message);
});
var silent = /* @__PURE__ */ mode(noop);
var noprefix = (property2, value, important) => `${property2}:${value}${important ? " !important" : ""}`;
var autoprefix = (property2, value, important) => {
  let cssText = "";
  const propertyAlias = r$4(property2);
  if (propertyAlias)
    cssText += `${noprefix(propertyAlias, value, important)};`;
  let flags = n$4(property2);
  if (flags & 1)
    cssText += `-webkit-${noprefix(property2, value, important)};`;
  if (flags & 2)
    cssText += `-moz-${noprefix(property2, value, important)};`;
  if (flags & 4)
    cssText += `-ms-${noprefix(property2, value, important)};`;
  flags = t$4(property2, value);
  if (flags & 1)
    cssText += `${noprefix(property2, `-webkit-${value}`, important)};`;
  if (flags & 2)
    cssText += `${noprefix(property2, `-moz-${value}`, important)};`;
  if (flags & 4)
    cssText += `${noprefix(property2, `-ms-${value}`, important)};`;
  cssText += noprefix(property2, value, important);
  return cssText;
};

// src/twind/theme.ts
var ratios = (start, end) => {
  const result = {};
  do {
    for (let dividend = 1; dividend < start; dividend++) {
      result[`${dividend}/${start}`] = Number((dividend / start * 100).toFixed(6)) + "%";
    }
  } while (++start <= end);
  return result;
};
var exponential = (stop, unit, start = 0) => {
  const result = {};
  for (; start <= stop; start = start * 2 || 1) {
    result[start] = start + unit;
  }
  return result;
};
var linear = (stop, unit = "", divideBy = 1, start = 0, step = 1, result = {}) => {
  for (; start <= stop; start += step) {
    result[start] = start / divideBy + unit;
  }
  return result;
};
var alias2 = (section) => (theme2) => theme2(section);
var defaultTheme = {
  screens: {
    sm: "640px",
    md: "768px",
    lg: "1024px",
    xl: "1280px",
    "2xl": "1536px"
  },
  colors: {
    transparent: "transparent",
    current: "currentColor",
    black: "#000",
    white: "#fff",
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d"
    },
    yellow: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f"
    },
    green: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81"
    },
    purple: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843"
    }
  },
  spacing: {
    px: "1px",
    0: "0px",
    .../* @__PURE__ */ linear(4, "rem", 4, 0.5, 0.5),
    .../* @__PURE__ */ linear(12, "rem", 4, 5),
    14: "3.5rem",
    .../* @__PURE__ */ linear(64, "rem", 4, 16, 4),
    72: "18rem",
    80: "20rem",
    96: "24rem"
  },
  durations: {
    75: "75ms",
    100: "100ms",
    150: "150ms",
    200: "200ms",
    300: "300ms",
    500: "500ms",
    700: "700ms",
    1e3: "1000ms"
  },
  animation: {
    none: "none",
    spin: "spin 1s linear infinite",
    ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
    pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
    bounce: "bounce 1s infinite"
  },
  backdropBlur: /* @__PURE__ */ alias2("blur"),
  backdropBrightness: /* @__PURE__ */ alias2("brightness"),
  backdropContrast: /* @__PURE__ */ alias2("contrast"),
  backdropGrayscale: /* @__PURE__ */ alias2("grayscale"),
  backdropHueRotate: /* @__PURE__ */ alias2("hueRotate"),
  backdropInvert: /* @__PURE__ */ alias2("invert"),
  backdropOpacity: /* @__PURE__ */ alias2("opacity"),
  backdropSaturate: /* @__PURE__ */ alias2("saturate"),
  backdropSepia: /* @__PURE__ */ alias2("sepia"),
  backgroundColor: /* @__PURE__ */ alias2("colors"),
  backgroundImage: {
    none: "none"
  },
  backgroundOpacity: /* @__PURE__ */ alias2("opacity"),
  backgroundSize: {
    auto: "auto",
    cover: "cover",
    contain: "contain"
  },
  blur: {
    0: "0",
    sm: "4px",
    DEFAULT: "8px",
    md: "12px",
    lg: "16px",
    xl: "24px",
    "2xl": "40px",
    "3xl": "64px"
  },
  brightness: {
    .../* @__PURE__ */ linear(200, "", 100, 0, 50),
    .../* @__PURE__ */ linear(110, "", 100, 90, 5),
    75: "0.75",
    125: "1.25"
  },
  borderColor: (theme2) => ({
    ...theme2("colors"),
    DEFAULT: theme2("colors.gray.200", "currentColor")
  }),
  borderOpacity: /* @__PURE__ */ alias2("opacity"),
  borderRadius: {
    none: "0px",
    sm: "0.125rem",
    DEFAULT: "0.25rem",
    md: "0.375rem",
    lg: "0.5rem",
    xl: "0.75rem",
    "2xl": "1rem",
    "3xl": "1.5rem",
    "1/2": "50%",
    full: "9999px"
  },
  borderWidth: {
    DEFAULT: "1px",
    .../* @__PURE__ */ exponential(8, "px")
  },
  boxShadow: {
    sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
    DEFAULT: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
    md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
    lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
    xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
    "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
    inner: "inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)",
    none: "none"
  },
  contrast: {
    .../* @__PURE__ */ linear(200, "", 100, 0, 50),
    75: "0.75",
    125: "1.25"
  },
  divideColor: /* @__PURE__ */ alias2("borderColor"),
  divideOpacity: /* @__PURE__ */ alias2("borderOpacity"),
  divideWidth: /* @__PURE__ */ alias2("borderWidth"),
  dropShadow: {
    sm: "0 1px 1px rgba(0,0,0,0.05)",
    DEFAULT: ["0 1px 2px rgba(0, 0, 0, 0.1)", "0 1px 1px rgba(0, 0, 0, 0.06)"],
    md: ["0 4px 3px rgba(0, 0, 0, 0.07)", "0 2px 2px rgba(0, 0, 0, 0.06)"],
    lg: ["0 10px 8px rgba(0, 0, 0, 0.04)", "0 4px 3px rgba(0, 0, 0, 0.1)"],
    xl: ["0 20px 13px rgba(0, 0, 0, 0.03)", "0 8px 5px rgba(0, 0, 0, 0.08)"],
    "2xl": "0 25px 25px rgba(0, 0, 0, 0.15)",
    none: "0 0 #0000"
  },
  fill: {current: "currentColor"},
  grayscale: {
    0: "0",
    DEFAULT: "100%"
  },
  hueRotate: {
    0: "0deg",
    15: "15deg",
    30: "30deg",
    60: "60deg",
    90: "90deg",
    180: "180deg"
  },
  invert: {
    0: "0",
    DEFAULT: "100%"
  },
  flex: {
    1: "1 1 0%",
    auto: "1 1 auto",
    initial: "0 1 auto",
    none: "none"
  },
  fontFamily: {
    sans: 'ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"'.split(","),
    serif: 'ui-serif,Georgia,Cambria,"Times New Roman",Times,serif'.split(","),
    mono: 'ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'.split(",")
  },
  fontSize: {
    xs: ["0.75rem", "1rem"],
    sm: ["0.875rem", "1.25rem"],
    base: ["1rem", "1.5rem"],
    lg: ["1.125rem", "1.75rem"],
    xl: ["1.25rem", "1.75rem"],
    "2xl": ["1.5rem", "2rem"],
    "3xl": ["1.875rem", "2.25rem"],
    "4xl": ["2.25rem", "2.5rem"],
    "5xl": ["3rem", "1"],
    "6xl": ["3.75rem", "1"],
    "7xl": ["4.5rem", "1"],
    "8xl": ["6rem", "1"],
    "9xl": ["8rem", "1"]
  },
  fontWeight: {
    thin: "100",
    extralight: "200",
    light: "300",
    normal: "400",
    medium: "500",
    semibold: "600",
    bold: "700",
    extrabold: "800",
    black: "900"
  },
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridAutoColumns: {
    min: "min-content",
    max: "max-content",
    fr: "minmax(0,1fr)"
  },
  gridAutoRows: {
    min: "min-content",
    max: "max-content",
    fr: "minmax(0,1fr)"
  },
  gridColumn: {
    auto: "auto",
    "span-full": "1 / -1"
  },
  gridRow: {
    auto: "auto",
    "span-full": "1 / -1"
  },
  gap: /* @__PURE__ */ alias2("spacing"),
  gradientColorStops: /* @__PURE__ */ alias2("colors"),
  height: (theme2) => ({
    auto: "auto",
    ...theme2("spacing"),
    ...ratios(2, 6),
    full: "100%",
    screen: "100vh"
  }),
  inset: (theme2) => ({
    auto: "auto",
    ...theme2("spacing"),
    ...ratios(2, 4),
    full: "100%"
  }),
  keyframes: {
    spin: {
      from: {
        transform: "rotate(0deg)"
      },
      to: {
        transform: "rotate(360deg)"
      }
    },
    ping: {
      "0%": {
        transform: "scale(1)",
        opacity: "1"
      },
      "75%,100%": {
        transform: "scale(2)",
        opacity: "0"
      }
    },
    pulse: {
      "0%,100%": {
        opacity: "1"
      },
      "50%": {
        opacity: ".5"
      }
    },
    bounce: {
      "0%, 100%": {
        transform: "translateY(-25%)",
        animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
      },
      "50%": {
        transform: "none",
        animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
      }
    }
  },
  letterSpacing: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0em",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeight: {
    none: "1",
    tight: "1.25",
    snug: "1.375",
    normal: "1.5",
    relaxed: "1.625",
    loose: "2",
    .../* @__PURE__ */ linear(10, "rem", 4, 3)
  },
  margin: (theme2) => ({
    auto: "auto",
    ...theme2("spacing")
  }),
  maxHeight: (theme2) => ({
    ...theme2("spacing"),
    full: "100%",
    screen: "100vh"
  }),
  maxWidth: (theme2, {breakpoints}) => ({
    none: "none",
    0: "0rem",
    xs: "20rem",
    sm: "24rem",
    md: "28rem",
    lg: "32rem",
    xl: "36rem",
    "2xl": "42rem",
    "3xl": "48rem",
    "4xl": "56rem",
    "5xl": "64rem",
    "6xl": "72rem",
    "7xl": "80rem",
    full: "100%",
    min: "min-content",
    max: "max-content",
    prose: "65ch",
    ...breakpoints(theme2("screens"))
  }),
  minHeight: {
    0: "0px",
    full: "100%",
    screen: "100vh"
  },
  minWidth: {
    0: "0px",
    full: "100%",
    min: "min-content",
    max: "max-content"
  },
  opacity: {
    .../* @__PURE__ */ linear(100, "", 100, 0, 10),
    5: "0.05",
    25: "0.25",
    75: "0.75",
    95: "0.95"
  },
  order: {
    first: "-9999",
    last: "9999",
    none: "0",
    .../* @__PURE__ */ linear(12, "", 1, 1)
  },
  outline: {
    none: ["2px solid transparent", "2px"],
    white: ["2px dotted white", "2px"],
    black: ["2px dotted black", "2px"]
  },
  padding: /* @__PURE__ */ alias2("spacing"),
  placeholderColor: /* @__PURE__ */ alias2("colors"),
  placeholderOpacity: /* @__PURE__ */ alias2("opacity"),
  ringColor: (theme2) => ({
    DEFAULT: theme2("colors.blue.500", "#3b82f6"),
    ...theme2("colors")
  }),
  ringOffsetColor: /* @__PURE__ */ alias2("colors"),
  ringOffsetWidth: /* @__PURE__ */ exponential(8, "px"),
  ringOpacity: (theme2) => ({
    DEFAULT: "0.5",
    ...theme2("opacity")
  }),
  ringWidth: {
    DEFAULT: "3px",
    .../* @__PURE__ */ exponential(8, "px")
  },
  rotate: {
    .../* @__PURE__ */ exponential(2, "deg"),
    .../* @__PURE__ */ exponential(12, "deg", 3),
    .../* @__PURE__ */ exponential(180, "deg", 45)
  },
  saturate: /* @__PURE__ */ linear(200, "", 100, 0, 50),
  scale: {
    .../* @__PURE__ */ linear(150, "", 100, 0, 50),
    .../* @__PURE__ */ linear(110, "", 100, 90, 5),
    75: "0.75",
    125: "1.25"
  },
  sepia: {
    0: "0",
    DEFAULT: "100%"
  },
  skew: {
    .../* @__PURE__ */ exponential(2, "deg"),
    .../* @__PURE__ */ exponential(12, "deg", 3)
  },
  space: /* @__PURE__ */ alias2("spacing"),
  stroke: {
    current: "currentColor"
  },
  strokeWidth: /* @__PURE__ */ linear(2),
  textColor: /* @__PURE__ */ alias2("colors"),
  textOpacity: /* @__PURE__ */ alias2("opacity"),
  transitionDuration: (theme2) => ({
    DEFAULT: "150ms",
    ...theme2("durations")
  }),
  transitionDelay: /* @__PURE__ */ alias2("durations"),
  transitionProperty: {
    none: "none",
    all: "all",
    DEFAULT: "background-color,border-color,color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter",
    colors: "background-color,border-color,color,fill,stroke",
    opacity: "opacity",
    shadow: "box-shadow",
    transform: "transform"
  },
  transitionTimingFunction: {
    DEFAULT: "cubic-bezier(0.4,0,0.2,1)",
    linear: "linear",
    in: "cubic-bezier(0.4,0,1,1)",
    out: "cubic-bezier(0,0,0.2,1)",
    "in-out": "cubic-bezier(0.4,0,0.2,1)"
  },
  translate: (theme2) => ({
    ...theme2("spacing"),
    ...ratios(2, 4),
    full: "100%"
  }),
  width: (theme2) => ({
    auto: "auto",
    ...theme2("spacing"),
    ...ratios(2, 6),
    ...ratios(12, 12),
    screen: "100vw",
    full: "100%",
    min: "min-content",
    max: "max-content"
  }),
  zIndex: {
    auto: "auto",
    .../* @__PURE__ */ linear(50, "", 1, 0, 10)
  }
};
var flattenColorPalette = (colors, target = {}, prefix = []) => {
  Object.keys(colors).forEach((property2) => {
    const value = colors[property2];
    if (property2 == "DEFAULT") {
      target[join(prefix)] = value;
      target[join(prefix, ".")] = value;
    }
    const key = [...prefix, property2];
    target[join(key)] = value;
    target[join(key, ".")] = value;
    if (value && typeof value == "object") {
      flattenColorPalette(value, target, key);
    }
  }, target);
  return target;
};
var resolveContext = {
  negative: () => ({}),
  breakpoints: (screens) => Object.keys(screens).filter((key) => typeof screens[key] == "string").reduce((target, key) => {
    target["screen-" + key] = screens[key];
    return target;
  }, {})
};
var handleArbitraryValues = (section, key) => (key = key[0] == "[" && key.slice(-1) == "]" && key.slice(1, -1)) && includes$1(section, "olor") == /^(#|(hsl|rgb)a?\(|[a-z]+$)/.test(key) && (includes$1(key, "calc(") ? key.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ") : key);
var makeThemeResolver = (config) => {
  const cache = new Map();
  const theme2 = {...defaultTheme, ...config};
  const deref = (theme3, section) => {
    const base = theme3 && theme3[section];
    const value = typeof base == "function" ? base(resolve, resolveContext) : base;
    return value && section == "colors" ? flattenColorPalette(value) : value;
  };
  const resolve = (section, key, defaultValue) => {
    const keypath = section.split(".");
    section = keypath[0];
    if (keypath.length > 1) {
      defaultValue = key;
      key = join(tail(keypath), ".");
    }
    let base = cache.get(section);
    if (!base) {
      cache.set(section, base = {...deref(theme2, section)});
      Object.assign(base, deref(theme2.extend, section));
    }
    if (key != null) {
      key = (Array.isArray(key) ? join(key) : key) || "DEFAULT";
      const value = handleArbitraryValues(section, key) || base[key];
      return value == null ? defaultValue : Array.isArray(value) && !includes$1(["fontSize", "outline", "dropShadow"], section) ? join(value, ",") : value;
    }
    return base;
  };
  return resolve;
};

// src/twind/translate.ts
var translate$2 = (plugins, context) => (rule, isTranslating) => {
  if (typeof rule.d == "function") {
    return rule.d(context);
  }
  const parameters = rule.d.split(/-(?![^[]*])/g);
  if (!isTranslating && parameters[0] == "tw" && rule.$ == rule.d) {
    return rule.$;
  }
  for (let index = parameters.length; index; index--) {
    const id = join(parameters.slice(0, index));
    const plugin = plugins[id];
    if (plugin) {
      return typeof plugin == "function" ? plugin(tail(parameters, index), context, id) : typeof plugin == "string" ? context[isTranslating ? "css" : "tw"](plugin) : plugin;
    }
  }
};

// src/twind/decorate.ts
var _2;
var GROUP_RE = /^:(group(?:(?!-focus).+?)*)-(.+)$/;
var NOT_PREFIX_RE = /^(:not)-(.+)/;
var prepareVariantSelector = (variant) => variant[1] == "[" ? tail(variant) : variant;
var decorate$1 = (darkMode, variants, {theme: theme2, tag}) => {
  const applyVariant = (translation, variant) => {
    if (_2 = theme2("screens", tail(variant), "")) {
      return {[buildMediaQuery(_2)]: translation};
    }
    if (variant == ":dark" && darkMode == "class") {
      return {".dark &": translation};
    }
    if (_2 = GROUP_RE.exec(variant)) {
      return {[`.${escape(tag(_2[1]))}:${_2[2]} &`]: translation};
    }
    return {
      [variants[tail(variant)] || "&" + variant.replace(NOT_PREFIX_RE, (_4, not, variant2) => not + "(" + prepareVariantSelector(":" + variant2) + ")")]: translation
    };
  };
  return (translation, rule) => rule.v.reduceRight(applyVariant, translation);
};

// src/twind/presedence.ts
var _3;
var responsivePrecedence = (css) => (((_3 = /(?:^|min-width: *)(\d+(?:.\d+)?)(p)?/.exec(css)) ? +_3[1] / (_3[2] ? 15 : 1) / 10 : 0) & 31) << 22;
var seperatorPrecedence = (string) => {
  _3 = 0;
  for (let index = string.length; index--; ) {
    _3 += includes$1("-:,", string[index]);
  }
  return _3;
};
var atRulePresedence = (css) => (seperatorPrecedence(css) & 15) << 18;
var PRECEDENCES_BY_PSEUDO_CLASS = [
  "rst",
  "st",
  "en",
  "d",
  "nk",
  "sited",
  "pty",
  "ecked",
  "cus-w",
  "ver",
  "cus",
  "cus-v",
  "tive",
  "sable",
  "ad-on",
  "tiona",
  "quire"
];
var pseudoPrecedence = (pseudoClass) => 1 << (~(_3 = PRECEDENCES_BY_PSEUDO_CLASS.indexOf(pseudoClass.replace(GROUP_RE, ":$2").slice(3, 8))) ? _3 : 17);
var makeVariantPresedenceCalculator = (theme2, variants) => (presedence, variant) => presedence | ((_3 = theme2("screens", tail(variant), "")) ? 1 << 27 | responsivePrecedence(buildMediaQuery(_3)) : variant == ":dark" ? 1 << 30 : (_3 = variants[variant] || variant.replace(NOT_PREFIX_RE, ":$2"))[0] == "@" ? atRulePresedence(_3) : pseudoPrecedence(variant));
var declarationPropertyPrecedence = (property2) => property2[0] == "-" ? 0 : seperatorPrecedence(property2) + ((_3 = /^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7}$)|([fl].{5}l|g.{8}$|pl))/.exec(property2)) ? +!!_3[1] || -!!_3[2] : 0) + 1;

// src/twind/serialize.ts
var stringifyBlock = (body, selector) => selector + "{" + body + "}";
var serialize = (prefix, variants, context) => {
  const {theme: theme2, tag} = context;
  const tagVar = (_4, property2) => "--" + tag(property2);
  const tagVars = (value) => `${value}`.replace(/--(tw-[\w-]+)\b/g, tagVar);
  const stringifyDeclaration = (property2, value, important) => {
    property2 = tagVars(property2);
    return Array.isArray(value) ? join(value.filter(Boolean).map((value2) => prefix(property2, tagVars(value2), important)), ";") : prefix(property2, tagVars(value), important);
  };
  let rules2;
  const stringify3 = (atRules, selector, presedence, css, important) => {
    if (Array.isArray(css)) {
      css.forEach((css2) => css2 && stringify3(atRules, selector, presedence, css2, important));
      return;
    }
    let declarations = "";
    let maxPropertyPresedence = 0;
    let numberOfDeclarations = 0;
    if (css["@apply"]) {
      css = merge$2(evalThunk$1(apply$1(css["@apply"]), context), {...css, "@apply": void 0}, context);
    }
    Object.keys(css).forEach((key) => {
      const value = evalThunk$1(css[key], context);
      if (isCSSProperty$1(key, value)) {
        if (value !== "" && key.length > 1) {
          const property2 = hyphenate$1(key);
          numberOfDeclarations += 1;
          maxPropertyPresedence = Math.max(maxPropertyPresedence, declarationPropertyPrecedence(property2));
          declarations = (declarations && declarations + ";") + stringifyDeclaration(property2, value, important);
        }
      } else if (value) {
        if (key == ":global") {
          key = "@global";
        }
        if (key[0] == "@") {
          if (key[1] == "g") {
            stringify3([], "", 0, value, important);
          } else if (key[1] == "f") {
            stringify3([], key, 0, value, important);
          } else if (key[1] == "k") {
            const currentSize = rules2.length;
            stringify3([], "", 0, value, important);
            const waypoints = rules2.splice(currentSize, rules2.length - currentSize);
            rules2.push({
              r: stringifyBlock(join(waypoints.map((p) => p.r), ""), key),
              p: waypoints.reduce((sum, p) => sum + p.p, 0)
            });
          } else if (key[1] == "i") {
            (Array.isArray(value) ? value : [value]).forEach((value2) => value2 && rules2.push({p: 0, r: `${key} ${value2};`}));
          } else {
            if (key[2] == "c") {
              key = buildMediaQuery(context.theme("screens", tail(key, 8).trim()));
            }
            stringify3([...atRules, key], selector, presedence | responsivePrecedence(key) | atRulePresedence(key), value, important);
          }
        } else {
          stringify3(atRules, selector ? join(selector.split(/,(?![^[]*])/g).map((selectorPart) => join(key.split(/,(?![^[]*])/g).map((keyPart) => includes$1(keyPart, "&") ? keyPart.replace(/&/g, selectorPart) : (selectorPart && selectorPart + " ") + keyPart), ",")), ",") : key, presedence, value, important);
        }
      }
    });
    if (numberOfDeclarations) {
      rules2.push({
        r: atRules.reduceRight(stringifyBlock, stringifyBlock(declarations, selector)),
        p: presedence * (1 << 8) + ((Math.max(0, 15 - numberOfDeclarations) & 15) << 4 | (maxPropertyPresedence || 15) & 15)
      });
    }
  };
  const variantPresedence = makeVariantPresedenceCalculator(theme2, variants);
  return (css, className, rule, layer = 0) => {
    layer <<= 28;
    rules2 = [];
    stringify3([], className ? "." + escape(className) : "", rule ? rule.v.reduceRight(variantPresedence, layer) : layer, css, rule && rule.i);
    return rules2;
  };
};

// src/twind/inject.ts
var inject = (sheet, mode2, init, context) => {
  let sortedPrecedences;
  init((value = []) => sortedPrecedences = value);
  let insertedRules;
  init((value = new Set()) => insertedRules = value);
  return ({r: css, p: presedence}) => {
    if (!insertedRules.has(css)) {
      insertedRules.add(css);
      const index = sortedInsertionIndex(sortedPrecedences, presedence);
      try {
        sheet.insert(css, index);
        sortedPrecedences.splice(index, 0, presedence);
      } catch (error) {
        if (!/:-[mwo]/.test(css)) {
          mode2.report({id: "INJECT_CSS_ERROR", css, error}, context);
        }
      }
    }
  };
};

// src/twind/configure.ts
var sanitize$1 = (value, defaultValue, disabled, enabled = defaultValue) => value === false ? disabled : value === true ? enabled : value || defaultValue;
var loadMode = (mode2) => (typeof mode2 == "string" ? {t: strict, a: warn, i: silent}[mode2[1]] : mode2) || warn;
var stringifyVariant = (selector, variant) => selector + (variant[1] == ":" ? tail(variant, 2) + ":" : tail(variant)) + ":";
var stringify2 = (rule, directive2 = rule.d) => typeof directive2 == "function" ? "" : rule.v.reduce(stringifyVariant, "") + (rule.i ? "!" : "") + (rule.n ? "-" : "") + directive2;
var COMPONENT_PROPS = {_: {value: "", writable: true}};
var configure = (config = {}) => {
  const theme2 = makeThemeResolver(config.theme);
  const mode2 = loadMode(config.mode);
  const hash = sanitize$1(config.hash, false, false, cyrb32);
  const important = config.important;
  let activeRule = {v: []};
  let translateDepth = 0;
  const lastTranslations = [];
  const context = {
    tw: (...tokens) => process(tokens),
    theme: (section, key, defaultValue) => {
      var _a;
      const value = (_a = theme2(section, key, defaultValue)) != null ? _a : mode2.unknown(section, key == null || Array.isArray(key) ? key : key.split("."), defaultValue != null, context);
      return activeRule.n && value && includes$1("rg", (typeof value)[5]) ? `calc(${value} * -1)` : value;
    },
    tag: (value) => hash ? hash(value) : value,
    css: (rules2) => {
      translateDepth++;
      const lastTranslationsIndex = lastTranslations.length;
      try {
        (typeof rules2 == "string" ? parse([rules2]) : rules2).forEach(convert);
        const css = Object.create(null, COMPONENT_PROPS);
        for (let index = lastTranslationsIndex; index < lastTranslations.length; index++) {
          const translation = lastTranslations[index];
          if (translation) {
            switch (typeof translation) {
              case "object":
                merge$2(css, translation, context);
                break;
              case "string":
                css._ += (css._ && " ") + translation;
            }
          }
        }
        return css;
      } finally {
        lastTranslations.length = lastTranslationsIndex;
        translateDepth--;
      }
    }
  };
  const translate2 = translate$2({...corePlugins, ...config.plugins}, context);
  const doTranslate = (rule) => {
    const parentRule = activeRule;
    activeRule = rule;
    try {
      return evalThunk$1(translate2(rule), context);
    } finally {
      activeRule = parentRule;
    }
  };
  const variants = {...coreVariants, ...config.variants};
  const decorate2 = decorate$1(config.darkMode || "media", variants, context);
  const serialize2 = serialize(sanitize$1(config.prefix, autoprefix, noprefix), variants, context);
  const sheet = config.sheet || (typeof window == "undefined" ? voidSheet() : cssomSheet(config));
  const {init = (callback) => callback()} = sheet;
  const inject2 = inject(sheet, mode2, init, context);
  let idToClassName;
  init((value = new Map()) => idToClassName = value);
  const inlineDirectiveName = new WeakMap();
  const evaluateFunctions = (key, value) => key == "_" ? void 0 : typeof value == "function" ? JSON.stringify(evalThunk$1(value, context), evaluateFunctions) : value;
  const convert = (rule) => {
    if (!translateDepth && activeRule.v.length) {
      rule = {...rule, v: [...activeRule.v, ...rule.v], $: ""};
    }
    if (!rule.$) {
      rule.$ = stringify2(rule, inlineDirectiveName.get(rule.d));
    }
    let className = translateDepth ? null : idToClassName.get(rule.$);
    if (className == null) {
      let translation = doTranslate(rule);
      if (!rule.$) {
        rule.$ = cyrb32(JSON.stringify(translation, evaluateFunctions));
        inlineDirectiveName.set(rule.d, rule.$);
        rule.$ = stringify2(rule, rule.$);
      }
      if (translation && typeof translation == "object") {
        rule.v = rule.v.map(prepareVariantSelector);
        if (important)
          rule.i = important;
        translation = decorate2(translation, rule);
        if (translateDepth) {
          lastTranslations.push(translation);
        } else {
          const layer = typeof rule.d == "function" ? typeof translation._ == "string" ? 1 : 3 : 2;
          className = hash || typeof rule.d == "function" ? (hash || cyrb32)(layer + rule.$) : rule.$;
          serialize2(translation, className, rule, layer).forEach(inject2);
          if (translation._) {
            className += " " + translation._;
          }
        }
      } else {
        if (typeof translation == "string") {
          className = translation;
        } else {
          className = rule.$;
          mode2.report({id: "UNKNOWN_DIRECTIVE", rule: className}, context);
        }
        if (translateDepth && typeof rule.d !== "function") {
          lastTranslations.push(className);
        }
      }
      if (!translateDepth) {
        idToClassName.set(rule.$, className);
        ensureMaxSize(idToClassName, 3e4);
      }
    }
    return className;
  };
  const process = (tokens) => join(parse(tokens).map(convert).filter(Boolean), " ");
  const preflight = sanitize$1(config.preflight, identity$1, false);
  if (preflight) {
    const css = createPreflight(theme2);
    const styles = serialize2(typeof preflight == "function" ? evalThunk$1(preflight(css, context), context) || css : {...css, ...preflight});
    init((injected = (styles.forEach(inject2), true)) => injected);
  }
  return {
    init: () => mode2.report({id: "LATE_SETUP_CALL"}, context),
    process
  };
};

// src/twind/instance.ts
var create = (config) => {
  let process = (tokens) => {
    init();
    return process(tokens);
  };
  let init = (config2) => {
    ({process, init} = configure(config2));
  };
  if (config)
    init(config);
  let context;
  const fromContext = (key) => () => {
    if (!context) {
      process([
        (_4) => {
          context = _4;
          return "";
        }
      ]);
    }
    return context[key];
  };
  return {
    tw: Object.defineProperties((...tokens) => process(tokens), {
      theme: {
        get: fromContext("theme")
      }
    }),
    setup: (config2) => init(config2)
  };
};

// src/css/index.ts

// src/internal/util.ts
var includes = (value, search) => !!~value.indexOf(search);
var hyphenate = (value) => value.replace(/[A-Z]/g, "-$&").toLowerCase();
var evalThunk = (value, context) => {
  while (typeof value == "function") {
    value = value(context);
  }
  return value;
};
var isCSSProperty = (key, value) => !includes("@:&", key[0]) && (includes("rg", (typeof value)[5]) || Array.isArray(value));
var merge$1 = (target, source, context) => source ? Object.keys(source).reduce((target2, key) => {
  const value = evalThunk(source[key], context);
  if (isCSSProperty(key, value)) {
    target2[hyphenate(key)] = value;
  } else {
    target2[key] = key[0] == "@" && includes("figa", key[1]) ? (target2[key] || []).concat(value) : merge$1(target2[key] || {}, value, context);
  }
  return target2;
}, target) : target;
var translate$1 = (tokens, context) => {
  const collect = (target, token) => Array.isArray(token) ? token.reduce(collect, target) : merge$1(target, evalThunk(token, context), context);
  return tokens.reduce(collect, {});
};
var newRule = /\s*(?:([\w-%@]+)\s*:?\s*([^{;]+?)\s*(?:;|$|})|([^;}{]*?)\s*{)|(})/gi;
var ruleClean = /\/\*[\s\S]*?\*\/|\s+|\n/gm;
var decorate = (selectors, currentBlock) => selectors.reduceRight((rules, selector) => ({[selector]: rules}), currentBlock);
var saveBlock = (rules, selectors, currentBlock) => {
  if (currentBlock) {
    rules.push(decorate(selectors, currentBlock));
  }
};
var interleave = (strings, interpolations, context) => {
  let buffer = strings[0];
  const result = [];
  for (let index = 0; index < interpolations.length; ) {
    const interpolation = evalThunk(interpolations[index], context);
    if (interpolation && typeof interpolation == "object") {
      result.push(buffer, interpolation);
      buffer = strings[++index];
    } else {
      buffer += (interpolation || "") + strings[++index];
    }
  }
  result.push(buffer);
  return result;
};
var astish = (values, context) => {
  const selectors = [];
  const rules = [];
  let currentBlock;
  let match;
  for (let index = 0; index < values.length; index++) {
    const value = values[index];
    if (typeof value == "string") {
      while (match = newRule.exec(value.replace(ruleClean, " "))) {
        if (!match[0])
          continue;
        if (match[4]) {
          currentBlock = saveBlock(rules, selectors, currentBlock);
          selectors.pop();
        }
        if (match[3]) {
          currentBlock = saveBlock(rules, selectors, currentBlock);
          selectors.push(match[3]);
        } else if (!match[4]) {
          if (!currentBlock)
            currentBlock = {};
          const value2 = match[2] && /\S/.test(match[2]) ? match[2] : values[++index];
          if (value2) {
            if (match[1] == "@apply") {
              merge$1(currentBlock, evalThunk(apply$1(value2), context), context);
            } else {
              currentBlock[match[1]] = value2;
            }
          }
        }
      }
    } else {
      currentBlock = saveBlock(rules, selectors, currentBlock);
      rules.push(decorate(selectors, value));
    }
  }
  saveBlock(rules, selectors, currentBlock);
  return rules;
};
var cssFactory = (tokens, context) => translate$1(Array.isArray(tokens[0]) && Array.isArray(tokens[0].raw) ? astish(interleave(tokens[0], tokens.slice(1), context), context) : tokens, context);
var css$1 = (...tokens) => directive(cssFactory, tokens);

// src/colors/index.ts
var black = "#000";
var white = "#fff";
var rose = {
  50: "#fff1f2",
  100: "#ffe4e6",
  200: "#fecdd3",
  300: "#fda4af",
  400: "#fb7185",
  500: "#f43f5e",
  600: "#e11d48",
  700: "#be123c",
  800: "#9f1239",
  900: "#881337"
};
var pink = {
  50: "#fdf2f8",
  100: "#fce7f3",
  200: "#fbcfe8",
  300: "#f9a8d4",
  400: "#f472b6",
  500: "#ec4899",
  600: "#db2777",
  700: "#be185d",
  800: "#9d174d",
  900: "#831843"
};
var fuchsia = {
  50: "#fdf4ff",
  100: "#fae8ff",
  200: "#f5d0fe",
  300: "#f0abfc",
  400: "#e879f9",
  500: "#d946ef",
  600: "#c026d3",
  700: "#a21caf",
  800: "#86198f",
  900: "#701a75"
};
var purple = {
  50: "#faf5ff",
  100: "#f3e8ff",
  200: "#e9d5ff",
  300: "#d8b4fe",
  400: "#c084fc",
  500: "#a855f7",
  600: "#9333ea",
  700: "#7e22ce",
  800: "#6b21a8",
  900: "#581c87"
};
var violet = {
  50: "#f5f3ff",
  100: "#ede9fe",
  200: "#ddd6fe",
  300: "#c4b5fd",
  400: "#a78bfa",
  500: "#8b5cf6",
  600: "#7c3aed",
  700: "#6d28d9",
  800: "#5b21b6",
  900: "#4c1d95"
};
var indigo = {
  50: "#eef2ff",
  100: "#e0e7ff",
  200: "#c7d2fe",
  300: "#a5b4fc",
  400: "#818cf8",
  500: "#6366f1",
  600: "#4f46e5",
  700: "#4338ca",
  800: "#3730a3",
  900: "#312e81"
};
var blue = {
  50: "#eff6ff",
  100: "#dbeafe",
  200: "#bfdbfe",
  300: "#93c5fd",
  400: "#60a5fa",
  500: "#3b82f6",
  600: "#2563eb",
  700: "#1d4ed8",
  800: "#1e40af",
  900: "#1e3a8a"
};
var lightBlue = {
  50: "#f0f9ff",
  100: "#e0f2fe",
  200: "#bae6fd",
  300: "#7dd3fc",
  400: "#38bdf8",
  500: "#0ea5e9",
  600: "#0284c7",
  700: "#0369a1",
  800: "#075985",
  900: "#0c4a6e"
};
var cyan = {
  50: "#ecfeff",
  100: "#cffafe",
  200: "#a5f3fc",
  300: "#67e8f9",
  400: "#22d3ee",
  500: "#06b6d4",
  600: "#0891b2",
  700: "#0e7490",
  800: "#155e75",
  900: "#164e63"
};
var teal = {
  50: "#f0fdfa",
  100: "#ccfbf1",
  200: "#99f6e4",
  300: "#5eead4",
  400: "#2dd4bf",
  500: "#14b8a6",
  600: "#0d9488",
  700: "#0f766e",
  800: "#115e59",
  900: "#134e4a"
};
var emerald = {
  50: "#ecfdf5",
  100: "#d1fae5",
  200: "#a7f3d0",
  300: "#6ee7b7",
  400: "#34d399",
  500: "#10b981",
  600: "#059669",
  700: "#047857",
  800: "#065f46",
  900: "#064e3b"
};
var green = {
  50: "#f0fdf4",
  100: "#dcfce7",
  200: "#bbf7d0",
  300: "#86efac",
  400: "#4ade80",
  500: "#22c55e",
  600: "#16a34a",
  700: "#15803d",
  800: "#166534",
  900: "#14532d"
};
var lime = {
  50: "#f7fee7",
  100: "#ecfccb",
  200: "#d9f99d",
  300: "#bef264",
  400: "#a3e635",
  500: "#84cc16",
  600: "#65a30d",
  700: "#4d7c0f",
  800: "#3f6212",
  900: "#365314"
};
var yellow = {
  50: "#fefce8",
  100: "#fef9c3",
  200: "#fef08a",
  300: "#fde047",
  400: "#facc15",
  500: "#eab308",
  600: "#ca8a04",
  700: "#a16207",
  800: "#854d0e",
  900: "#713f12"
};
var amber = {
  50: "#fffbeb",
  100: "#fef3c7",
  200: "#fde68a",
  300: "#fcd34d",
  400: "#fbbf24",
  500: "#f59e0b",
  600: "#d97706",
  700: "#b45309",
  800: "#92400e",
  900: "#78350f"
};
var orange = {
  50: "#fff7ed",
  100: "#ffedd5",
  200: "#fed7aa",
  300: "#fdba74",
  400: "#fb923c",
  500: "#f97316",
  600: "#ea580c",
  700: "#c2410c",
  800: "#9a3412",
  900: "#7c2d12"
};
var red = {
  50: "#fef2f2",
  100: "#fee2e2",
  200: "#fecaca",
  300: "#fca5a5",
  400: "#f87171",
  500: "#ef4444",
  600: "#dc2626",
  700: "#b91c1c",
  800: "#991b1b",
  900: "#7f1d1d"
};
var warmGray = {
  50: "#fafaf9",
  100: "#f5f5f4",
  200: "#e7e5e4",
  300: "#d6d3d1",
  400: "#a8a29e",
  500: "#78716c",
  600: "#57534e",
  700: "#44403c",
  800: "#292524",
  900: "#1c1917"
};
var trueGray = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#e5e5e5",
  300: "#d4d4d4",
  400: "#a3a3a3",
  500: "#737373",
  600: "#525252",
  700: "#404040",
  800: "#262626",
  900: "#171717"
};
var gray = {
  50: "#fafafa",
  100: "#f4f4f5",
  200: "#e4e4e7",
  300: "#d4d4d8",
  400: "#a1a1aa",
  500: "#71717a",
  600: "#52525b",
  700: "#3f3f46",
  800: "#27272a",
  900: "#18181b"
};
var coolGray = {
  50: "#f9fafb",
  100: "#f3f4f6",
  200: "#e5e7eb",
  300: "#d1d5db",
  400: "#9ca3af",
  500: "#6b7280",
  600: "#4b5563",
  700: "#374151",
  800: "#1f2937",
  900: "#111827"
};
var blueGray = {
  50: "#f8fafc",
  100: "#f1f5f9",
  200: "#e2e8f0",
  300: "#cbd5e1",
  400: "#94a3b8",
  500: "#64748b",
  600: "#475569",
  700: "#334155",
  800: "#1e293b",
  900: "#0f172a"
};

var md5 = createCommonjsModule(function (module) {
/**
 * [js-md5]{@link https://github.com/emn178/js-md5}
 *
 * @namespace md5
 * @version 0.7.3
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function () {

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_MD5_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = commonjsGlobal;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && 'object' === 'object' && module.exports;
  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [128, 32768, 8388608, -2147483648];
  var SHIFT = [0, 8, 16, 24];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];
  var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  var blocks = [], buffer8;
  if (ARRAY_BUFFER) {
    var buffer = new ArrayBuffer(68);
    buffer8 = new Uint8Array(buffer);
    blocks = new Uint32Array(buffer);
  }

  if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  /**
   * @method hex
   * @memberof md5
   * @description Output hash as hex string
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} Hex string
   * @example
   * md5.hex('The quick brown fox jumps over the lazy dog');
   * // equal to
   * md5('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method digest
   * @memberof md5
   * @description Output hash as bytes array
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Array} Bytes array
   * @example
   * md5.digest('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method array
   * @memberof md5
   * @description Output hash as bytes array
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Array} Bytes array
   * @example
   * md5.array('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method arrayBuffer
   * @memberof md5
   * @description Output hash as ArrayBuffer
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {ArrayBuffer} ArrayBuffer
   * @example
   * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method buffer
   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
   * @memberof md5
   * @description Output hash as ArrayBuffer
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {ArrayBuffer} ArrayBuffer
   * @example
   * md5.buffer('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method base64
   * @memberof md5
   * @description Output hash as base64 string
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} base64 string
   * @example
   * md5.base64('The quick brown fox jumps over the lazy dog');
   */
  var createOutputMethod = function (outputType) {
    return function (message) {
      return new Md5(true).update(message)[outputType]();
    };
  };

  /**
   * @method create
   * @memberof md5
   * @description Create Md5 object
   * @returns {Md5} Md5 object.
   * @example
   * var hash = md5.create();
   */
  /**
   * @method update
   * @memberof md5
   * @description Create and update Md5 object
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @example
   * var hash = md5.update('The quick brown fox jumps over the lazy dog');
   * // equal to
   * var hash = md5.create();
   * hash.update('The quick brown fox jumps over the lazy dog');
   */
  var createMethod = function () {
    var method = createOutputMethod('hex');
    if (NODE_JS) {
      method = nodeWrap(method);
    }
    method.create = function () {
      return new Md5();
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }
    return method;
  };

  var nodeWrap = function (method) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash('md5').update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw ERROR;
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      if (Array.isArray(message) || ArrayBuffer.isView(message) ||
        message.constructor === Buffer) {
        return crypto.createHash('md5').update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  /**
   * Md5 class
   * @class Md5
   * @description This is internal class.
   * @see {@link md5.create}
   */
  function Md5(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
      this.buffer8 = buffer8;
    } else {
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        this.buffer8 = new Uint8Array(buffer);
        this.blocks = new Uint32Array(buffer);
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
    }
    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }

  /**
   * @method update
   * @memberof Md5
   * @instance
   * @description Update hash
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @see {@link md5.update}
   */
  Md5.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }

    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw ERROR;
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw ERROR;
          }
        }
      } else {
        throw ERROR;
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;
    var buffer8 = this.buffer8;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        if (ARRAY_BUFFER) {
          for (i = this.start; index < length && i < 64; ++index) {
            buffer8[i++] = message[index];
          }
        } else {
          for (i = this.start; index < length && i < 64; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        }
      } else {
        if (ARRAY_BUFFER) {
          for (i = this.start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              buffer8[i++] = code;
            } else if (code < 0x800) {
              buffer8[i++] = 0xc0 | (code >> 6);
              buffer8[i++] = 0x80 | (code & 0x3f);
            } else if (code < 0xd800 || code >= 0xe000) {
              buffer8[i++] = 0xe0 | (code >> 12);
              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);
              buffer8[i++] = 0x80 | (code & 0x3f);
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
              buffer8[i++] = 0xf0 | (code >> 18);
              buffer8[i++] = 0x80 | ((code >> 12) & 0x3f);
              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);
              buffer8[i++] = 0x80 | (code & 0x3f);
            }
          }
        } else {
          for (i = this.start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 0x800) {
              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else if (code < 0xd800 || code >= 0xe000) {
              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            }
          }
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Md5.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[i >> 2] |= EXTRA[i & 3];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = blocks[16];
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.bytes << 3;
    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
    this.hash();
  };

  Md5.prototype.hash = function () {
    var a, b, c, d, bc, da, blocks = this.blocks;

    if (this.first) {
      a = blocks[0] - 680876937;
      a = (a << 7 | a >>> 25) - 271733879 << 0;
      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
      d = (d << 12 | d >>> 20) + a << 0;
      c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;
      c = (c << 17 | c >>> 15) + d << 0;
      b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;
      b = (b << 22 | b >>> 10) + c << 0;
    } else {
      a = this.h0;
      b = this.h1;
      c = this.h2;
      d = this.h3;
      a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;
      b = (b << 22 | b >>> 10) + c << 0;
    }

    a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;
    b = (b << 20 | b >>> 12) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[5] - 378558;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[8] - 2022574463;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[11] + 1839030562;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[14] - 35309556;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[1] - 1530992060;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[4] + 1272893353;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[7] - 155497632;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[10] - 1094730640;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[13] + 681279174;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[0] - 358537222;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[3] - 722521979;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[6] + 76029189;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[9] - 640364487;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[12] - 421815835;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[15] + 530742520;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[2] - 995338651;
    b = (b << 23 | b >>> 9) + c << 0;
    a += (c ^ (b | ~d)) + blocks[0] - 198630844;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[5] - 57434055;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[10] - 1051523;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[15] - 30611744;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[4] - 145523070;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[2] + 718787259;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[9] - 343485551;
    b = (b << 21 | b >>> 11) + c << 0;

    if (this.first) {
      this.h0 = a + 1732584193 << 0;
      this.h1 = b - 271733879 << 0;
      this.h2 = c - 1732584194 << 0;
      this.h3 = d + 271733878 << 0;
      this.first = false;
    } else {
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
    }
  };

  /**
   * @method hex
   * @memberof Md5
   * @instance
   * @description Output hash as hex string
   * @returns {String} Hex string
   * @see {@link md5.hex}
   * @example
   * hash.hex();
   */
  Md5.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;

    return HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
      HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F];
  };

  /**
   * @method toString
   * @memberof Md5
   * @instance
   * @description Output hash as hex string
   * @returns {String} Hex string
   * @see {@link md5.hex}
   * @example
   * hash.toString();
   */
  Md5.prototype.toString = Md5.prototype.hex;

  /**
   * @method digest
   * @memberof Md5
   * @instance
   * @description Output hash as bytes array
   * @returns {Array} Bytes array
   * @see {@link md5.digest}
   * @example
   * hash.digest();
   */
  Md5.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
    return [
      h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 24) & 0xFF,
      h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 24) & 0xFF,
      h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 24) & 0xFF,
      h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 24) & 0xFF
    ];
  };

  /**
   * @method array
   * @memberof Md5
   * @instance
   * @description Output hash as bytes array
   * @returns {Array} Bytes array
   * @see {@link md5.array}
   * @example
   * hash.array();
   */
  Md5.prototype.array = Md5.prototype.digest;

  /**
   * @method arrayBuffer
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.arrayBuffer}
   * @example
   * hash.arrayBuffer();
   */
  Md5.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(16);
    var blocks = new Uint32Array(buffer);
    blocks[0] = this.h0;
    blocks[1] = this.h1;
    blocks[2] = this.h2;
    blocks[3] = this.h3;
    return buffer;
  };

  /**
   * @method buffer
   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.buffer}
   * @example
   * hash.buffer();
   */
  Md5.prototype.buffer = Md5.prototype.arrayBuffer;

  /**
   * @method base64
   * @memberof Md5
   * @instance
   * @description Output hash as base64 string
   * @returns {String} base64 string
   * @see {@link md5.base64}
   * @example
   * hash.base64();
   */
  Md5.prototype.base64 = function () {
    var v1, v2, v3, base64Str = '', bytes = this.array();
    for (var i = 0; i < 15;) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i++];
      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +
        BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] +
        BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] +
        BASE64_ENCODE_CHAR[v3 & 63];
    }
    v1 = bytes[i];
    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +
      BASE64_ENCODE_CHAR[(v1 << 4) & 63] +
      '==';
    return base64Str;
  };

  var exports = createMethod();

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    /**
     * @method md5
     * @description Md5 hash function, export to global in browsers.
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {String} md5 hashes
     * @example
     * md5(''); // d41d8cd98f00b204e9800998ecf8427e
     * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6
     * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0
     *
     * // It also supports UTF-8 encoding
     * md5('中文'); // a7bac2239fcdcb3a067903d8077c4a07
     *
     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
     * md5([]); // d41d8cd98f00b204e9800998ecf8427e
     * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e
     */
    root.md5 = exports;
  }
})();
});

var sha1 = createCommonjsModule(function (module) {
/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function() {

  var root = typeof window === 'object' ? window : {};
  var NODE_JS = !root.JS_SHA1_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = commonjsGlobal;
  }
  var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && 'object' === 'object' && module.exports;
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  var createOutputMethod = function (outputType) {
    return function (message) {
      return new Sha1(true).update(message)[outputType]();
    };
  };

  var createMethod = function () {
    var method = createOutputMethod('hex');
    if (NODE_JS) {
      method = nodeWrap(method);
    }
    method.create = function () {
      return new Sha1();
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }
    return method;
  };

  var nodeWrap = function (method) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash('sha1').update(message, 'utf8').digest('hex');
      } else if (message.constructor === ArrayBuffer) {
        message = new Uint8Array(message);
      } else if (message.length === undefined) {
        return method(message);
      }
      return crypto.createHash('sha1').update(new Buffer(message)).digest('hex');
    };
    return nodeMethod;
  };

  function Sha1(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    this.h0 = 0x67452301;
    this.h1 = 0xEFCDAB89;
    this.h2 = 0x98BADCFE;
    this.h3 = 0x10325476;
    this.h4 = 0xC3D2E1F0;

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }

  Sha1.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString = typeof(message) !== 'string';
    if (notString && message.constructor === root.ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var code, index = 0, i, length = message.length || 0, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if(notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha1.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha1.prototype.hash = function () {
    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;
    var f, j, t, blocks = this.blocks;

    for(j = 16; j < 80; ++j) {
      t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
      blocks[j] =  (t << 1) | (t >>> 31);
    }

    for(j = 0; j < 20; j += 5) {
      f = (b & c) | ((~b) & d);
      t = (a << 5) | (a >>> 27);
      e = t + f + e + 1518500249 + blocks[j] << 0;
      b = (b << 30) | (b >>> 2);

      f = (a & b) | ((~a) & c);
      t = (e << 5) | (e >>> 27);
      d = t + f + d + 1518500249 + blocks[j + 1] << 0;
      a = (a << 30) | (a >>> 2);

      f = (e & a) | ((~e) & b);
      t = (d << 5) | (d >>> 27);
      c = t + f + c + 1518500249 + blocks[j + 2] << 0;
      e = (e << 30) | (e >>> 2);

      f = (d & e) | ((~d) & a);
      t = (c << 5) | (c >>> 27);
      b = t + f + b + 1518500249 + blocks[j + 3] << 0;
      d = (d << 30) | (d >>> 2);

      f = (c & d) | ((~c) & e);
      t = (b << 5) | (b >>> 27);
      a = t + f + a + 1518500249 + blocks[j + 4] << 0;
      c = (c << 30) | (c >>> 2);
    }

    for(; j < 40; j += 5) {
      f = b ^ c ^ d;
      t = (a << 5) | (a >>> 27);
      e = t + f + e + 1859775393 + blocks[j] << 0;
      b = (b << 30) | (b >>> 2);

      f = a ^ b ^ c;
      t = (e << 5) | (e >>> 27);
      d = t + f + d + 1859775393 + blocks[j + 1] << 0;
      a = (a << 30) | (a >>> 2);

      f = e ^ a ^ b;
      t = (d << 5) | (d >>> 27);
      c = t + f + c + 1859775393 + blocks[j + 2] << 0;
      e = (e << 30) | (e >>> 2);

      f = d ^ e ^ a;
      t = (c << 5) | (c >>> 27);
      b = t + f + b + 1859775393 + blocks[j + 3] << 0;
      d = (d << 30) | (d >>> 2);

      f = c ^ d ^ e;
      t = (b << 5) | (b >>> 27);
      a = t + f + a + 1859775393 + blocks[j + 4] << 0;
      c = (c << 30) | (c >>> 2);
    }

    for(; j < 60; j += 5) {
      f = (b & c) | (b & d) | (c & d);
      t = (a << 5) | (a >>> 27);
      e = t + f + e - 1894007588 + blocks[j] << 0;
      b = (b << 30) | (b >>> 2);

      f = (a & b) | (a & c) | (b & c);
      t = (e << 5) | (e >>> 27);
      d = t + f + d - 1894007588 + blocks[j + 1] << 0;
      a = (a << 30) | (a >>> 2);

      f = (e & a) | (e & b) | (a & b);
      t = (d << 5) | (d >>> 27);
      c = t + f + c - 1894007588 + blocks[j + 2] << 0;
      e = (e << 30) | (e >>> 2);

      f = (d & e) | (d & a) | (e & a);
      t = (c << 5) | (c >>> 27);
      b = t + f + b - 1894007588 + blocks[j + 3] << 0;
      d = (d << 30) | (d >>> 2);

      f = (c & d) | (c & e) | (d & e);
      t = (b << 5) | (b >>> 27);
      a = t + f + a - 1894007588 + blocks[j + 4] << 0;
      c = (c << 30) | (c >>> 2);
    }

    for(; j < 80; j += 5) {
      f = b ^ c ^ d;
      t = (a << 5) | (a >>> 27);
      e = t + f + e - 899497514 + blocks[j] << 0;
      b = (b << 30) | (b >>> 2);

      f = a ^ b ^ c;
      t = (e << 5) | (e >>> 27);
      d = t + f + d - 899497514 + blocks[j + 1] << 0;
      a = (a << 30) | (a >>> 2);

      f = e ^ a ^ b;
      t = (d << 5) | (d >>> 27);
      c = t + f + c - 899497514 + blocks[j + 2] << 0;
      e = (e << 30) | (e >>> 2);

      f = d ^ e ^ a;
      t = (c << 5) | (c >>> 27);
      b = t + f + b - 899497514 + blocks[j + 3] << 0;
      d = (d << 30) | (d >>> 2);

      f = c ^ d ^ e;
      t = (b << 5) | (b >>> 27);
      a = t + f + a - 899497514 + blocks[j + 4] << 0;
      c = (c << 30) | (c >>> 2);
    }

    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
  };

  Sha1.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;

    return HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
           HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
           HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
           HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
           HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
           HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
           HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
           HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
           HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
           HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
           HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
           HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
           HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
           HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
           HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
           HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
           HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
           HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
           HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
           HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F];
  };

  Sha1.prototype.toString = Sha1.prototype.hex;

  Sha1.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;

    return [
      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF
    ];
  };

  Sha1.prototype.array = Sha1.prototype.digest;

  Sha1.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(20);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    return buffer;
  };

  var exports = createMethod();

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha1 = exports;
  }
})();
});

/** List of hex digit for fast accessing by index */
var HEX_DIGITS = '0123456789abcdef'.split('');

/**
 * Converts unsigned byte to hex representation
 * @param {number} ubyte The unsigned byte to convert
 * @returns {string} The hex representation
 */
var uint8ToHex = function(ubyte) {
  var first = ubyte >> 4;
  var second = ubyte - (first << 4);

  return HEX_DIGITS[first] + HEX_DIGITS[second];
};

/**
 * Converts unsigned byte buffer to hex string
 * @param {Uint8Array} buf The unsigned bytes buffer
 * @returns {string} The hex string representation
 */
var uint8ArrayToHex = function(buf) {
  var out = [];

  for (var i = 0; i < buf.length; i++) {
    out.push(uint8ToHex(buf[i]));
  }

  return out.join('');
};

/**
 * Converts string to buffer of char codes
 * @param {string} str The string to parse
 * @returns {Uint8Array} Buffer of char codes
 */
var stringToCharBuffer = function(str) {
  var buffer = new Uint8Array(str.length);

  for (var i = 0; i < str.length; i++) {
    buffer[i] = str[i].charCodeAt(0);
  }

  return buffer;
};

/**
 * Generates MD5 hash from buffer
 * @param {Uint8Array} buf Buffer of char codes
 * @returns {Uint8Array} MD5 hash buffer
 */
var md5Hash = function(buf) {
  return new Uint8Array(md5.arrayBuffer(buf));
};

/**
 * Generates SHA-1 hash from buffer
 * @param {Uint8Array} buf Buffer of char codes
 * @returns {Uint8Array} SHA-1 hash buffer
 */
var sha1Hash = function(buf) {
  return new Uint8Array(sha1.arrayBuffer(buf));
};

/**
 * Concatenates two uint8 buffers
 * @param {Uint8Array} buf1 The first buffer to concatenate
 * @param {Uint8Array} buf2 The second buffer to concatenate
 * @returns {Uint8Array} Concatenation result
 */
var concatBuffers = function(buf1, buf2) {
  var out = new Uint8Array(buf1.length + buf2.length);

  out.set(new Uint8Array(buf1), 0);
  out.set(new Uint8Array(buf2), buf1.byteLength);

  return out;
};

/**
 * Creates uuid from hash buffer
 * @param {Uint8Array} hashBuffer Hash buffer
 * @param {3|5} version Version of uuid
 * @returns {string} The uuid
 */
var hashToUuid = function(hashBuffer, version) {
  return [
    // The low field of the timestamp
    uint8ArrayToHex(hashBuffer.slice(0, 4)),
    '-',

    // The middle field of the timestamp
    uint8ArrayToHex(hashBuffer.slice(4, 6)),
    '-',

    // The high field of the timestamp multiplexed with the version number
    uint8ToHex((hashBuffer[6] & 0x0f) | parseInt(version * 10, 16)),
    uint8ToHex(hashBuffer[7]),
    '-',

    // The high field of the clock sequence multiplexed with the variant
    uint8ToHex((hashBuffer[8] & 0x3f) | 0x80),
    // The low field of the clock sequence
    uint8ToHex(hashBuffer[9]),
    '-',
    //  The spatially unique node identifier

    uint8ArrayToHex(hashBuffer.slice(10, 16))
  ].join('');
};

var lib = {
  uint8ToHex,
  uint8ArrayToHex,
  stringToCharBuffer,
  md5Hash,
  sha1Hash,
  concatBuffers,
  hashToUuid
};

/** Uin8Array with zero items */
var EMPTY_UINT8_ARRAY = new Uint8Array(0);

/**
 * Generates the Name-Based UUID hashes v3 and v5 according to RFC-4122
 * https://tools.ietf.org/html/rfc4122#section-4.3
 * @param {string} target Hashing target
 * @param {string} [namespace] Some name space within which generation occurs
 * @param {3|5} [version=5] Version of UUID. Available versions is 3 and 5
 * according to RFC-4122. The version is responsible for the hashing algorithm:
 * version 3 uses MD5, and version 5 uses SHA-1. Default is 5.
 * @returns {string} UUID
 */
function generateUuid(target, namespace, version) {
  if (typeof target !== 'string') {
    throw TypeError('Value must be string');
  }

  if (typeof namespace === 'number') {
    return generateUuid(target, undefined, namespace);
  }

  if (version == null) {
    return generateUuid(target, namespace, 5);
  }

  if (version !== 3 && version !== 5) {
    throw TypeError('Version of UUID can be only 3 or 5');
  }

  // Parsing target chars
  var charBuffer = lib.stringToCharBuffer(target);

  // TODO: Test namespace for uuid and parse to buffer
  var namespaceCharBuffer = typeof namespace === 'string' ? lib.stringToCharBuffer(namespace) : EMPTY_UINT8_ARRAY;

  // Concatenation two buffers of strings to one
  var buffer = lib.concatBuffers(namespaceCharBuffer, charBuffer);

  // Getting hash
  var hash = version === 3 ? lib.md5Hash(buffer) : lib.sha1Hash(buffer);

  return lib.hashToUuid(hash, version);
}

/**
 * Export module
 */
var src = generateUuid;

// src/internal/dom.ts
var STYLE_ELEMENT_ID = "__twind";
var createStorage = () => {
  const callbacks = [];
  let state = [];
  const invoke = (callback, index) => state[index] = callback(state[index]);
  return {
    init: (callback) => invoke(callback, callbacks.push(callback) - 1),
    reset: (snapshot = []) => {
      [snapshot, state] = [state, snapshot];
      callbacks.forEach(invoke);
      return snapshot;
    }
  };
};
var virtualSheet = () => {
  const storage = createStorage();
  let target;
  storage.init((value = []) => target = value);
  return Object.defineProperties({
    get target() {
      return [...target];
    },
    insert: (rule, index) => target.splice(index, 0, rule)
  }, Object.getOwnPropertyDescriptors(storage));
};
var getStyleTagProperties = (sheet) => ({
  id: STYLE_ELEMENT_ID,
  textContent: (Array.isArray(sheet) ? sheet : sheet.target).join("")
});

/**
 * Check if Chrome.
 *
 * @returns {boolean} True if user is using Chrome.
 */
function isChrome() {
  return /chrome/.test(navigator.userAgent.toLowerCase());
}

/**
 * Create CSSOM sheet.
 *
 * @param {HTMLElement} el HTML element.
 * @returns {object} Twind object.
 */
function cssTw(el) {
  const focus = 'transition ease-in duration-100 focus:outline-none focus-visible:outline-none';
  const sheet = isChrome()
    ? cssomSheet({ target: new CSSStyleSheet() })
    : virtualSheet();
  const { tw } = create({
    sheet,
    theme: {
      colors: {
        transparent: 'transparent',
        current: 'currentColor',
        black: black,
        white: white,
        'blue-gray': blueGray,
        'cool-gray': coolGray,
        gray: gray,
        'true-gray': trueGray,
        'warm-gray': warmGray,
        red: red,
        orange: orange,
        amber: amber,
        yellow: yellow,
        lime: lime,
        green: green,
        emerald: emerald,
        teal: teal,
        cyan: cyan,
        sky: lightBlue,
        blue: blue,
        indigo: indigo,
        violet: violet,
        purple: purple,
        fuchsia: fuchsia,
        pink: pink,
        rose: rose,
      },
    },
    plugins: {
      focus: apply$1 `${focus} focus-visible:shadow-[var(--spx-focus)]`,
      'focus-border': apply$1 `${focus} focus-visible:border-blue-500 focus-visible:shadow-[var(--spx-focus-px)]`,
      'focus-out': apply$1 `${focus} focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus:shadow-none`,
    },
    mode: 'silent',
  });
  if (isChrome()) {
    el.adoptedStyleSheets = [...el.adoptedStyleSheets, sheet.target];
  }
  else {
    setTimeout(() => {
      const string = getStyleTagProperties(sheet).textContent;
      const stringId = src(string);
      if (!el.querySelector(`style[data-tw="${stringId}"]`)) {
        const style = document.createElement('style');
        style.setAttribute('data-tw', stringId);
        style.innerHTML = string;
        el.appendChild(style);
      }
    }, 1);
  }
  return { tw, css: css$1, apply: apply$1 };
}

// eslint-disable-next-line no-unused-vars
/**
 * Button element.
 *
 * @param {object} obj HTML element props.
 * @param {HTMLCollection} children HTML element children.
 * @returns {HTMLElement} Return an HTML element.
 */
function Button(obj, children) {
  const props = {
    onKeyDown: function (e) {
      if (obj.onEnter && (e.key === 'Enter' || e.key === 'enter')) {
        obj.onEnter();
      }
      if (obj.onArrowLeft && e.key === 'ArrowLeft') {
        obj.onArrowLeft();
      }
      if (obj.onArrowRight && e.key === 'ArrowRight') {
        obj.onArrowRight();
      }
    },
  };
  const mergedProps = Object.assign(Object.assign({}, props), obj);
  return obj.href ? (h$4("a", Object.assign({ style: { textAlign: 'left' } }, mergedProps), children)) : obj.as === 'div' ? (h$4("div", Object.assign({ style: { textAlign: 'left' }, role: "button", tabindex: "0" }, mergedProps), children)) : (h$4("button", Object.assign({ style: { textAlign: 'left' } }, mergedProps), children));
}

/**
 * Check if Safari.
 *
 * @param {HTMLElement} node HTML Element to check.
 * @returns {boolean} True if node is inside Shadow DOM.
 */
function isInShadow(node) {
  return node.getRootNode() instanceof ShadowRoot;
}

const tag$n = 'spx-accordion';
const SpxAccordion$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxAccordionDidLoad = createEvent(this, "spxAccordionDidLoad", 7);
    /** Animate the opening of the content. Set to false if Accordion is starting hidden. */
    this.animation = true;
    this.contentColor = 'var(--spx-color-gray-900)';
    /** Content text. */
    this.contentText = 'Default Content Text';
    /** Content text tag. */
    this.contentTextTag = 'span';
    this.contentTransitionDuration = transitionDuration;
    this.contentTransitionTimingFunction = transitionTimingFunction;
    this.display = display$1;
    this.fontSize = fontSize;
    this.fontSizeMax = 1.2;
    this.fontSizeMin = 1;
    /** Space between header and content. */
    this.gap = '0.4em';
    this.gapMax = 1.2;
    this.gapMin = 1;
    this.headerColor = 'var(--spx-color-gray-900)';
    /** Gap between header text and icon. */
    this.headerGap = '0.4em';
    this.headerGapMax = 1;
    this.headerGapMin = 0.6;
    /** Header text. */
    this.headerText = 'Default Header Text';
    /** Header text tag. */
    this.headerTextTag = 'span';
    /** Indicator icon. */
    this.indicatorIcon = 'arrow-down';
    /** Indicator icon type. */
    this.indicatorIconType = 'ionicons';
    /** Indicator icon transform. */
    this.indicatorIconTransform = 'rotate(180deg)';
    /** State of accordion. */
    // eslint-disable-next-line @stencil/decorators-style
    this.openState = false;
    /**
     * Styling.
     *
     * @choice 'default', 'fluid', 'headless'
     */
    this.styling = 'default';
    /** Header is clicked. */
    this.clickHeader = () => {
      /** Handle linked instances. */
      if (this.link) {
        /** Check if element is inside another Shadow DOM. */
        (isInShadow(this.el) ? this.el.getRootNode() : document)
          .querySelectorAll('spx-accordion[link="' + this.link + '"]')
          .forEach((item) => {
          /** Make sure not to toggle current element. */
          if (item !== this.el) {
            if (this.linkType === 'open') {
              item.setAttribute('open', '');
            }
            if (this.linkType === 'close') {
              item.removeAttribute('open');
            }
            if (this.linkType === 'toggle') {
              if (item.hasAttribute('open')) {
                item.removeAttribute('open');
              }
              else {
                item.setAttribute('open', '');
              }
            }
          }
        });
      }
      /** Set the correct heights. */
      if (this.openState) {
        if (!this.disableAnimation) {
          this.content.style.maxHeight = null;
        }
        this.openState = false;
      }
      else {
        if (!this.disableAnimation) {
          this.content.style.maxHeight = this.content.scrollHeight + 'px';
        }
        this.openState = true;
      }
    };
  }
  componentWillLoad() {
    if (this.el.querySelector('[slot="header"]')) {
      this.headerCustom = true;
    }
    if (this.el.querySelector('[slot="content"]')) {
      this.contentCustom = true;
    }
    /** Turn animation off if linked, since height can't be calculated otherwise. */
    if (this.link) {
      this.disableAnimation = true;
    }
    else if (this.animation === false) {
      this.disableAnimation = true;
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.spxAccordionDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  /** Closes the accordion. */
  async close() {
    this.openState = false;
  }
  /** Opens the accordion. */
  async open() {
    this.openState = true;
  }
  /** Toggles the accordion. */
  async toggle() {
    this.openState = !this.openState;
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    const { css } = cssEmotion(this.el.shadowRoot);
    const { tw } = cssTw(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$n, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = (this.styling === 'default' || this.styling === 'fluid') &&
      css({
        fontFamily: fontFamily,
        fontSize: setStyle(tag$n, 'font-size', this.fontSize, this.fontSizeMin, this.fontSizeMax, this.styling),
        display: 'flex',
        flexDirection: 'column',
      });
    /** Header styles. */
    const styleHeader = this.styling === 'default' || this.styling === 'fluid'
      ? css(Object.assign({ display: 'grid', gridAutoFlow: 'column', gridTemplateColumns: this.reverse ? '1fr auto' : 'auto 1fr', alignItems: 'center', justifyItems: 'left', gridColumnGap: setStyle(tag$n, 'header-gap', this.headerGap, this.headerGapMin, this.headerGapMax, this.styling), cursor: 'pointer', transitionProperty: 'box-shadow', transitionDuration: transitionDuration, transitionTimingFunction: transitionTimingFunction, 'h1, h2, h3, h4, h5, h6, p, span': {
          color: setVar(tag$n, 'header-color', this.headerColor),
        }, '*:not([slot])': {
          margin: '0',
        } }, focus))
      : this.openState
        ? tw((_a = this.classHeader) !== null && _a !== void 0 ? _a : '') + ' ' + tw((_b = this.classHeaderActive) !== null && _b !== void 0 ? _b : '')
        : tw((_c = this.classHeader) !== null && _c !== void 0 ? _c : '') + ' ' + tw((_d = this.classHeaderInactive) !== null && _d !== void 0 ? _d : '');
    /** Header custom styles. */
    const styleHeaderIcon = this.styling === 'default' || this.styling === 'fluid'
      ? css({
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transformOrigin: 'center center',
        gridColumn: this.reverse && '2',
        transform: this.openState &&
          setVar(tag$n, 'indicator-icon-transform', this.indicatorIconTransform),
        color: setVar(tag$n, 'header-color', this.headerColor),
      })
      : this.openState
        ? tw((_e = this.classHeaderIcon) !== null && _e !== void 0 ? _e : '') +
          ' ' +
          tw((_f = this.classHeaderIconActive) !== null && _f !== void 0 ? _f : '')
        : tw((_g = this.classHeaderIcon) !== null && _g !== void 0 ? _g : '') +
          ' ' +
          tw((_h = this.classHeaderIconInactive) !== null && _h !== void 0 ? _h : '');
    /** Content styles. */
    const styleContent = this.styling === 'default' || this.styling === 'fluid'
      ? css({
        display: this.disableAnimation && this.openState
          ? 'block'
          : this.disableAnimation && !this.openState && 'none',
        marginTop: this.openState
          ? setStyle(tag$n, 'gap', this.gap, this.gapMin, this.gapMax, this.styling)
          : 0,
        maxHeight: this.disableAnimation ? 'none' : '0',
        overflow: 'hidden',
        height: this.disableAnimation && 'auto',
        transitionProperty: 'max-height, margin-top',
        willChange: 'max-height, margin-top',
        transitionDuration: setVar(tag$n, 'transition-duration', this.contentTransitionDuration),
        transitionTimingFunction: setVar(tag$n, 'transition-timing-function', this.contentTransitionTimingFunction),
        'h1, h2, h3, h4, h5, h6, p, span:not(.token)': {
          color: setVar(tag$n, 'content-color', this.contentColor),
        },
      })
      : this.openState
        ? tw((_j = this.classContent) !== null && _j !== void 0 ? _j : '') + ' ' + tw((_k = this.classContentActive) !== null && _k !== void 0 ? _k : '')
        : tw((_l = this.classContentActive) !== null && _l !== void 0 ? _l : '') +
          ' ' +
          tw((_m = this.classContentInactive) !== null && _m !== void 0 ? _m : '');
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleShadowHost }, h$4(Button, { as: "div", onClick: this.clickHeader, onEnter: this.clickHeader, class: !this.headerCustom ? styleHeader : '', "aria-expanded": this.openState ? 'true' : 'false' }, !this.headerCustom && (h$4("div", { class: styleHeaderIcon }, this.indicatorIcon && this.indicatorIconType && (h$4("spx-icon", { icon: this.indicatorIcon, type: this.indicatorIconType })))), tagSelector(!this.headerCustom, this.headerTextTag, this.headerTextOpen && this.openState
      ? this.headerTextOpen
      : this.headerText, 'header', this.styling === 'headless' && this.openState
      ? tw((_o = this.classHeaderText) !== null && _o !== void 0 ? _o : '') +
        ' ' +
        tw((_p = this.classHeaderTextActive) !== null && _p !== void 0 ? _p : '')
      : this.styling === 'headless' &&
        tw((_q = this.classHeaderText) !== null && _q !== void 0 ? _q : '') +
          ' ' +
          tw((_r = this.classHeaderTextInactive) !== null && _r !== void 0 ? _r : ''))), h$4("div", { class: styleContent, ref: (el) => (this.content = el) }, tagSelector(!this.contentCustom, this.contentTextTag, this.contentText, 'content', this.styling === 'headless' && this.openState
      ? tw((_s = this.classContentText) !== null && _s !== void 0 ? _s : '') +
        ' ' +
        ((_t = this.classContentTextActive) !== null && _t !== void 0 ? _t : '')
      : this.styling === 'headless' &&
        tw((_u = this.classContentText) !== null && _u !== void 0 ? _u : '') +
          ' ' +
          ((_v = this.classContentTextInactive) !== null && _v !== void 0 ? _v : ''))))));
  }
  get el() { return this; }
};

function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*!
 * GSAP 3.7.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum$1 = 1e8,
    _tinyNum = 1 / _bigNum$1,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists$1 = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
    _globalTimeline,
    _win$1,
    _coreInitted,
    _doc$1,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);
  }
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _round(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _round((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    prevIteration = _animationCycle(tween._tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== prevIteration) {
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (!child._dur && child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (!child._dur && child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _round(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum$1 ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value) {
  if (typeof value !== "string") {
    return "";
  }

  var v = _unitExp.exec(value);

  return v ? value.substr(v.index + v[0].length) : "";
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp$1 = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win$1;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc$1).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc$1.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum$1])[1];

      if (!wrapAt) {
        max = -_bigNum$1;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum$1;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum$1;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum$1,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap$1 = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum$1,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    _hue = function _hue(h, m1, m2) {
  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists$1()) {
          _win$1 = _coreInitted = window;
          _doc$1 = _win$1.document || {};
          _globals.gsap = gsap;
          (_win$1.gsapVersions || (_win$1.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win$1.GreenSockGlobals || !_win$1.gsap && _win$1 || {});

          _raf = _win$1.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win$1.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback) {
      _listeners.indexOf(callback) < 0 && _listeners.push(callback);

      _wake();
    },
    remove: function remove(callback) {
      var i;
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose$1(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized$1(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized$1(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum$1;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _round(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum$1,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (parsedStart !== end) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);
    prevStartAt && prevStartAt.render(-1, true).kill();

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        } // if (time > 0) {
        // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        // } else if (dur && !(time < 0 && prevStartAt)) {
        // 	time && (tween._zTime = time);
        // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        // }

      } else if (autoRevert === false) {
        tween._startAt = 0;
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0)); //Also make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose$1(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized$1(_this3);
      tl._start = 0;

      if (keyframes) {
        _setDefaults(tl.vars.defaults, {
          ease: "none"
        });

        stagger ? parsedTargets.forEach(function (t, i) {
          return keyframes.forEach(function (frame, j) {
            return tl.to(t, frame, j ? ">" : i * stagger);
          });
        }) : keyframes.forEach(function (frame) {
          return tl.to(parsedTargets, frame, ">");
        });
      } else {
        l = parsedTargets.length;
        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = {};

          for (p in vars) {
            if (_staggerPropsToSkip.indexOf(p) < 0) {
              copy[p] = vars[p];
            }
          }

          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized$1(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized$1(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized$1(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized$1(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized$1(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized$1(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap$1,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp$1,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.7.1";
_coreReady = 1;
_windowExists$1() && _wake();

/*!
 * CSSPlugin 3.7.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {
    return _round(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = _getCache(parent);
      cache.time = _ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      relative,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  _colorStringFilter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_numWithUnitExp) || [];
  endValues = end.match(_numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: relative ? relative * endNum : endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || _getCache(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = _round(Math.sqrt(a * a + b * b + c * c));
      scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = _round(scaleX);
  cache.scaleY = _round(scaleY);
  cache.rotation = _round(rotation) + deg;
  cache.rotationX = _round(rotationX) + deg;
  cache.rotationY = _round(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = getUnit(start);
  return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = _round(a11);
    a21 = _round(a21);
    a12 = _round(a12);
    a22 = _round(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = _round(tx + xPercent / 100 * temp.width);
    ty = _round(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
  var cap = 360,
      isString = _isString(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = getUnit(startValue);
      endUnit = getUnit(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


_forEachName("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = _replaceRandom(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _colorExp.lastIndex = 0;

        if (!_colorExp.test(startValue)) {
          // colors don't have units
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          p in _config.units && !getUnit(startValue) && (startValue += _config.units[p]); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit) {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], endValue, index, targets);
          } else {
            _missingPlugin(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, endValue);
        }

        props.push(p);
      }
    }

    hasPriority && _sortPropTweensByPriority(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
gsap.utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  _forEachName(rotation, function (name) {
    _config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  _forEachName(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _config.units[name] = "px";
});

gsap.registerPlugin(CSSPlugin);

var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;

const tag$m = 'spx-animate';
const SpxAnimate$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.spxAnimateDidLoad = createEvent(this, "spxAnimateDidLoad", 7);
    /** Delay before animation starts. */
    this.delay = 0;
    this.display = display$1;
    /** Animation duration. */
    this.duration = 1;
    /** Ease being used. Accepts all common GSAP options. */
    this.ease = 'power1.out';
    /** Opacity level the animation starts from. */
    this.opacity = 0;
    /** Amount of time elements should be staggered by. */
    this.stagger = 0.15;
    /** The target element that should be animated inside the component. */
    this.target = '*';
    /** X position the animation starts from. */
    this.x = 0;
    /** Y position the animation starts from. */
    this.y = 0;
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    /** Init loop to make sure the component fires correctly in Oxygen. */
    const init = () => {
      this.elements = this.el.querySelectorAll(this.target);
      if ((this.elements === undefined || this.elements.length === 0) &&
        document.body.classList.contains('oxygen-builder-body')) {
        setTimeout(init, 100);
      }
      else {
        this.tl = gsapWithCSS.timeline({
          defaults: {
            ease: this.ease,
          },
          paused: true,
        });
        const options = {
          clipPath: this.clipPath,
          delay: this.delay,
          duration: this.duration,
          filter: this.filter,
          webkitFilter: this.filter,
          opacity: this.opacity,
          repeat: this.repeat,
          repeatDelay: this.repeatDelay,
          stagger: this.stagger,
          x: this.x,
          y: this.y,
          yoyo: this.yoyo,
          onComplete: () => {
            const el = this.el.parentElement;
            if (this.el.parentElement.tagName === 'SPX-NOTATION') {
              // @ts-ignore
              el.show();
            }
          },
        };
        if (this.reverse) {
          this.tl.to(this.elements, options);
        }
        else {
          this.tl.from(this.elements, options);
        }
        /** Play immediately when not in viewport. */
        if (!this.viewport) {
          this.tl.play();
        }
        /** Check viewport before playing. */
        if (this.viewport) {
          const options = {
            rootMargin: '' +
              '' +
              (this.viewportMarginTop || '0px') +
              ' ' +
              '' +
              (this.viewportMarginRight || '0px') +
              ' ' +
              '' +
              (this.viewportMarginBottom || '0px') +
              ' ' +
              '' +
              (this.viewportMarginLeft || '0px') +
              '',
          };
          const intersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                this.tl.play();
              }
              else {
                if (!this.once) {
                  this.tl.reverse();
                }
              }
            });
          }, options);
          intersectionObserver.observe(this.el);
        }
        this.spxAnimateDidLoad.emit({ target: 'document' });
      }
    };
    init();
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  /**
   * Plays animation.
   *
   * @param {number} from From where to play animation.
   * @param {boolean} suppressEvents Suppress events before playing.
   */
  async play(from = 0, suppressEvents = true) {
    this.tl.play(from, suppressEvents);
  }
  /**
   * Restarts animation.
   *
   * @param {boolean} includeDelay Include delay when restarting.
   * @param {boolean} suppressEvents Suppress events before playing.
   */
  async restart(includeDelay = false, suppressEvents = true) {
    this.tl.restart(includeDelay, suppressEvents);
  }
  render() {
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$m, 'display', this.display),
    });
    return (h$4(Host, { class: styleHost }, h$4("slot", null)));
  }
  get el() { return this; }
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$e.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$e.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$d.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag$1);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$2(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject$2(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$c = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$c.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject$2(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root, 'WeakMap');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject$2(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$1(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$b.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$a.call(object, key) && eq$1(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject$2(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq$1(object[index], value);
  }
  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$a;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$9.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$1 = moduleExports$2 ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag = '[object Function]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    objectTag$3 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag] =
typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] =
typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] =
typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] =
typedArrayTags[weakMapTag$1] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$8.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject$2(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$6.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */
var objectTag$2 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$3 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$3.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/** Used to compose unicode character classes. */
var rsAstralRange$2 = '\\ud800-\\udfff',
    rsComboMarksRange$3 = '\\u0300-\\u036f',
    reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
    rsVarRange$2 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ$2 = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2  + rsComboRange$3 + rsVarRange$2 + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$2 = '\\u0300-\\u036f',
    reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']',
    rsCombo$2 = '[' + rsComboRange$2 + ']',
    rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
    rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
    rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
    rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod$1 = rsModifier$1 + '?',
    rsOptVar$1 = '[' + rsVarRange$1 + ']?',
    rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
    rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;

/** Used to compose unicode capture groups. */
var rsCombo$1 = '[' + rsComboRange$1 + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo$1, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter$1(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$1(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/* Built-in method references that are verified to be native. */
var DataView$1 = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root, 'Set');

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$1 = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag$1 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap$1);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1) ||
    (Map$1 && getTag(new Map$1) != mapTag$1) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$1) ||
    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$1;
        case mapCtorString: return mapTag$1;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$1;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

const getTag$1 = getTag;

/** Built-in value references. */
var Uint8Array$1 = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq$1(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag$1(object),
      othTag = othIsArr ? arrayTag : getTag$1(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$1.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject$2(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq$1(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject$2(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter$1(collection, predicate) {
  var func = isArray(collection) ? arrayFilter$1 : baseFilter;
  return func(collection, baseIteratee(predicate));
}

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate), index);
}

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find$1 = createFind(findIndex);

/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['a', 1], ['b', 2]]);
 * // => { 'a': 1, 'b': 2 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs == null ? 0 : pairs.length,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}

/**
 * The opposite of `_.mapValues`; this method creates an object with the
 * same values as `object` and keys generated by running each own enumerable
 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
 * with three arguments: (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapValues
 * @example
 *
 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
 *   return key + value;
 * });
 * // => { 'a1': 1, 'b2': 2 }
 */
function mapKeys(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, iteratee(value, key, object), value);
  });
  return result;
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function startsWith(string, target, position) {
  string = toString(string);
  position = position == null
    ? 0
    : baseClamp(toInteger(position), 0, string.length);

  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}

/**
 * Wrap element in another element.
 *
 * @param {HTMLElement} el HTML element to wrap.
 * @param {HTMLElement} wrapper HTML element to use as a wrapper.
 */
function wrap(el, wrapper) {
  el.parentNode.insertBefore(wrapper, el);
  wrapper.appendChild(el);
}

/**
 * Insert element before another one.
 *
 * @param {HTMLElement} newNode New node to be inserted.
 * @param {HTMLElement} existingNode Existing node that will be used as reference for new node.
 */
function insertBefore(newNode, existingNode) {
  existingNode.parentNode.insertBefore(newNode, existingNode);
}

/**
 * Slugify string.
 *
 * @param {string} str String to slugify.
 * @returns {string} Slugified string.
 */
function slugify(str) {
  str = str.toString().toLowerCase().trim();
  const sets = [
    { to: 'a', from: '[ÀÁÂÃÄÅÆĀĂĄẠẢẤẦẨẪẬẮẰẲẴẶ]' },
    { to: 'c', from: '[ÇĆĈČ]' },
    { to: 'd', from: '[ÐĎĐÞ]' },
    { to: 'e', from: '[ÈÉÊËĒĔĖĘĚẸẺẼẾỀỂỄỆ]' },
    { to: 'g', from: '[ĜĞĢǴ]' },
    { to: 'h', from: '[ĤḦ]' },
    { to: 'i', from: '[ÌÍÎÏĨĪĮİỈỊ]' },
    { to: 'j', from: '[Ĵ]' },
    { to: 'ij', from: '[Ĳ]' },
    { to: 'k', from: '[Ķ]' },
    { to: 'l', from: '[ĹĻĽŁ]' },
    { to: 'm', from: '[Ḿ]' },
    { to: 'n', from: '[ÑŃŅŇ]' },
    { to: 'o', from: '[ÒÓÔÕÖØŌŎŐỌỎỐỒỔỖỘỚỜỞỠỢǪǬƠ]' },
    { to: 'oe', from: '[Œ]' },
    { to: 'p', from: '[ṕ]' },
    { to: 'r', from: '[ŔŖŘ]' },
    { to: 's', from: '[ßŚŜŞŠ]' },
    { to: 't', from: '[ŢŤ]' },
    { to: 'u', from: '[ÙÚÛÜŨŪŬŮŰŲỤỦỨỪỬỮỰƯ]' },
    { to: 'w', from: '[ẂŴẀẄ]' },
    { to: 'x', from: '[ẍ]' },
    { to: 'y', from: '[ÝŶŸỲỴỶỸ]' },
    { to: 'z', from: '[ŹŻŽ]' },
    { to: '-', from: "[·/_,:;']" },
  ];
  sets.forEach((set) => {
    str = str.replace(new RegExp(set.from, 'gi'), set.to);
  });
  return str
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars
    .replace(/--+/g, '-') // Replace multiple - with single -
    .replace(/^-+/, '') // Trim - from start of text
    .replace(/-+$/, ''); // Trim - from end of text
}

const tag$l = 'spx-block-docs';
const SpxBlockDocs$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.spxDocsDidLoad = createEvent(this, "spxDocsDidLoad", 7);
    this.bpMobile = 1024;
    this.gap = '3em';
    this.contentPaddingYMin = 0;
    this.contentPaddingYMax = 0;
    this.navigationGapMin = 0.2;
    this.navigationGapMax = 0.4;
    this.navigationHeadingTag = 'h1';
    this.navigationLinkFontSizeMax = 1;
    this.navigationLinkFontSizeMin = 0.8;
    this.navigationLinkFontWeight = '500';
    this.navigationLinkLetterSpacing = '0';
    this.navigationLinkLineHeight = '1.25';
    this.navigationLinkTextTransform = 'default';
    this.navigationPaddingYMin = 0;
    this.navigationPaddingYMax = 0;
    this.navigationTitleFontSizeMax = 0.9;
    this.navigationTitleFontSizeMin = 0.8;
    this.navigationTitleFontWeight = '500';
    this.navigationTitleLetterSpacing = '0';
    this.navigationTitleLineHeight = '1.25';
    this.navigationTitleTextTransform = 'uppercase';
    this.navigationTitleMarginBottom = 1;
    this.navigationTitleMarginBottomMin = 1;
    this.navigationTitleMarginBottomMax = 2;
    this.navigationTop = '0';
    this.offsetMarginTop = '';
    /**
     * Styling.
     *
     * @choice 'default', 'fluid'
     */
    this.styling = 'fluid';
    /** Generates the navigation. */
    this.createNavigation = () => {
      if (this.content.innerHTML !== '') {
        /** Create links from IDs. */
        this.content
          .querySelectorAll(this.navigationHeadingTag + ':not([data-spx-docs-no-navigation])')
          .forEach((item, index) => {
          const link = slugify(item.innerHTML);
          const id = this.uniqueId ? link + '-' + index : link;
          const a = document.createElement('a');
          item.setAttribute('data-spx-docs-index', String(index));
          item.setAttribute('id', id);
          a.setAttribute('data-spx-docs-index', String(index));
          a.setAttribute('href', '#' + id);
          a.innerHTML = item.innerHTML;
          this.navigation.appendChild(a);
          wrap(a, document.createElement('li'));
        });
        /** Create headings and separators. */
        this.content
          .querySelectorAll(this.navigationHeadingTag +
          '[data-spx-docs-heading]:not([data-spx-docs-no-navigation])')
          .forEach((item) => {
          const index = item.getAttribute('data-spx-docs-index');
          const span = document.createElement('span');
          const el = this.navigation.querySelector('[data-spx-docs-index="' + index + '"]').parentElement;
          span.innerHTML = item.getAttribute('data-spx-docs-heading');
          this.navigation.insertBefore(span, el);
          if (this.separator && index !== '0') {
            const span = document.createElement(this.separator);
            span.setAttribute('data-spx-docs-separator', '');
            span.setAttribute('data-spx-docs-content', item.getAttribute('data-spx-docs-heading'));
            span.innerHTML = item.getAttribute('data-spx-docs-heading');
            this.content.appendChild(span);
            insertBefore(span, item);
          }
        });
        this.el.querySelector('spx-scrollspy').reload();
      }
    };
  }
  /** Listen to window resize. */
  onResize() {
    this.mobile = window.innerWidth < this.bpMobile;
  }
  componentWillLoad() {
    this.onResize();
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.createNavigation();
    if (window.location.hash) {
      if (document.querySelector(window.location.hash)) {
        document.querySelector(window.location.hash).scrollIntoView();
      }
    }
    this.spxDocsDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    /** Host. */
    const styleHost = css$2({
      display: this.mobile ? 'block' : 'grid',
      gridTemplateColumns: !this.mobile && 'minmax(0, auto) minmax(0, 1fr)',
      gap: setVar(tag$l, 'gap', this.gap),
      gridAutoFlow: 'column',
    });
    const styleNavigationWrap = css$2({
      display: this.mobile ? 'none' : 'block',
      background: setVar(tag$l, 'navigation-background', this.navigationBackground),
    });
    /** Navigation. */
    const styleNavigation = {
      position: 'sticky',
      top: setVar(tag$l, 'navigation-top', this.navigationTop),
      gridAutoRows: 'max-content',
      height: 'calc(100vh - ' + this.navigationTop + ')',
      paddingTop: setStyle(tag$l, 'navigation-padding-y', this.navigationPaddingY, this.navigationPaddingYMin, this.navigationPaddingYMax, this.styling),
      paddingBottom: setStyle(tag$l, 'navigation-padding-y', this.navigationPaddingY, this.navigationPaddingYMin, this.navigationPaddingYMax, this.styling),
      overflowY: 'auto',
      ul: {
        display: 'grid',
        gridGap: setStyle(tag$l, 'navigation-gap', this.navigationGap, this.navigationGapMin, this.navigationGapMax, this.styling),
      },
      a: Object.assign(Object.assign({}, text$1(tag$l, 'navigation-link', this.navigationLinkColor, this.navigationLinkFontSize, this.navigationLinkFontSizeMin, this.navigationLinkFontSizeMax, this.navigationLinkFontWeight, this.navigationLinkLetterSpacing, this.navigationLinkLineHeight, this.navigationLinkTextTransform, this.styling)), { width: 'max-content', transitionProperty: 'color', transitionDuration: setVar(tag$l, 'navigation-transition-duration', transitionDuration), itemTransitionTimingFunction: setVar(tag$l, 'navigation-transition-timing-function', transitionTimingFunction) }),
      li: {
        '&:last-of-type': {
          marginBottom: setStyle(tag$l, 'navigation-padding-y', this.navigationPaddingY, this.navigationPaddingYMin, this.navigationPaddingYMax, this.styling),
        },
        '&.spx-scrollspy__nav--active a': {
          color: setVar(tag$l, 'navigation-link-color-active', this.navigationLinkColorActive),
        },
      },
      span: Object.assign({}, text$1(tag$l, 'navigation-title', this.navigationTitleColor, this.navigationTitleFontSize, this.navigationTitleFontSizeMin, this.navigationTitleFontSizeMax, this.navigationTitleFontWeight, this.navigationTitleLetterSpacing, this.navigationTitleLineHeight, this.navigationTitleTextTransform, this.styling)),
      'li + span': {
        display: 'block',
        marginTop: setStyle(tag$l, 'navigation-title-margin-bottom', this.navigationTitleMarginBottom, this.navigationTitleMarginBottomMin, this.navigationTitleMarginBottomMax, this.styling),
      },
    };
    /** Merge navigation objects to avoid emotion error. */
    const styleNavigationMerge = css$2(merge(styleNavigation, {}));
    /** Content. */
    const styleContent = {
      paddingTop: setVar(tag$l, 'content-padding', setClamp(tag$l, 'padding-y', this.contentPaddingYMin, this.contentPaddingYMax)),
      paddingBottom: setVar(tag$l, 'content-padding', setClamp(tag$l, 'padding-y', this.contentPaddingYMin, this.contentPaddingYMax)),
      '[data-spx-docs-index]:before': {
        display: 'block',
        content: '" "',
        marginTop: 'calc(' +
          setVar(tag$l, 'offset-margin-top', this.offsetMarginTop) +
          ' * -1)',
        height: setVar(tag$l, 'offset-margin-top', this.offsetMarginTop),
        visibility: 'hidden',
      },
      '&:last-child': {
        marginBottom: setClamp(tag$l, 'content-padding-y', this.contentPaddingYMin, this.contentPaddingYMax),
      },
    };
    /** Merge content objects to avoid emotion error. */
    const styleContentMerge = css$2(merge(styleContent, {}));
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleNavigationWrap }, h$4("spx-scrollspy", { display: "grid", "url-change": true, scrolling: this.scrolling, class: styleNavigationMerge }, h$4("ul", { ref: (el) => (this.navigation = el) }))), h$4("div", { ref: (el) => (this.content = el), class: styleContentMerge }, h$4("slot", null))));
  }
  get el() { return this; }
};

const tag$k = 'spx-class-toggle';
const SpxClassToggle$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.spxClassToggleDidLoad = createEvent(this, "spxClassToggleDidLoad", 7);
    this.display = display$1;
    /** List of classes that should be toggled. */
    this.toggle = 'spx-class-toggle--active';
    /** Create an array of classes from the component attribute. */
    this.createToggleArray = () => {
      this.classesArray = this.toggle.replace(/ /g, ',').split(',');
    };
    /** Toggle classes. */
    this.toggleClasses = () => {
      this.classesArray.forEach((item) => {
        (this.target
          ? document.querySelectorAll(this.target)
          : this.el.querySelectorAll('*')).forEach((itemInner) => {
          if (itemInner.classList.contains(item)) {
            itemInner.classList.remove(item);
            if (this.local) {
              localStorage.removeItem(this.local);
            }
          }
          else {
            itemInner.classList.add(item);
            if (this.local) {
              localStorage.setItem(this.local, String(true));
            }
          }
        });
      });
    };
    /** Add classes. */
    this.addClasses = () => {
      this.classesArray.forEach((item) => {
        (this.target
          ? document.querySelectorAll(this.target)
          : this.el.querySelectorAll('*')).forEach((itemInner) => {
          if (itemInner.classList.contains(item)) {
            itemInner.classList.remove(item);
          }
          else {
            itemInner.classList.add(item);
          }
        });
      });
    };
  }
  toggleUpdate() {
    this.createToggleArray();
  }
  componentWillLoad() {
    this.createToggleArray();
    /** Check if local storage is set. */
    if (this.local) {
      if (localStorage.getItem(this.local)) {
        this.addClasses();
      }
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.spxClassToggleDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$k, 'display', this.display),
    });
    return (h$4(Host, { onClick: this.toggleClasses, class: styleHost }, h$4("slot", null)));
  }
  get el() { return this; }
  static get watchers() { return {
    "toggle": ["toggleUpdate"]
  }; }
};

var prism = createCommonjsModule(function (module) {
/* **********************************************
     Begin prism-core.js
********************************************** */

/// <reference lib="WebWorker"/>

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
var Prism = (function (_self) {

	// Private helper vars
	var lang = /\blang(?:uage)?-([\w-]+)\b/i;
	var uniqueId = 0;

	// The grammar object for plaintext
	var plainTextGrammar = {};


	var _ = {
		/**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		manual: _self.Prism && _self.Prism.manual,
		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

		/**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */
		util: {
			encode: function encode(tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, encode(tokens.content), tokens.alias);
				} else if (Array.isArray(tokens)) {
					return tokens.map(encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},

			/**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */
			type: function (o) {
				return Object.prototype.toString.call(o).slice(8, -1);
			},

			/**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},

			/**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */
			clone: function deepClone(o, visited) {
				visited = visited || {};

				var clone; var id;
				switch (_.util.type(o)) {
					case 'Object':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = /** @type {Record<string, any>} */ ({});
						visited[id] = clone;

						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = deepClone(o[key], visited);
							}
						}

						return /** @type {any} */ (clone);

					case 'Array':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = [];
						visited[id] = clone;

						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
							clone[i] = deepClone(v, visited);
						});

						return /** @type {any} */ (clone);

					default:
						return o;
				}
			},

			/**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */
			getLanguage: function (element) {
				while (element && !lang.test(element.className)) {
					element = element.parentElement;
				}
				if (element) {
					return (element.className.match(lang) || [, 'none'])[1].toLowerCase();
				}
				return 'none';
			},

			/**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */
			currentScript: function () {
				if (typeof document === 'undefined') {
					return null;
				}
				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
					return /** @type {any} */ (document.currentScript);
				}

				// IE11 workaround
				// we'll get the src of the current script by parsing IE11's error stack trace
				// this will not work for inline scripts

				try {
					throw new Error();
				} catch (err) {
					// Get file src url from stack. Specifically works with the format of stack traces in IE.
					// A stack will look like this:
					//
					// Error
					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
					//    at Global code (http://localhost/components/prism-core.js:606:1)

					var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];
					if (src) {
						var scripts = document.getElementsByTagName('script');
						for (var i in scripts) {
							if (scripts[i].src == src) {
								return scripts[i];
							}
						}
					}
					return null;
				}
			},

			/**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */
			isActive: function (element, className, defaultActivation) {
				var no = 'no-' + className;

				while (element) {
					var classList = element.classList;
					if (classList.contains(className)) {
						return true;
					}
					if (classList.contains(no)) {
						return false;
					}
					element = element.parentElement;
				}
				return !!defaultActivation;
			}
		},

		/**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		languages: {
			/**
			 * The grammar for plain, unformatted text.
			 */
			plain: plainTextGrammar,
			plaintext: plainTextGrammar,
			text: plainTextGrammar,
			txt: plainTextGrammar,

			/**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);

				for (var key in redef) {
					lang[key] = redef[key];
				}

				return lang;
			},

			/**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || /** @type {any} */ (_.languages);
				var grammar = root[inside];
				/** @type {Grammar} */
				var ret = {};

				for (var token in grammar) {
					if (grammar.hasOwnProperty(token)) {

						if (token == before) {
							for (var newToken in insert) {
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}

						// Do not insert token which also occur in insert. See #1525
						if (!insert.hasOwnProperty(token)) {
							ret[token] = grammar[token];
						}
					}
				}

				var old = root[inside];
				root[inside] = ret;

				// Update references in other language definitions
				_.languages.DFS(_.languages, function (key, value) {
					if (value === old && key != inside) {
						this[key] = ret;
					}
				});

				return ret;
			},

			// Traverse a language definition with Depth First Search
			DFS: function DFS(o, callback, type, visited) {
				visited = visited || {};

				var objId = _.util.objId;

				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);

						var property = o[i];
						var propertyType = _.util.type(property);

						if (propertyType === 'Object' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, null, visited);
						} else if (propertyType === 'Array' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, i, visited);
						}
					}
				}
			}
		},

		plugins: {},

		/**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */
		highlightAll: function (async, callback) {
			_.highlightAllUnder(document, async, callback);
		},

		/**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */
		highlightAllUnder: function (container, async, callback) {
			var env = {
				callback: callback,
				container: container,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};

			_.hooks.run('before-highlightall', env);

			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

			_.hooks.run('before-all-elements-highlight', env);

			for (var i = 0, element; (element = env.elements[i++]);) {
				_.highlightElement(element, async === true, env.callback);
			}
		},

		/**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */
		highlightElement: function (element, async, callback) {
			// Find language
			var language = _.util.getLanguage(element);
			var grammar = _.languages[language];

			// Set language on the element, if not present
			element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

			// Set language on the parent, for styling
			var parent = element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre') {
				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
			}

			var code = element.textContent;

			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};

			function insertHighlightedCode(highlightedCode) {
				env.highlightedCode = highlightedCode;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
			}

			_.hooks.run('before-sanity-check', env);

			// plugins may change/add the parent/element
			parent = env.element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
				parent.setAttribute('tabindex', '0');
			}

			if (!env.code) {
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
				return;
			}

			_.hooks.run('before-highlight', env);

			if (!env.grammar) {
				insertHighlightedCode(_.util.encode(env.code));
				return;
			}

			if (async && _self.Worker) {
				var worker = new Worker(_.filename);

				worker.onmessage = function (evt) {
					insertHighlightedCode(evt.data);
				};

				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			} else {
				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
			}
		},

		/**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */
		highlight: function (text, grammar, language) {
			var env = {
				code: text,
				grammar: grammar,
				language: language
			};
			_.hooks.run('before-tokenize', env);
			env.tokens = _.tokenize(env.code, env.grammar);
			_.hooks.run('after-tokenize', env);
			return Token.stringify(_.util.encode(env.tokens), env.language);
		},

		/**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */
		tokenize: function (text, grammar) {
			var rest = grammar.rest;
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}

				delete grammar.rest;
			}

			var tokenList = new LinkedList();
			addAfter(tokenList, tokenList.head, text);

			matchGrammar(text, tokenList, grammar, tokenList.head, 0);

			return toArray(tokenList);
		},

		/**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		hooks: {
			all: {},

			/**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */
			add: function (name, callback) {
				var hooks = _.hooks.all;

				hooks[name] = hooks[name] || [];

				hooks[name].push(callback);
			},

			/**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */
			run: function (name, env) {
				var callbacks = _.hooks.all[name];

				if (!callbacks || !callbacks.length) {
					return;
				}

				for (var i = 0, callback; (callback = callbacks[i++]);) {
					callback(env);
				}
			}
		},

		Token: Token
	};
	_self.Prism = _;


	// Typescript note:
	// The following can be used to import the Token type in JSDoc:
	//
	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

	/**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */
	function Token(type, content, alias, matchedStr) {
		/**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */
		this.type = type;
		/**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */
		this.content = content;
		/**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || '').length | 0;
	}

	/**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */

	/**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */
	Token.stringify = function stringify(o, language) {
		if (typeof o == 'string') {
			return o;
		}
		if (Array.isArray(o)) {
			var s = '';
			o.forEach(function (e) {
				s += stringify(e, language);
			});
			return s;
		}

		var env = {
			type: o.type,
			content: stringify(o.content, language),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language
		};

		var aliases = o.alias;
		if (aliases) {
			if (Array.isArray(aliases)) {
				Array.prototype.push.apply(env.classes, aliases);
			} else {
				env.classes.push(aliases);
			}
		}

		_.hooks.run('wrap', env);

		var attributes = '';
		for (var name in env.attributes) {
			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}

		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
	};

	/**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */
	function matchPattern(pattern, pos, text, lookbehind) {
		pattern.lastIndex = pos;
		var match = pattern.exec(text);
		if (match && lookbehind && match[1]) {
			// change the match to remove the text matched by the Prism lookbehind group
			var lookbehindLength = match[1].length;
			match.index += lookbehindLength;
			match[0] = match[0].slice(lookbehindLength);
		}
		return match;
	}

	/**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */
	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
		for (var token in grammar) {
			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = Array.isArray(patterns) ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				if (rematch && rematch.cause == token + ',' + j) {
					return;
				}

				var patternObj = patterns[j];
				var inside = patternObj.inside;
				var lookbehind = !!patternObj.lookbehind;
				var greedy = !!patternObj.greedy;
				var alias = patternObj.alias;

				if (greedy && !patternObj.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
				}

				/** @type {RegExp} */
				var pattern = patternObj.pattern || patternObj;

				for ( // iterate the token list and keep track of the current token/string position
					var currentNode = startNode.next, pos = startPos;
					currentNode !== tokenList.tail;
					pos += currentNode.value.length, currentNode = currentNode.next
				) {

					if (rematch && pos >= rematch.reach) {
						break;
					}

					var str = currentNode.value;

					if (tokenList.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						return;
					}

					if (str instanceof Token) {
						continue;
					}

					var removeCount = 1; // this is the to parameter of removeBetween
					var match;

					if (greedy) {
						match = matchPattern(pattern, pos, text, lookbehind);
						if (!match) {
							break;
						}

						var from = match.index;
						var to = match.index + match[0].length;
						var p = pos;

						// find the node that contains the match
						p += currentNode.value.length;
						while (from >= p) {
							currentNode = currentNode.next;
							p += currentNode.value.length;
						}
						// adjust pos (and p)
						p -= currentNode.value.length;
						pos = p;

						// the current node is a Token, then the match starts inside another Token, which is invalid
						if (currentNode.value instanceof Token) {
							continue;
						}

						// find the last node which is affected by this match
						for (
							var k = currentNode;
							k !== tokenList.tail && (p < to || typeof k.value === 'string');
							k = k.next
						) {
							removeCount++;
							p += k.value.length;
						}
						removeCount--;

						// replace with the new match
						str = text.slice(pos, p);
						match.index -= pos;
					} else {
						match = matchPattern(pattern, 0, str, lookbehind);
						if (!match) {
							continue;
						}
					}

					// eslint-disable-next-line no-redeclare
					var from = match.index;
					var matchStr = match[0];
					var before = str.slice(0, from);
					var after = str.slice(from + matchStr.length);

					var reach = pos + str.length;
					if (rematch && reach > rematch.reach) {
						rematch.reach = reach;
					}

					var removeFrom = currentNode.prev;

					if (before) {
						removeFrom = addAfter(tokenList, removeFrom, before);
						pos += before.length;
					}

					removeRange(tokenList, removeFrom, removeCount);

					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
					currentNode = addAfter(tokenList, removeFrom, wrapped);

					if (after) {
						addAfter(tokenList, currentNode, after);
					}

					if (removeCount > 1) {
						// at least one Token object was removed, so we have to do some rematching
						// this can only happen if the current pattern is greedy

						/** @type {RematchOptions} */
						var nestedRematch = {
							cause: token + ',' + j,
							reach: reach
						};
						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

						// the reach might have been extended because of the rematching
						if (rematch && nestedRematch.reach > rematch.reach) {
							rematch.reach = nestedRematch.reach;
						}
					}
				}
			}
		}
	}

	/**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */

	/**
	 * @template T
	 * @private
	 */
	function LinkedList() {
		/** @type {LinkedListNode<T>} */
		var head = { value: null, prev: null, next: null };
		/** @type {LinkedListNode<T>} */
		var tail = { value: null, prev: head, next: null };
		head.next = tail;

		/** @type {LinkedListNode<T>} */
		this.head = head;
		/** @type {LinkedListNode<T>} */
		this.tail = tail;
		this.length = 0;
	}

	/**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */
	function addAfter(list, node, value) {
		// assumes that node != list.tail && values.length >= 0
		var next = node.next;

		var newNode = { value: value, prev: node, next: next };
		node.next = newNode;
		next.prev = newNode;
		list.length++;

		return newNode;
	}
	/**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */
	function removeRange(list, node, count) {
		var next = node.next;
		for (var i = 0; i < count && next !== list.tail; i++) {
			next = next.next;
		}
		node.next = next;
		next.prev = node;
		list.length -= i;
	}
	/**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */
	function toArray(list) {
		var array = [];
		var node = list.head.next;
		while (node !== list.tail) {
			array.push(node.value);
			node = node.next;
		}
		return array;
	}


	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _;
		}

		if (!_.disableWorkerMessageHandler) {
			// In worker
			_self.addEventListener('message', function (evt) {
				var message = JSON.parse(evt.data);
				var lang = message.language;
				var code = message.code;
				var immediateClose = message.immediateClose;

				_self.postMessage(_.highlight(code, _.languages[lang], lang));
				if (immediateClose) {
					_self.close();
				}
			}, false);
		}

		return _;
	}

	// Get current script and highlight
	var script = _.util.currentScript();

	if (script) {
		_.filename = script.src;

		if (script.hasAttribute('data-manual')) {
			_.manual = true;
		}
	}

	function highlightAutomaticallyCallback() {
		if (!_.manual) {
			_.highlightAll();
		}
	}

	if (!_.manual) {
		// If the document state is "loading", then we'll use DOMContentLoaded.
		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
		// might take longer one animation frame to execute which can create a race condition where only some plugins have
		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
		// See https://github.com/PrismJS/prism/issues/2102
		var readyState = document.readyState;
		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
		} else {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(highlightAutomaticallyCallback);
			} else {
				window.setTimeout(highlightAutomaticallyCallback, 16);
			}
		}
	}

	return _;

}(_self));

if (module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof commonjsGlobal !== 'undefined') {
	commonjsGlobal.Prism = Prism;
}

// some additional documentation/types

/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */

/**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */

/**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */

/**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\s\S]*?-->/,
	'prolog': /<\?[\s\S]+?\?>/,
	'doctype': {
		// https://www.w3.org/TR/xml/#NT-doctypedecl
		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: true,
		inside: {
			'internal-subset': {
				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
				lookbehind: true,
				greedy: true,
				inside: null // see below
			},
			'string': {
				pattern: /"[^"]*"|'[^']*'/,
				greedy: true
			},
			'punctuation': /^<!|>$|[[\]]/,
			'doctype-tag': /^DOCTYPE/,
			'name': /[^\s<>'"]+/
		}
	},
	'cdata': /<!\[CDATA\[[\s\S]*?\]\]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: true,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'special-attr': [],
			'attr-value': {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					'punctuation': [
						{
							pattern: /^=/,
							alias: 'attr-equals'
						},
						/"|'/
					]
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': [
		{
			pattern: /&[\da-z]{1,8};/i,
			alias: 'named-entity'
		},
		/&#x?[\da-f]{1,8};/i
	]
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	Prism.languages.markup['entity'];
Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	/**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
	value: function addInlined(tagName, lang) {
		var includedCdataInside = {};
		includedCdataInside['language-' + lang] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism.languages[lang]
		};
		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

		var inside = {
			'included-cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: includedCdataInside
			}
		};
		inside['language-' + lang] = {
			pattern: /[\s\S]+/,
			inside: Prism.languages[lang]
		};

		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
			lookbehind: true,
			greedy: true,
			inside: inside
		};

		Prism.languages.insertBefore('markup', 'cdata', def);
	}
});
Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
	/**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */
	value: function (attrName, lang) {
		Prism.languages.markup.tag.inside['special-attr'].push({
			pattern: RegExp(
				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
				'i'
			),
			lookbehind: true,
			inside: {
				'attr-name': /^[^\s=]+/,
				'attr-value': {
					pattern: /=[\s\S]+/,
					inside: {
						'value': {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: true,
							alias: [lang, 'language-' + lang],
							inside: Prism.languages[lang]
						},
						'punctuation': [
							{
								pattern: /^=/,
								alias: 'attr-equals'
							},
							/"|'/
						]
					}
				}
			}
		});
	}
});

Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.xml = Prism.languages.extend('markup', {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;


/* **********************************************
     Begin prism-css.js
********************************************** */

(function (Prism) {

	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

	Prism.languages.css = {
		'comment': /\/\*[\s\S]*?\*\//,
		'atrule': {
			pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
			inside: {
				'rule': /^@[\w-]+/,
				'selector-function-argument': {
					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: true,
					alias: 'selector'
				},
				'keyword': {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: true
				}
				// See rest below
			}
		},
		'url': {
			// https://drafts.csswg.org/css-values-3/#urls
			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
			greedy: true,
			inside: {
				'function': /^url/i,
				'punctuation': /^\(|\)$/,
				'string': {
					pattern: RegExp('^' + string.source + '$'),
					alias: 'url'
				}
			}
		},
		'selector': {
			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
			lookbehind: true
		},
		'string': {
			pattern: string,
			greedy: true
		},
		'property': {
			pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
			lookbehind: true
		},
		'important': /!important\b/i,
		'function': {
			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
			lookbehind: true
		},
		'punctuation': /[(){};:,]/
	};

	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

	var markup = Prism.languages.markup;
	if (markup) {
		markup.tag.addInlined('style', 'css');
		markup.tag.addAttribute('style', 'css');
	}

}(Prism));


/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			greedy: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}
	],
	'string': {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
		lookbehind: true,
		inside: {
			'punctuation': /[.\\]/
		}
	},
	'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(?:true|false)\b/,
	'function': /\b\w+(?=\()/,
	'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|\})\s*)catch\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		// eslint-disable-next-line regexp/no-dupe-characters-character-class
		pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
		lookbehind: true,
		greedy: true,
		inside: {
			'regex-source': {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: 'language-regex',
				inside: Prism.languages.regex
			},
			'regex-delimiter': /^\/|\/$/,
			'regex-flags': /^[a-z]+$/,
		}
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'hashbang': {
		pattern: /^#!.*/,
		greedy: true,
		alias: 'comment'
	},
	'template-string': {
		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');

	// add attribute support for all DOM events.
	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
	Prism.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
		'javascript'
	);
}

Prism.languages.js = Prism.languages.javascript;


/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {

	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
		return;
	}

	// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
	if (!Element.prototype.matches) {
		Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	}

	var LOADING_MESSAGE = 'Loading…';
	var FAILURE_MESSAGE = function (status, message) {
		return '✖ Error ' + status + ' while fetching file: ' + message;
	};
	var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

	var EXTENSIONS = {
		'js': 'javascript',
		'py': 'python',
		'rb': 'ruby',
		'ps1': 'powershell',
		'psm1': 'powershell',
		'sh': 'bash',
		'bat': 'batch',
		'h': 'c',
		'tex': 'latex'
	};

	var STATUS_ATTR = 'data-src-status';
	var STATUS_LOADING = 'loading';
	var STATUS_LOADED = 'loaded';
	var STATUS_FAILED = 'failed';

	var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
		+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

	var lang = /\blang(?:uage)?-([\w-]+)\b/i;

	/**
	 * Sets the Prism `language-xxxx` or `lang-xxxx` class to the given language.
	 *
	 * @param {HTMLElement} element
	 * @param {string} language
	 * @returns {void}
	 */
	function setLanguageClass(element, language) {
		var className = element.className;
		className = className.replace(lang, ' ') + ' language-' + language;
		element.className = className.replace(/\s+/g, ' ').trim();
	}


	Prism.hooks.add('before-highlightall', function (env) {
		env.selector += ', ' + SELECTOR;
	});

	Prism.hooks.add('before-sanity-check', function (env) {
		var pre = /** @type {HTMLPreElement} */ (env.element);
		if (pre.matches(SELECTOR)) {
			env.code = ''; // fast-path the whole thing and go to complete

			pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

			// add code element with loading message
			var code = pre.appendChild(document.createElement('CODE'));
			code.textContent = LOADING_MESSAGE;

			var src = pre.getAttribute('data-src');

			var language = env.language;
			if (language === 'none') {
				// the language might be 'none' because there is no language set;
				// in this case, we want to use the extension as the language
				var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
				language = EXTENSIONS[extension] || extension;
			}

			// set language classes
			setLanguageClass(code, language);
			setLanguageClass(pre, language);

			// preload the language
			var autoloader = Prism.plugins.autoloader;
			if (autoloader) {
				autoloader.loadLanguages(language);
			}

			// load file
			var xhr = new XMLHttpRequest();
			xhr.open('GET', src, true);
			xhr.onreadystatechange = function () {
				if (xhr.readyState == 4) {
					if (xhr.status < 400 && xhr.responseText) {
						// mark as loaded
						pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

						// highlight code
						code.textContent = xhr.responseText;
						Prism.highlightElement(code);

					} else {
						// mark as failed
						pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

						if (xhr.status >= 400) {
							code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
						} else {
							code.textContent = FAILURE_EMPTY_MESSAGE;
						}
					}
				}
			};
			xhr.send(null);
		}
	});

	Prism.plugins.fileHighlight = {
		/**
		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
		 *
		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
		 *
		 * @param {ParentNode} [container=document]
		 */
		highlight: function highlight(container) {
			var elements = (container || document).querySelectorAll(SELECTOR);

			for (var i = 0, element; (element = elements[i++]);) {
				Prism.highlightElement(element);
			}
		}
	};

	var logged = false;
	/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
	Prism.fileHighlight = function () {
		if (!logged) {
			console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
			logged = true;
		}
		Prism.plugins.fileHighlight.highlight.apply(this, arguments);
	};

}());
});

(function (Prism) {

	/**
	 * Returns the placeholder for the given language id and index.
	 *
	 * @param {string} language
	 * @param {string|number} index
	 * @returns {string}
	 */
	function getPlaceholder(language, index) {
		return '___' + language.toUpperCase() + index + '___';
	}

	Object.defineProperties(Prism.languages['markup-templating'] = {}, {
		buildPlaceholders: {
			/**
			 * Tokenize all inline templating expressions matching `placeholderPattern`.
			 *
			 * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
			 * `true` will be replaced.
			 *
			 * @param {object} env The environment of the `before-tokenize` hook.
			 * @param {string} language The language id.
			 * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
			 * @param {(match: string) => boolean} [replaceFilter]
			 */
			value: function (env, language, placeholderPattern, replaceFilter) {
				if (env.language !== language) {
					return;
				}

				var tokenStack = env.tokenStack = [];

				env.code = env.code.replace(placeholderPattern, function (match) {
					if (typeof replaceFilter === 'function' && !replaceFilter(match)) {
						return match;
					}
					var i = tokenStack.length;
					var placeholder;

					// Check for existing strings
					while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {
						++i;
					}

					// Create a sparse array
					tokenStack[i] = match;

					return placeholder;
				});

				// Switch the grammar to markup
				env.grammar = Prism.languages.markup;
			}
		},
		tokenizePlaceholders: {
			/**
			 * Replace placeholders with proper tokens after tokenizing.
			 *
			 * @param {object} env The environment of the `after-tokenize` hook.
			 * @param {string} language The language id.
			 */
			value: function (env, language) {
				if (env.language !== language || !env.tokenStack) {
					return;
				}

				// Switch the grammar back
				env.grammar = Prism.languages[language];

				var j = 0;
				var keys = Object.keys(env.tokenStack);

				function walkTokens(tokens) {
					for (var i = 0; i < tokens.length; i++) {
						// all placeholders are replaced already
						if (j >= keys.length) {
							break;
						}

						var token = tokens[i];
						if (typeof token === 'string' || (token.content && typeof token.content === 'string')) {
							var k = keys[j];
							var t = env.tokenStack[k];
							var s = typeof token === 'string' ? token : token.content;
							var placeholder = getPlaceholder(language, k);

							var index = s.indexOf(placeholder);
							if (index > -1) {
								++j;

								var before = s.substring(0, index);
								var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);
								var after = s.substring(index + placeholder.length);

								var replacement = [];
								if (before) {
									replacement.push.apply(replacement, walkTokens([before]));
								}
								replacement.push(middle);
								if (after) {
									replacement.push.apply(replacement, walkTokens([after]));
								}

								if (typeof token === 'string') {
									tokens.splice.apply(tokens, [i, 1].concat(replacement));
								} else {
									token.content = replacement;
								}
							}
						} else if (token.content /* && typeof token.content !== 'string' */) {
							walkTokens(token.content);
						}
					}

					return tokens;
				}

				walkTokens(env.tokens);
			}
		}
	});

}(Prism));

/**
 * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
 * Modified by Miles Johnson: http://milesj.me
 * Rewritten by Tom Pavelec
 *
 * Supports PHP 5.3 - 8.0
 */
(function (Prism) {
	var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
	var constant = [
		{
			pattern: /\b(?:false|true)\b/i,
			alias: 'boolean'
		},
		{
			pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
			greedy: true,
			lookbehind: true,
		},
		{
			pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
			greedy: true,
			lookbehind: true,
		},
		/\b(?:null)\b/i,
		/\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/,
	];
	var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
	var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
	var punctuation = /[{}\[\](),:;]/;

	Prism.languages.php = {
		'delimiter': {
			pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
			alias: 'important'
		},
		'comment': comment,
		'variable': /\$+(?:\w+\b|(?=\{))/i,
		'package': {
			pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
			lookbehind: true,
			inside: {
				'punctuation': /\\/
			}
		},
		'class-name-definition': {
			pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
			lookbehind: true,
			alias: 'class-name'
		},
		'function-definition': {
			pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
			lookbehind: true,
			alias: 'function'
		},
		'keyword': [
			{
				pattern: /(\(\s*)\b(?:bool|boolean|int|integer|float|string|object|array)\b(?=\s*\))/i,
				alias: 'type-casting',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /([(,?]\s*)\b(?:bool|int|float|string|object|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b(?=\s*\$)/i,
				alias: 'type-hint',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /([(,?]\s*[\w|]\|\s*)(?:null|false)\b(?=\s*\$)/i,
				alias: 'type-hint',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b/i,
				alias: 'return-type',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?[\w|]\|\s*)(?:null|false)\b/i,
				alias: 'return-type',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|iterable|(?:null|false)(?=\s*\|))\b/i,
				alias: 'type-declaration',
				greedy: true
			},
			{
				pattern: /(\|\s*)(?:null|false)\b/i,
				alias: 'type-declaration',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b(?:parent|self|static)(?=\s*::)/i,
				alias: 'static-context',
				greedy: true
			},
			{
				// yield from
				pattern: /(\byield\s+)from\b/i,
				lookbehind: true
			},
			// `class` is always a keyword unlike other keywords
			/\bclass\b/i,
			{
				// https://www.php.net/manual/en/reserved.keywords.php
				//
				// keywords cannot be preceded by "->"
				// the complex lookbehind means `(?<!(?:->|::)\s*)`
				pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|match|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i,
				lookbehind: true
			}
		],
		'argument-name': {
			pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
			lookbehind: true
		},
		'class-name': [
			{
				pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
				greedy: true
			},
			{
				pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /\b[a-z_]\w*(?=\s*\$)/i,
				alias: 'type-declaration',
				greedy: true
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
				alias: ['class-name-fully-qualified', 'type-declaration'],
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /\b[a-z_]\w*(?=\s*::)/i,
				alias: 'static-context',
				greedy: true
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
				alias: ['class-name-fully-qualified', 'static-context'],
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
				alias: 'type-hint',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
				alias: ['class-name-fully-qualified', 'type-hint'],
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
				alias: 'return-type',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				alias: ['class-name-fully-qualified', 'return-type'],
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			}
		],
		'constant': constant,
		'function': {
			pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
			lookbehind: true,
			inside: {
				'punctuation': /\\/
			}
		},
		'property': {
			pattern: /(->\s*)\w+/,
			lookbehind: true
		},
		'number': number,
		'operator': operator,
		'punctuation': punctuation
	};

	var string_interpolation = {
		pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
		lookbehind: true,
		inside: Prism.languages.php
	};

	var string = [
		{
			pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
			alias: 'nowdoc-string',
			greedy: true,
			inside: {
				'delimiter': {
					pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
					alias: 'symbol',
					inside: {
						'punctuation': /^<<<'?|[';]$/
					}
				}
			}
		},
		{
			pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
			alias: 'heredoc-string',
			greedy: true,
			inside: {
				'delimiter': {
					pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
					alias: 'symbol',
					inside: {
						'punctuation': /^<<<"?|[";]$/
					}
				},
				'interpolation': string_interpolation
			}
		},
		{
			pattern: /`(?:\\[\s\S]|[^\\`])*`/,
			alias: 'backtick-quoted-string',
			greedy: true
		},
		{
			pattern: /'(?:\\[\s\S]|[^\\'])*'/,
			alias: 'single-quoted-string',
			greedy: true
		},
		{
			pattern: /"(?:\\[\s\S]|[^\\"])*"/,
			alias: 'double-quoted-string',
			greedy: true,
			inside: {
				'interpolation': string_interpolation
			}
		}
	];

	Prism.languages.insertBefore('php', 'variable', {
		'string': string,
		'attribute': {
			pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
			greedy: true,
			inside: {
				'attribute-content': {
					pattern: /^(#\[)[\s\S]+(?=\]$)/,
					lookbehind: true,
					// inside can appear subset of php
					inside: {
						'comment': comment,
						'string': string,
						'attribute-class-name': [
							{
								pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
								alias: 'class-name',
								greedy: true,
								lookbehind: true
							},
							{
								pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
								alias: [
									'class-name',
									'class-name-fully-qualified'
								],
								greedy: true,
								lookbehind: true,
								inside: {
									'punctuation': /\\/
								}
							}
						],
						'constant': constant,
						'number': number,
						'operator': operator,
						'punctuation': punctuation
					}
				},
				'delimiter': {
					pattern: /^#\[|\]$/,
					alias: 'punctuation'
				}
			}
		},
	});

	Prism.hooks.add('before-tokenize', function (env) {
		if (!/<\?/.test(env.code)) {
			return;
		}

		var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/gi;
		Prism.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);
	});

	Prism.hooks.add('after-tokenize', function (env) {
		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'php');
	});

}(Prism));

// https://www.json.org/json-en.html
Prism.languages.json = {
	'property': {
		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
		lookbehind: true,
		greedy: true
	},
	'string': {
		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
		lookbehind: true,
		greedy: true
	},
	'comment': {
		pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
		greedy: true
	},
	'number': /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
	'punctuation': /[{}[\],]/,
	'operator': /:/,
	'boolean': /\b(?:true|false)\b/,
	'null': {
		pattern: /\bnull\b/,
		alias: 'keyword'
	}
};

Prism.languages.webmanifest = Prism.languages.json;

Prism.languages.twig = {
	'comment': /\{#[\s\S]*?#\}/,
	'tag': {
		pattern: /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}/,
		inside: {
			'ld': {
				pattern: /^(?:\{\{-?|\{%-?\s*\w+)/,
				inside: {
					'punctuation': /^(?:\{\{|\{%)-?/,
					'keyword': /\w+/
				}
			},
			'rd': {
				pattern: /-?(?:%\}|\}\})$/,
				inside: {
					'punctuation': /.+/
				}
			},
			'string': {
				pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
				inside: {
					'punctuation': /^['"]|['"]$/
				}
			},
			'keyword': /\b(?:even|if|odd)\b/,
			'boolean': /\b(?:true|false|null)\b/,
			'number': /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
			'operator': [
				{
					pattern: /(\s)(?:and|b-and|b-xor|b-or|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
					lookbehind: true
				},
				/[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
			],
			'property': /\b[a-zA-Z_]\w*\b/,
			'punctuation': /[()\[\]{}:.,]/
		}
	},

	// The rest can be parsed as HTML
	'other': {
		// We want non-blank matches
		pattern: /\S(?:[\s\S]*\S)?/,
		inside: Prism.languages.markup
	}
};

createCommonjsModule(function (module) {
(function () {

	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
		return;
	}

	var assign = Object.assign || function (obj1, obj2) {
		for (var name in obj2) {
			if (obj2.hasOwnProperty(name)) {
				obj1[name] = obj2[name];
			}
		}
		return obj1;
	};

	function NormalizeWhitespace(defaults) {
		this.defaults = assign({}, defaults);
	}

	function toCamelCase(value) {
		return value.replace(/-(\w)/g, function (match, firstChar) {
			return firstChar.toUpperCase();
		});
	}

	function tabLen(str) {
		var res = 0;
		for (var i = 0; i < str.length; ++i) {
			if (str.charCodeAt(i) == '\t'.charCodeAt(0)) {
				res += 3;
			}
		}
		return str.length + res;
	}

	NormalizeWhitespace.prototype = {
		setDefaults: function (defaults) {
			this.defaults = assign(this.defaults, defaults);
		},
		normalize: function (input, settings) {
			settings = assign(this.defaults, settings);

			for (var name in settings) {
				var methodName = toCamelCase(name);
				if (name !== 'normalize' && methodName !== 'setDefaults' &&
					settings[name] && this[methodName]) {
					input = this[methodName].call(this, input, settings[name]);
				}
			}

			return input;
		},

		/*
		 * Normalization methods
		 */
		leftTrim: function (input) {
			return input.replace(/^\s+/, '');
		},
		rightTrim: function (input) {
			return input.replace(/\s+$/, '');
		},
		tabsToSpaces: function (input, spaces) {
			spaces = spaces|0 || 4;
			return input.replace(/\t/g, new Array(++spaces).join(' '));
		},
		spacesToTabs: function (input, spaces) {
			spaces = spaces|0 || 4;
			return input.replace(RegExp(' {' + spaces + '}', 'g'), '\t');
		},
		removeTrailing: function (input) {
			return input.replace(/\s*?$/gm, '');
		},
		// Support for deprecated plugin remove-initial-line-feed
		removeInitialLineFeed: function (input) {
			return input.replace(/^(?:\r?\n|\r)/, '');
		},
		removeIndent: function (input) {
			var indents = input.match(/^[^\S\n\r]*(?=\S)/gm);

			if (!indents || !indents[0].length) {
				return input;
			}

			indents.sort(function (a, b) { return a.length - b.length; });

			if (!indents[0].length) {
				return input;
			}

			return input.replace(RegExp('^' + indents[0], 'gm'), '');
		},
		indent: function (input, tabs) {
			return input.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++tabs).join('\t') + '$&');
		},
		breakLines: function (input, characters) {
			characters = (characters === true) ? 80 : characters|0 || 80;

			var lines = input.split('\n');
			for (var i = 0; i < lines.length; ++i) {
				if (tabLen(lines[i]) <= characters) {
					continue;
				}

				var line = lines[i].split(/(\s+)/g);
				var len = 0;

				for (var j = 0; j < line.length; ++j) {
					var tl = tabLen(line[j]);
					len += tl;
					if (len > characters) {
						line[j] = '\n' + line[j];
						len = tl;
					}
				}
				lines[i] = line.join('');
			}
			return lines.join('\n');
		}
	};

	// Support node modules
	if (module.exports) {
		module.exports = NormalizeWhitespace;
	}

	// Exit if prism is not loaded
	if (typeof Prism === 'undefined') {
		return;
	}

	Prism.plugins.NormalizeWhitespace = new NormalizeWhitespace({
		'remove-trailing': true,
		'remove-indent': true,
		'left-trim': true,
		'right-trim': true,
		/*'break-lines': 80,
		'indent': 2,
		'remove-initial-line-feed': false,
		'tabs-to-spaces': 4,
		'spaces-to-tabs': 4*/
	});

	Prism.hooks.add('before-sanity-check', function (env) {
		var Normalizer = Prism.plugins.NormalizeWhitespace;

		// Check settings
		if (env.settings && env.settings['whitespace-normalization'] === false) {
			return;
		}

		// Check classes
		if (!Prism.util.isActive(env.element, 'whitespace-normalization', true)) {
			return;
		}

		// Simple mode if there is no env.element
		if ((!env.element || !env.element.parentNode) && env.code) {
			env.code = Normalizer.normalize(env.code, env.settings);
			return;
		}

		// Normal mode
		var pre = env.element.parentNode;
		if (!env.code || !pre || pre.nodeName.toLowerCase() !== 'pre') {
			return;
		}

		var children = pre.childNodes;
		var before = '';
		var after = '';
		var codeFound = false;

		// Move surrounding whitespace from the <pre> tag into the <code> tag
		for (var i = 0; i < children.length; ++i) {
			var node = children[i];

			if (node == env.element) {
				codeFound = true;
			} else if (node.nodeName === '#text') {
				if (codeFound) {
					after += node.nodeValue;
				} else {
					before += node.nodeValue;
				}

				pre.removeChild(node);
				--i;
			}
		}

		if (!env.element.children.length || !Prism.plugins.KeepMarkup) {
			env.code = before + env.code + after;
			env.code = Normalizer.normalize(env.code, env.settings);
		} else {
			// Preserve markup for keep-markup plugin
			var html = before + env.element.innerHTML + after;
			env.element.innerHTML = Normalizer.normalize(html, env.settings);
			env.code = env.element.textContent;
		}
	});

}());
});

var clipboard = createCommonjsModule(function (module, exports) {
/*!
 * clipboard.js v2.0.8
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(commonjsGlobal, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 134:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ clipboard; }
});

// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
var tiny_emitter = __webpack_require__(279);
var tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);
// EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
var listen = __webpack_require__(370);
var listen_default = /*#__PURE__*/__webpack_require__.n(listen);
// EXTERNAL MODULE: ./node_modules/select/src/select.js
var src_select = __webpack_require__(817);
var select_default = /*#__PURE__*/__webpack_require__.n(src_select);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Inner class which performs selection from either `text` or `target`
 * properties and then executes copy or cut operations.
 */

var ClipboardAction = /*#__PURE__*/function () {
  /**
   * @param {Object} options
   */
  function ClipboardAction(options) {
    _classCallCheck(this, ClipboardAction);

    this.resolveOptions(options);
    this.initSelection();
  }
  /**
   * Defines base properties passed from constructor.
   * @param {Object} options
   */


  _createClass(ClipboardAction, [{
    key: "resolveOptions",
    value: function resolveOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.action = options.action;
      this.container = options.container;
      this.emitter = options.emitter;
      this.target = options.target;
      this.text = options.text;
      this.trigger = options.trigger;
      this.selectedText = '';
    }
    /**
     * Decides which selection strategy is going to be applied based
     * on the existence of `text` and `target` properties.
     */

  }, {
    key: "initSelection",
    value: function initSelection() {
      if (this.text) {
        this.selectFake();
      } else if (this.target) {
        this.selectTarget();
      }
    }
    /**
     * Creates a fake textarea element, sets its value from `text` property,
     */

  }, {
    key: "createFakeElement",
    value: function createFakeElement() {
      var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
      this.fakeElem = document.createElement('textarea'); // Prevent zooming on iOS

      this.fakeElem.style.fontSize = '12pt'; // Reset box model

      this.fakeElem.style.border = '0';
      this.fakeElem.style.padding = '0';
      this.fakeElem.style.margin = '0'; // Move element out of screen horizontally

      this.fakeElem.style.position = 'absolute';
      this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      this.fakeElem.style.top = "".concat(yPosition, "px");
      this.fakeElem.setAttribute('readonly', '');
      this.fakeElem.value = this.text;
      return this.fakeElem;
    }
    /**
     * Get's the value of fakeElem,
     * and makes a selection on it.
     */

  }, {
    key: "selectFake",
    value: function selectFake() {
      var _this = this;

      var fakeElem = this.createFakeElement();

      this.fakeHandlerCallback = function () {
        return _this.removeFake();
      };

      this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;
      this.container.appendChild(fakeElem);
      this.selectedText = select_default()(fakeElem);
      this.copyText();
      this.removeFake();
    }
    /**
     * Only removes the fake element after another click event, that way
     * a user can hit `Ctrl+C` to copy because selection still exists.
     */

  }, {
    key: "removeFake",
    value: function removeFake() {
      if (this.fakeHandler) {
        this.container.removeEventListener('click', this.fakeHandlerCallback);
        this.fakeHandler = null;
        this.fakeHandlerCallback = null;
      }

      if (this.fakeElem) {
        this.container.removeChild(this.fakeElem);
        this.fakeElem = null;
      }
    }
    /**
     * Selects the content from element passed on `target` property.
     */

  }, {
    key: "selectTarget",
    value: function selectTarget() {
      this.selectedText = select_default()(this.target);
      this.copyText();
    }
    /**
     * Executes the copy operation based on the current selection.
     */

  }, {
    key: "copyText",
    value: function copyText() {
      var succeeded;

      try {
        succeeded = document.execCommand(this.action);
      } catch (err) {
        succeeded = false;
      }

      this.handleResult(succeeded);
    }
    /**
     * Fires an event based on the copy operation result.
     * @param {Boolean} succeeded
     */

  }, {
    key: "handleResult",
    value: function handleResult(succeeded) {
      this.emitter.emit(succeeded ? 'success' : 'error', {
        action: this.action,
        text: this.selectedText,
        trigger: this.trigger,
        clearSelection: this.clearSelection.bind(this)
      });
    }
    /**
     * Moves focus away from `target` and back to the trigger, removes current selection.
     */

  }, {
    key: "clearSelection",
    value: function clearSelection() {
      if (this.trigger) {
        this.trigger.focus();
      }

      document.activeElement.blur();
      window.getSelection().removeAllRanges();
    }
    /**
     * Sets the `action` to be performed which can be either 'copy' or 'cut'.
     * @param {String} action
     */

  }, {
    key: "destroy",

    /**
     * Destroy lifecycle.
     */
    value: function destroy() {
      this.removeFake();
    }
  }, {
    key: "action",
    set: function set() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';
      this._action = action;

      if (this._action !== 'copy' && this._action !== 'cut') {
        throw new Error('Invalid "action" value, use either "copy" or "cut"');
      }
    }
    /**
     * Gets the `action` property.
     * @return {String}
     */
    ,
    get: function get() {
      return this._action;
    }
    /**
     * Sets the `target` property using an element
     * that will be have its content copied.
     * @param {Element} target
     */

  }, {
    key: "target",
    set: function set(target) {
      if (target !== undefined) {
        if (target && _typeof(target) === 'object' && target.nodeType === 1) {
          if (this.action === 'copy' && target.hasAttribute('disabled')) {
            throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
          }

          if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
            throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
          }

          this._target = target;
        } else {
          throw new Error('Invalid "target" value, use a valid Element');
        }
      }
    }
    /**
     * Gets the `target` property.
     * @return {String|HTMLElement}
     */
    ,
    get: function get() {
      return this._target;
    }
  }]);

  return ClipboardAction;
}();

/* harmony default export */ var clipboard_action = (ClipboardAction);
function clipboard_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { clipboard_typeof = function _typeof(obj) { return typeof obj; }; } else { clipboard_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return clipboard_typeof(obj); }

function clipboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function clipboard_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function clipboard_createClass(Constructor, protoProps, staticProps) { if (protoProps) clipboard_defineProperties(Constructor.prototype, protoProps); if (staticProps) clipboard_defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




/**
 * Helper function to retrieve attribute value.
 * @param {String} suffix
 * @param {Element} element
 */

function getAttributeValue(suffix, element) {
  var attribute = "data-clipboard-".concat(suffix);

  if (!element.hasAttribute(attribute)) {
    return;
  }

  return element.getAttribute(attribute);
}
/**
 * Base class which takes one or more elements, adds event listeners to them,
 * and instantiates a new `ClipboardAction` on each click.
 */


var Clipboard = /*#__PURE__*/function (_Emitter) {
  _inherits(Clipboard, _Emitter);

  var _super = _createSuper(Clipboard);

  /**
   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
   * @param {Object} options
   */
  function Clipboard(trigger, options) {
    var _this;

    clipboard_classCallCheck(this, Clipboard);

    _this = _super.call(this);

    _this.resolveOptions(options);

    _this.listenClick(trigger);

    return _this;
  }
  /**
   * Defines if attributes would be resolved using internal setter functions
   * or custom functions that were passed in the constructor.
   * @param {Object} options
   */


  clipboard_createClass(Clipboard, [{
    key: "resolveOptions",
    value: function resolveOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
      this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
      this.text = typeof options.text === 'function' ? options.text : this.defaultText;
      this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
    }
    /**
     * Adds a click event listener to the passed trigger.
     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
     */

  }, {
    key: "listenClick",
    value: function listenClick(trigger) {
      var _this2 = this;

      this.listener = listen_default()(trigger, 'click', function (e) {
        return _this2.onClick(e);
      });
    }
    /**
     * Defines a new `ClipboardAction` on each click event.
     * @param {Event} e
     */

  }, {
    key: "onClick",
    value: function onClick(e) {
      var trigger = e.delegateTarget || e.currentTarget;

      if (this.clipboardAction) {
        this.clipboardAction = null;
      }

      this.clipboardAction = new clipboard_action({
        action: this.action(trigger),
        target: this.target(trigger),
        text: this.text(trigger),
        container: this.container,
        trigger: trigger,
        emitter: this
      });
    }
    /**
     * Default `action` lookup function.
     * @param {Element} trigger
     */

  }, {
    key: "defaultAction",
    value: function defaultAction(trigger) {
      return getAttributeValue('action', trigger);
    }
    /**
     * Default `target` lookup function.
     * @param {Element} trigger
     */

  }, {
    key: "defaultTarget",
    value: function defaultTarget(trigger) {
      var selector = getAttributeValue('target', trigger);

      if (selector) {
        return document.querySelector(selector);
      }
    }
    /**
     * Returns the support of the given action, or all actions if no action is
     * given.
     * @param {String} [action]
     */

  }, {
    key: "defaultText",

    /**
     * Default `text` lookup function.
     * @param {Element} trigger
     */
    value: function defaultText(trigger) {
      return getAttributeValue('text', trigger);
    }
    /**
     * Destroy lifecycle.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.listener.destroy();

      if (this.clipboardAction) {
        this.clipboardAction.destroy();
        this.clipboardAction = null;
      }
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];
      var actions = typeof action === 'string' ? [action] : action;
      var support = !!document.queryCommandSupported;
      actions.forEach(function (action) {
        support = support && !!document.queryCommandSupported(action);
      });
      return support;
    }
  }]);

  return Clipboard;
}((tiny_emitter_default()));

/* harmony default export */ var clipboard = (Clipboard);

/***/ }),

/***/ 828:
/***/ (function(module) {

var DOCUMENT_NODE_TYPE = 9;

/**
 * A polyfill for Element.matches()
 */
if (typeof Element !== 'undefined' && !Element.prototype.matches) {
    var proto = Element.prototype;

    proto.matches = proto.matchesSelector ||
                    proto.mozMatchesSelector ||
                    proto.msMatchesSelector ||
                    proto.oMatchesSelector ||
                    proto.webkitMatchesSelector;
}

/**
 * Finds the closest parent that matches a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @return {Function}
 */
function closest (element, selector) {
    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
        if (typeof element.matches === 'function' &&
            element.matches(selector)) {
          return element;
        }
        element = element.parentNode;
    }
}

module.exports = closest;


/***/ }),

/***/ 438:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var closest = __webpack_require__(828);

/**
 * Delegates event to a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function _delegate(element, selector, type, callback, useCapture) {
    var listenerFn = listener.apply(this, arguments);

    element.addEventListener(type, listenerFn, useCapture);

    return {
        destroy: function() {
            element.removeEventListener(type, listenerFn, useCapture);
        }
    }
}

/**
 * Delegates event to a selector.
 *
 * @param {Element|String|Array} [elements]
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function delegate(elements, selector, type, callback, useCapture) {
    // Handle the regular Element usage
    if (typeof elements.addEventListener === 'function') {
        return _delegate.apply(null, arguments);
    }

    // Handle Element-less usage, it defaults to global delegation
    if (typeof type === 'function') {
        // Use `document` as the first parameter, then apply arguments
        // This is a short way to .unshift `arguments` without running into deoptimizations
        return _delegate.bind(null, document).apply(null, arguments);
    }

    // Handle Selector-based usage
    if (typeof elements === 'string') {
        elements = document.querySelectorAll(elements);
    }

    // Handle Array-like based usage
    return Array.prototype.map.call(elements, function (element) {
        return _delegate(element, selector, type, callback, useCapture);
    });
}

/**
 * Finds closest match and invokes callback.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Function}
 */
function listener(element, selector, type, callback) {
    return function(e) {
        e.delegateTarget = closest(e.target, selector);

        if (e.delegateTarget) {
            callback.call(element, e);
        }
    }
}

module.exports = delegate;


/***/ }),

/***/ 879:
/***/ (function(__unused_webpack_module, exports) {

/**
 * Check if argument is a HTML element.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.node = function(value) {
    return value !== undefined
        && value instanceof HTMLElement
        && value.nodeType === 1;
};

/**
 * Check if argument is a list of HTML elements.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.nodeList = function(value) {
    var type = Object.prototype.toString.call(value);

    return value !== undefined
        && (type === '[object NodeList]' || type === '[object HTMLCollection]')
        && ('length' in value)
        && (value.length === 0 || exports.node(value[0]));
};

/**
 * Check if argument is a string.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.string = function(value) {
    return typeof value === 'string'
        || value instanceof String;
};

/**
 * Check if argument is a function.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.fn = function(value) {
    var type = Object.prototype.toString.call(value);

    return type === '[object Function]';
};


/***/ }),

/***/ 370:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var is = __webpack_require__(879);
var delegate = __webpack_require__(438);

/**
 * Validates all params and calls the right
 * listener function based on its target type.
 *
 * @param {String|HTMLElement|HTMLCollection|NodeList} target
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listen(target, type, callback) {
    if (!target && !type && !callback) {
        throw new Error('Missing required arguments');
    }

    if (!is.string(type)) {
        throw new TypeError('Second argument must be a String');
    }

    if (!is.fn(callback)) {
        throw new TypeError('Third argument must be a Function');
    }

    if (is.node(target)) {
        return listenNode(target, type, callback);
    }
    else if (is.nodeList(target)) {
        return listenNodeList(target, type, callback);
    }
    else if (is.string(target)) {
        return listenSelector(target, type, callback);
    }
    else {
        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
    }
}

/**
 * Adds an event listener to a HTML element
 * and returns a remove listener function.
 *
 * @param {HTMLElement} node
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNode(node, type, callback) {
    node.addEventListener(type, callback);

    return {
        destroy: function() {
            node.removeEventListener(type, callback);
        }
    }
}

/**
 * Add an event listener to a list of HTML elements
 * and returns a remove listener function.
 *
 * @param {NodeList|HTMLCollection} nodeList
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNodeList(nodeList, type, callback) {
    Array.prototype.forEach.call(nodeList, function(node) {
        node.addEventListener(type, callback);
    });

    return {
        destroy: function() {
            Array.prototype.forEach.call(nodeList, function(node) {
                node.removeEventListener(type, callback);
            });
        }
    }
}

/**
 * Add an event listener to a selector
 * and returns a remove listener function.
 *
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenSelector(selector, type, callback) {
    return delegate(document.body, selector, type, callback);
}

module.exports = listen;


/***/ }),

/***/ 817:
/***/ (function(module) {

function select(element) {
    var selectedText;

    if (element.nodeName === 'SELECT') {
        element.focus();

        selectedText = element.value;
    }
    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
        var isReadOnly = element.hasAttribute('readonly');

        if (!isReadOnly) {
            element.setAttribute('readonly', '');
        }

        element.select();
        element.setSelectionRange(0, element.value.length);

        if (!isReadOnly) {
            element.removeAttribute('readonly');
        }

        selectedText = element.value;
    }
    else {
        if (element.hasAttribute('contenteditable')) {
            element.focus();
        }

        var selection = window.getSelection();
        var range = document.createRange();

        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);

        selectedText = selection.toString();
    }

    return selectedText;
}

module.exports = select;


/***/ }),

/***/ 279:
/***/ (function(module) {

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;
module.exports.TinyEmitter = E;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); };
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(134);
/******/ })()
.default;
});
});

const Clipboard = /*@__PURE__*/getDefaultExportFromCjs(clipboard);

/**
 * Check if component is in view.
 *
 * @param {HTMLElement} el HTML element to watch.
 * @param {Function} functionToRun Callback to run once element is in view.
 */
function intersectionObserver(el, functionToRun) {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.intersectionRatio > 0) {
        functionToRun();
        observer.unobserve(el);
      }
    });
  });
  observer.observe(el);
}

var purify = createCommonjsModule(function (module, exports) {
/*! @license DOMPurify 2.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.0/LICENSE */

(function (global, factory) {
  module.exports = factory() ;
}(commonjsGlobal, function () {
  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var hasOwnProperty = Object.hasOwnProperty,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);

  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);

  var regExpTest = unapply(RegExp.prototype.test);

  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create(null);

    var property = void 0;
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }

  /* IE10 doesn't support __lookupGetter__ so lets'
   * simulate it. It also automatically checks
   * if the prop is function or getter and behaves
   * accordingly. */
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

  // SVG
  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

  var text = freeze(['#text']);

  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };

  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';
    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '2.3.0';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;

      return DOMPurify;
    }

    var originalDocument = window.document;

    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        Text = window.Text,
        Comment = window.Comment,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;


    var ElementPrototype = Element.prototype;

    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;


    var documentMode = {};
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
        ERB_EXPR$$1 = ERB_EXPR,
        DATA_ATTR$$1 = DATA_ATTR,
        ARIA_ATTR$$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    var RETURN_DOM_FRAGMENT = false;

    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
     * `Node` is imported into the current `Document`. If this flag is not enabled the
     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
     * DOMPurify.
     *
     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
     * might cause XSS from attacks hidden in closed shadowroots in case the browser
     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
     */
    var RETURN_DOM_IMPORT = true;

    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    var RETURN_TRUSTED_TYPE = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    var IN_PLACE = false;

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {};

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }

      /* Shield configuration object from tampering */
      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
        cfg = {};
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);

      /* Set configuration parameters */
      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html);
          addToSet(ALLOWED_ATTR, html$1);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl);
          addToSet(ALLOWED_ATTR, mathMl$1);
          addToSet(ALLOWED_ATTR, xml);
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */
    var ALL_SVG_TAGS = addToSet({}, svg);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);

    var ALL_MATHML_TAGS = addToSet({}, mathMl);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */
    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element);

      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        }

        // The only way to switch from MathML to SVG is via
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }

        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        }

        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        }

        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erronously deleted from
        // HTML namespace.
        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
      }

      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG or MathML). Return false just in case.
      return false;
    };

    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_) {
          node.remove();
        }
      }
    };

    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name);

      // We void attribute values for unremovable "is"" attributes
      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };

    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0;
      var leadingWhitespace = void 0;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
        } catch (_) {}
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }

      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };

    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };

    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */
    var _isClobbered = function _isClobbered(elm) {
      if (elm instanceof Text || elm instanceof Comment) {
        return false;
      }

      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {
        return true;
      }

      return false;
    };

    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0;

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null);

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Now let's check the element's type and name */
      var tagName = stringToLowerCase(currentNode.nodeName);

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });

      /* Detect mXSS attempts abusing namespace confusion */
      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);
        return true;
      }

      /* Check whether element has a valid namespace */
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
        content = stringReplace(content, ERB_EXPR$$1, ' ');
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };

    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }

      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        return false;

        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var l = void 0;
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;

        value = stringTrim(attr.value);
        lcName = stringToLowerCase(name);

        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }

        /* Remove attribute */
        _removeAttribute(name, currentNode);

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }

        /* Work around a security issue in jQuery 3.0 */
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
          value = stringReplace(value, ERB_EXPR$$1, ' ');
        }

        /* Is `value` valid for this attribute? */
        var lcTag = currentNode.nodeName.toLowerCase();
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue;
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode);
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }

      /* Clean up removed elements */
      DOMPurify.removed = [];

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) ; else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty);

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : emptyHTML;
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;

      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (RETURN_DOM_IMPORT) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };

    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };

    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };

    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = stringToLowerCase(tag);
      var lcName = stringToLowerCase(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };

    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };

    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     */
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };

    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };

    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */
    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));
//# sourceMappingURL=purify.js.map
});

/**
 * Sanitize content.
 *
 * @param {string} content Content to be sanitized.
 * @returns {string} Sanitized content.
 */
function sanitize(content) {
  return purify.sanitize(content);
}

const tag$j = 'spx-code';
const SpxCode$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxCodeDidLoad = createEvent(this, "spxCodeDidLoad", 7);
    this.background = 'var(--spx-color-gray-900)';
    this.borderRadius = borderRadius;
    /** Enable clipboard button. */
    this.clipboard = true;
    this.clipboardButtonBackground = 'var(--spx-color-gray-800)';
    this.clipboardButtonColor = 'var(--spx-color-gray-400)';
    this.clipboardButtonFontSize = '12px';
    this.clipboardButtonFontWeight = '600';
    this.clipboardButtonPadding = '6px 12px';
    this.clipboardButtonText = 'Copy';
    this.clipboardButtonTextCopied = 'Copied!';
    this.clipboardButtonTextTransform = 'uppercase';
    this.display = display$1;
    this.fontSize = 'clamp(12px, 1.6vw, 16px)';
    this.height = 'auto';
    /** Enable line numbers. */
    this.lineNumbers = true;
    this.lineNumbersBackground = 'var(--spx-color-gray-800)';
    this.lineNumbersColor = 'var(--spx-color-gray-400)';
    this.maxWidth = '100%';
    this.overflow = 'auto';
    this.padding = 'clamp(20px, 2.4vw, 40px)';
    /** Hide scrollbar. */
    this.scrollbar = true;
    /**
     * Colour theme.
     *
     * @choice 'default', 'dracula'
     */
    this.theme = 'default';
    /**
     * Determines the programming language.
     *
     * @choice 'markup', 'css', 'js', 'php', 'twig', 'json'
     */
    this.type = 'markup';
    /** Removes all whitespace from the top of the code block. */
    this.whitespaceLeftTrim = true;
    /** If the whole code block is indented too much it removes the extra indent. */
    this.whitespaceRemoveIndent = true;
    /** Removes trailing whitespace on all lines. */
    this.whitespaceRemoveTrailing = true;
    /** Removes all whitespace from the bottom of the code block. */
    this.whitespaceRightTrim = true;
    this.onClickClipboard = () => {
      /** Copy the code to the data-attribute and change button text. */
      this.clipboardButton.setAttribute('data-clipboard-text', this.text);
      this.clipboardButton.innerText = this.clipboardButtonTextCopied;
      setTimeout(() => {
        this.clipboardButton.innerText = this.clipboardButtonText;
      }, 5000);
    };
    this.highlightCode = () => {
      var _a;
      const nw = prism.plugins.NormalizeWhitespace;
      let content = (_a = this.content) !== null && _a !== void 0 ? _a : this.el.textContent;
      content = nw.normalize(content, {
        'remove-trailing': this.whitespaceRemoveTrailing,
        'remove-indent': this.whitespaceRemoveIndent,
        'left-trim': this.whitespaceLeftTrim,
        'right-trim': this.whitespaceRightTrim,
      });
      this.text = content;
      this.contentInner = prism.highlight(content, prism.languages[this.type], this.type);
      const length = (this.contentInner.match(/\n/g) || '').length + 1;
      this.contentInner +=
        `<span aria-hidden="true" class="line-numbers-rows">${Array.from({ length: length }, () => '<span></span>')}`.replaceAll(',', '');
    };
  }
  toggleUpdate() {
    this.highlightCode();
  }
  componentWillLoad() {
    /** Highlight code. */
    if (this.lazy) {
      intersectionObserver(this.el, this.highlightCode);
    }
    else {
      this.highlightCode();
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el, cb: this.highlightCode });
    /** Setup clipboard button. */
    if (this.clipboard) {
      // eslint-disable-next-line no-new
      new Clipboard(this.clipboardButton);
    }
    this.spxCodeDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$j, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = {
      position: 'relative',
      borderRadius: setVar(tag$j, 'border-radius', this.borderRadius),
      maxWidth: setVar(tag$j, 'max-width', this.maxWidth),
      height: setVar(tag$j, 'height', this.height),
      'pre, code': {
        borderRadius: setVar(tag$j, 'border-radius', this.borderRadius),
        padding: '0',
        margin: '0',
        display: 'block',
        position: 'relative',
        fontFamily: "Consolas, Monaco, 'Andale Mono', monospace !important",
        height: setVar(tag$j, 'height', this.height),
      },
      pre: {
        overflow: setVar(tag$j, 'overflow', this.overflow),
        background: setVar(tag$j, 'background', this.background) + '!important',
        padding: setVar(tag$j, 'padding', this.padding),
        msOverflowStyle: !this.scrollbar ? 'none' : 'auto',
        scrollbarWidth: !this.scrollbar ? 'none' : 'auto',
        '::-webkit-scrollbar': {
          display: !this.scrollbar && 'none',
        },
        color: '#a9b7c6',
        textAlign: 'left',
        whiteSpace: 'pre',
        wordSpacing: 'normal',
        wordBreak: 'normal',
        lineHeight: '1.5',
        tabSize: '4',
        hyphens: 'none',
        display: 'flex',
        '&:before': {
          minWidth: setVar(tag$j, 'padding', this.padding),
          height: '100%',
        },
      },
      code: {
        filter: setVar(tag$j, 'filter', this.filter),
        fontSize: setVar(tag$j, 'font-size', this.fontSize),
        '*': {
          fontSize: setVar(tag$j, 'font-size', this.fontSize),
        },
      },
      '.line-numbers': {
        paddingLeft: '5.2rem',
        counterReset: this.lineNumbersStart
          ? `linenumber ${this.lineNumbersStart - 1}`
          : 'linenumber',
      },
      '.line-numbers-rows': {
        top: 'calc(' + setVar(tag$j, 'padding', this.padding) + ' * -1)',
        paddingTop: setVar(tag$j, 'padding', this.padding),
        height: 'calc(' + setVar(tag$j, 'padding', this.padding) + ' + 100%)',
        background: setVar(tag$j, 'line-numbers-background', this.lineNumbersBackground),
        position: 'absolute',
        pointerEvents: 'none',
        fontSize: '100%',
        left: '-5.2rem',
        zIndex: 0,
        width: '3.5em',
        letterSpacing: '-1px',
        userSelect: 'none',
        '& > span': {
          display: 'block',
          counterIncrement: 'linenumber',
          zIndex: 0,
          '&:before': {
            content: 'counter(linenumber)',
            display: 'block',
            paddingRight: '1.2em',
            textAlign: 'right',
            color: setVar(tag$j, 'line-numbers-color', this.lineNumbersColor),
          },
        },
      },
    };
    /** Clipboard styles. */
    const styleClipboard = css(Object.assign({ position: 'absolute', border: 'none', right: 0, top: 0, cursor: 'pointer', textTransform: setVar(tag$j, 'clipboard-button-text-transform', this.clipboardButtonTextTransform), background: setVar(tag$j, 'clipboard-button-background', this.clipboardButtonBackground), color: setVar(tag$j, 'clipboard-button-color', this.clipboardButtonColor), padding: setVar(tag$j, 'clipboard-button-padding', this.clipboardButtonPadding), fontSize: setVar(tag$j, 'clipboard-button-font-size', this.clipboardButtonFontSize), fontWeight: setVar(tag$j, 'clipboard-button-font-weight', this.clipboardButtonFontWeight), borderBottomLeftRadius: setVar(tag$j, 'border-radius', this.borderRadius), borderTopRightRadius: setVar(tag$j, 'border-radius', this.borderRadius), transitionProperty: 'box-shadow', transitionDuration: transitionDuration, transitionTimingFunction: transitionTimingFunction }, focus));
    /** Theme: Default. */
    const styleThemeDefault = {
      '.token.comment, token.prolog, .token.cdata': { color: '#808080' },
      '.token.delimiter, .token.boolean, .token.keyword, .token.selector, .token.important, .token.atrule': {
        color: '#cc7832',
      },
      '.token.operator, .token.punctuation, .token.attr-name': {
        color: '#a9b7c6',
      },
      '.token.tag, .token.tag .punctuation, .token.doctype, .token.builtin': {
        color: '#e8bf6a',
      },
      '.token.entity, .token.number, .token.symbol': { color: '#6897bb' },
      '.token.property, .token.constant, .token.variable': {
        color: '#9876aa',
      },
      '.token.string, .token.char': { color: '#6a8759' },
      '.token.attr-value, .token.attr-value .punctuation': {
        color: '#a5c261',
      },
      '.token.attr-value .punctuation:first-child': { color: '#a9b7c6' },
      '.token.url': { color: '#287bde', textDecoration: 'underline' },
      '.token.function': { color: '#ffc66d' },
      '.token.regex': { background: '#364135' },
      '.token.bold': { fontWeight: 'bold' },
      '.token.italic': { fontStyle: 'italic' },
      '.token.inserted': { background: '#294436' },
      '.token.deleted': { background: '#484a4a' },
      'code.language-css .token.property, code.language-css .token.property + .token.punctuation': {
        color: '#a9b7c6',
      },
      'code.language-css .token.id': { color: '#ffc66d' },
      'code.language-css .token.selector > .token.class, code.language-css .token.selector > .token.attribute, code.language-css .token.selector > .token.pseudo-class, code.language-css .token.selector > .token.pseudo-element': {
        color: '#ffc66d',
      },
    };
    /** Theme: Dracula. */
    const styleThemeDracula = {
      '.language-css': { color: '#bd93f9' },
      '.token': { color: '#ff79c6' },
      '.language-css .token': { color: '#ff79c6' },
      '.token.script': { color: '#f8f8f2' },
      '.token.bold': { fontWeight: 'bold' },
      '.token.italic': { fontStyle: 'italic' },
      '.token.atrule, .token.attr-name, .token.attr-value': {
        color: '#50fa7b',
      },
      '.language-css .token.atrule': { color: '#bd93f9' },
      '.language-html .token.attr-value, .language-markup .token.attr-value': {
        color: '#f1fa8c',
      },
      '.token.boolean': { color: '#bd93f9' },
      '.token.builtin, .token.class-name': { color: '#8be9fd' },
      '.token.comment': { color: '#6272a4' },
      '.token.constant': { color: '#bd93f9' },
      '.language-javascript .token.constant': {
        color: '#ffb86c',
        fontStyle: 'italic',
      },
      '.token.entity': { color: '#ff79c6' },
      '.language-css .token.entity': { color: '#50fa7b' },
      '.language-html .token.entity.named-entity': { color: '#bd93f9' },
      '.language-html .token.entity:not(.named-entity)': { color: '#ff79c6' },
      '.language-markup .token.entity.named-entity': { color: '#bd93f9' },
      '.language-markup .token.entity:not(.named-entity)': { color: '#ff79c6' },
      '.token.function': { color: '#50fa7b' },
      '.language-css .token.function': { color: '#8be9fd' },
      '.token.important, .token.keyword': { color: '#ff79c6' },
      '.token.prolog': { color: '#f8f8f2' },
      '.token.property': { color: '#ffb86c' },
      '.language-css .token.property': { color: '#8be9fd' },
      '.token.punctuation': { color: '#ff79c6' },
      '.language-css .token.punctuation': { color: '#ffb86c' },
      '.language-html .token.punctuation, .language-markup .token.punctuation': {
        color: '#f8f8f2',
      },
      '.token.selector': { color: '#ff79c6' },
      '.language-css .token.selector': { color: '#50fa7b' },
      '.token.regex': { color: '#ff5555' },
      '.language-css .token.rule:not(.atrule)': { color: '#f8f8f2' },
      '.token.string': { color: '#f1fa8c' },
      '.token.tag': { color: '#ff79c6' },
      '.token.url': { color: '#8be9fd' },
      '.language-css .token.url': { color: '#ffb86c' },
      '.token.variable': { color: '#6272a4' },
      '.token.number': { color: 'rgba(189, 147, 249, 1)' },
      '.token.operator': { color: 'rgba(139, 233, 253, 1)' },
      '.token.char': { color: 'rgba(255, 135, 157, 1)' },
      '.token.symbol': { color: 'rgba(255, 184, 108, 1)' },
      '.token.deleted': { color: '#e2777a' },
      '.token.namespace': { color: '#e2777a' },
    };
    /** Merged object. */
    const styleMergedObject = css(merge(styleShadowHost, this.theme === 'dracula' ? styleThemeDracula : styleThemeDefault));
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleMergedObject }, h$4("pre", { tabindex: "-1", class: this.lineNumbers && 'line-numbers' }, h$4("code", { tabindex: "-1", class: 'language-' + this.type, innerHTML: sanitize(this.contentInner) })), this.clipboard && (h$4(Button, { as: "button", ref: (el) => (this.clipboardButton = el), class: styleClipboard, onClick: this.onClickClipboard, onEnter: this.onClickClipboard }, this.clipboardButtonText)))));
  }
  get el() { return this; }
  static get watchers() { return {
    "content": ["toggleUpdate"]
  }; }
};

/*!
 * iro.js v5.5.2
 * 2016-2021 James Daniel
 * Licensed under MPL 2.0
 * github.com/jaames/iro.js
 */

var n$3,u$3,t$3,i$3,r$3,f$3={},e$3=[],c$3=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;function s$3(n,l){for(var u in l){ n[u]=l[u]; }return n}function a$3(n){var l=n.parentNode;l&&l.removeChild(n);}function h$3(n,l,u){var t,i,r,o,f=arguments;if(l=s$3({},l),arguments.length>3){ for(u=[u],t=3;t<arguments.length;t++){ u.push(f[t]); } }if(null!=u&&(l.children=u),null!=n&&null!=n.defaultProps){ for(i in n.defaultProps){ void 0===l[i]&&(l[i]=n.defaultProps[i]); } }return o=l.key,null!=(r=l.ref)&&delete l.ref,null!=o&&delete l.key,v$2(n,l,o,r)}function v$2(l,u,t,i){var r={type:l,props:u,key:t,ref:i,__k:null,__p:null,__b:0,__e:null,l:null,__c:null,constructor:void 0};return n$3.vnode&&n$3.vnode(r),r}function d$3(n){return n.children}function y$2(n){if(null==n||"boolean"==typeof n){ return null; }if("string"==typeof n||"number"==typeof n){ return v$2(null,n,null,null); }if(null!=n.__e||null!=n.__c){var l=v$2(n.type,n.props,n.key,null);return l.__e=n.__e,l}return n}function m$3(n,l){this.props=n,this.context=l;}function w$2(n,l){if(null==l){ return n.__p?w$2(n.__p,n.__p.__k.indexOf(n)+1):null; }for(var u;l<n.__k.length;l++){ if(null!=(u=n.__k[l])&&null!=u.__e){ return u.__e; } }return "function"==typeof n.type?w$2(n):null}function g$3(n){var l,u;if(null!=(n=n.__p)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++){ if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break} }return g$3(n)}}function k$2(l){(!l.__d&&(l.__d=!0)&&1===u$3.push(l)||i$3!==n$3.debounceRendering)&&(i$3=n$3.debounceRendering,(n$3.debounceRendering||t$3)(_$3));}function _$3(){var n,l,t,i,r,o,f,e;for(u$3.sort(function(n,l){return l.__v.__b-n.__v.__b});n=u$3.pop();){ n.__d&&(t=void 0,i=void 0,o=(r=(l=n).__v).__e,f=l.__P,e=l.u,l.u=!1,f&&(t=[],i=$$3(f,r,s$3({},r),l.__n,void 0!==f.ownerSVGElement,null,t,e,null==o?w$2(r):o),j$2(t,r),i!=o&&g$3(r))); }}function b$2(n,l,u,t,i,r,o,c,s){var h,v,p,d,y,m,g,k=u&&u.__k||e$3,_=k.length;if(c==f$3&&(c=null!=r?r[0]:_?w$2(u,0):null),h=0,l.__k=x$2(l.__k,function(u){if(null!=u){if(u.__p=l,u.__b=l.__b+1,null===(p=k[h])||p&&u.key==p.key&&u.type===p.type){ k[h]=void 0; }else { for(v=0;v<_;v++){if((p=k[v])&&u.key==p.key&&u.type===p.type){k[v]=void 0;break}p=null;} }if(d=$$3(n,u,p=p||f$3,t,i,r,o,null,c,s),(v=u.ref)&&p.ref!=v&&(g||(g=[])).push(v,u.__c||d,u),null!=d){if(null==m&&(m=d),null!=u.l){ d=u.l,u.l=null; }else if(r==p||d!=c||null==d.parentNode){n:if(null==c||c.parentNode!==n){ n.appendChild(d); }else {for(y=c,v=0;(y=y.nextSibling)&&v<_;v+=2){ if(y==d){ break n; } }n.insertBefore(d,c);}"option"==l.type&&(n.value="");}c=d.nextSibling,"function"==typeof l.type&&(l.l=d);}}return h++,u}),l.__e=m,null!=r&&"function"!=typeof l.type){ for(h=r.length;h--;){ null!=r[h]&&a$3(r[h]); } }for(h=_;h--;){ null!=k[h]&&D$2(k[h],k[h]); }if(g){ for(h=0;h<g.length;h++){ A$2(g[h],g[++h],g[++h]); } }}function x$2(n,l,u){if(null==u&&(u=[]),null==n||"boolean"==typeof n){ l&&u.push(l(null)); }else if(Array.isArray(n)){ for(var t=0;t<n.length;t++){ x$2(n[t],l,u); } }else { u.push(l?l(y$2(n)):n); }return u}function C$2(n,l,u,t,i){var r;for(r in u){ r in l||N$2(n,r,null,u[r],t); }for(r in l){ i&&"function"!=typeof l[r]||"value"===r||"checked"===r||u[r]===l[r]||N$2(n,r,l[r],u[r],t); }}function P$2(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]="number"==typeof u&&!1===c$3.test(l)?u+"px":null==u?"":u;}function N$2(n,l,u,t,i){var r,o,f,e,c;if("key"===(l=i?"className"===l?"class":l:"class"===l?"className":l)||"children"===l);else if("style"===l){ if(r=n.style,"string"==typeof u){ r.cssText=u; }else {if("string"==typeof t&&(r.cssText="",t=null),t){ for(o in t){ u&&o in u||P$2(r,o,""); } }if(u){ for(f in u){ t&&u[f]===t[f]||P$2(r,f,u[f]); } }} }else { "o"===l[0]&&"n"===l[1]?(e=l!==(l=l.replace(/Capture$/,"")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(t||n.addEventListener(l,T$2,e),(n.t||(n.t={}))[l]=u):n.removeEventListener(l,T$2,e)):"list"!==l&&"tagName"!==l&&"form"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/^xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u?n.removeAttribute(l):n.setAttribute(l,u)); }}function T$2(l){return this.t[l.type](n$3.event?n$3.event(l):l)}function $$3(l,u,t,i,r,o,f,e,c,a){var h,v,p,y,w,g,k,_,C,P,N=u.type;if(void 0!==u.constructor){ return null; }(h=n$3.__b)&&h(u);try{n:if("function"==typeof N){if(_=u.props,C=(h=N.contextType)&&i[h.__c],P=h?C?C.props.value:h.__p:i,t.__c?k=(v=u.__c=t.__c).__p=v.__E:("prototype"in N&&N.prototype.render?u.__c=v=new N(_,P):(u.__c=v=new m$3(_,P),v.constructor=N,v.render=H$2),C&&C.sub(v),v.props=_,v.state||(v.state={}),v.context=P,v.__n=i,p=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=N.getDerivedStateFromProps&&s$3(v.__s==v.state?v.__s=s$3({},v.__s):v.__s,N.getDerivedStateFromProps(_,v.__s)),p){ null==N.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&f.push(v); }else {if(null==N.getDerivedStateFromProps&&null==e&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(_,P),!e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(_,v.__s,P)){for(v.props=_,v.state=v.__s,v.__d=!1,v.__v=u,u.__e=null!=c?c!==t.__e?c:t.__e:null,u.__k=t.__k,h=0;h<u.__k.length;h++){ u.__k[h]&&(u.__k[h].__p=u); }break n}null!=v.componentWillUpdate&&v.componentWillUpdate(_,v.__s,P);}for(y=v.props,w=v.state,v.context=P,v.props=_,v.state=v.__s,(h=n$3.__r)&&h(u),v.__d=!1,v.__v=u,v.__P=l,h=v.render(v.props,v.state,v.context),u.__k=x$2(null!=h&&h.type==d$3&&null==h.key?h.props.children:h),null!=v.getChildContext&&(i=s$3(s$3({},i),v.getChildContext())),p||null==v.getSnapshotBeforeUpdate||(g=v.getSnapshotBeforeUpdate(y,w)),b$2(l,u,t,i,r,o,f,c,a),v.base=u.__e;h=v.__h.pop();){ v.__s&&(v.state=v.__s),h.call(v); }p||null==y||null==v.componentDidUpdate||v.componentDidUpdate(y,w,g),k&&(v.__E=v.__p=null);}else { u.__e=z$2(t.__e,u,t,i,r,o,f,a); }(h=n$3.diffed)&&h(u);}catch(l){n$3.__e(l,u,t);}return u.__e}function j$2(l,u){for(var t;t=l.pop();){ try{t.componentDidMount();}catch(l){n$3.__e(l,t.__v);} }n$3.__c&&n$3.__c(u);}function z$2(n,l,u,t,i,r,o,c){var s,a,h,v,p=u.props,d=l.props;if(i="svg"===l.type||i,null==n&&null!=r){ for(s=0;s<r.length;s++){ if(null!=(a=r[s])&&(null===l.type?3===a.nodeType:a.localName===l.type)){n=a,r[s]=null;break} } }if(null==n){if(null===l.type){ return document.createTextNode(d); }n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type),r=null;}return null===l.type?p!==d&&(null!=r&&(r[r.indexOf(n)]=null),n.data=d):l!==u&&(null!=r&&(r=e$3.slice.call(n.childNodes)),h=(p=u.props||f$3).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,c||(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||"")),C$2(n,d,p,i,c),l.__k=l.props.children,v||b$2(n,l,u,t,"foreignObject"!==l.type&&i,r,o,f$3,c),c||("value"in d&&void 0!==d.value&&d.value!==n.value&&(n.value=null==d.value?"":d.value),"checked"in d&&void 0!==d.checked&&d.checked!==n.checked&&(n.checked=d.checked))),n}function A$2(l,u,t){try{"function"==typeof l?l(u):l.current=u;}catch(l){n$3.__e(l,t);}}function D$2(l,u,t){var i,r,o;if(n$3.unmount&&n$3.unmount(l),(i=l.ref)&&A$2(i,null,u),t||"function"==typeof l.type||(t=null!=(r=l.__e)),l.__e=l.l=null,null!=(i=l.__c)){if(i.componentWillUnmount){ try{i.componentWillUnmount();}catch(l){n$3.__e(l,u);} }i.base=i.__P=null;}if(i=l.__k){ for(o=0;o<i.length;o++){ i[o]&&D$2(i[o],u,t); } }null!=r&&a$3(r);}function H$2(n,l,u){return this.constructor(n,u)}function I$2(l,u,t){var i,o,c;n$3.__p&&n$3.__p(l,u),o=(i=t===r$3)?null:t&&t.__k||u.__k,l=h$3(d$3,null,[l]),c=[],$$3(u,i?u.__k=l:(t||u).__k=l,o||f$3,f$3,void 0!==u.ownerSVGElement,t&&!i?[t]:o?null:e$3.slice.call(u.childNodes),c,!1,t||f$3,i),j$2(c,l);}n$3={},m$3.prototype.setState=function(n,l){var u=this.__s!==this.state&&this.__s||(this.__s=s$3({},this.state));("function"!=typeof n||(n=n(u,this.props)))&&s$3(u,n),null!=n&&this.__v&&(this.u=!1,l&&this.__h.push(l),k$2(this));},m$3.prototype.forceUpdate=function(n){this.__v&&(n&&this.__h.push(n),this.u=!0,k$2(this));},m$3.prototype.render=d$3,u$3=[],t$3="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,i$3=n$3.debounceRendering,n$3.__e=function(n,l,u){for(var t;l=l.__p;){ if((t=l.__c)&&!t.__p){ try{if(t.constructor&&null!=t.constructor.getDerivedStateFromError){ t.setState(t.constructor.getDerivedStateFromError(n)); }else {if(null==t.componentDidCatch){ continue; }t.componentDidCatch(n);}return k$2(t.__E=t)}catch(l){n=l;} } }throw n},r$3=f$3,0;

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) { descriptor.writable = true; }
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) { _defineProperties$1(Constructor.prototype, protoProps); }
  if (staticProps) { _defineProperties$1(Constructor, staticProps); }
  return Constructor;
}

function _extends$8() {
  _extends$8 = Object.assign || function (target) {
    var arguments$1 = arguments;

    for (var i = 1; i < arguments.length; i++) {
      var source = arguments$1[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$8.apply(this, arguments);
}

// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor
// https://github.com/bgrins/TinyColor
// Kelvin temperature math borrowed from Neil Barlett's implementation
// from https://github.com/neilbartlett/color-temperature
// https://www.w3.org/TR/css3-values/#integers
var CSS_INTEGER = '[-\\+]?\\d+%?'; // http://www.w3.org/TR/css3-values/#number-value

var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?'; // Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome

var CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')'; // Parse function params
// Parens and commas are optional, and this also allows for whitespace between numbers

var PERMISSIVE_MATCH_3 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
var PERMISSIVE_MATCH_4 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?'; // Regex patterns for functional color strings

var REGEX_FUNCTIONAL_RGB = new RegExp('rgb' + PERMISSIVE_MATCH_3);
var REGEX_FUNCTIONAL_RGBA = new RegExp('rgba' + PERMISSIVE_MATCH_4);
var REGEX_FUNCTIONAL_HSL = new RegExp('hsl' + PERMISSIVE_MATCH_3);
var REGEX_FUNCTIONAL_HSLA = new RegExp('hsla' + PERMISSIVE_MATCH_4); // Color string parsing regex

var HEX_START = '^(?:#?|0x?)';
var HEX_INT_SINGLE = '([0-9a-fA-F]{1})';
var HEX_INT_DOUBLE = '([0-9a-fA-F]{2})';
var REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');
var REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');
var REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');
var REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$'); // Kelvin temperature bounds

var KELVIN_MIN = 2000;
var KELVIN_MAX = 40000; // Math shorthands

var log = Math.log,
    round$1 = Math.round,
    floor = Math.floor;
/**
 * @desc Clamp a number between a min and max value
 * @param num - input value
 * @param min - min allowed value
 * @param max - max allowed value
 */

function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
/**
 * @desc Parse a css unit string - either regular int or a percentage number
 * @param str - css unit string
 * @param max - max unit value, used for calculating percentages
 */


function parseUnit(str, max) {
  var isPercentage = str.indexOf('%') > -1;
  var num = parseFloat(str);
  return isPercentage ? max / 100 * num : num;
}
/**
 * @desc Parse hex str to an int
 * @param str - hex string to parse
 */


function parseHexInt(str) {
  return parseInt(str, 16);
}
/**
 * @desc Convert nunber into to 2-digit hex
 * @param int - number to convert
 */


function intToHex(_int) {
  return _int.toString(16).padStart(2, '0');
}

var IroColor =
/*#__PURE__*/
function () {
  /**
    * @constructor Color object
    * @param value - initial color value
  */
  function IroColor(value, onChange) {
    // The default Color value
    this.$ = {
      h: 0,
      s: 0,
      v: 0,
      a: 1
    };
    if (value) { this.set(value); } // The watch callback function for this Color will be stored here

    this.onChange = onChange;
    this.initialValue = _extends$8({}, this.$); // copy initial value
  }
  /**
    * @desc Set the Color from any valid value
    * @param value - new color value
  */


  var _proto = IroColor.prototype;

  _proto.set = function set(value) {
    if (typeof value === 'string') {
      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value)) {
        this.hexString = value;
      } else if (/^rgba?/.test(value)) {
        this.rgbString = value;
      } else if (/^hsla?/.test(value)) {
        this.hslString = value;
      }
    } else if (typeof value === 'object') {
      if (value instanceof IroColor) {
        this.hsva = value.hsva;
      } else if ('r' in value && 'g' in value && 'b' in value) {
        this.rgb = value;
      } else if ('h' in value && 's' in value && 'v' in value) {
        this.hsv = value;
      } else if ('h' in value && 's' in value && 'l' in value) {
        this.hsl = value;
      } else if ('kelvin' in value) {
        this.kelvin = value.kelvin;
      }
    } else {
      throw new Error('Invalid color value');
    }
  }
  /**
    * @desc Shortcut to set a specific channel value
    * @param format - hsv | hsl | rgb
    * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l
    * @param value - new value for the channel
  */
  ;

  _proto.setChannel = function setChannel(format, channel, value) {
    var _extends2;

    this[format] = _extends$8({}, this[format], (_extends2 = {}, _extends2[channel] = value, _extends2));
  }
  /**
   * @desc Reset color back to its initial value
   */
  ;

  _proto.reset = function reset() {
    this.hsva = this.initialValue;
  }
  /**
    * @desc make new Color instance with the same value as this one
  */
  ;

  _proto.clone = function clone() {
    return new IroColor(this);
  }
  /**
   * @desc remove color onChange
   */
  ;

  _proto.unbind = function unbind() {
    this.onChange = undefined;
  }
  /**
    * @desc Convert hsv object to rgb
    * @param hsv - hsv color object
  */
  ;

  IroColor.hsvToRgb = function hsvToRgb(hsv) {
    var h = hsv.h / 60;
    var s = hsv.s / 100;
    var v = hsv.v / 100;
    var i = floor(h);
    var f = h - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var mod = i % 6;
    var r = [v, q, p, p, t, v][mod];
    var g = [t, v, v, q, p, p][mod];
    var b = [p, p, t, v, v, q][mod];
    return {
      r: clamp(r * 255, 0, 255),
      g: clamp(g * 255, 0, 255),
      b: clamp(b * 255, 0, 255)
    };
  }
  /**
    * @desc Convert rgb object to hsv
    * @param rgb - rgb object
  */
  ;

  IroColor.rgbToHsv = function rgbToHsv(rgb) {
    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var delta = max - min;
    var hue = 0;
    var value = max;
    var saturation = max === 0 ? 0 : delta / max;

    switch (max) {
      case min:
        hue = 0; // achromatic

        break;

      case r:
        hue = (g - b) / delta + (g < b ? 6 : 0);
        break;

      case g:
        hue = (b - r) / delta + 2;
        break;

      case b:
        hue = (r - g) / delta + 4;
        break;
    }

    return {
      h: hue * 60 % 360,
      s: clamp(saturation * 100, 0, 100),
      v: clamp(value * 100, 0, 100)
    };
  }
  /**
    * @desc Convert hsv object to hsl
    * @param hsv - hsv object
  */
  ;

  IroColor.hsvToHsl = function hsvToHsl(hsv) {
    var s = hsv.s / 100;
    var v = hsv.v / 100;
    var l = (2 - s) * v;
    var divisor = l <= 1 ? l : 2 - l; // Avoid division by zero when lightness is close to zero

    var saturation = divisor < 1e-9 ? 0 : s * v / divisor;
    return {
      h: hsv.h,
      s: clamp(saturation * 100, 0, 100),
      l: clamp(l * 50, 0, 100)
    };
  }
  /**
    * @desc Convert hsl object to hsv
    * @param hsl - hsl object
  */
  ;

  IroColor.hslToHsv = function hslToHsv(hsl) {
    var l = hsl.l * 2;
    var s = hsl.s * (l <= 100 ? l : 200 - l) / 100; // Avoid division by zero when l + s is near 0

    var saturation = l + s < 1e-9 ? 0 : 2 * s / (l + s);
    return {
      h: hsl.h,
      s: clamp(saturation * 100, 0, 100),
      v: clamp((l + s) / 2, 0, 100)
    };
  }
  /**
    * @desc Convert a kelvin temperature to an approx, RGB value
    * @param kelvin - kelvin temperature
  */
  ;

  IroColor.kelvinToRgb = function kelvinToRgb(kelvin) {
    var temp = kelvin / 100;
    var r, g, b;

    if (temp < 66) {
      r = 255;
      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);
      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);
    } else {
      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);
      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);
      b = 255;
    }

    return {
      r: clamp(floor(r), 0, 255),
      g: clamp(floor(g), 0, 255),
      b: clamp(floor(b), 0, 255)
    };
  }
  /**
   * @desc Convert an RGB color to an approximate kelvin temperature
   * @param kelvin - kelvin temperature
  */
  ;

  IroColor.rgbToKelvin = function rgbToKelvin(rgb) {
    var r = rgb.r,
        b = rgb.b;
    var eps = 0.4;
    var minTemp = KELVIN_MIN;
    var maxTemp = KELVIN_MAX;
    var temp;

    while (maxTemp - minTemp > eps) {
      temp = (maxTemp + minTemp) * 0.5;

      var _rgb = IroColor.kelvinToRgb(temp);

      if (_rgb.b / _rgb.r >= b / r) {
        maxTemp = temp;
      } else {
        minTemp = temp;
      }
    }

    return temp;
  };

  _createClass$1(IroColor, [{
    key: "hsv",
    get: function get() {
      // value is cloned to allow changes to be made to the values before passing them back
      var value = this.$;
      return {
        h: value.h,
        s: value.s,
        v: value.v
      };
    },
    set: function set(newValue) {
      var oldValue = this.$;
      newValue = _extends$8({}, oldValue, newValue); // If this Color is being watched for changes we need to compare the new and old values to check the difference
      // Otherwise we can just be lazy

      if (this.onChange) {
        // Compute changed values
        var changes = {
          h: false,
          v: false,
          s: false,
          a: false
        };

        for (var key in oldValue) {
          changes[key] = newValue[key] != oldValue[key];
        }

        this.$ = newValue; // If the value has changed, call hook callback

        if (changes.h || changes.s || changes.v || changes.a) { this.onChange(this, changes); }
      } else {
        this.$ = newValue;
      }
    }
  }, {
    key: "hsva",
    get: function get() {
      return _extends$8({}, this.$);
    },
    set: function set(value) {
      this.hsv = value;
    }
  }, {
    key: "hue",
    get: function get() {
      return this.$.h;
    },
    set: function set(value) {
      this.hsv = {
        h: value
      };
    }
  }, {
    key: "saturation",
    get: function get() {
      return this.$.s;
    },
    set: function set(value) {
      this.hsv = {
        s: value
      };
    }
  }, {
    key: "value",
    get: function get() {
      return this.$.v;
    },
    set: function set(value) {
      this.hsv = {
        v: value
      };
    }
  }, {
    key: "alpha",
    get: function get() {
      return this.$.a;
    },
    set: function set(value) {
      this.hsv = _extends$8({}, this.hsv, {
        a: value
      });
    }
  }, {
    key: "kelvin",
    get: function get() {
      return IroColor.rgbToKelvin(this.rgb);
    },
    set: function set(value) {
      this.rgb = IroColor.kelvinToRgb(value);
    }
  }, {
    key: "red",
    get: function get() {
      var rgb = this.rgb;
      return rgb.r;
    },
    set: function set(value) {
      this.rgb = _extends$8({}, this.rgb, {
        r: value
      });
    }
  }, {
    key: "green",
    get: function get() {
      var rgb = this.rgb;
      return rgb.g;
    },
    set: function set(value) {
      this.rgb = _extends$8({}, this.rgb, {
        g: value
      });
    }
  }, {
    key: "blue",
    get: function get() {
      var rgb = this.rgb;
      return rgb.b;
    },
    set: function set(value) {
      this.rgb = _extends$8({}, this.rgb, {
        b: value
      });
    }
  }, {
    key: "rgb",
    get: function get() {
      var _IroColor$hsvToRgb = IroColor.hsvToRgb(this.$),
          r = _IroColor$hsvToRgb.r,
          g = _IroColor$hsvToRgb.g,
          b = _IroColor$hsvToRgb.b;

      return {
        r: round$1(r),
        g: round$1(g),
        b: round$1(b)
      };
    },
    set: function set(value) {
      this.hsv = _extends$8({}, IroColor.rgbToHsv(value), {
        a: value.a === undefined ? 1 : value.a
      });
    }
  }, {
    key: "rgba",
    get: function get() {
      return _extends$8({}, this.rgb, {
        a: this.alpha
      });
    },
    set: function set(value) {
      this.rgb = value;
    }
  }, {
    key: "hsl",
    get: function get() {
      var _IroColor$hsvToHsl = IroColor.hsvToHsl(this.$),
          h = _IroColor$hsvToHsl.h,
          s = _IroColor$hsvToHsl.s,
          l = _IroColor$hsvToHsl.l;

      return {
        h: round$1(h),
        s: round$1(s),
        l: round$1(l)
      };
    },
    set: function set(value) {
      this.hsv = _extends$8({}, IroColor.hslToHsv(value), {
        a: value.a === undefined ? 1 : value.a
      });
    }
  }, {
    key: "hsla",
    get: function get() {
      return _extends$8({}, this.hsl, {
        a: this.alpha
      });
    },
    set: function set(value) {
      this.hsl = value;
    }
  }, {
    key: "rgbString",
    get: function get() {
      var rgb = this.rgb;
      return "rgb(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ")";
    },
    set: function set(value) {
      var match;
      var r,
          g,
          b,
          a = 1;

      if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {
        r = parseUnit(match[1], 255);
        g = parseUnit(match[2], 255);
        b = parseUnit(match[3], 255);
      } else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {
        r = parseUnit(match[1], 255);
        g = parseUnit(match[2], 255);
        b = parseUnit(match[3], 255);
        a = parseUnit(match[4], 1);
      }

      if (match) {
        this.rgb = {
          r: r,
          g: g,
          b: b,
          a: a
        };
      } else {
        throw new Error('Invalid rgb string');
      }
    }
  }, {
    key: "rgbaString",
    get: function get() {
      var rgba = this.rgba;
      return "rgba(" + rgba.r + ", " + rgba.g + ", " + rgba.b + ", " + rgba.a + ")";
    },
    set: function set(value) {
      this.rgbString = value;
    }
  }, {
    key: "hexString",
    get: function get() {
      var rgb = this.rgb;
      return "#" + intToHex(rgb.r) + intToHex(rgb.g) + intToHex(rgb.b);
    },
    set: function set(value) {
      var match;
      var r,
          g,
          b,
          a = 255;

      if (match = REGEX_HEX_3.exec(value)) {
        r = parseHexInt(match[1]) * 17;
        g = parseHexInt(match[2]) * 17;
        b = parseHexInt(match[3]) * 17;
      } else if (match = REGEX_HEX_4.exec(value)) {
        r = parseHexInt(match[1]) * 17;
        g = parseHexInt(match[2]) * 17;
        b = parseHexInt(match[3]) * 17;
        a = parseHexInt(match[4]) * 17;
      } else if (match = REGEX_HEX_6.exec(value)) {
        r = parseHexInt(match[1]);
        g = parseHexInt(match[2]);
        b = parseHexInt(match[3]);
      } else if (match = REGEX_HEX_8.exec(value)) {
        r = parseHexInt(match[1]);
        g = parseHexInt(match[2]);
        b = parseHexInt(match[3]);
        a = parseHexInt(match[4]);
      }

      if (match) {
        this.rgb = {
          r: r,
          g: g,
          b: b,
          a: a / 255
        };
      } else {
        throw new Error('Invalid hex string');
      }
    }
  }, {
    key: "hex8String",
    get: function get() {
      var rgba = this.rgba;
      return "#" + intToHex(rgba.r) + intToHex(rgba.g) + intToHex(rgba.b) + intToHex(floor(rgba.a * 255));
    },
    set: function set(value) {
      this.hexString = value;
    }
  }, {
    key: "hslString",
    get: function get() {
      var hsl = this.hsl;
      return "hsl(" + hsl.h + ", " + hsl.s + "%, " + hsl.l + "%)";
    },
    set: function set(value) {
      var match;
      var h,
          s,
          l,
          a = 1;

      if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {
        h = parseUnit(match[1], 360);
        s = parseUnit(match[2], 100);
        l = parseUnit(match[3], 100);
      } else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {
        h = parseUnit(match[1], 360);
        s = parseUnit(match[2], 100);
        l = parseUnit(match[3], 100);
        a = parseUnit(match[4], 1);
      }

      if (match) {
        this.hsl = {
          h: h,
          s: s,
          l: l,
          a: a
        };
      } else {
        throw new Error('Invalid hsl string');
      }
    }
  }, {
    key: "hslaString",
    get: function get() {
      var hsla = this.hsla;
      return "hsla(" + hsla.h + ", " + hsla.s + "%, " + hsla.l + "%, " + hsla.a + ")";
    },
    set: function set(value) {
      this.hslString = value;
    }
  }]);

  return IroColor;
}();

var sliderDefaultOptions = {
  sliderShape: 'bar',
  sliderType: 'value',
  minTemperature: 2200,
  maxTemperature: 11000
};
/**
 * @desc Get the bounding dimensions of the slider
 * @param props - slider props
 */

function getSliderDimensions(props) {
  var _sliderSize;

  var width = props.width,
      sliderSize = props.sliderSize,
      borderWidth = props.borderWidth,
      handleRadius = props.handleRadius,
      padding = props.padding,
      sliderShape = props.sliderShape;
  var ishorizontal = props.layoutDirection === 'horizontal'; // automatically calculate sliderSize if its not defined

  sliderSize = (_sliderSize = sliderSize) != null ? _sliderSize : padding * 2 + handleRadius * 2;

  if (sliderShape === 'circle') {
    return {
      handleStart: props.padding + props.handleRadius,
      handleRange: width - padding * 2 - handleRadius * 2,
      width: width,
      height: width,
      cx: width / 2,
      cy: width / 2,
      radius: width / 2 - borderWidth / 2
    };
  } else {
    return {
      handleStart: sliderSize / 2,
      handleRange: width - sliderSize,
      radius: sliderSize / 2,
      x: 0,
      y: 0,
      width: ishorizontal ? sliderSize : width,
      height: ishorizontal ? width : sliderSize
    };
  }
}
/**
 * @desc Get the current slider value for a given color, as a percentage
 * @param props - slider props
 * @param color
 */

function getCurrentSliderValue(props, color) {
  var hsva = color.hsva;
  var rgb = color.rgb;

  switch (props.sliderType) {
    case 'red':
      return rgb.r / 2.55;

    case 'green':
      return rgb.g / 2.55;

    case 'blue':
      return rgb.b / 2.55;

    case 'alpha':
      return hsva.a * 100;

    case 'kelvin':
      var minTemperature = props.minTemperature,
          maxTemperature = props.maxTemperature;
      var temperatureRange = maxTemperature - minTemperature;
      var percent = (color.kelvin - minTemperature) / temperatureRange * 100; // clmap percentage

      return Math.max(0, Math.min(percent, 100));

    case 'hue':
      return hsva.h /= 3.6;

    case 'saturation':
      return hsva.s;

    case 'value':
    default:
      return hsva.v;
  }
}
/**
 * @desc Get the current slider value from user input
 * @param props - slider props
 * @param x - global input x position
 * @param y - global input y position
 */

function getSliderValueFromInput(props, x, y) {
  var _getSliderDimensions = getSliderDimensions(props),
      handleRange = _getSliderDimensions.handleRange,
      handleStart = _getSliderDimensions.handleStart;

  var handlePos;

  if (props.layoutDirection === 'horizontal') {
    handlePos = -1 * y + handleRange + handleStart;
  } else {
    handlePos = x - handleStart;
  } // clamp handle position


  handlePos = Math.max(Math.min(handlePos, handleRange), 0);
  var percent = Math.round(100 / handleRange * handlePos);

  switch (props.sliderType) {
    case 'kelvin':
      var minTemperature = props.minTemperature,
          maxTemperature = props.maxTemperature;
      var temperatureRange = maxTemperature - minTemperature;
      return minTemperature + temperatureRange * (percent / 100);

    case 'alpha':
      return percent / 100;

    case 'hue':
      return percent * 3.6;

    case 'red':
    case 'blue':
    case 'green':
      return percent * 2.55;

    default:
      return percent;
  }
}
/**
 * @desc Get the current handle position for a given color
 * @param props - slider props
 * @param color
 */

function getSliderHandlePosition(props, color) {
  var _getSliderDimensions2 = getSliderDimensions(props),
      width = _getSliderDimensions2.width,
      height = _getSliderDimensions2.height,
      handleRange = _getSliderDimensions2.handleRange,
      handleStart = _getSliderDimensions2.handleStart;

  var ishorizontal = props.layoutDirection === 'horizontal';
  var sliderValue = getCurrentSliderValue(props, color);
  var midPoint = ishorizontal ? width / 2 : height / 2;
  var handlePos = handleStart + sliderValue / 100 * handleRange;

  if (ishorizontal) {
    handlePos = -1 * handlePos + handleRange + handleStart * 2;
  }

  return {
    x: ishorizontal ? midPoint : handlePos,
    y: ishorizontal ? handlePos : midPoint
  };
}
/**
 * @desc Get the gradient stops for a slider
 * @param props - slider props
 * @param color
 */

function getSliderGradient(props, color) {
  var hsv = color.hsv;
  var rgb = color.rgb;

  switch (props.sliderType) {
    case 'red':
      return [[0, "rgb(" + 0 + "," + rgb.g + "," + rgb.b + ")"], [100, "rgb(" + 255 + "," + rgb.g + "," + rgb.b + ")"]];

    case 'green':
      return [[0, "rgb(" + rgb.r + "," + 0 + "," + rgb.b + ")"], [100, "rgb(" + rgb.r + "," + 255 + "," + rgb.b + ")"]];

    case 'blue':
      return [[0, "rgb(" + rgb.r + "," + rgb.g + "," + 0 + ")"], [100, "rgb(" + rgb.r + "," + rgb.g + "," + 255 + ")"]];

    case 'alpha':
      return [[0, "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ",0)"], [100, "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")"]];

    case 'kelvin':
      var stops = [];
      var min = props.minTemperature;
      var max = props.maxTemperature;
      var numStops = 8;
      var range = max - min;

      for (var kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {
        var _IroColor$kelvinToRgb = IroColor.kelvinToRgb(kelvin),
            r = _IroColor$kelvinToRgb.r,
            g = _IroColor$kelvinToRgb.g,
            b = _IroColor$kelvinToRgb.b;

        stops.push([100 / numStops * stop, "rgb(" + r + "," + g + "," + b + ")"]);
      }

      return stops;

    case 'hue':
      return [[0, '#f00'], [16.666, '#ff0'], [33.333, '#0f0'], [50, '#0ff'], [66.666, '#00f'], [83.333, '#f0f'], [100, '#f00']];

    case 'saturation':
      var noSat = IroColor.hsvToHsl({
        h: hsv.h,
        s: 0,
        v: hsv.v
      });
      var fullSat = IroColor.hsvToHsl({
        h: hsv.h,
        s: 100,
        v: hsv.v
      });
      return [[0, "hsl(" + noSat.h + "," + noSat.s + "%," + noSat.l + "%)"], [100, "hsl(" + fullSat.h + "," + fullSat.s + "%," + fullSat.l + "%)"]];

    case 'value':
    default:
      var hsl = IroColor.hsvToHsl({
        h: hsv.h,
        s: hsv.s,
        v: 100
      });
      return [[0, '#000'], [100, "hsl(" + hsl.h + "," + hsl.s + "%," + hsl.l + "%)"]];
  }
}

var TAU = Math.PI * 2; // javascript's modulo operator doesn't produce positive numbers with negative input
// https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e

var mod = function mod(a, n) {
  return (a % n + n) % n;
}; // distance between points (x, y) and (0, 0)


var dist = function dist(x, y) {
  return Math.sqrt(x * x + y * y);
};
/**
 * @param props - wheel props
 * @internal
 */


function getHandleRange(props) {
  return props.width / 2 - props.padding - props.handleRadius - props.borderWidth;
}
/**
 * Returns true if point (x, y) lands inside the wheel
 * @param props - wheel props
 * @param x
 * @param y
 */


function isInputInsideWheel(props, x, y) {
  var _getWheelDimensions = getWheelDimensions(props),
      cx = _getWheelDimensions.cx,
      cy = _getWheelDimensions.cy;

  var r = props.width / 2;
  return dist(cx - x, cy - y) < r;
}
/**
 * @desc Get the point as the center of the wheel
 * @param props - wheel props
 */

function getWheelDimensions(props) {
  var r = props.width / 2;
  return {
    width: props.width,
    radius: r - props.borderWidth,
    cx: r,
    cy: r
  };
}
/**
 * @desc Translate an angle according to wheelAngle and wheelDirection
 * @param props - wheel props
 * @param angle - input angle
 */

function translateWheelAngle(props, angle, invert) {
  var wheelAngle = props.wheelAngle;
  var wheelDirection = props.wheelDirection; // inverted and clockwisee

  if (invert && wheelDirection === 'clockwise') { angle = wheelAngle + angle; } // clockwise (input handling)
  else if (wheelDirection === 'clockwise') { angle = 360 - wheelAngle + angle; } // inverted and anticlockwise
    else if (invert && wheelDirection === 'anticlockwise') { angle = wheelAngle + 180 - angle; } // anticlockwise (input handling)
      else if (wheelDirection === 'anticlockwise') { angle = wheelAngle - angle; }
  return mod(angle, 360);
}
/**
 * @desc Get the current handle position for a given color
 * @param props - wheel props
 * @param color
 */

function getWheelHandlePosition(props, color) {
  var hsv = color.hsv;

  var _getWheelDimensions2 = getWheelDimensions(props),
      cx = _getWheelDimensions2.cx,
      cy = _getWheelDimensions2.cy;

  var handleRange = getHandleRange(props);
  var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);
  var handleDist = hsv.s / 100 * handleRange;
  var direction = props.wheelDirection === 'clockwise' ? -1 : 1;
  return {
    x: cx + handleDist * Math.cos(handleAngle) * direction,
    y: cy + handleDist * Math.sin(handleAngle) * direction
  };
}
/**
 * @desc Get the current wheel value from user input
 * @param props - wheel props
 * @param x - global input x position
 * @param y - global input y position
 */

function getWheelValueFromInput(props, x, y) {
  var _getWheelDimensions3 = getWheelDimensions(props),
      cx = _getWheelDimensions3.cx,
      cy = _getWheelDimensions3.cy;

  var handleRange = getHandleRange(props);
  x = cx - x;
  y = cy - y; // Calculate the hue by converting the angle to radians

  var hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU)); // Find the point's distance from the center of the wheel
  // This is used to show the saturation level

  var handleDist = Math.min(dist(x, y), handleRange);
  return {
    h: Math.round(hue),
    s: Math.round(100 / handleRange * handleDist)
  };
}
/**
 * @desc Get the bounding dimensions of the box
 * @param props - box props
 */

function getBoxDimensions(props) {
  var width = props.width,
      boxHeight = props.boxHeight,
      padding = props.padding,
      handleRadius = props.handleRadius;
  return {
    width: width,
    height: boxHeight != null ? boxHeight : width,
    radius: padding + handleRadius
  };
}
/**
 * @desc Get the current box value from user input
 * @param props - box props
 * @param x - global input x position
 * @param y - global input y position
 */

function getBoxValueFromInput(props, x, y) {
  var _getBoxDimensions = getBoxDimensions(props),
      width = _getBoxDimensions.width,
      height = _getBoxDimensions.height,
      radius = _getBoxDimensions.radius;

  var handleStart = radius;
  var handleRangeX = width - radius * 2;
  var handleRangeY = height - radius * 2;
  var percentX = (x - handleStart) / handleRangeX * 100;
  var percentY = (y - handleStart) / handleRangeY * 100;
  return {
    s: Math.max(0, Math.min(percentX, 100)),
    v: Math.max(0, Math.min(100 - percentY, 100))
  };
}
/**
 * @desc Get the current box handle position for a given color
 * @param props - box props
 * @param color
 */

function getBoxHandlePosition(props, color) {
  var _getBoxDimensions2 = getBoxDimensions(props),
      width = _getBoxDimensions2.width,
      height = _getBoxDimensions2.height,
      radius = _getBoxDimensions2.radius;

  var hsv = color.hsv;
  var handleStart = radius;
  var handleRangeX = width - radius * 2;
  var handleRangeY = height - radius * 2;
  return {
    x: handleStart + hsv.s / 100 * handleRangeX,
    y: handleStart + (handleRangeY - hsv.v / 100 * handleRangeY)
  };
}
/**
 * @desc Get the gradient stops for a box
 * @param props - box props
 * @param color
 */

function getBoxGradients(props, color) {
  var hue = color.hue;
  return [// saturation gradient
  [[0, '#fff'], [100, "hsl(" + hue + ",100%,50%)"]], // lightness gradient
  [[0, 'rgba(0,0,0,0)'], [100, '#000']]];
}

// Keep track of html <base> elements for resolveSvgUrl
// getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree
// So it only needs to be called once
var BASE_ELEMENTS;
/**
 * @desc Resolve an SVG reference URL
 * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions
 * If a page is using a client-side routing library which makes use of the HTML <base> tag,
 * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)
 * More info on the problem:
 * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427
 * https://github.com/jaames/iro.js/issues/18
 * https://github.com/jaames/iro.js/issues/45
 * https://github.com/jaames/iro.js/pull/89
 * @props url - SVG reference URL
 */

function resolveSvgUrl(url) {
  if (!BASE_ELEMENTS) { BASE_ELEMENTS = document.getElementsByTagName('base'); } // Sniff useragent string to check if the user is running Safari

  var ua = window.navigator.userAgent;
  var isSafari = /^((?!chrome|android).)*safari/i.test(ua);
  var isIos = /iPhone|iPod|iPad/i.test(ua);
  var location = window.location;
  return (isSafari || isIos) && BASE_ELEMENTS.length > 0 ? location.protocol + "//" + location.host + location.pathname + location.search + url : url;
}
/**
 * @desc Given a specifc (x, y) position, test if there's a handle there and return its index, else return null.
 *       This is used for components like the box and wheel which support multiple handles when multicolor is active
 * @props x - point x position
 * @props y - point y position
 * @props handlePositions - array of {x, y} coords for each handle
 */

function getHandleAtPoint(props, x, y, handlePositions) {
  for (var i = 0; i < handlePositions.length; i++) {
    var dX = handlePositions[i].x - x;
    var dY = handlePositions[i].y - y;
    var dist = Math.sqrt(dX * dX + dY * dY);

    if (dist < props.handleRadius) {
      return i;
    }
  }

  return null;
}

function cssBorderStyles(props) {
  return {
    boxSizing: 'border-box',
    border: props.borderWidth + "px solid " + props.borderColor
  };
}
function cssGradient(type, direction, stops) {
  return type + "-gradient(" + direction + ", " + stops.map(function (_ref) {
    var o = _ref[0],
        col = _ref[1];
    return col + " " + o + "%";
  }).join(',') + ")";
}
function cssValue(value) {
  if (typeof value === 'string') { return value; }
  return value + "px";
}

var iroColorPickerOptionDefaults = {
  width: 300,
  height: 300,
  color: '#fff',
  colors: [],
  padding: 6,
  layoutDirection: 'vertical',
  borderColor: '#fff',
  borderWidth: 0,
  handleRadius: 8,
  activeHandleRadius: null,
  handleSvg: null,
  handleProps: {
    x: 0,
    y: 0
  },
  wheelLightness: true,
  wheelAngle: 0,
  wheelDirection: 'anticlockwise',
  sliderSize: null,
  sliderMargin: 12,
  boxHeight: null
};

var SECONDARY_EVENTS = ["mousemove" /* MouseMove */, "touchmove" /* TouchMove */, "mouseup" /* MouseUp */, "touchend" /* TouchEnd */];
// Base component class for iro UI components
// This extends the Preact component class to allow them to react to mouse/touch input events by themselves
var IroComponentWrapper = /*@__PURE__*/(function (Component) {
    function IroComponentWrapper(props) {
        Component.call(this, props);
        // Generate unique ID for the component
        // This can be used to generate unique IDs for gradients, etc
        this.uid = (Math.random() + 1).toString(36).substring(5);
    }

    if ( Component ) IroComponentWrapper.__proto__ = Component;
    IroComponentWrapper.prototype = Object.create( Component && Component.prototype );
    IroComponentWrapper.prototype.constructor = IroComponentWrapper;
    IroComponentWrapper.prototype.render = function render (props) {
        var eventHandler = this.handleEvent.bind(this);
        var rootProps = {
            onMouseDown: eventHandler,
            // https://github.com/jaames/iro.js/issues/126
            // https://github.com/preactjs/preact/issues/2113#issuecomment-553408767
            ontouchstart: eventHandler,
        };
        var isHorizontal = props.layoutDirection === 'horizontal';
        var margin = props.margin === null ? props.sliderMargin : props.margin;
        var rootStyles = {
            overflow: 'visible',
            display: isHorizontal ? 'inline-block' : 'block'
        };
        // first component shouldn't have any margin
        if (props.index > 0) {
            rootStyles[isHorizontal ? 'marginLeft' : 'marginTop'] = margin;
        }
        return (h$3(d$3, null, props.children(this.uid, rootProps, rootStyles)));
    };
    // More info on handleEvent:
    // https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38
    // TL;DR this lets us have a single point of entry for multiple events, and we can avoid callback/binding hell
    IroComponentWrapper.prototype.handleEvent = function handleEvent (e) {
        var this$1 = this;

        var inputHandler = this.props.onInput;
        // Get the screen position of the component
        var bounds = this.base.getBoundingClientRect();
        // Prefect default browser action
        e.preventDefault();
        // Detect if the event is a touch event by checking if it has the `touches` property
        // If it is a touch event, use the first touch input
        var point = e.touches ? e.changedTouches[0] : e;
        var x = point.clientX - bounds.left;
        var y = point.clientY - bounds.top;
        switch (e.type) {
            case "mousedown" /* MouseDown */:
            case "touchstart" /* TouchStart */:
                var result = inputHandler(x, y, 0 /* Start */);
                if (result !== false) {
                    SECONDARY_EVENTS.forEach(function (event) {
                        document.addEventListener(event, this$1, { passive: false });
                    });
                }
                break;
            case "mousemove" /* MouseMove */:
            case "touchmove" /* TouchMove */:
                inputHandler(x, y, 1 /* Move */);
                break;
            case "mouseup" /* MouseUp */:
            case "touchend" /* TouchEnd */:
                inputHandler(x, y, 2 /* End */);
                SECONDARY_EVENTS.forEach(function (event) {
                    document.removeEventListener(event, this$1, { passive: false });
                });
                break;
        }
    };

    return IroComponentWrapper;
}(m$3));

function IroHandle(props) {
    var radius = props.r;
    var url = props.url;
    var cx = radius;
    var cy = radius;
    return (h$3("svg", { className: ("IroHandle IroHandle--" + (props.index) + " " + (props.isActive ? 'IroHandle--isActive' : '')), style: {
            '-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0);',
            transform: ("translate(" + (cssValue(props.x)) + ", " + (cssValue(props.y)) + ")"),
            willChange: 'transform',
            top: cssValue(-radius),
            left: cssValue(-radius),
            width: cssValue(radius * 2),
            height: cssValue(radius * 2),
            position: 'absolute',
            overflow: 'visible'
        } },
        url && (h$3("use", Object.assign({ xlinkHref: resolveSvgUrl(url) }, props.props))),
        !url && (h$3("circle", { cx: cx, cy: cy, r: radius, fill: "none", "stroke-width": 2, stroke: "#000" })),
        !url && (h$3("circle", { cx: cx, cy: cy, r: radius - 2, fill: props.fill, "stroke-width": 2, stroke: "#fff" }))));
}
IroHandle.defaultProps = {
    fill: 'none',
    x: 0,
    y: 0,
    r: 8,
    url: null,
    props: { x: 0, y: 0 }
};

function IroSlider(props) {
    var activeIndex = props.activeIndex;
    var activeColor = (activeIndex !== undefined && activeIndex < props.colors.length) ? props.colors[activeIndex] : props.color;
    var ref = getSliderDimensions(props);
    var width = ref.width;
    var height = ref.height;
    var radius = ref.radius;
    var handlePos = getSliderHandlePosition(props, activeColor);
    var gradient = getSliderGradient(props, activeColor);
    function handleInput(x, y, type) {
        var value = getSliderValueFromInput(props, x, y);
        props.parent.inputActive = true;
        activeColor[props.sliderType] = value;
        props.onInput(type, props.id);
    }
    return (h$3(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h$3("div", Object.assign({}, rootProps, { className: "IroSlider", style: Object.assign({}, {position: 'relative',
            width: cssValue(width),
            height: cssValue(height),
            borderRadius: cssValue(radius),
            // checkered bg to represent alpha
            background: "conic-gradient(#ccc 25%, #fff 0 50%, #ccc 0 75%, #fff 0)",
            backgroundSize: '8px 8px'},
            rootStyles) }),
        h$3("div", { className: "IroSliderGradient", style: Object.assign({}, {position: 'absolute',
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                borderRadius: cssValue(radius),
                background: cssGradient('linear', props.layoutDirection === 'horizontal' ? 'to top' : 'to right', gradient)},
                cssBorderStyles(props)) }),
        h$3(IroHandle, { isActive: true, index: activeColor.index, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePos.x, y: handlePos.y }))); }));
}
IroSlider.defaultProps = Object.assign({}, sliderDefaultOptions);

function IroBox(props) {
    var ref = getBoxDimensions(props);
    var width = ref.width;
    var height = ref.height;
    var radius = ref.radius;
    var colors = props.colors;
    var colorPicker = props.parent;
    var activeIndex = props.activeIndex;
    var activeColor = (activeIndex !== undefined && activeIndex < props.colors.length) ? props.colors[activeIndex] : props.color;
    var gradients = getBoxGradients(props, activeColor);
    var handlePositions = colors.map(function (color) { return getBoxHandlePosition(props, color); });
    function handleInput(x, y, inputType) {
        if (inputType === 0 /* Start */) {
            // getHandleAtPoint() returns the index for the handle if the point 'hits' it, or null otherwise
            var activeHandle = getHandleAtPoint(props, x, y, handlePositions);
            // If the input hit a handle, set it as the active handle, but don't update the color
            if (activeHandle !== null) {
                colorPicker.setActiveColor(activeHandle);
            }
            // If the input didn't hit a handle, set the currently active handle to that position
            else {
                colorPicker.inputActive = true;
                activeColor.hsv = getBoxValueFromInput(props, x, y);
                props.onInput(inputType, props.id);
            }
        }
        // move is fired when the user has started dragging
        else if (inputType === 1 /* Move */) {
            colorPicker.inputActive = true;
            activeColor.hsv = getBoxValueFromInput(props, x, y);
        }
        // let the color picker fire input:start, input:move or input:end events
        props.onInput(inputType, props.id);
    }
    return (h$3(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h$3("div", Object.assign({}, rootProps, { className: "IroBox", style: Object.assign({}, {width: cssValue(width),
            height: cssValue(height),
            position: 'relative'},
            rootStyles) }),
        h$3("div", { className: "IroBox", style: Object.assign({}, {width: '100%',
                height: '100%',
                borderRadius: cssValue(radius)},
                cssBorderStyles(props),
                {background: cssGradient('linear', 'to bottom', gradients[1])
                    + ',' +
                    cssGradient('linear', 'to right', gradients[0])}) }),
        colors.filter(function (color) { return color !== activeColor; }).map(function (color) { return (h$3(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y })); }),
        h$3(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.activeHandleRadius || props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y }))); }));
}

var HUE_GRADIENT_CLOCKWISE = 'conic-gradient(red, yellow, lime, aqua, blue, magenta, red)';
var HUE_GRADIENT_ANTICLOCKWISE = 'conic-gradient(red, magenta, blue, aqua, lime, yellow, red)';
function IroWheel(props) {
    var ref = getWheelDimensions(props);
    var width = ref.width;
    var colors = props.colors;
    var colorPicker = props.parent;
    var activeColor = props.color;
    var hsv = activeColor.hsv;
    var handlePositions = colors.map(function (color) { return getWheelHandlePosition(props, color); });
    var circleStyles = {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        borderRadius: '50%',
        boxSizing: 'border-box'
    };
    function handleInput(x, y, inputType) {
        if (inputType === 0 /* Start */) {
            // input hitbox is a square, 
            // so we want to ignore any initial clicks outside the circular shape of the wheel
            if (!isInputInsideWheel(props, x, y)) {
                // returning false will cease all event handling for this interaction
                return false;
            }
            // getHandleAtPoint() returns the index for the handle if the point 'hits' it, or null otherwise
            var activeHandle = getHandleAtPoint(props, x, y, handlePositions);
            // If the input hit a handle, set it as the active handle, but don't update the color
            if (activeHandle !== null) {
                colorPicker.setActiveColor(activeHandle);
            }
            // If the input didn't hit a handle, set the currently active handle to that position
            else {
                colorPicker.inputActive = true;
                activeColor.hsv = getWheelValueFromInput(props, x, y);
                props.onInput(inputType, props.id);
            }
        }
        // move is fired when the user has started dragging
        else if (inputType === 1 /* Move */) {
            colorPicker.inputActive = true;
            activeColor.hsv = getWheelValueFromInput(props, x, y);
        }
        // let the color picker fire input:start, input:move or input:end events
        props.onInput(inputType, props.id);
    }
    return (h$3(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h$3("div", Object.assign({}, rootProps, { className: "IroWheel", style: Object.assign({}, {width: cssValue(width),
            height: cssValue(width),
            position: 'relative'},
            rootStyles) }),
        h$3("div", { className: "IroWheelHue", style: Object.assign({}, circleStyles,
                {transform: ("rotateZ(" + (props.wheelAngle + 90) + "deg)"),
                background: props.wheelDirection === 'clockwise' ? HUE_GRADIENT_CLOCKWISE : HUE_GRADIENT_ANTICLOCKWISE}) }),
        h$3("div", { className: "IroWheelSaturation", style: Object.assign({}, circleStyles,
                {background: 'radial-gradient(circle closest-side, #fff, transparent)'}) }),
        props.wheelLightness && (h$3("div", { className: "IroWheelLightness", style: Object.assign({}, circleStyles,
                {background: '#000',
                opacity: 1 - hsv.v / 100}) })),
        h$3("div", { className: "IroWheelBorder", style: Object.assign({}, circleStyles,
                cssBorderStyles(props)) }),
        colors.filter(function (color) { return color !== activeColor; }).map(function (color) { return (h$3(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y })); }),
        h$3(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.activeHandleRadius || props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y }))); }));
}

function createWidget(WidgetComponent) {
    var widgetFactory = function (parent, props) {
        var widget; // will become an instance of the widget component class
        var widgetRoot = document.createElement('div');
        // Render widget into a temp DOM node
        I$2(h$3(WidgetComponent, Object.assign({}, {ref: function (ref) { return widget = ref; }},
            props)), widgetRoot);
        function mountWidget() {
            var container = parent instanceof Element ? parent : document.querySelector(parent);
            container.appendChild(widget.base);
            widget.onMount(container);
        }
        // Mount it into the DOM when the page document is ready
        if (document.readyState !== 'loading') {
            mountWidget();
        }
        else {
            document.addEventListener('DOMContentLoaded', mountWidget);
        }
        return widget;
    };
    // Allow the widget factory to inherit component prototype + static class methods
    // This makes it easier for plugin authors to extend the base widget component
    widgetFactory.prototype = WidgetComponent.prototype;
    Object.assign(widgetFactory, WidgetComponent);
    // Add reference to base component too
    widgetFactory.__component = WidgetComponent;
    return widgetFactory;
}

var IroColorPicker = /*@__PURE__*/(function (Component) {
    function IroColorPicker(props) {
        var this$1 = this;

        Component.call(this, props);
        this.colors = [];
        this.inputActive = false;
        this.events = {};
        this.activeEvents = {};
        this.deferredEvents = {};
        this.id = props.id;
        var colors = props.colors.length > 0 ? props.colors : [props.color];
        colors.forEach(function (colorValue) { return this$1.addColor(colorValue); });
        this.setActiveColor(0);
        // Pass all the props into the component's state,
        // Except we want to add the color object and make sure that refs aren't passed down to children
        this.state = Object.assign({}, props,
            {color: this.color,
            colors: this.colors,
            layout: props.layout});
    }

    if ( Component ) IroColorPicker.__proto__ = Component;
    IroColorPicker.prototype = Object.create( Component && Component.prototype );
    IroColorPicker.prototype.constructor = IroColorPicker;
    // Plubic multicolor API
    /**
    * @desc Add a color to the color picker
    * @param color new color to add
    * @param index optional color index
    */
    IroColorPicker.prototype.addColor = function addColor (color, index) {
        if ( index === void 0 ) index = this.colors.length;

        // Create a new iro.Color
        // Also bind it to onColorChange, so whenever the color changes it updates the color picker
        var newColor = new IroColor(color, this.onColorChange.bind(this));
        // Insert color @ the given index
        this.colors.splice(index, 0, newColor);
        // Reindex colors
        this.colors.forEach(function (color, index) { return color.index = index; });
        // Update picker state if necessary
        if (this.state) {
            this.setState({ colors: this.colors });
        }
        // Fire color init event
        this.deferredEmit('color:init', newColor);
    };
    /**
     * @desc Remove a color from the color picker
     * @param index color index
     */
    IroColorPicker.prototype.removeColor = function removeColor (index) {
        var color = this.colors.splice(index, 1)[0];
        // Destroy the color object -- this unbinds it from the color picker
        color.unbind();
        // Reindex colors
        this.colors.forEach(function (color, index) { return color.index = index; });
        // Update picker state if necessary
        if (this.state) {
            this.setState({ colors: this.colors });
        }
        // If the active color was removed, default active color to 0
        if (color.index === this.color.index) {
            this.setActiveColor(0);
        }
        // Fire color remove event
        this.emit('color:remove', color);
    };
    /**
     * @desc Set the currently active color
     * @param index color index
     */
    IroColorPicker.prototype.setActiveColor = function setActiveColor (index) {
        this.color = this.colors[index];
        if (this.state) {
            this.setState({ color: this.color });
        }
        // Fire color switch event
        this.emit('color:setActive', this.color);
    };
    /**
     * @desc Replace all of the current colorPicker colors
     * @param newColorValues list of new colors to add
     */
    IroColorPicker.prototype.setColors = function setColors (newColorValues, activeColorIndex) {
        var this$1 = this;
        if ( activeColorIndex === void 0 ) activeColorIndex = 0;

        // Unbind color events
        this.colors.forEach(function (color) { return color.unbind(); });
        // Destroy old colors
        this.colors = [];
        // Add new colors
        newColorValues.forEach(function (colorValue) { return this$1.addColor(colorValue); });
        // Reset active color
        this.setActiveColor(activeColorIndex);
        this.emit('color:setAll', this.colors);
    };
    // Public ColorPicker events API
    /**
     * @desc Set a callback function for an event
     * @param eventList event(s) to listen to
     * @param callback - Function called when the event is fired
     */
    IroColorPicker.prototype.on = function on (eventList, callback) {
        var this$1 = this;

        var events = this.events;
        // eventList can be an eventType string or an array of eventType strings
        (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {
            // Add event callback
            (events[eventType] || (events[eventType] = [])).push(callback);
            // Call deferred events
            // These are events that can be stored until a listener for them is added
            if (this$1.deferredEvents[eventType]) {
                // Deffered events store an array of arguments from when the event was called
                this$1.deferredEvents[eventType].forEach(function (args) {
                    callback.apply(null, args);
                });
                // Clear deferred events
                this$1.deferredEvents[eventType] = [];
            }
        });
    };
    /**
     * @desc Remove a callback function for an event added with on()
     * @param eventList - event(s) to listen to
     * @param callback - original callback function to remove
     */
    IroColorPicker.prototype.off = function off (eventList, callback) {
        var this$1 = this;

        (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {
            var callbackList = this$1.events[eventType];
            // this.emitHook('event:off', eventType, callback);
            if (callbackList)
                { callbackList.splice(callbackList.indexOf(callback), 1); }
        });
    };
    /**
     * @desc Emit an event
     * @param eventType event to emit
     */
    IroColorPicker.prototype.emit = function emit (eventType) {
        var this$1 = this;
        var args = [], len = arguments.length - 1;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

        var activeEvents = this.activeEvents;
        var isEventActive = activeEvents.hasOwnProperty(eventType) ? activeEvents[eventType] : false;
        // Prevent event callbacks from firing if the event is already active
        // This stops infinite loops if something in an event callback causes the same event to be fired again
        // (e.g. setting the color inside a color:change callback)
        if (!isEventActive) {
            activeEvents[eventType] = true;
            var callbackList = this.events[eventType] || [];
            callbackList.forEach(function (fn) { return fn.apply(this$1, args); });
            activeEvents[eventType] = false;
        }
    };
    /**
     * @desc Emit an event now, or save it for when the relevent event listener is added
     * @param eventType - The name of the event to emit
     */
    IroColorPicker.prototype.deferredEmit = function deferredEmit (eventType) {
        var ref;

        var args = [], len = arguments.length - 1;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
        var deferredEvents = this.deferredEvents;
        (ref = this).emit.apply(ref, [ eventType ].concat( args ));
        (deferredEvents[eventType] || (deferredEvents[eventType] = [])).push(args);
    };
    // Public utility methods
    IroColorPicker.prototype.setOptions = function setOptions (newOptions) {
        this.setState(newOptions);
    };
    /**
     * @desc Resize the color picker
     * @param width - new width
     */
    IroColorPicker.prototype.resize = function resize (width) {
        this.setOptions({ width: width });
    };
    /**
     * @desc Reset the color picker to the initial color provided in the color picker options
     */
    IroColorPicker.prototype.reset = function reset () {
        this.colors.forEach(function (color) { return color.reset(); });
        this.setState({ colors: this.colors });
    };
    /**
     * @desc Called by the createWidget wrapper when the element is mounted into the page
     * @param container - the container element for this ColorPicker instance
     */
    IroColorPicker.prototype.onMount = function onMount (container) {
        this.el = container;
        this.deferredEmit('mount', this);
    };
    // Internal methods
    /**
     * @desc React to a color update
     * @param color - current color
     * @param changes - shows which h,s,v,a color channels changed
     */
    IroColorPicker.prototype.onColorChange = function onColorChange (color, changes) {
        this.setState({ color: this.color });
        if (this.inputActive) {
            this.inputActive = false;
            this.emit('input:change', color, changes);
        }
        this.emit('color:change', color, changes);
    };
    /**
     * @desc Handle input from a UI control element
     * @param type - event type
     */
    IroColorPicker.prototype.emitInputEvent = function emitInputEvent (type, originId) {
        if (type === 0 /* Start */) {
            this.emit('input:start', this.color, originId);
        }
        else if (type === 1 /* Move */) {
            this.emit('input:move', this.color, originId);
        }
        else if (type === 2 /* End */) {
            this.emit('input:end', this.color, originId);
        }
    };
    IroColorPicker.prototype.render = function render (props, state) {
        var this$1 = this;

        var layout = state.layout;
        // use layout shorthands
        if (!Array.isArray(layout)) {
            switch (layout) {
                // TODO: implement some?
                default:
                    layout = [
                        { component: IroWheel },
                        { component: IroSlider } ];
            }
            // add transparency slider to the layout
            if (state.transparency) {
                layout.push({
                    component: IroSlider,
                    options: {
                        sliderType: 'alpha'
                    }
                });
            }
        }
        return (h$3("div", { class: "IroColorPicker", id: state.id, style: {
                display: state.display
            } }, layout.map(function (ref, componentIndex) {
                var UiComponent = ref.component;
                var options = ref.options;

                return (h$3(UiComponent, Object.assign({}, state, options, { ref: undefined, onInput: this$1.emitInputEvent.bind(this$1), parent: this$1, index: componentIndex })));
        })));
    };

    return IroColorPicker;
}(m$3));
IroColorPicker.defaultProps = Object.assign({}, iroColorPickerOptionDefaults,
    {colors: [],
    display: 'block',
    id: null,
    layout: 'default',
    margin: null});
var IroColorPickerWidget = createWidget(IroColorPicker);

var iro;
(function (iro) {
    iro.version = "5.5.2"; // replaced by @rollup/plugin-replace; see rollup.config.js
    iro.Color = IroColor;
    iro.ColorPicker = IroColorPickerWidget;
    (function (ui) {
        ui.h = h$3;
        ui.ComponentBase = IroComponentWrapper;
        ui.Handle = IroHandle;
        ui.Slider = IroSlider;
        ui.Wheel = IroWheel;
        ui.Box = IroBox;
    })(iro.ui || (iro.ui = {}));
})(iro || (iro = {}));
var iro$1 = iro;

const SpxControlColor$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.init = false;
    this.clickHandler = () => {
      var _a;
      this.picker.classList.toggle('hidden');
      if (!this.init) {
        // @ts-ignore
        this.colorPicker = new iro$1.ColorPicker(this.picker, {
          width: 217,
          color: (_a = this.color) !== null && _a !== void 0 ? _a : 'black',
        });
        this.colorPicker.on('color:change', (color) => {
          if (color.index === 0) {
            this.swatch.style.background = color.hexString;
            this.input.value = color.hexString;
          }
        });
        this.init = true;
      }
    };
    this.textHandler = (e) => {
      if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
        this.colorPicker.color.hexString = e.target.value;
      }
    };
  }
  render() {
    const { tw } = cssTw(this.el.shadowRoot);
    return (h$4("div", { class: tw(`flex flex-col`) }, h$4("spx-control-label", { label: this.label, mb: true }), h$4("div", { style: { gridTemplateColumns: 'auto 1fr' }, class: tw(`grid items-center gap-2`) }, h$4(Button, { ref: (el) => (this.swatch = el), onClick: this.clickHandler, class: tw(`focus-out bg-[${this.color}] h-[34px] w-[34px] border border-blue-gray-300 rounded-md`) }), h$4("spx-control-text", { ref: (el) => (this.input = el), value: this.color, handleChange: this.textHandler })), h$4("div", { ref: (el) => (this.picker = el), class: tw(`hidden mt-4`) })));
  }
  get el() { return this; }
};

const SpxControlGroup$2 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  render() {
    const { tw } = cssTw(this.el.shadowRoot);
    return (h$4("div", { class: tw(`grid gap-6`) }, h$4("slot", null)));
  }
  get el() { return this; }
};

const SpxControlGroup$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  render() {
    const { tw } = cssTw(this.el.shadowRoot);
    return (h$4(Host, { style: { display: 'flex' } }, h$4("span", { class: tw(`text-blue-gray-700 text-xs uppercase font-medium inline-block ${this.mb && 'mb-1.5'}`) }, this.label)));
  }
  get el() { return this; }
};

const SpxControlSelect$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.delimiter = ',';
  }
  render() {
    const { tw, css } = cssTw(this.el.shadowRoot);
    return (h$4("div", null, this.label && h$4("spx-control-label", { label: this.label, mb: true }), h$4("select", { class: tw(`focus-out border border-blue-gray-200 py-1.5 px-2 rounded-md w-full text-blue-gray-900 text-sm`) +
        ' ' +
        tw(css `
              background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
              background-position: right 0.25rem center;
              background-repeat: no-repeat;
              background-size: 1.5em 1.5em;
              appearance: none;
            `), onChange: this.handleChange }, this.options &&
      this.options.split(this.delimiter).map((item) => {
        return h$4("option", { selected: this.selected === item }, item);
      }))));
  }
  get el() { return this; }
};

var nouislider = createCommonjsModule(function (module, exports) {
(function (global, factory) {
    factory(exports) ;
}(commonjsGlobal, (function (exports) {
    exports.PipsMode = void 0;
    (function (PipsMode) {
        PipsMode["Range"] = "range";
        PipsMode["Steps"] = "steps";
        PipsMode["Positions"] = "positions";
        PipsMode["Count"] = "count";
        PipsMode["Values"] = "values";
    })(exports.PipsMode || (exports.PipsMode = {}));
    exports.PipsType = void 0;
    (function (PipsType) {
        PipsType[PipsType["None"] = -1] = "None";
        PipsType[PipsType["NoValue"] = 0] = "NoValue";
        PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
        PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
    })(exports.PipsType || (exports.PipsType = {}));
    //region Helper Methods
    function isValidFormatter(entry) {
        return isValidPartialFormatter(entry) && typeof entry.from === "function";
    }
    function isValidPartialFormatter(entry) {
        // partial formatters only need a to function and not a from function
        return typeof entry === "object" && typeof entry.to === "function";
    }
    function removeElement(el) {
        el.parentElement.removeChild(el);
    }
    function isSet(value) {
        return value !== null && value !== undefined;
    }
    // Bindable version
    function preventDefault(e) {
        e.preventDefault();
    }
    // Removes duplicates from an array.
    function unique(array) {
        return array.filter(function (a) {
            return !this[a] ? (this[a] = true) : false;
        }, {});
    }
    // Round a value to the closest 'to'.
    function closest(value, to) {
        return Math.round(value / to) * to;
    }
    // Current position of an element relative to the document.
    function offset(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc);
        // getBoundingClientRect contains left scroll in Chrome on Android.
        // I haven't found a feature detection that proves this. Worst case
        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.
        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
            pageOffset.x = 0;
        }
        return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
    }
    // Checks whether a value is numerical.
    function isNumeric(a) {
        return typeof a === "number" && !isNaN(a) && isFinite(a);
    }
    // Sets a class and removes it after [duration] ms.
    function addClassFor(element, className, duration) {
        if (duration > 0) {
            addClass(element, className);
            setTimeout(function () {
                removeClass(element, className);
            }, duration);
        }
    }
    // Limits a value to 0 - 100
    function limit(a) {
        return Math.max(Math.min(a, 100), 0);
    }
    // Wraps a variable as an array, if it isn't one yet.
    // Note that an input array is returned by reference!
    function asArray(a) {
        return Array.isArray(a) ? a : [a];
    }
    // Counts decimals
    function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
    }
    // http://youmightnotneedjquery.com/#add_class
    function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
            el.classList.add(className);
        }
        else {
            el.className += " " + className;
        }
    }
    // http://youmightnotneedjquery.com/#remove_class
    function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
            el.classList.remove(className);
        }
        else {
            el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
    }
    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/
    function hasClass(el, className) {
        return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
    }
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes
    function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== undefined;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x = supportPageOffset
            ? window.pageXOffset
            : isCSS1Compat
                ? doc.documentElement.scrollLeft
                : doc.body.scrollLeft;
        var y = supportPageOffset
            ? window.pageYOffset
            : isCSS1Compat
                ? doc.documentElement.scrollTop
                : doc.body.scrollTop;
        return {
            x: x,
            y: y
        };
    }
    // we provide a function to compute constants instead
    // of accessing window.* as soon as the module needs it
    // so that we do not compute anything if not needed
    function getActions() {
        // Determine the events to bind. IE11 implements pointerEvents without
        // a prefix, which breaks compatibility with the IE10 implementation.
        return window.navigator.pointerEnabled
            ? {
                start: "pointerdown",
                move: "pointermove",
                end: "pointerup"
            }
            : window.navigator.msPointerEnabled
                ? {
                    start: "MSPointerDown",
                    move: "MSPointerMove",
                    end: "MSPointerUp"
                }
                : {
                    start: "mousedown touchstart",
                    move: "mousemove touchmove",
                    end: "mouseup touchend"
                };
    }
    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    // Issue #785
    function getSupportsPassive() {
        var supportsPassive = false;
        /* eslint-disable */
        try {
            var opts = Object.defineProperty({}, "passive", {
                get: function () {
                    supportsPassive = true;
                }
            });
            // @ts-ignore
            window.addEventListener("test", null, opts);
        }
        catch (e) { }
        /* eslint-enable */
        return supportsPassive;
    }
    function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
    }
    //endregion
    //region Range Calculation
    // Determine the size of a sub-range in relation to a full range.
    function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
    }
    // (percentage) How many percent is this value of this range?
    function fromPercentage(range, value, startRange) {
        return (value * 100) / (range[startRange + 1] - range[startRange]);
    }
    // (percentage) Where is this value on this range?
    function toPercentage(range, value) {
        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
    }
    // (value) How much is this percentage on this range?
    function isPercentage(range, value) {
        return (value * (range[1] - range[0])) / 100 + range[0];
    }
    function getJ(value, arr) {
        var j = 1;
        while (value >= arr[j]) {
            j += 1;
        }
        return j;
    }
    // (percentage) Input a value, find where, on a scale of 0-100, it applies.
    function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
            return 100;
        }
        var j = getJ(value, xVal);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];
        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
    }
    // (value) Input a percentage, find where it is on the specified range.
    function fromStepping(xVal, xPct, value) {
        // There is no range group that fits 100
        if (value >= 100) {
            return xVal.slice(-1)[0];
        }
        var j = getJ(value, xPct);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];
        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
    }
    // (percentage) Get the step that applies at a certain value.
    function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
            return value;
        }
        var j = getJ(value, xPct);
        var a = xPct[j - 1];
        var b = xPct[j];
        // If 'snap' is set, steps are used as fixed points on the slider.
        if (snap) {
            // Find the closest position, a or b.
            if (value - a > (b - a) / 2) {
                return b;
            }
            return a;
        }
        if (!xSteps[j - 1]) {
            return value;
        }
        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
    }
    //endregion
    //region Spectrum
    var Spectrum = /** @class */ (function () {
        function Spectrum(entry, snap, singleStep) {
            this.xPct = [];
            this.xVal = [];
            this.xSteps = [];
            this.xNumSteps = [];
            this.xHighestCompleteStep = [];
            this.xSteps = [singleStep || false];
            this.xNumSteps = [false];
            this.snap = snap;
            var index;
            var ordered = [];
            // Map the object keys to an array.
            Object.keys(entry).forEach(function (index) {
                ordered.push([asArray(entry[index]), index]);
            });
            // Sort all entries by value (numeric sort).
            ordered.sort(function (a, b) {
                return a[0][0] - b[0][0];
            });
            // Convert all entries to subranges.
            for (index = 0; index < ordered.length; index++) {
                this.handleEntryPoint(ordered[index][1], ordered[index][0]);
            }
            // Store the actual step values.
            // xSteps is sorted in the same order as xPct and xVal.
            this.xNumSteps = this.xSteps.slice(0);
            // Convert all numeric steps to the percentage of the subrange they represent.
            for (index = 0; index < this.xNumSteps.length; index++) {
                this.handleStepPoint(index, this.xNumSteps[index]);
            }
        }
        Spectrum.prototype.getDistance = function (value) {
            var index;
            var distances = [];
            for (index = 0; index < this.xNumSteps.length - 1; index++) {
                // last "range" can't contain step size as it is purely an endpoint.
                var step = this.xNumSteps[index];
                if (step && (value / step) % 1 !== 0) {
                    throw new Error("noUiSlider: 'limit', 'margin' and 'padding' of " +
                        this.xPct[index] +
                        "% range must be divisible by step.");
                }
                // Calculate percentual distance in current range of limit, margin or padding
                distances[index] = fromPercentage(this.xVal, value, index);
            }
            return distances;
        };
        // Calculate the percentual distance over the whole scale of ranges.
        // direction: 0 = backwards / 1 = forwards
        Spectrum.prototype.getAbsoluteDistance = function (value, distances, direction) {
            var xPct_index = 0;
            // Calculate range where to start calculation
            if (value < this.xPct[this.xPct.length - 1]) {
                while (value > this.xPct[xPct_index + 1]) {
                    xPct_index++;
                }
            }
            else if (value === this.xPct[this.xPct.length - 1]) {
                xPct_index = this.xPct.length - 2;
            }
            // If looking backwards and the value is exactly at a range separator then look one range further
            if (!direction && value === this.xPct[xPct_index + 1]) {
                xPct_index++;
            }
            if (distances === null) {
                distances = [];
            }
            var start_factor;
            var rest_factor = 1;
            var rest_rel_distance = distances[xPct_index];
            var range_pct = 0;
            var rel_range_distance = 0;
            var abs_distance_counter = 0;
            var range_counter = 0;
            // Calculate what part of the start range the value is
            if (direction) {
                start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            }
            else {
                start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            }
            // Do until the complete distance across ranges is calculated
            while (rest_rel_distance > 0) {
                // Calculate the percentage of total range
                range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
                // Detect if the margin, padding or limit is larger then the current range and calculate
                if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                    // If larger then take the percentual distance of the whole range
                    rel_range_distance = range_pct * start_factor;
                    // Rest factor of relative percentual distance still to be calculated
                    rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                    // Set start factor to 1 as for next range it does not apply.
                    start_factor = 1;
                }
                else {
                    // If smaller or equal then take the percentual distance of the calculate percentual part of that range
                    rel_range_distance = ((distances[xPct_index + range_counter] * range_pct) / 100) * rest_factor;
                    // No rest left as the rest fits in current range
                    rest_factor = 0;
                }
                if (direction) {
                    abs_distance_counter = abs_distance_counter - rel_range_distance;
                    // Limit range to first range when distance becomes outside of minimum range
                    if (this.xPct.length + range_counter >= 1) {
                        range_counter--;
                    }
                }
                else {
                    abs_distance_counter = abs_distance_counter + rel_range_distance;
                    // Limit range to last range when distance becomes outside of maximum range
                    if (this.xPct.length - range_counter >= 1) {
                        range_counter++;
                    }
                }
                // Rest of relative percentual distance still to be calculated
                rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
            }
            return value + abs_distance_counter;
        };
        Spectrum.prototype.toStepping = function (value) {
            value = toStepping(this.xVal, this.xPct, value);
            return value;
        };
        Spectrum.prototype.fromStepping = function (value) {
            return fromStepping(this.xVal, this.xPct, value);
        };
        Spectrum.prototype.getStep = function (value) {
            value = getStep(this.xPct, this.xSteps, this.snap, value);
            return value;
        };
        Spectrum.prototype.getDefaultStep = function (value, isDown, size) {
            var j = getJ(value, this.xPct);
            // When at the top or stepping down, look at the previous sub-range
            if (value === 100 || (isDown && value === this.xPct[j - 1])) {
                j = Math.max(j - 1, 1);
            }
            return (this.xVal[j] - this.xVal[j - 1]) / size;
        };
        Spectrum.prototype.getNearbySteps = function (value) {
            var j = getJ(value, this.xPct);
            return {
                stepBefore: {
                    startValue: this.xVal[j - 2],
                    step: this.xNumSteps[j - 2],
                    highestStep: this.xHighestCompleteStep[j - 2]
                },
                thisStep: {
                    startValue: this.xVal[j - 1],
                    step: this.xNumSteps[j - 1],
                    highestStep: this.xHighestCompleteStep[j - 1]
                },
                stepAfter: {
                    startValue: this.xVal[j],
                    step: this.xNumSteps[j],
                    highestStep: this.xHighestCompleteStep[j]
                }
            };
        };
        Spectrum.prototype.countStepDecimals = function () {
            var stepDecimals = this.xNumSteps.map(countDecimals);
            return Math.max.apply(null, stepDecimals);
        };
        // Outside testing
        Spectrum.prototype.convert = function (value) {
            return this.getStep(this.toStepping(value));
        };
        Spectrum.prototype.handleEntryPoint = function (index, value) {
            var percentage;
            // Covert min/max syntax to 0 and 100.
            if (index === "min") {
                percentage = 0;
            }
            else if (index === "max") {
                percentage = 100;
            }
            else {
                percentage = parseFloat(index);
            }
            // Check for correct input.
            if (!isNumeric(percentage) || !isNumeric(value[0])) {
                throw new Error("noUiSlider: 'range' value isn't numeric.");
            }
            // Store values.
            this.xPct.push(percentage);
            this.xVal.push(value[0]);
            var value1 = Number(value[1]);
            // NaN will evaluate to false too, but to keep
            // logging clear, set step explicitly. Make sure
            // not to override the 'step' setting with false.
            if (!percentage) {
                if (!isNaN(value1)) {
                    this.xSteps[0] = value1;
                }
            }
            else {
                this.xSteps.push(isNaN(value1) ? false : value1);
            }
            this.xHighestCompleteStep.push(0);
        };
        Spectrum.prototype.handleStepPoint = function (i, n) {
            // Ignore 'false' stepping.
            if (!n) {
                return;
            }
            // Step over zero-length ranges (#948);
            if (this.xVal[i] === this.xVal[i + 1]) {
                this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];
                return;
            }
            // Factor to range ratio
            this.xSteps[i] =
                fromPercentage([this.xVal[i], this.xVal[i + 1]], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);
            var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];
            var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
            var step = this.xVal[i] + this.xNumSteps[i] * highestStep;
            this.xHighestCompleteStep[i] = step;
        };
        return Spectrum;
    }());
    //endregion
    //region Options
    /*	Every input option is tested and parsed. This will prevent
        endless validation in internal methods. These tests are
        structured with an item for every option available. An
        option can be marked as required by setting the 'r' flag.
        The testing function is provided with three arguments:
            - The provided value for the option;
            - A reference to the options object;
            - The name for the option;

        The testing function returns false when an error is detected,
        or true when everything is OK. It can also modify the option
        object, to make sure all values can be correctly looped elsewhere. */
    //region Defaults
    var defaultFormatter = {
        to: function (value) {
            return value === undefined ? "" : value.toFixed(2);
        },
        from: Number
    };
    var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
    };
    // Namespaces of internal event listeners
    var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
    };
    //endregion
    function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'step' is not numeric.");
        }
        // The step option can still be used to set stepping
        // for linear sliders. Overwritten if set in 'range'.
        parsed.singleStep = entry;
    }
    function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
        }
        parsed.keyboardPageMultiplier = entry;
    }
    function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
        }
        parsed.keyboardDefaultStep = entry;
    }
    function testRange(parsed, entry) {
        // Filter incorrect input.
        if (typeof entry !== "object" || Array.isArray(entry)) {
            throw new Error("noUiSlider: 'range' is not an object.");
        }
        // Catch missing start or end.
        if (entry.min === undefined || entry.max === undefined) {
            throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
        }
        // Catch equal start or end.
        if (entry.min === entry.max) {
            throw new Error("noUiSlider: 'range' 'min' and 'max' cannot be equal.");
        }
        parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
    }
    function testStart(parsed, entry) {
        entry = asArray(entry);
        // Validate input. Values aren't tested, as the public .val method
        // will always provide a valid location.
        if (!Array.isArray(entry) || !entry.length) {
            throw new Error("noUiSlider: 'start' option is incorrect.");
        }
        // Store the number of handles.
        parsed.handles = entry.length;
        // When the slider is initialized, the .val method will
        // be called with the start options.
        parsed.start = entry;
    }
    function testSnap(parsed, entry) {
        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider: 'snap' option must be a boolean.");
        }
        // Enforce 100% stepping within subranges.
        parsed.snap = entry;
    }
    function testAnimate(parsed, entry) {
        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider: 'animate' option must be a boolean.");
        }
        // Enforce 100% stepping within subranges.
        parsed.animate = entry;
    }
    function testAnimationDuration(parsed, entry) {
        if (typeof entry !== "number") {
            throw new Error("noUiSlider: 'animationDuration' option must be a number.");
        }
        parsed.animationDuration = entry;
    }
    function testConnect(parsed, entry) {
        var connect = [false];
        var i;
        // Map legacy options
        if (entry === "lower") {
            entry = [true, false];
        }
        else if (entry === "upper") {
            entry = [false, true];
        }
        // Handle boolean options
        if (entry === true || entry === false) {
            for (i = 1; i < parsed.handles; i++) {
                connect.push(entry);
            }
            connect.push(false);
        }
        // Reject invalid input
        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
            throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        }
        else {
            connect = entry;
        }
        parsed.connect = connect;
    }
    function testOrientation(parsed, entry) {
        // Set orientation to an a numerical value for easy
        // array selection.
        switch (entry) {
            case "horizontal":
                parsed.ort = 0;
                break;
            case "vertical":
                parsed.ort = 1;
                break;
            default:
                throw new Error("noUiSlider: 'orientation' option is invalid.");
        }
    }
    function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'margin' option must be numeric.");
        }
        // Issue #582
        if (entry === 0) {
            return;
        }
        parsed.margin = parsed.spectrum.getDistance(entry);
    }
    function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'limit' option must be numeric.");
        }
        parsed.limit = parsed.spectrum.getDistance(entry);
        if (!parsed.limit || parsed.handles < 2) {
            throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
    }
    function testPadding(parsed, entry) {
        var index;
        if (!isNumeric(entry) && !Array.isArray(entry)) {
            throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
            throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (entry === 0) {
            return;
        }
        if (!Array.isArray(entry)) {
            entry = [entry, entry];
        }
        // 'getDistance' returns false for invalid values.
        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];
        for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {
            // last "range" can't contain step size as it is purely an endpoint.
            if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {
                throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
            }
        }
        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
        if (totalPadding / (lastValue - firstValue) > 1) {
            throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
    }
    function testDirection(parsed, entry) {
        // Set direction as a numerical value for easy parsing.
        // Invert connection for RTL sliders, so that the proper
        // handles get the connect/background classes.
        switch (entry) {
            case "ltr":
                parsed.dir = 0;
                break;
            case "rtl":
                parsed.dir = 1;
                break;
            default:
                throw new Error("noUiSlider: 'direction' option was not recognized.");
        }
    }
    function testBehaviour(parsed, entry) {
        // Make sure the input is a string.
        if (typeof entry !== "string") {
            throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
        }
        // Check if the string contains any keywords.
        // None are required.
        var tap = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;
        if (fixed) {
            if (parsed.handles !== 2) {
                throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
            }
            // Use margin to enforce fixed state
            testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }
        if (unconstrained && (parsed.margin || parsed.limit)) {
            throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
        }
        parsed.events = {
            tap: tap || snap,
            drag: drag,
            fixed: fixed,
            snap: snap,
            hover: hover,
            unconstrained: unconstrained
        };
    }
    function testTooltips(parsed, entry) {
        if (entry === false) {
            return;
        }
        if (entry === true || isValidPartialFormatter(entry)) {
            parsed.tooltips = [];
            for (var i = 0; i < parsed.handles; i++) {
                parsed.tooltips.push(entry);
            }
        }
        else {
            entry = asArray(entry);
            if (entry.length !== parsed.handles) {
                throw new Error("noUiSlider: must pass a formatter for all handles.");
            }
            entry.forEach(function (formatter) {
                if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
                    throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
                }
            });
            parsed.tooltips = entry;
        }
    }
    function testAriaFormat(parsed, entry) {
        if (!isValidPartialFormatter(entry)) {
            throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
        }
        parsed.ariaFormat = entry;
    }
    function testFormat(parsed, entry) {
        if (!isValidFormatter(entry)) {
            throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
        }
        parsed.format = entry;
    }
    function testKeyboardSupport(parsed, entry) {
        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
        }
        parsed.keyboardSupport = entry;
    }
    function testDocumentElement(parsed, entry) {
        // This is an advanced option. Passed values are used without validation.
        parsed.documentElement = entry;
    }
    function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
            throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
        }
        parsed.cssPrefix = entry;
    }
    function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
            throw new Error("noUiSlider: 'cssClasses' must be an object.");
        }
        if (typeof parsed.cssPrefix === "string") {
            parsed.cssClasses = {};
            Object.keys(entry).forEach(function (key) {
                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
            });
        }
        else {
            parsed.cssClasses = entry;
        }
    }
    // Test all developer settings and parse to assumption-safe values.
    function testOptions(options) {
        // To prove a fix for #537, freeze options here.
        // If the object is modified, an error will be thrown.
        // Object.freeze(options);
        var parsed = {
            margin: null,
            limit: null,
            padding: null,
            animate: true,
            animationDuration: 300,
            ariaFormat: defaultFormatter,
            format: defaultFormatter
        };
        // Tests are executed in the order they are presented here.
        var tests = {
            step: { r: false, t: testStep },
            keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
            keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
            start: { r: true, t: testStart },
            connect: { r: true, t: testConnect },
            direction: { r: true, t: testDirection },
            snap: { r: false, t: testSnap },
            animate: { r: false, t: testAnimate },
            animationDuration: { r: false, t: testAnimationDuration },
            range: { r: true, t: testRange },
            orientation: { r: false, t: testOrientation },
            margin: { r: false, t: testMargin },
            limit: { r: false, t: testLimit },
            padding: { r: false, t: testPadding },
            behaviour: { r: true, t: testBehaviour },
            ariaFormat: { r: false, t: testAriaFormat },
            format: { r: false, t: testFormat },
            tooltips: { r: false, t: testTooltips },
            keyboardSupport: { r: true, t: testKeyboardSupport },
            documentElement: { r: false, t: testDocumentElement },
            cssPrefix: { r: true, t: testCssPrefix },
            cssClasses: { r: true, t: testCssClasses }
        };
        var defaults = {
            connect: false,
            direction: "ltr",
            behaviour: "tap",
            orientation: "horizontal",
            keyboardSupport: true,
            cssPrefix: "noUi-",
            cssClasses: cssClasses,
            keyboardPageMultiplier: 5,
            keyboardDefaultStep: 10
        };
        // AriaFormat defaults to regular format, if any.
        if (options.format && !options.ariaFormat) {
            options.ariaFormat = options.format;
        }
        // Run all options through a testing mechanism to ensure correct
        // input. It should be noted that options might get modified to
        // be handled properly. E.g. wrapping integers in arrays.
        Object.keys(tests).forEach(function (name) {
            // If the option isn't set, but it is required, throw an error.
            if (!isSet(options[name]) && defaults[name] === undefined) {
                if (tests[name].r) {
                    throw new Error("noUiSlider: '" + name + "' is required.");
                }
                return;
            }
            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
        });
        // Forward pips options
        parsed.pips = options.pips;
        // All recent browsers accept unprefixed transform.
        // We need -ms- for IE9 and -webkit- for older Android;
        // Assume use of -webkit- if unprefixed and -ms- are not supported.
        // https://caniuse.com/#feat=transforms2d
        var d = document.createElement("div");
        var msPrefix = d.style.msTransform !== undefined;
        var noPrefix = d.style.transform !== undefined;
        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
        // Pips don't move, so we can place them using left/top.
        var styles = [["left", "top"], ["right", "bottom"]];
        parsed.style = styles[parsed.dir][parsed.ort];
        return parsed;
    }
    //endregion
    function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive();
        // All variables local to 'scope' are prefixed with 'scope_'
        // Slider DOM Nodes
        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips;
        // Slider state values
        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {};
        // Document Nodes
        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body;
        // For horizontal sliders in standard ltr documents,
        // make .noUi-origin overflow to the left so the document doesn't scroll.
        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
        // Creates a node, adds it to target, returns the new node.
        function addNodeTo(addTarget, className) {
            var div = scope_Document.createElement("div");
            if (className) {
                addClass(div, className);
            }
            addTarget.appendChild(div);
            return div;
        }
        // Append a origin to the base
        function addOrigin(base, handleNumber) {
            var origin = addNodeTo(base, options.cssClasses.origin);
            var handle = addNodeTo(origin, options.cssClasses.handle);
            addNodeTo(handle, options.cssClasses.touchArea);
            handle.setAttribute("data-handle", String(handleNumber));
            if (options.keyboardSupport) {
                // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                // 0 = focusable and reachable
                handle.setAttribute("tabindex", "0");
                handle.addEventListener("keydown", function (event) {
                    return eventKeydown(event, handleNumber);
                });
            }
            handle.setAttribute("role", "slider");
            handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
            if (handleNumber === 0) {
                addClass(handle, options.cssClasses.handleLower);
            }
            else if (handleNumber === options.handles - 1) {
                addClass(handle, options.cssClasses.handleUpper);
            }
            return origin;
        }
        // Insert nodes for connect elements
        function addConnect(base, add) {
            if (!add) {
                return false;
            }
            return addNodeTo(base, options.cssClasses.connect);
        }
        // Add handles to the slider base.
        function addElements(connectOptions, base) {
            var connectBase = addNodeTo(base, options.cssClasses.connects);
            scope_Handles = [];
            scope_Connects = [];
            scope_Connects.push(addConnect(connectBase, connectOptions[0]));
            // [::::O====O====O====]
            // connectOptions = [0, 1, 1, 1]
            for (var i = 0; i < options.handles; i++) {
                // Keep a list of all added handles.
                scope_Handles.push(addOrigin(base, i));
                scope_HandleNumbers[i] = i;
                scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
            }
        }
        // Initialize a single slider.
        function addSlider(addTarget) {
            // Apply classes and data to the target.
            addClass(addTarget, options.cssClasses.target);
            if (options.dir === 0) {
                addClass(addTarget, options.cssClasses.ltr);
            }
            else {
                addClass(addTarget, options.cssClasses.rtl);
            }
            if (options.ort === 0) {
                addClass(addTarget, options.cssClasses.horizontal);
            }
            else {
                addClass(addTarget, options.cssClasses.vertical);
            }
            var textDirection = getComputedStyle(addTarget).direction;
            if (textDirection === "rtl") {
                addClass(addTarget, options.cssClasses.textDirectionRtl);
            }
            else {
                addClass(addTarget, options.cssClasses.textDirectionLtr);
            }
            return addNodeTo(addTarget, options.cssClasses.base);
        }
        function addTooltip(handle, handleNumber) {
            if (!options.tooltips || !options.tooltips[handleNumber]) {
                return false;
            }
            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }
        function isSliderDisabled() {
            return scope_Target.hasAttribute("disabled");
        }
        // Disable the slider dragging if any handle is disabled
        function isHandleDisabled(handleNumber) {
            var handleOrigin = scope_Handles[handleNumber];
            return handleOrigin.hasAttribute("disabled");
        }
        function removeTooltips() {
            if (scope_Tooltips) {
                removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
                scope_Tooltips.forEach(function (tooltip) {
                    if (tooltip) {
                        removeElement(tooltip);
                    }
                });
                scope_Tooltips = null;
            }
        }
        // The tooltips option is a shorthand for using the 'update' event.
        function tooltips() {
            removeTooltips();
            // Tooltips are added with options.tooltips in original order.
            scope_Tooltips = scope_Handles.map(addTooltip);
            bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function (values, handleNumber, unencoded) {
                if (!scope_Tooltips || !options.tooltips) {
                    return;
                }
                if (scope_Tooltips[handleNumber] === false) {
                    return;
                }
                var formattedValue = values[handleNumber];
                if (options.tooltips[handleNumber] !== true) {
                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
                }
                scope_Tooltips[handleNumber].innerHTML = formattedValue;
            });
        }
        function aria() {
            removeEvent("update" + INTERNAL_EVENT_NS.aria);
            bindEvent("update" + INTERNAL_EVENT_NS.aria, function (values, handleNumber, unencoded, tap, positions) {
                // Update Aria Values for all handles, as a change in one changes min and max values for the next.
                scope_HandleNumbers.forEach(function (index) {
                    var handle = scope_Handles[index];
                    var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
                    var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);
                    var now = positions[index];
                    // Formatted value for display
                    var text = String(options.ariaFormat.to(unencoded[index]));
                    // Map to slider range values
                    min = scope_Spectrum.fromStepping(min).toFixed(1);
                    max = scope_Spectrum.fromStepping(max).toFixed(1);
                    now = scope_Spectrum.fromStepping(now).toFixed(1);
                    handle.children[0].setAttribute("aria-valuemin", min);
                    handle.children[0].setAttribute("aria-valuemax", max);
                    handle.children[0].setAttribute("aria-valuenow", now);
                    handle.children[0].setAttribute("aria-valuetext", text);
                });
            });
        }
        function getGroup(pips) {
            // Use the range.
            if (pips.mode === exports.PipsMode.Range || pips.mode === exports.PipsMode.Steps) {
                return scope_Spectrum.xVal;
            }
            if (pips.mode === exports.PipsMode.Count) {
                if (pips.values < 2) {
                    throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
                }
                // Divide 0 - 100 in 'count' parts.
                var interval = pips.values - 1;
                var spread = 100 / interval;
                var values = [];
                // List these parts and have them handled as 'positions'.
                while (interval--) {
                    values[interval] = interval * spread;
                }
                values.push(100);
                return mapToRange(values, pips.stepped);
            }
            if (pips.mode === exports.PipsMode.Positions) {
                // Map all percentages to on-range values.
                return mapToRange(pips.values, pips.stepped);
            }
            if (pips.mode === exports.PipsMode.Values) {
                // If the value must be stepped, it needs to be converted to a percentage first.
                if (pips.stepped) {
                    return pips.values.map(function (value) {
                        // Convert to percentage, apply step, return to value.
                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                    });
                }
                // Otherwise, we can simply use the values.
                return pips.values;
            }
            return []; // pips.mode = never
        }
        function mapToRange(values, stepped) {
            return values.map(function (value) {
                return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
            });
        }
        function generateSpread(pips) {
            function safeIncrement(value, increment) {
                // Avoid floating point variance by dropping the smallest decimal places.
                return Number((value + increment).toFixed(7));
            }
            var group = getGroup(pips);
            var indexes = {};
            var firstInRange = scope_Spectrum.xVal[0];
            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
            var ignoreFirst = false;
            var ignoreLast = false;
            var prevPct = 0;
            // Create a copy of the group, sort it and filter away all duplicates.
            group = unique(group.slice().sort(function (a, b) {
                return a - b;
            }));
            // Make sure the range starts with the first element.
            if (group[0] !== firstInRange) {
                group.unshift(firstInRange);
                ignoreFirst = true;
            }
            // Likewise for the last one.
            if (group[group.length - 1] !== lastInRange) {
                group.push(lastInRange);
                ignoreLast = true;
            }
            group.forEach(function (current, index) {
                // Get the current step and the lower + upper positions.
                var step;
                var i;
                var q;
                var low = current;
                var high = group[index + 1];
                var newPct;
                var pctDifference;
                var pctPos;
                var type;
                var steps;
                var realSteps;
                var stepSize;
                var isSteps = pips.mode === exports.PipsMode.Steps;
                // When using 'steps' mode, use the provided steps.
                // Otherwise, we'll step on to the next subrange.
                if (isSteps) {
                    step = scope_Spectrum.xNumSteps[index];
                }
                // Default to a 'full' step.
                if (!step) {
                    step = high - low;
                }
                // If high is undefined we are at the last subrange. Make sure it iterates once (#1088)
                if (high === undefined) {
                    high = low;
                }
                // Make sure step isn't 0, which would cause an infinite loop (#654)
                step = Math.max(step, 0.0000001);
                // Find all steps in the subrange.
                for (i = low; i <= high; i = safeIncrement(i, step)) {
                    // Get the percentage value for the current step,
                    // calculate the size for the subrange.
                    newPct = scope_Spectrum.toStepping(i);
                    pctDifference = newPct - prevPct;
                    steps = pctDifference / (pips.density || 1);
                    realSteps = Math.round(steps);
                    // This ratio represents the amount of percentage-space a point indicates.
                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.
                    // Round the percentage offset to an even number, then divide by two
                    // to spread the offset on both sides of the range.
                    stepSize = pctDifference / realSteps;
                    // Divide all points evenly, adding the correct number to this subrange.
                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.
                    for (q = 1; q <= realSteps; q += 1) {
                        // The ratio between the rounded value and the actual size might be ~1% off.
                        // Correct the percentage offset by the number of points
                        // per subrange. density = 1 will result in 100 points on the
                        // full range, 2 for 50, 4 for 25, etc.
                        pctPos = prevPct + q * stepSize;
                        indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
                    }
                    // Determine the point type.
                    type = group.indexOf(i) > -1 ? exports.PipsType.LargeValue : isSteps ? exports.PipsType.SmallValue : exports.PipsType.NoValue;
                    // Enforce the 'ignoreFirst' option by overwriting the type for 0.
                    if (!index && ignoreFirst && i !== high) {
                        type = 0;
                    }
                    if (!(i === high && ignoreLast)) {
                        // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
                        indexes[newPct.toFixed(5)] = [i, type];
                    }
                    // Update the percentage count.
                    prevPct = newPct;
                }
            });
            return indexes;
        }
        function addMarking(spread, filterFunc, formatter) {
            var _a, _b;
            var element = scope_Document.createElement("div");
            var valueSizeClasses = (_a = {},
                _a[exports.PipsType.None] = "",
                _a[exports.PipsType.NoValue] = options.cssClasses.valueNormal,
                _a[exports.PipsType.LargeValue] = options.cssClasses.valueLarge,
                _a[exports.PipsType.SmallValue] = options.cssClasses.valueSub,
                _a);
            var markerSizeClasses = (_b = {},
                _b[exports.PipsType.None] = "",
                _b[exports.PipsType.NoValue] = options.cssClasses.markerNormal,
                _b[exports.PipsType.LargeValue] = options.cssClasses.markerLarge,
                _b[exports.PipsType.SmallValue] = options.cssClasses.markerSub,
                _b);
            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
            addClass(element, options.cssClasses.pips);
            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
            function getClasses(type, source) {
                var a = source === options.cssClasses.value;
                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
                return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
            }
            function addSpread(offset, value, type) {
                // Apply the filter function, if it is set.
                type = filterFunc ? filterFunc(value, type) : type;
                if (type === exports.PipsType.None) {
                    return;
                }
                // Add a marker for every point
                var node = addNodeTo(element, false);
                node.className = getClasses(type, options.cssClasses.marker);
                node.style[options.style] = offset + "%";
                // Values are only appended for points marked '1' or '2'.
                if (type > exports.PipsType.NoValue) {
                    node = addNodeTo(element, false);
                    node.className = getClasses(type, options.cssClasses.value);
                    node.setAttribute("data-value", String(value));
                    node.style[options.style] = offset + "%";
                    node.innerHTML = String(formatter.to(value));
                }
            }
            // Append all points.
            Object.keys(spread).forEach(function (offset) {
                addSpread(offset, spread[offset][0], spread[offset][1]);
            });
            return element;
        }
        function removePips() {
            if (scope_Pips) {
                removeElement(scope_Pips);
                scope_Pips = null;
            }
        }
        function pips(pips) {
            // Fix #669
            removePips();
            var spread = generateSpread(pips);
            var filter = pips.filter;
            var format = pips.format || {
                to: function (value) {
                    return String(Math.round(value));
                }
            };
            scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));
            return scope_Pips;
        }
        // Shorthand for base dimensions.
        function baseSize() {
            var rect = scope_Base.getBoundingClientRect();
            var alt = ("offset" + ["Width", "Height"][options.ort]);
            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        }
        // Handler for attaching events trough a proxy.
        function attachEvent(events, element, callback, data) {
            // This function can be used to 'filter' events to the slider.
            // element is a node, not a nodeList
            var method = function (event) {
                var e = fixEvent(event, data.pageOffset, data.target || element);
                // fixEvent returns false if this event has a different target
                // when handling (multi-) touch events;
                if (!e) {
                    return false;
                }
                // doNotReject is passed by all end events to make sure released touches
                // are not rejected, leaving the slider "stuck" to the cursor;
                if (isSliderDisabled() && !data.doNotReject) {
                    return false;
                }
                // Stop if an active 'tap' transition is taking place.
                if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
                    return false;
                }
                // Ignore right or middle clicks on start #454
                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {
                    return false;
                }
                // Ignore right or middle clicks on start #454
                if (data.hover && e.buttons) {
                    return false;
                }
                // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
                // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
                // touch-action: manipulation, but that allows panning, which breaks
                // sliders after zooming/on non-responsive pages.
                // See: https://bugs.webkit.org/show_bug.cgi?id=133112
                if (!supportsPassive) {
                    e.preventDefault();
                }
                e.calcPoint = e.points[options.ort];
                // Call the event handler with the event [ and additional data ].
                callback(e, data);
                return;
            };
            var methods = [];
            // Bind a closure on the target for every event type.
            events.split(" ").forEach(function (eventName) {
                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
                methods.push([eventName, method]);
            });
            return methods;
        }
        // Provide a clean event with standardized offset values.
        function fixEvent(e, pageOffset, eventTarget) {
            // Filter the event to register the type, which can be
            // touch, mouse or pointer. Offset changes need to be
            // made on an event specific basis.
            var touch = e.type.indexOf("touch") === 0;
            var mouse = e.type.indexOf("mouse") === 0;
            var pointer = e.type.indexOf("pointer") === 0;
            var x = 0;
            var y = 0;
            // IE10 implemented pointer events with a prefix;
            if (e.type.indexOf("MSPointer") === 0) {
                pointer = true;
            }
            // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with
            // the slider. They appear to be of type MouseEvent, yet they don't have usual properties set. Ignore
            // events that have no touches or buttons associated with them. (#1057, #1079, #1095)
            if (e.type === "mousedown" && !e.buttons && !e.touches) {
                return false;
            }
            // The only thing one handle should be concerned about is the touches that originated on top of it.
            if (touch) {
                // Returns true if a touch originated on the target.
                var isTouchOnTarget = function (checkTouch) {
                    var target = checkTouch.target;
                    return (target === eventTarget ||
                        eventTarget.contains(target) ||
                        (e.composed && e.composedPath().shift() === eventTarget));
                };
                // In the case of touchstart events, we need to make sure there is still no more than one
                // touch on the target so we look amongst all touches.
                if (e.type === "touchstart") {
                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
                    // Do not support more than one touch per handle.
                    if (targetTouches.length > 1) {
                        return false;
                    }
                    x = targetTouches[0].pageX;
                    y = targetTouches[0].pageY;
                }
                else {
                    // In the other cases, find on changedTouches is enough.
                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
                    // Cancel if the target touch has not moved.
                    if (!targetTouch) {
                        return false;
                    }
                    x = targetTouch.pageX;
                    y = targetTouch.pageY;
                }
            }
            pageOffset = pageOffset || getPageOffset(scope_Document);
            if (mouse || pointer) {
                x = e.clientX + pageOffset.x;
                y = e.clientY + pageOffset.y;
            }
            e.pageOffset = pageOffset;
            e.points = [x, y];
            e.cursor = mouse || pointer; // Fix #435
            return e;
        }
        // Translate a coordinate in the document to a percentage on the slider
        function calcPointToPercentage(calcPoint) {
            var location = calcPoint - offset(scope_Base, options.ort);
            var proposal = (location * 100) / baseSize();
            // Clamp proposal between 0% and 100%
            // Out-of-bound coordinates may occur when .noUi-base pseudo-elements
            // are used (e.g. contained handles feature)
            proposal = limit(proposal);
            return options.dir ? 100 - proposal : proposal;
        }
        // Find handle closest to a certain percentage on the slider
        function getClosestHandle(clickedPosition) {
            var smallestDifference = 100;
            var handleNumber = false;
            scope_Handles.forEach(function (handle, index) {
                // Disabled handles are ignored
                if (isHandleDisabled(index)) {
                    return;
                }
                var handlePosition = scope_Locations[index];
                var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
                // Initial state
                var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
                // Difference with this handle is smaller than the previously checked handle
                var isCloser = differenceWithThisHandle < smallestDifference;
                var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
                if (isCloser || isCloserAfter || clickAtEdge) {
                    handleNumber = index;
                    smallestDifference = differenceWithThisHandle;
                }
            });
            return handleNumber;
        }
        // Fire 'end' when a mouse or pen leaves the document.
        function documentLeave(event, data) {
            if (event.type === "mouseout" &&
                event.target.nodeName === "HTML" &&
                event.relatedTarget === null) {
                eventEnd(event, data);
            }
        }
        // Handle movement on document for handle and range drag.
        function eventMove(event, data) {
            // Fix #498
            // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
            // IE9 has .buttons and .which zero on mousemove.
            // Firefox breaks the spec MDN defines.
            if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
                return eventEnd(event, data);
            }
            // Check if we are moving up or down
            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
            // Convert the movement into a percentage of the slider width/height
            var proposal = (movement * 100) / data.baseSize;
            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
        }
        // Unbind move events on document, call callbacks.
        function eventEnd(event, data) {
            // The handle is no longer active, so remove the class.
            if (data.handle) {
                removeClass(data.handle, options.cssClasses.active);
                scope_ActiveHandlesCount -= 1;
            }
            // Unbind the move and end events, which are added on 'start'.
            data.listeners.forEach(function (c) {
                scope_DocumentElement.removeEventListener(c[0], c[1]);
            });
            if (scope_ActiveHandlesCount === 0) {
                // Remove dragging class.
                removeClass(scope_Target, options.cssClasses.drag);
                setZindex();
                // Remove cursor styles and text-selection events bound to the body.
                if (event.cursor) {
                    scope_Body.style.cursor = "";
                    scope_Body.removeEventListener("selectstart", preventDefault);
                }
            }
            data.handleNumbers.forEach(function (handleNumber) {
                fireEvent("change", handleNumber);
                fireEvent("set", handleNumber);
                fireEvent("end", handleNumber);
            });
        }
        // Bind move events on document.
        function eventStart(event, data) {
            // Ignore event if any handle is disabled
            if (data.handleNumbers.some(isHandleDisabled)) {
                return;
            }
            var handle;
            if (data.handleNumbers.length === 1) {
                var handleOrigin = scope_Handles[data.handleNumbers[0]];
                handle = handleOrigin.children[0];
                scope_ActiveHandlesCount += 1;
                // Mark the handle as 'active' so it can be styled.
                addClass(handle, options.cssClasses.active);
            }
            // A drag should never propagate up to the 'tap' event.
            event.stopPropagation();
            // Record the event listeners.
            var listeners = [];
            // Attach the move and end events.
            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                // The event target has changed so we need to propagate the original one so that we keep
                // relying on it to extract target touches.
                target: event.target,
                handle: handle,
                connect: data.connect,
                listeners: listeners,
                startCalcPoint: event.calcPoint,
                baseSize: baseSize(),
                pageOffset: event.pageOffset,
                handleNumbers: data.handleNumbers,
                buttonsProperty: event.buttons,
                locations: scope_Locations.slice()
            });
            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                target: event.target,
                handle: handle,
                listeners: listeners,
                doNotReject: true,
                handleNumbers: data.handleNumbers
            });
            var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                target: event.target,
                handle: handle,
                listeners: listeners,
                doNotReject: true,
                handleNumbers: data.handleNumbers
            });
            // We want to make sure we pushed the listeners in the listener list rather than creating
            // a new one as it has already been passed to the event handlers.
            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
            // Text selection isn't an issue on touch devices,
            // so adding cursor styles can be skipped.
            if (event.cursor) {
                // Prevent the 'I' cursor and extend the range-drag cursor.
                scope_Body.style.cursor = getComputedStyle(event.target).cursor;
                // Mark the target with a dragging state.
                if (scope_Handles.length > 1) {
                    addClass(scope_Target, options.cssClasses.drag);
                }
                // Prevent text selection when dragging the handles.
                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
                // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
                // The 'cursor' flag is false.
                // See: http://caniuse.com/#search=selectstart
                scope_Body.addEventListener("selectstart", preventDefault, false);
            }
            data.handleNumbers.forEach(function (handleNumber) {
                fireEvent("start", handleNumber);
            });
        }
        // Move closest handle to tapped location.
        function eventTap(event) {
            // The tap event shouldn't propagate up
            event.stopPropagation();
            var proposal = calcPointToPercentage(event.calcPoint);
            var handleNumber = getClosestHandle(proposal);
            // Tackle the case that all handles are 'disabled'.
            if (handleNumber === false) {
                return;
            }
            // Flag the slider as it is now in a transitional state.
            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.
            if (!options.events.snap) {
                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }
            setHandle(handleNumber, proposal, true, true);
            setZindex();
            fireEvent("slide", handleNumber, true);
            fireEvent("update", handleNumber, true);
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);
            if (options.events.snap) {
                eventStart(event, { handleNumbers: [handleNumber] });
            }
        }
        // Fires a 'hover' event for a hovered mouse/pen position.
        function eventHover(event) {
            var proposal = calcPointToPercentage(event.calcPoint);
            var to = scope_Spectrum.getStep(proposal);
            var value = scope_Spectrum.fromStepping(to);
            Object.keys(scope_Events).forEach(function (targetEvent) {
                if ("hover" === targetEvent.split(".")[0]) {
                    scope_Events[targetEvent].forEach(function (callback) {
                        callback.call(scope_Self, value);
                    });
                }
            });
        }
        // Handles keydown on focused handles
        // Don't move the document when pressing arrow keys on focused handles
        function eventKeydown(event, handleNumber) {
            if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
                return false;
            }
            var horizontalKeys = ["Left", "Right"];
            var verticalKeys = ["Down", "Up"];
            var largeStepKeys = ["PageDown", "PageUp"];
            var edgeKeys = ["Home", "End"];
            if (options.dir && !options.ort) {
                // On an right-to-left slider, the left and right keys act inverted
                horizontalKeys.reverse();
            }
            else if (options.ort && !options.dir) {
                // On a top-to-bottom slider, the up and down keys act inverted
                verticalKeys.reverse();
                largeStepKeys.reverse();
            }
            // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
            var key = event.key.replace("Arrow", "");
            var isLargeDown = key === largeStepKeys[0];
            var isLargeUp = key === largeStepKeys[1];
            var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
            var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
            var isMin = key === edgeKeys[0];
            var isMax = key === edgeKeys[1];
            if (!isDown && !isUp && !isMin && !isMax) {
                return true;
            }
            event.preventDefault();
            var to;
            if (isUp || isDown) {
                var multiplier = options.keyboardPageMultiplier;
                var direction = isDown ? 0 : 1;
                var steps = getNextStepsForHandle(handleNumber);
                var step = steps[direction];
                // At the edge of a slider, do nothing
                if (step === null) {
                    return false;
                }
                // No step set, use the default of 10% of the sub-range
                if (step === false) {
                    step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
                }
                if (isLargeUp || isLargeDown) {
                    step *= multiplier;
                }
                // Step over zero-length ranges (#948);
                step = Math.max(step, 0.0000001);
                // Decrement for down steps
                step = (isDown ? -1 : 1) * step;
                to = scope_Values[handleNumber] + step;
            }
            else if (isMax) {
                // End key
                to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
            }
            else {
                // Home key
                to = options.spectrum.xVal[0];
            }
            setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
            fireEvent("slide", handleNumber);
            fireEvent("update", handleNumber);
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            return false;
        }
        // Attach events to several slider parts.
        function bindSliderEvents(behaviour) {
            // Attach the standard drag event to the handles.
            if (!behaviour.fixed) {
                scope_Handles.forEach(function (handle, index) {
                    // These events are only bound to the visual handle
                    // element, not the 'real' origin element.
                    attachEvent(actions.start, handle.children[0], eventStart, {
                        handleNumbers: [index]
                    });
                });
            }
            // Attach the tap event to the slider base.
            if (behaviour.tap) {
                attachEvent(actions.start, scope_Base, eventTap, {});
            }
            // Fire hover events
            if (behaviour.hover) {
                attachEvent(actions.move, scope_Base, eventHover, {
                    hover: true
                });
            }
            // Make the range draggable.
            if (behaviour.drag) {
                scope_Connects.forEach(function (connect, index) {
                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {
                        return;
                    }
                    var handleBefore = scope_Handles[index - 1];
                    var handleAfter = scope_Handles[index];
                    var eventHolders = [connect];
                    addClass(connect, options.cssClasses.draggable);
                    // When the range is fixed, the entire range can
                    // be dragged by the handles. The handle in the first
                    // origin will propagate the start event upward,
                    // but it needs to be bound manually on the other.
                    if (behaviour.fixed) {
                        eventHolders.push(handleBefore.children[0]);
                        eventHolders.push(handleAfter.children[0]);
                    }
                    eventHolders.forEach(function (eventHolder) {
                        attachEvent(actions.start, eventHolder, eventStart, {
                            handles: [handleBefore, handleAfter],
                            handleNumbers: [index - 1, index],
                            connect: connect
                        });
                    });
                });
            }
        }
        // Attach an event to this slider, possibly including a namespace
        function bindEvent(namespacedEvent, callback) {
            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
            scope_Events[namespacedEvent].push(callback);
            // If the event bound is 'update,' fire it immediately for all handles.
            if (namespacedEvent.split(".")[0] === "update") {
                scope_Handles.forEach(function (a, index) {
                    fireEvent("update", index);
                });
            }
        }
        function isInternalNamespace(namespace) {
            return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        }
        // Undo attachment of event
        function removeEvent(namespacedEvent) {
            var event = namespacedEvent && namespacedEvent.split(".")[0];
            var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
            Object.keys(scope_Events).forEach(function (bind) {
                var tEvent = bind.split(".")[0];
                var tNamespace = bind.substring(tEvent.length);
                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
                    // only delete protected internal event if intentional
                    if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                        delete scope_Events[bind];
                    }
                }
            });
        }
        // External event handling
        function fireEvent(eventName, handleNumber, tap) {
            Object.keys(scope_Events).forEach(function (targetEvent) {
                var eventType = targetEvent.split(".")[0];
                if (eventName === eventType) {
                    scope_Events[targetEvent].forEach(function (callback) {
                        callback.call(
                        // Use the slider public API as the scope ('this')
                        scope_Self, 
                        // Return values as array, so arg_1[arg_2] is always valid.
                        scope_Values.map(options.format.to), 
                        // Handle index, 0 or 1
                        handleNumber, 
                        // Un-formatted slider values
                        scope_Values.slice(), 
                        // Event is fired by tap, true or false
                        tap || false, 
                        // Left offset of the handle, in relation to the slider
                        scope_Locations.slice(), 
                        // add the slider public API to an accessible parameter when this is unavailable
                        scope_Self);
                    });
                }
            });
        }
        // Split out the handle positioning logic so the Move event can use it, too
        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
            var distance;
            // For sliders with multiple handles, limit movement to the other handle.
            // Apply the margin option by adding it to the handle positions.
            if (scope_Handles.length > 1 && !options.events.unconstrained) {
                if (lookBackward && handleNumber > 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
                    to = Math.max(to, distance);
                }
                if (lookForward && handleNumber < scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
                    to = Math.min(to, distance);
                }
            }
            // The limit option has the opposite effect, limiting handles to a
            // maximum distance from another. Limit must be > 0, as otherwise
            // handles would be unmovable.
            if (scope_Handles.length > 1 && options.limit) {
                if (lookBackward && handleNumber > 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
                    to = Math.min(to, distance);
                }
                if (lookForward && handleNumber < scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
                    to = Math.max(to, distance);
                }
            }
            // The padding option keeps the handles a certain distance from the
            // edges of the slider. Padding must be > 0.
            if (options.padding) {
                if (handleNumber === 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
                    to = Math.max(to, distance);
                }
                if (handleNumber === scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
                    to = Math.min(to, distance);
                }
            }
            to = scope_Spectrum.getStep(to);
            // Limit percentage to the 0 - 100 range
            to = limit(to);
            // Return false if handle can't move
            if (to === reference[handleNumber] && !getValue) {
                return false;
            }
            return to;
        }
        // Uses slider orientation to create CSS rules. a = base value;
        function inRuleOrder(v, a) {
            var o = options.ort;
            return (o ? a : v) + ", " + (o ? v : a);
        }
        // Moves handle(s) by a percentage
        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])
        function moveHandles(upward, proposal, locations, handleNumbers, connect) {
            var proposals = locations.slice();
            // Store first handle now, so we still have it in case handleNumbers is reversed
            var firstHandle = handleNumbers[0];
            var b = [!upward, upward];
            var f = [upward, !upward];
            // Copy handleNumbers so we don't change the dataset
            handleNumbers = handleNumbers.slice();
            // Check to see which handle is 'leading'.
            // If that one can't move the second can't either.
            if (upward) {
                handleNumbers.reverse();
            }
            // Step 1: get the maximum percentage that any of the handles can move
            if (handleNumbers.length > 1) {
                handleNumbers.forEach(function (handleNumber, o) {
                    var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false);
                    // Stop if one of the handles can't move.
                    if (to === false) {
                        proposal = 0;
                    }
                    else {
                        proposal = to - proposals[handleNumber];
                        proposals[handleNumber] = to;
                    }
                });
            }
            // If using one handle, check backward AND forward
            else {
                b = f = [true];
            }
            var state = false;
            // Step 2: Try to set the handles with the found percentage
            handleNumbers.forEach(function (handleNumber, o) {
                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
            });
            // Step 3: If a handle moved, fire events
            if (state) {
                handleNumbers.forEach(function (handleNumber) {
                    fireEvent("update", handleNumber);
                    fireEvent("slide", handleNumber);
                });
                // If target is a connect, then fire drag event
                if (connect != undefined) {
                    fireEvent("drag", firstHandle);
                }
            }
        }
        // Takes a base value and an offset. This offset is used for the connect bar size.
        // In the initial design for this feature, the origin element was 1% wide.
        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature
        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223
        function transformDirection(a, b) {
            return options.dir ? 100 - a - b : a;
        }
        // Updates scope_Locations and scope_Values, updates visual state
        function updateHandlePosition(handleNumber, to) {
            // Update locations.
            scope_Locations[handleNumber] = to;
            // Convert the value to the slider stepping/range.
            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
            var translation = 10 * (transformDirection(to, 0) - scope_DirOffset);
            var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
            scope_Handles[handleNumber].style[options.transformRule] = translateRule;
            updateConnect(handleNumber);
            updateConnect(handleNumber + 1);
        }
        // Handles before the slider middle are stacked later = higher,
        // Handles after the middle later is lower
        // [[7] [8] .......... | .......... [5] [4]
        function setZindex() {
            scope_HandleNumbers.forEach(function (handleNumber) {
                var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
                var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
                scope_Handles[handleNumber].style.zIndex = String(zIndex);
            });
        }
        // Test suggested values and apply margin, step.
        // if exactInput is true, don't run checkHandlePosition, then the handle can be placed in between steps (#436)
        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
            if (!exactInput) {
                to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);
            }
            if (to === false) {
                return false;
            }
            updateHandlePosition(handleNumber, to);
            return true;
        }
        // Updates style attribute for connect nodes
        function updateConnect(index) {
            // Skip connects set to false
            if (!scope_Connects[index]) {
                return;
            }
            var l = 0;
            var h = 100;
            if (index !== 0) {
                l = scope_Locations[index - 1];
            }
            if (index !== scope_Connects.length - 1) {
                h = scope_Locations[index];
            }
            // We use two rules:
            // 'translate' to change the left/top offset;
            // 'scale' to change the width of the element;
            // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)
            var connectWidth = h - l;
            var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
            var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
            scope_Connects[index].style[options.transformRule] =
                translateRule + " " + scaleRule;
        }
        // Parses value passed to .set method. Returns current value if not parse-able.
        function resolveToValue(to, handleNumber) {
            // Setting with null indicates an 'ignore'.
            // Inputting 'false' is invalid.
            if (to === null || to === false || to === undefined) {
                return scope_Locations[handleNumber];
            }
            // If a formatted number was passed, attempt to decode it.
            if (typeof to === "number") {
                to = String(to);
            }
            to = options.format.from(to);
            if (to !== false) {
                to = scope_Spectrum.toStepping(to);
            }
            // If parsing the number failed, use the current value.
            if (to === false || isNaN(to)) {
                return scope_Locations[handleNumber];
            }
            return to;
        }
        // Set the slider value.
        function valueSet(input, fireSetEvent, exactInput) {
            var values = asArray(input);
            var isInit = scope_Locations[0] === undefined;
            // Event fires by default
            fireSetEvent = fireSetEvent === undefined ? true : fireSetEvent;
            // Animation is optional.
            // Make sure the initial values were set before using animated placement.
            if (options.animate && !isInit) {
                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }
            // First pass, without lookAhead but with lookBackward. Values are set from left to right.
            scope_HandleNumbers.forEach(function (handleNumber) {
                setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
            });
            var i = scope_HandleNumbers.length === 1 ? 0 : 1;
            // Secondary passes. Now that all base values are set, apply constraints.
            // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)
            for (; i < scope_HandleNumbers.length; ++i) {
                scope_HandleNumbers.forEach(function (handleNumber) {
                    setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
                });
            }
            setZindex();
            scope_HandleNumbers.forEach(function (handleNumber) {
                fireEvent("update", handleNumber);
                // Fire the event only for handles that received a new value, as per #579
                if (values[handleNumber] !== null && fireSetEvent) {
                    fireEvent("set", handleNumber);
                }
            });
        }
        // Reset slider to initial values
        function valueReset(fireSetEvent) {
            valueSet(options.start, fireSetEvent);
        }
        // Set value for a single handle
        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
            // Ensure numeric input
            handleNumber = Number(handleNumber);
            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
                throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
            }
            // Look both backward and forward, since we don't want this handle to "push" other handles (#960);
            // The exactInput argument can be used to ignore slider stepping (#436)
            setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
            fireEvent("update", handleNumber);
            if (fireSetEvent) {
                fireEvent("set", handleNumber);
            }
        }
        // Get the slider value.
        function valueGet(unencoded) {
            if (unencoded === void 0) { unencoded = false; }
            if (unencoded) {
                // return a copy of the raw values
                return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
            }
            var values = scope_Values.map(options.format.to);
            // If only one handle is used, return a single value.
            if (values.length === 1) {
                return values[0];
            }
            return values;
        }
        // Removes classes from the root and empties it.
        function destroy() {
            // remove protected internal listeners
            removeEvent(INTERNAL_EVENT_NS.aria);
            removeEvent(INTERNAL_EVENT_NS.tooltips);
            Object.keys(options.cssClasses).forEach(function (key) {
                removeClass(scope_Target, options.cssClasses[key]);
            });
            while (scope_Target.firstChild) {
                scope_Target.removeChild(scope_Target.firstChild);
            }
            delete scope_Target.noUiSlider;
        }
        function getNextStepsForHandle(handleNumber) {
            var location = scope_Locations[handleNumber];
            var nearbySteps = scope_Spectrum.getNearbySteps(location);
            var value = scope_Values[handleNumber];
            var increment = nearbySteps.thisStep.step;
            var decrement = null;
            // If snapped, directly use defined step value
            if (options.snap) {
                return [
                    value - nearbySteps.stepBefore.startValue || null,
                    nearbySteps.stepAfter.startValue - value || null
                ];
            }
            // If the next value in this step moves into the next step,
            // the increment is the start of the next step - the current value
            if (increment !== false) {
                if (value + increment > nearbySteps.stepAfter.startValue) {
                    increment = nearbySteps.stepAfter.startValue - value;
                }
            }
            // If the value is beyond the starting point
            if (value > nearbySteps.thisStep.startValue) {
                decrement = nearbySteps.thisStep.step;
            }
            else if (nearbySteps.stepBefore.step === false) {
                decrement = false;
            }
            // If a handle is at the start of a step, it always steps back into the previous step first
            else {
                decrement = value - nearbySteps.stepBefore.highestStep;
            }
            // Now, if at the slider edges, there is no in/decrement
            if (location === 100) {
                increment = null;
            }
            else if (location === 0) {
                decrement = null;
            }
            // As per #391, the comparison for the decrement step can have some rounding issues.
            var stepDecimals = scope_Spectrum.countStepDecimals();
            // Round per #391
            if (increment !== null && increment !== false) {
                increment = Number(increment.toFixed(stepDecimals));
            }
            if (decrement !== null && decrement !== false) {
                decrement = Number(decrement.toFixed(stepDecimals));
            }
            return [decrement, increment];
        }
        // Get the current step size for the slider.
        function getNextSteps() {
            return scope_HandleNumbers.map(getNextStepsForHandle);
        }
        // Updatable: margin, limit, padding, step, range, animate, snap
        function updateOptions(optionsToUpdate, fireSetEvent) {
            // Spectrum is created using the range, snap, direction and step options.
            // 'snap' and 'step' can be updated.
            // If 'snap' and 'step' are not passed, they should remain unchanged.
            var v = valueGet();
            var updateAble = [
                "margin",
                "limit",
                "padding",
                "range",
                "animate",
                "snap",
                "step",
                "format",
                "pips",
                "tooltips"
            ];
            // Only change options that we're actually passed to update.
            updateAble.forEach(function (name) {
                // Check for undefined. null removes the value.
                if (optionsToUpdate[name] !== undefined) {
                    originalOptions[name] = optionsToUpdate[name];
                }
            });
            var newOptions = testOptions(originalOptions);
            // Load new options into the slider state
            updateAble.forEach(function (name) {
                if (optionsToUpdate[name] !== undefined) {
                    options[name] = newOptions[name];
                }
            });
            scope_Spectrum = newOptions.spectrum;
            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)
            options.margin = newOptions.margin;
            options.limit = newOptions.limit;
            options.padding = newOptions.padding;
            // Update pips, removes existing.
            if (options.pips) {
                pips(options.pips);
            }
            else {
                removePips();
            }
            // Update tooltips, removes existing.
            if (options.tooltips) {
                tooltips();
            }
            else {
                removeTooltips();
            }
            // Invalidate the current positioning so valueSet forces an update.
            scope_Locations = [];
            valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
        }
        // Initialization steps
        function setupSlider() {
            // Create the base element, initialize HTML and set classes.
            // Add handles and connect elements.
            scope_Base = addSlider(scope_Target);
            addElements(options.connect, scope_Base);
            // Attach user events.
            bindSliderEvents(options.events);
            // Use the public value method to set the start values.
            valueSet(options.start);
            if (options.pips) {
                pips(options.pips);
            }
            if (options.tooltips) {
                tooltips();
            }
            aria();
        }
        setupSlider();
        var scope_Self = {
            destroy: destroy,
            steps: getNextSteps,
            on: bindEvent,
            off: removeEvent,
            get: valueGet,
            set: valueSet,
            setHandle: valueSetHandle,
            reset: valueReset,
            // Exposed for unit testing, don't use this in your application.
            __moveHandles: function (upward, proposal, handleNumbers) {
                moveHandles(upward, proposal, scope_Locations, handleNumbers);
            },
            options: originalOptions,
            updateOptions: updateOptions,
            target: scope_Target,
            removePips: removePips,
            removeTooltips: removeTooltips,
            getTooltips: function () {
                return scope_Tooltips;
            },
            getOrigins: function () {
                return scope_Handles;
            },
            pips: pips // Issue #594
        };
        return scope_Self;
    }
    // Run the standard initializer
    function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
            throw new Error("noUiSlider: create requires a single element, got: " + target);
        }
        // Throw an error if the slider was already initialized.
        if (target.noUiSlider) {
            throw new Error("noUiSlider: Slider was already initialized.");
        }
        // Test the options and create the slider environment;
        var options = testOptions(originalOptions);
        var api = scope(target, options, originalOptions);
        target.noUiSlider = api;
        return api;
    }
    var nouislider = {
        // Exposed for unit testing, don't use this in your application.
        __spectrum: Spectrum,
        // A reference to the default classes, allows global changes.
        // Use the cssClasses option for changes to one slider.
        cssClasses: cssClasses,
        create: initialize
    };

    exports.create = initialize;
    exports.cssClasses = cssClasses;
    exports.default = nouislider;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
});

const SpxControlSlider$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  componentWillLoad() {
    this.value = this.start;
  }
  componentDidLoad() {
    const slider = nouislider.create(this.container, {
      start: this.start,
      connect: 'lower',
      range: {
        min: this.min,
        max: this.max,
      },
    });
    slider.on('update', (values) => {
      this.value = values[0];
    });
  }
  render() {
    const { tw, css } = cssTw(this.el.shadowRoot);
    const base = tw(css `
      .noUi-target,
      .noUi-target * {
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-user-select: none;
        -ms-touch-action: none;
        touch-action: none;
        -ms-user-select: none;
        -moz-user-select: none;
        user-select: none;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
      }
      .noUi-target {
        position: relative;
      }
      .noUi-base,
      .noUi-connects {
        width: 100%;
        height: 100%;
        position: relative;
        z-index: 1;
      }
      .noUi-connects {
        overflow: hidden;
        z-index: 0;
      }
      .noUi-connect,
      .noUi-origin {
        will-change: transform;
        position: absolute;
        z-index: 1;
        top: 0;
        right: 0;
        -ms-transform-origin: 0 0;
        -webkit-transform-origin: 0 0;
        -webkit-transform-style: preserve-3d;
        transform-origin: 0 0;
        transform-style: flat;
      }
      .noUi-connect {
        height: 100%;
        width: 100%;
      }
      .noUi-origin {
        height: 10%;
        width: 10%;
      }
      .noUi-txt-dir-rtl.noUi-horizontal .noUi-origin {
        left: 0;
        right: auto;
      }
      .noUi-vertical .noUi-origin {
        width: 0;
      }
      .noUi-horizontal .noUi-origin {
        height: 0;
      }
      .noUi-handle {
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        position: absolute;
      }
      .noUi-touch-area {
        height: 100%;
        width: 100%;
      }
      .noUi-state-tap .noUi-connect,
      .noUi-state-tap .noUi-origin {
        -webkit-transition: transform 0.3s;
        transition: transform 0.3s;
      }
      .noUi-state-drag * {
        cursor: inherit !important;
      }
      .noUi-horizontal {
        height: 18px;
      }
      .noUi-horizontal .noUi-handle {
        width: 34px;
        height: 28px;
        right: -17px;
        top: -6px;
      }
      .noUi-vertical {
        width: 18px;
      }
      .noUi-vertical .noUi-handle {
        width: 28px;
        height: 34px;
        right: -6px;
        top: -17px;
      }
      .noUi-txt-dir-rtl.noUi-horizontal .noUi-handle {
        left: -17px;
        right: auto;
      }
      .noUi-target {
        background: #fafafa;
        border-radius: 4px;
        border: 1px solid #d3d3d3;
        box-shadow: inset 0 1px 1px #f0f0f0, 0 3px 6px -5px #bbb;
      }
      .noUi-connects {
        border-radius: 3px;
      }
      .noUi-connect {
        background: #3fb8af;
      }
      .noUi-draggable {
        cursor: ew-resize;
      }
      .noUi-vertical .noUi-draggable {
        cursor: ns-resize;
      }
      .noUi-handle {
        border: 1px solid #d9d9d9;
        border-radius: 3px;
        background: #fff;
        cursor: default;
        box-shadow: inset 0 0 1px #fff, inset 0 1px 7px #ebebeb,
          0 3px 6px -3px #bbb;
      }
      .noUi-active {
        box-shadow: inset 0 0 1px #fff, inset 0 1px 7px #ddd,
          0 3px 6px -3px #bbb;
      }
      .noUi-handle:before,
      .noUi-handle:after {
        content: '';
        display: block;
        position: absolute;
        height: 14px;
        width: 1px;
        background: #e8e7e6;
        left: 14px;
        top: 6px;
      }
      .noUi-handle:after {
        left: 17px;
      }
      .noUi-vertical .noUi-handle:before,
      .noUi-vertical .noUi-handle:after {
        width: 14px;
        height: 1px;
        left: 6px;
        top: 14px;
      }
      .noUi-vertical .noUi-handle:after {
        top: 17px;
      }
      [disabled] .noUi-connect {
        background: #b8b8b8;
      }
      [disabled].noUi-target,
      [disabled].noUi-handle,
      [disabled] .noUi-handle {
        cursor: not-allowed;
      }
      .noUi-pips,
      .noUi-pips * {
        -moz-box-sizing: border-box;
        box-sizing: border-box;
      }
      .noUi-pips {
        position: absolute;
        color: #999;
      }
      .noUi-value {
        position: absolute;
        white-space: nowrap;
        text-align: center;
      }
      .noUi-value-sub {
        color: #ccc;
        font-size: 10px;
      }
      .noUi-marker {
        position: absolute;
        background: #ccc;
      }
      .noUi-marker-sub {
        background: #aaa;
      }
      .noUi-marker-large {
        background: #aaa;
      }
      .noUi-pips-horizontal {
        padding: 10px 0;
        height: 80px;
        top: 100%;
        left: 0;
        width: 100%;
      }
      .noUi-value-horizontal {
        -webkit-transform: translate(-50%, 50%);
        transform: translate(-50%, 50%);
      }
      .noUi-rtl .noUi-value-horizontal {
        -webkit-transform: translate(50%, 50%);
        transform: translate(50%, 50%);
      }
      .noUi-marker-horizontal.noUi-marker {
        margin-left: -1px;
        width: 2px;
        height: 5px;
      }
      .noUi-marker-horizontal.noUi-marker-sub {
        height: 10px;
      }
      .noUi-marker-horizontal.noUi-marker-large {
        height: 15px;
      }
      .noUi-pips-vertical {
        padding: 0 10px;
        height: 100%;
        top: 0;
        left: 100%;
      }
      .noUi-value-vertical {
        -webkit-transform: translate(0, -50%);
        transform: translate(0, -50%);
        padding-left: 25px;
      }
      .noUi-rtl .noUi-value-vertical {
        -webkit-transform: translate(0, 50%);
        transform: translate(0, 50%);
      }
      .noUi-marker-vertical.noUi-marker {
        width: 5px;
        height: 2px;
        margin-top: -1px;
      }
      .noUi-marker-vertical.noUi-marker-sub {
        width: 10px;
      }
      .noUi-marker-vertical.noUi-marker-large {
        width: 15px;
      }
      .noUi-tooltip {
        display: block;
        position: absolute;
        border: 1px solid #d9d9d9;
        border-radius: 3px;
        background: #fff;
        color: #000;
        padding: 5px;
        text-align: center;
        white-space: nowrap;
      }
      .noUi-horizontal .noUi-tooltip {
        -webkit-transform: translate(-50%, 0);
        transform: translate(-50%, 0);
        left: 50%;
        bottom: 120%;
      }
      .noUi-vertical .noUi-tooltip {
        -webkit-transform: translate(0, -50%);
        transform: translate(0, -50%);
        top: 50%;
        right: 120%;
      }
      .noUi-horizontal .noUi-origin > .noUi-tooltip {
        -webkit-transform: translate(50%, 0);
        transform: translate(50%, 0);
        left: auto;
        bottom: 10px;
      }
      .noUi-vertical .noUi-origin > .noUi-tooltip {
        -webkit-transform: translate(0, -18px);
        transform: translate(0, -18px);
        top: auto;
        right: 28px;
      }
    `);
    const style = tw(css({
      'div.noUi-target': {
        '@apply': 'h-1.5 mt-1.5 shadow-none bg-blue-gray-100 rounded-full border-none',
      },
      'div.noUi-connects': {
        '@apply': 'rounded-full border-transparent',
      },
      'div.noUi-connect': { '@apply': 'bg-blue-gray-300' },
      'div.noUi-horizontal .noUi-handle': {
        '@apply': 'focus-out shadow-none rounded-full border-blue-gray-300 h-6 w-6',
        top: '-9px',
        '&:before, &:after': {
          display: 'none',
        },
      },
    }));
    return (h$4("div", { class: base + ' ' + style }, h$4("div", { class: tw(`flex justify-between`) }, h$4("spx-control-label", { label: this.label, mb: true }), h$4("spx-control-label", { label: String(this.value), mb: true })), h$4("div", { ref: (el) => (this.container = el) })));
  }
  get el() { return this; }
};

const SpxControlSwitch$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  render() {
    const { tw, css } = cssTw(this.el.shadowRoot);
    return (h$4("label", { class: tw(`focus flex items-center cursor-pointer`) +
        ' ' +
        tw(css `
              .toggle:checked ~ .dot {
                transform: translateX(28px);
              }
              .toggle:checked + div {
                background: #0f172a;
              }
            `) }, h$4("div", { class: tw(`relative mr-3`) }, h$4("input", { type: "checkbox", class: tw(`sr-only`) + ` toggle`, onChange: this.handleChange, checked: this.checked }), h$4("div", { tabindex: "0", class: tw(`focus-out block bg-blue-gray-300 w-12 h-5 rounded-full transition ease-in-out duration-100`) }), h$4("div", { class: tw(`dot absolute left-1 top-1 bg-white w-3 h-3 rounded-full transition ease-in-out duration-100`) })), h$4("spx-control-label", { label: this.label })));
  }
  get el() { return this; }
};

const SpxControlText$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  render() {
    const { tw } = cssTw(this.el.shadowRoot);
    return (h$4("div", null, this.label && h$4("spx-control-label", { label: this.label, mb: true }), h$4("input", { class: tw(`focus-out border border-blue-gray-200 py-1.5 px-2 rounded-md w-full text-blue-gray-900 text-sm`), type: "text", value: this.value, placeholder: this.placeholder, onChange: this.handleChange })));
  }
  get el() { return this; }
};

const tag$i = 'spx-edit';
const SpxEdit$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.display = 'inline';
    this.outline = '2px solid red';
    this.outlineFocus = 'blue';
    this.placeholder = 'Enter some text here.';
    this.placeholderColor = 'inherit';
    this.placeholderOpacity = '0.7';
    this.typeText = (src) => {
      /**
       * Update body string with a special identifier. Is used to distinguish
       * between content types in the AJAX call.
       */
      this.el.setAttribute('body-string', '&' +
        this.name +
        '=' +
        src +
        'eF3ztPlKSglSF2g7uPUIs8fGWQnkeHqn' +
        (this.subfield ? 'parent' + this.type : this.type));
    };
  }
  watchEditable() {
    if (this.editable) {
      this.el.setAttribute('contenteditable', 'true');
    }
    else {
      this.el.removeAttribute('contenteditable');
    }
  }
  /**
   * Prevent enter key.
   *
   * @param {event} e Keydown event.
   */
  onClickEnter(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
    }
  }
  /** Discard changes. */
  onClickDiscard() {
    this.el.parentElement.innerHTML = this.originalText;
    this.editable = false;
  }
  /** Save changes. */
  onClickSave() {
    this.editable = false;
  }
  /** Sets the new body string correctly on key press. */
  onClickKeyup() {
    this.typeText(this.el.innerText);
  }
  componentDidLoad() {
    this.watchEditable();
    /** Set inner text as state. */
    this.originalText = this.el.innerText;
    /** Set original body string. */
    this.typeText(this.originalText);
  }
  render() {
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$i, 'display', this.display),
      position: 'relative',
      '&[contenteditable]': {
        outline: this.outline,
        cursor: 'text',
        ':focus': {
          outlineColor: this.outlineFocus,
        },
        ':empty:before': {
          content: '"' + this.placeholder + ' "',
          color: this.placeholderColor,
          opacity: this.placeholderOpacity,
        },
      },
    });
    return (h$4(Host, { class: styleHost }, h$4("slot", null)));
  }
  get el() { return this; }
  static get watchers() { return {
    "editable": ["watchEditable"]
  }; }
};

const tag$h = 'spx-edit-button';
const SpxEditButton$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxEditButtonDidLoad = createEvent(this, "spxEditButtonDidLoad", 7);
    this.spxEditButtonDiscard = createEvent(this, "spxEditButtonDiscard", 7);
    this.spxEditButtonSave = createEvent(this, "spxEditButtonSave", 7);
    this.loading = false;
    this.open = false;
    this.test = false;
    this.background = 'var(--spx-color-gray-900)';
    /**
     * Discard button background.
     *
     * @CSS
     */
    this.backgroundDiscard = 'var(--spx-color-gray-600)';
    this.border = 'none';
    this.borderRadius = borderRadius;
    this.color = '#ffffff';
    /**
     * Discard button color.
     *
     * @CSS
     */
    this.colorDiscard = '#ffffff';
    this.display = display$1;
    /**
     * Distance to the edge of the viewport on the x-axis.
     *
     * @CSS
     */
    this.distanceX = '1em';
    /**
     * Distance to the edge of the viewport on the y-axis.
     *
     * @CSS
     */
    this.distanceY = '1em';
    this.fontFamily = fontFamily;
    this.fontSize = fontSize;
    this.fontSizeMax = 1.2;
    this.fontSizeMin = 1;
    /**
     * Gap between the buttons.
     *
     * @CSS
     */
    this.gap = '0.4em';
    this.loaderColor = '#ffffff';
    this.loaderGap = '0.5em';
    this.padding = '0.7em 1.2em';
    this.paddingXMin = 1;
    this.paddingXMax = 1.4;
    this.paddingYMin = 0.7;
    this.paddingYMax = 1.2;
    /**
     * Component position in page.
     *
     * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
     */
    this.position = 'bottom-right';
    /** CSS property position of button. */
    this.positionCss = 'fixed';
    /**
     * Styling.
     *
     * @choice 'default', 'fluid', 'headless'
     */
    this.styling = 'default';
    /** Discard button text. */
    this.textDiscard = 'Discard';
    /** Edit button text. */
    this.textEdit = 'Edit site';
    /** Save button text. */
    this.textSave = 'Save';
    /** Success message. */
    this.textSuccess = 'Save was successful';
    this.zIndex = 99;
    this.createPositionArray = () => {
      this.positionArray = this.position.split('-');
    };
    this.clickEdit = () => {
      this.open = true;
      /** Generate edit components around text. */
      const elements = this.editId
        ? document.querySelectorAll('[data-spx-edit][data-spx-edit-id=' + this.editId + ']')
        : document.querySelectorAll('[data-spx-edit]');
      elements.forEach((item) => {
        const edit = document.createElement('spx-edit');
        const field = item.getAttribute('data-spx-edit');
        const type = item.getAttribute('data-spx-edit-type');
        const subfield = item.hasAttribute('data-spx-edit-subfield');
        const text = item.innerHTML;
        if (field) {
          edit.setAttribute('name', field);
        }
        if (type) {
          edit.setAttribute('type', type);
        }
        if (subfield) {
          edit.setAttribute('subfield', '');
        }
        edit.innerHTML = text;
        edit.setAttribute('editable', '');
        item.innerHTML = '';
        item.appendChild(edit);
      });
    };
    this.clickDiscard = () => {
      /** Close buttons again. */
      this.open = false;
      /** Emit closing event to document. */
      this.spxEditButtonDiscard.emit({ target: 'document' });
    };
    this.clickSave = () => {
      this.loading = true;
      /**
       * Emit save event to document.
       *
       * @returns {string} Send to WP Admin with AJAX.
       */
      const getBodyString = () => {
        /** Create the body string to be sent off to the AJAX call. */
        const string = Math.random().toString(36).substr(2, 9);
        const bodyStringArray = [];
        const elements = document.querySelectorAll('spx-edit');
        elements.forEach((item) => {
          const withoutAmpersand = item
            .getAttribute('body-string')
            .replace('&', '')
            .replace('=', string);
          const encoded = encodeURIComponent(withoutAmpersand);
          const final = '&' + encoded;
          bodyStringArray.push(final.replace(string, '='));
        });
        return bodyStringArray.toString().replace(/,&/g, '&');
      };
      const afterSuccess = () => {
        /** Insert snackbar. */
        const snackbar = document.createElement('spx-snackbar');
        snackbar.setAttribute('text', this.textSuccess);
        document.body.appendChild(snackbar);
        /** Remove edit components. */
        const elements = document.querySelectorAll('spx-edit');
        elements.forEach((item) => {
          item.parentElement.innerHTML = item.innerHTML;
        });
        /** Save changes event. */
        this.spxEditButtonSave.emit({ target: 'document' });
        /** Remove loader and close on success. */
        this.open = false;
        this.loading = false;
      };
      if (!this.test) {
        // @ts-ignore
        // eslint-disable-next-line no-undef
        fetch(spx.ajax, {
          method: 'POST',
          credentials: 'same-origin',
          headers: new Headers({
            'Content-Type': 'application/x-www-form-urlencoded',
          }),
          body: 'action=spxEditButtonAjaxHandler' +
            getBodyString() +
            '' +
            '&post_id=' +
            // @ts-ignore
            // eslint-disable-next-line no-undef
            spx.postId +
            '',
        }).then((response) => {
          if (response.status === 200) {
            afterSuccess();
          }
          else if (response.status === 500) {
            /** Remove loader on fail. */
            this.loading = false;
          }
        });
      }
      else {
        afterSuccess();
      }
    };
  }
  positionChanged() {
    this.createPositionArray();
  }
  componentWillLoad() {
    this.createPositionArray();
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.spxEditButtonDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  /** Discard changes. */
  async discard() {
    this.clickDiscard();
  }
  /** Enable editing. */
  async edit() {
    this.clickEdit();
  }
  /** Save changes. */
  async save() {
    this.clickSave();
  }
  render() {
    var _a, _b, _c, _d;
    const { tw, css } = cssTw(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$h, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = (this.styling === 'default' || this.styling === 'fluid') &&
      tw(css(Object.assign(Object.assign({}, position$1('edit-button', this.positionArray, this.distanceX, this.distanceY)), { fontFamily: fontFamily, fontSize: setStyle(tag$h, 'font-size', this.fontSize, this.fontSizeMin, this.fontSizeMax, this.styling), display: 'grid', gridGap: setVar(tag$h, 'gap', this.gap), position: this.positionCss, zIndex: this.zIndex })));
    /** Button styles. */
    const styleButton = this.styling === 'default' || this.styling === 'fluid'
      ? tw(css(Object.assign({ fontFamily: setVar(tag$h, 'font-family', this.fontFamily), display: 'flex', justifyContent: 'center', alignItems: 'center', textAlign: 'center', cursor: 'pointer', fontSize: '1em', padding: this.styling === 'default' &&
          setVar(tag$h, 'padding', this.padding), paddingLeft: this.styling === 'fluid' &&
          setClamp(tag$h, 'padding-x', this.paddingXMin, this.paddingXMax), paddingRight: this.styling === 'fluid' &&
          setClamp(tag$h, 'padding-x', this.paddingXMin, this.paddingXMax), paddingTop: this.styling === 'fluid' &&
          setClamp(tag$h, 'padding-x', this.paddingYMin, this.paddingYMax), paddingBottom: this.styling === 'fluid' &&
          setClamp(tag$h, 'padding-x', this.paddingYMin, this.paddingYMax), color: setVar(tag$h, 'color', this.color), background: setVar(tag$h, 'background', this.background), border: setVar(tag$h, 'border', this.border), borderRadius: setVar(tag$h, 'border-radius', this.borderRadius), transitionProperty: 'background, box-shadow', transitionDuration: transitionDuration, transitionTimingFunction: transitionTimingFunction }, focus)))
      : tw((_a = this.classButton) !== null && _a !== void 0 ? _a : '');
    /** Discard button styles. */
    const styleButtonDiscard = this.styling === 'default' || this.styling === 'fluid'
      ? tw(css({
        color: setVar(tag$h, 'color-discard', this.colorDiscard),
        background: setVar(tag$h, 'background-discard', this.backgroundDiscard),
      }))
      : tw(((_b = this.classButton) !== null && _b !== void 0 ? _b : '') + ' ' + ((_c = this.classButtonDiscard) !== null && _c !== void 0 ? _c : ''));
    /** Loader styles. */
    const styleLoader = this.styling === 'default' || this.styling === 'fluid'
      ? tw(css({
        marginRight: setVar(tag$h, 'loader-gap', this.loaderGap),
      }))
      : tw((_d = this.classLoader) !== null && _d !== void 0 ? _d : '');
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleShadowHost }, !this.open ? (
    /** Edit button. */
    h$4("button", { onClick: this.clickEdit, class: styleButton }, this.textEdit || h$4("slot", { name: "edit" }))) : (
    /** Discard button. */
    [
      h$4(Button, { as: "button", onClick: this.clickDiscard, class: this.styling === 'headless'
          ? styleButtonDiscard
          : styleButton + ' ' + styleButtonDiscard }, this.textDiscard || h$4("slot", { name: "discard" })),
      /** Save button. */
      h$4(Button, { as: "button", onClick: this.clickSave, class: styleButton }, this.loading && (h$4("spx-icon", { class: styleLoader, type: "loader", color: setVar(tag$h, 'loader-color', this.loaderColor) })), this.textSave || h$4("slot", { name: "save" })),
    ]))));
  }
  get el() { return this; }
  static get watchers() { return {
    "position": ["positionChanged"]
  }; }
};

const name$l = "spx-accordion";
const description$l = "The classic method to show and hide elements on your website. Can be used\nwith custom markup for the header and/or content section.";
const shadow$l = false;
const properties$l = [
	{
		name: "animation",
		attribute: "animation",
		type: "boolean",
		description: "Animate the opening of the content. Set to false if Accordion is starting hidden.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "classContent",
		attribute: "class-content",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classContentActive",
		attribute: "class-content-active",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classContentInactive",
		attribute: "class-content-inactive",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classContentText",
		attribute: "class-content-text",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classContentTextActive",
		attribute: "class-content-text-active",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classContentTextInactive",
		attribute: "class-content-text-inactive",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeader",
		attribute: "class-header",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderActive",
		attribute: "class-header-active",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderIcon",
		attribute: "class-header-icon",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderIconActive",
		attribute: "class-header-icon-active",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderIconContainer",
		attribute: "class-header-icon-container",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderIconContainerActive",
		attribute: "class-header-icon-container-active",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderIconContainerInactive",
		attribute: "class-header-icon-container-inactive",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderIconInactive",
		attribute: "class-header-icon-inactive",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderInactive",
		attribute: "class-header-inactive",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderText",
		attribute: "class-header-text",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderTextActive",
		attribute: "class-header-text-active",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classHeaderTextInactive",
		attribute: "class-header-text-inactive",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "contentColor",
		attribute: "content-color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "contentText",
		attribute: "content-text",
		type: "string",
		description: "Content text.",
		"default": "'Default Content Text'",
		defaultValue: "'Default Content Text'",
		tags: [
		]
	},
	{
		name: "contentTextTag",
		attribute: "content-text-tag",
		type: "string",
		description: "Content text tag.",
		"default": "'span'",
		defaultValue: "'span'",
		tags: [
		]
	},
	{
		name: "contentTransitionDuration",
		attribute: "content-transition-duration",
		type: "string",
		description: "",
		"default": "s.transitionDuration",
		defaultValue: "'var(--spx-transition-duration)'",
		tags: [
		]
	},
	{
		name: "contentTransitionTimingFunction",
		attribute: "content-transition-timing-function",
		type: "string",
		description: "",
		"default": "s.transitionTimingFunction",
		defaultValue: "'var(--spx-transition-timing-function)'",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "fontSize",
		attribute: "font-size",
		type: "string",
		description: "",
		"default": "s.fontSize",
		defaultValue: "'var(--spx-font-size)'",
		tags: [
		]
	},
	{
		name: "fontSizeMax",
		attribute: "font-size-max",
		type: "number",
		description: "",
		"default": "1.2",
		defaultValue: "1.2",
		tags: [
		]
	},
	{
		name: "fontSizeMin",
		attribute: "font-size-min",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "gap",
		attribute: "gap",
		type: "string",
		description: "Space between header and content.",
		"default": "'0.4em'",
		defaultValue: "'0.4em'",
		tags: [
		]
	},
	{
		name: "gapMax",
		attribute: "gap-max",
		type: "number",
		description: "",
		"default": "1.2",
		defaultValue: "1.2",
		tags: [
		]
	},
	{
		name: "gapMin",
		attribute: "gap-min",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "headerColor",
		attribute: "header-color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "headerGap",
		attribute: "header-gap",
		type: "string",
		description: "Gap between header text and icon.",
		"default": "'0.4em'",
		defaultValue: "'0.4em'",
		tags: [
		]
	},
	{
		name: "headerGapMax",
		attribute: "header-gap-max",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "headerGapMin",
		attribute: "header-gap-min",
		type: "number",
		description: "",
		"default": "0.6",
		defaultValue: "0.6",
		tags: [
		]
	},
	{
		name: "headerText",
		attribute: "header-text",
		type: "string",
		description: "Header text.",
		"default": "'Default Header Text'",
		defaultValue: "'Default Header Text'",
		tags: [
		]
	},
	{
		name: "headerTextOpen",
		attribute: "header-text-open",
		type: "string",
		description: "Header text when component is closed.",
		tags: [
		]
	},
	{
		name: "headerTextTag",
		attribute: "header-text-tag",
		type: "string",
		description: "Header text tag.",
		"default": "'span'",
		defaultValue: "'span'",
		tags: [
		]
	},
	{
		name: "indicatorIcon",
		attribute: "indicator-icon",
		type: "string",
		description: "Indicator icon.",
		"default": "'arrow-down'",
		defaultValue: "'arrow-down'",
		tags: [
		]
	},
	{
		name: "indicatorIconTransform",
		attribute: "indicator-icon-transform",
		type: "string",
		description: "Indicator icon transform.",
		"default": "'rotate(180deg)'",
		defaultValue: "'rotate(180deg)'",
		tags: [
		]
	},
	{
		name: "indicatorIconType",
		attribute: "indicator-icon-type",
		type: "string",
		description: "Indicator icon type.",
		"default": "'ionicons'",
		defaultValue: "'ionicons'",
		tags: [
		]
	},
	{
		name: "link",
		attribute: "link",
		type: "string",
		description: "Sets the ID to link different accordions together.",
		tags: [
		]
	},
	{
		name: "linkType",
		attribute: "link-type",
		type: "string",
		description: "Sets the type of link.",
		tags: [
			{
				text: "'open', 'close', 'toggle'",
				name: "choice"
			}
		]
	},
	{
		name: "openState",
		attribute: "open",
		type: "boolean",
		description: "State of accordion.",
		"default": "false",
		defaultValue: "false",
		tags: [
		]
	},
	{
		name: "reverse",
		attribute: "reverse",
		type: "boolean",
		description: "Reverse icon positioning.",
		tags: [
		]
	},
	{
		name: "styling",
		attribute: "styling",
		type: "string",
		description: "Styling.",
		"default": "'default'",
		defaultValue: "'default'",
		tags: [
			{
				text: "'default', 'fluid', 'headless'",
				name: "choice"
			}
		]
	}
];
const events$m = [
	{
		name: "spxAccordionDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$l = [
	{
		name: "close",
		description: "Closes the accordion.",
		signature: "close() => Promise<void>"
	},
	{
		name: "open",
		description: "Opens the accordion.",
		signature: "open() => Promise<void>"
	},
	{
		name: "toggle",
		description: "Toggles the accordion.",
		signature: "toggle() => Promise<void>"
	}
];
const slots$l = [
	{
		name: "content",
		description: "Slot for the content."
	},
	{
		name: "header",
		description: "Slot for the header."
	}
];
const spxAccordion = {
	name: name$l,
	description: description$l,
	shadow: shadow$l,
	properties: properties$l,
	events: events$m,
	methods: methods$l,
	slots: slots$l
};

const accordion = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$l,
  description: description$l,
  shadow: shadow$l,
  properties: properties$l,
  events: events$m,
  methods: methods$l,
  slots: slots$l,
  'default': spxAccordion
});

const name$k = "spx-animate";
const description$k = "Wrapper around GSAP that allows for staggered and scroll-based animation.";
const shadow$k = false;
const properties$k = [
	{
		name: "clipPath",
		attribute: "clip-path",
		type: "string",
		description: "Clip-path value the animation starts from.",
		tags: [
		]
	},
	{
		name: "delay",
		attribute: "delay",
		type: "number",
		description: "Delay before animation starts.",
		"default": "0",
		defaultValue: "0",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "duration",
		attribute: "duration",
		type: "number",
		description: "Animation duration.",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "ease",
		attribute: "ease",
		type: "string",
		description: "Ease being used. Accepts all common GSAP options.",
		"default": "'power1.out'",
		defaultValue: "'power1.out'",
		tags: [
		]
	},
	{
		name: "filter",
		attribute: "filter",
		type: "string",
		description: "Filter value the animation starts from.",
		tags: [
		]
	},
	{
		name: "once",
		attribute: "once",
		type: "boolean",
		description: "Determines if animation should only play once. (if viewport is true)",
		tags: [
		]
	},
	{
		name: "opacity",
		attribute: "opacity",
		type: "number",
		description: "Opacity level the animation starts from.",
		"default": "0",
		defaultValue: "0",
		tags: [
		]
	},
	{
		name: "repeat",
		attribute: "repeat",
		type: "number",
		description: "Repeats the animation. -1 to repeat indefinitely.",
		tags: [
		]
	},
	{
		name: "repeatDelay",
		attribute: "repeat-delay",
		type: "number",
		description: "Time to wait between repetitions.",
		tags: [
		]
	},
	{
		name: "reverse",
		attribute: "reverse",
		type: "boolean",
		description: "Reverses the animation.",
		tags: [
		]
	},
	{
		name: "stagger",
		attribute: "stagger",
		type: "number",
		description: "Amount of time elements should be staggered by.",
		"default": "0.15",
		defaultValue: "0.15",
		tags: [
		]
	},
	{
		name: "target",
		attribute: "target",
		type: "string",
		description: "The target element that should be animated inside the component.",
		"default": "'*'",
		defaultValue: "'*'",
		tags: [
		]
	},
	{
		name: "viewport",
		attribute: "viewport",
		type: "boolean",
		description: "Starts animation when target is in the viewport.",
		tags: [
		]
	},
	{
		name: "viewportMarginBottom",
		attribute: "viewport-margin-bottom",
		type: "string",
		description: "Adjust the root margin of the animation start.",
		tags: [
		]
	},
	{
		name: "viewportMarginLeft",
		attribute: "viewport-margin-left",
		type: "string",
		description: "Adjust the root margin of the animation start.",
		tags: [
		]
	},
	{
		name: "viewportMarginRight",
		attribute: "viewport-margin-right",
		type: "string",
		description: "Adjust the root margin of the animation start.",
		tags: [
		]
	},
	{
		name: "viewportMarginTop",
		attribute: "viewport-margin-top",
		type: "string",
		description: "Adjust the root margin of the animation start.",
		tags: [
		]
	},
	{
		name: "x",
		attribute: "x",
		type: "any",
		description: "X position the animation starts from.",
		"default": "0",
		defaultValue: "0",
		tags: [
		]
	},
	{
		name: "y",
		attribute: "y",
		type: "any",
		description: "Y position the animation starts from.",
		"default": "0",
		defaultValue: "0",
		tags: [
		]
	},
	{
		name: "yoyo",
		attribute: "yoyo",
		type: "boolean",
		description: "Causes the animation to go back and forth, alternating backward and forward\non each repeat.",
		tags: [
		]
	}
];
const events$l = [
	{
		name: "spxAnimateDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$k = [
	{
		name: "play",
		description: "Plays animation.",
		signature: "play(from?: number, suppressEvents?: boolean) => Promise<void>"
	},
	{
		name: "restart",
		description: "Restarts animation.",
		signature: "restart(includeDelay?: boolean, suppressEvents?: boolean) => Promise<void>"
	}
];
const slots$k = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxAnimate = {
	name: name$k,
	description: description$k,
	shadow: shadow$k,
	properties: properties$k,
	events: events$l,
	methods: methods$k,
	slots: slots$k
};

const animate = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$k,
  description: description$k,
  shadow: shadow$k,
  properties: properties$k,
  events: events$l,
  methods: methods$k,
  slots: slots$k,
  'default': spxAnimate
});

const name$j = "spx-class-toggle";
const description$j = "Toggle CSS classes on any element in the document.";
const shadow$j = false;
const properties$j = [
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "local",
		attribute: "local",
		type: "string",
		description: "Specify a local storage item, so the toggle state will be remembered when\nthe user visits the site again.",
		tags: [
		]
	},
	{
		name: "target",
		attribute: "target",
		type: "string",
		description: "Target element. Can take any querySelector value. (id, class, tag etc.) If\nnone is set it will default to the first element inside.",
		tags: [
		]
	},
	{
		name: "toggle",
		attribute: "toggle",
		type: "string",
		description: "List of classes that should be toggled.",
		"default": "'spx-class-toggle--active'",
		defaultValue: "'spx-class-toggle--active'",
		tags: [
		]
	}
];
const events$k = [
	{
		name: "spxClassToggleDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$j = [
];
const slots$j = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxClassToggle = {
	name: name$j,
	description: description$j,
	shadow: shadow$j,
	properties: properties$j,
	events: events$k,
	methods: methods$j,
	slots: slots$j
};

const classToggle = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$j,
  description: description$j,
  shadow: shadow$j,
  properties: properties$j,
  events: events$k,
  methods: methods$j,
  slots: slots$j,
  'default': spxClassToggle
});

const name$i = "spx-code";
const description$i = "Highlight a block of code similar to a code editor.";
const shadow$i = false;
const properties$i = [
	{
		name: "background",
		attribute: "background",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "borderRadius",
		attribute: "border-radius",
		type: "string",
		description: "",
		"default": "s.borderRadius",
		defaultValue: "'var(--spx-border-radius)'",
		tags: [
		]
	},
	{
		name: "clipboard",
		attribute: "clipboard",
		type: "boolean",
		description: "Enable clipboard button.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "clipboardButtonBackground",
		attribute: "clipboard-button-background",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-800)'",
		defaultValue: "'var(--spx-color-gray-800)'",
		tags: [
		]
	},
	{
		name: "clipboardButtonColor",
		attribute: "clipboard-button-color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-400)'",
		defaultValue: "'var(--spx-color-gray-400)'",
		tags: [
		]
	},
	{
		name: "clipboardButtonFontSize",
		attribute: "clipboard-button-font-size",
		type: "string",
		description: "",
		"default": "'12px'",
		defaultValue: "'12px'",
		tags: [
		]
	},
	{
		name: "clipboardButtonFontWeight",
		attribute: "clipboard-button-font-weight",
		type: "any",
		description: "",
		"default": "'600'",
		defaultValue: "'600'",
		tags: [
		]
	},
	{
		name: "clipboardButtonPadding",
		attribute: "clipboard-button-padding",
		type: "string",
		description: "",
		"default": "'6px 12px'",
		defaultValue: "'6px 12px'",
		tags: [
		]
	},
	{
		name: "clipboardButtonText",
		attribute: "clipboard-button-text",
		type: "string",
		description: "",
		"default": "'Copy'",
		defaultValue: "'Copy'",
		tags: [
		]
	},
	{
		name: "clipboardButtonTextCopied",
		attribute: "clipboard-button-text-copied",
		type: "string",
		description: "",
		"default": "'Copied!'",
		defaultValue: "'Copied!'",
		tags: [
		]
	},
	{
		name: "clipboardButtonTextTransform",
		attribute: "clipboard-button-text-transform",
		type: "string",
		description: "",
		"default": "'uppercase'",
		defaultValue: "'uppercase'",
		tags: [
		]
	},
	{
		name: "content",
		attribute: "content",
		type: "string",
		description: "Can be used instead of the inner slot.",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "filter",
		attribute: "filter",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "fontSize",
		attribute: "font-size",
		type: "string",
		description: "",
		"default": "'clamp(12px, 1.6vw, 16px)'",
		defaultValue: "'clamp(12px, 1.6vw, 16px)'",
		tags: [
		]
	},
	{
		name: "height",
		attribute: "height",
		type: "string",
		description: "",
		"default": "'auto'",
		defaultValue: "'auto'",
		tags: [
		]
	},
	{
		name: "lazy",
		attribute: "lazy",
		type: "boolean",
		description: "Load component when it enters the viewport.",
		tags: [
		]
	},
	{
		name: "lineNumbers",
		attribute: "line-numbers",
		type: "boolean",
		description: "Enable line numbers.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "lineNumbersBackground",
		attribute: "line-numbers-background",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-800)'",
		defaultValue: "'var(--spx-color-gray-800)'",
		tags: [
		]
	},
	{
		name: "lineNumbersColor",
		attribute: "line-numbers-color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-400)'",
		defaultValue: "'var(--spx-color-gray-400)'",
		tags: [
		]
	},
	{
		name: "lineNumbersStart",
		attribute: "line-numbers-start",
		type: "number",
		description: "Start of line number.",
		tags: [
		]
	},
	{
		name: "maxWidth",
		attribute: "max-width",
		type: "string",
		description: "",
		"default": "'100%'",
		defaultValue: "'100%'",
		tags: [
		]
	},
	{
		name: "overflow",
		attribute: "overflow",
		type: "string",
		description: "",
		"default": "'auto'",
		defaultValue: "'auto'",
		tags: [
		]
	},
	{
		name: "padding",
		attribute: "padding",
		type: "string",
		description: "",
		"default": "'clamp(20px, 2.4vw, 40px)'",
		defaultValue: "'clamp(20px, 2.4vw, 40px)'",
		tags: [
		]
	},
	{
		name: "scrollbar",
		attribute: "scrollbar",
		type: "boolean",
		description: "Hide scrollbar.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "theme",
		attribute: "theme",
		type: "string",
		description: "Colour theme.",
		"default": "'default'",
		defaultValue: "'default'",
		tags: [
			{
				text: "'default', 'dracula'",
				name: "choice"
			}
		]
	},
	{
		name: "type",
		attribute: "type",
		type: "string",
		description: "Determines the programming language.",
		"default": "'markup'",
		defaultValue: "'markup'",
		tags: [
			{
				text: "'markup', 'css', 'js', 'php', 'twig', 'json'",
				name: "choice"
			}
		]
	},
	{
		name: "whitespaceLeftTrim",
		attribute: "whitespace-left-trim",
		type: "boolean",
		description: "Removes all whitespace from the top of the code block.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "whitespaceRemoveIndent",
		attribute: "whitespace-remove-indent",
		type: "boolean",
		description: "If the whole code block is indented too much it removes the extra indent.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "whitespaceRemoveTrailing",
		attribute: "whitespace-remove-trailing",
		type: "boolean",
		description: "Removes trailing whitespace on all lines.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "whitespaceRightTrim",
		attribute: "whitespace-right-trim",
		type: "boolean",
		description: "Removes all whitespace from the bottom of the code block.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	}
];
const events$j = [
	{
		name: "spxCodeDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$i = [
];
const slots$i = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxCode = {
	name: name$i,
	description: description$i,
	shadow: shadow$i,
	properties: properties$i,
	events: events$j,
	methods: methods$i,
	slots: slots$i
};

const code = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$i,
  description: description$i,
  shadow: shadow$i,
  properties: properties$i,
  events: events$j,
  methods: methods$i,
  slots: slots$i,
  'default': spxCode
});

const name$h = "spx-edit-button";
const description$h = "Let your clients edit text on their site using this handy component.";
const shadow$h = false;
const properties$h = [
	{
		name: "background",
		attribute: "background",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "backgroundDiscard",
		attribute: "background-discard",
		type: "string",
		description: "Discard button background.",
		"default": "'var(--spx-color-gray-600)'",
		defaultValue: "'var(--spx-color-gray-600)'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "border",
		attribute: "border",
		type: "string",
		description: "",
		"default": "'none'",
		defaultValue: "'none'",
		tags: [
		]
	},
	{
		name: "borderRadius",
		attribute: "border-radius",
		type: "string",
		description: "",
		"default": "s.borderRadius",
		defaultValue: "'var(--spx-border-radius)'",
		tags: [
		]
	},
	{
		name: "classButton",
		attribute: "class-button",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classButtonDiscard",
		attribute: "class-button-discard",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classLoader",
		attribute: "class-loader",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "color",
		attribute: "color",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "colorDiscard",
		attribute: "color-discard",
		type: "string",
		description: "Discard button color.",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "distanceX",
		attribute: "distance-x",
		type: "string",
		description: "Distance to the edge of the viewport on the x-axis.",
		"default": "'1em'",
		defaultValue: "'1em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "distanceY",
		attribute: "distance-y",
		type: "string",
		description: "Distance to the edge of the viewport on the y-axis.",
		"default": "'1em'",
		defaultValue: "'1em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "editId",
		attribute: "edit-id",
		type: "string",
		description: "Corresponding ID for editable fields. This property is needed when multiple\nedit-button components are used on the page. Simply apply a\n\"data-spx-edit-id\" attribute with the same value to editable elements.",
		tags: [
		]
	},
	{
		name: "fontFamily",
		attribute: "font-family",
		type: "string",
		description: "",
		"default": "s.fontFamily",
		defaultValue: "'var(--spx-font-family)'",
		tags: [
		]
	},
	{
		name: "fontSize",
		attribute: "font-size",
		type: "string",
		description: "",
		"default": "s.fontSize",
		defaultValue: "'var(--spx-font-size)'",
		tags: [
		]
	},
	{
		name: "fontSizeMax",
		attribute: "font-size-max",
		type: "number",
		description: "",
		"default": "1.2",
		defaultValue: "1.2",
		tags: [
		]
	},
	{
		name: "fontSizeMin",
		attribute: "font-size-min",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "gap",
		attribute: "gap",
		type: "string",
		description: "Gap between the buttons.",
		"default": "'0.4em'",
		defaultValue: "'0.4em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "loaderColor",
		attribute: "loader-color",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "loaderGap",
		attribute: "loader-gap",
		type: "string",
		description: "",
		"default": "'0.5em'",
		defaultValue: "'0.5em'",
		tags: [
		]
	},
	{
		name: "padding",
		attribute: "padding",
		type: "string",
		description: "",
		"default": "'0.7em 1.2em'",
		defaultValue: "'0.7em 1.2em'",
		tags: [
		]
	},
	{
		name: "paddingXMax",
		attribute: "padding-x-max",
		type: "number",
		description: "",
		"default": "1.4",
		defaultValue: "1.4",
		tags: [
		]
	},
	{
		name: "paddingXMin",
		attribute: "padding-x-min",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "paddingYMax",
		attribute: "padding-y-max",
		type: "number",
		description: "",
		"default": "1.2",
		defaultValue: "1.2",
		tags: [
		]
	},
	{
		name: "paddingYMin",
		attribute: "padding-y-min",
		type: "number",
		description: "",
		"default": "0.7",
		defaultValue: "0.7",
		tags: [
		]
	},
	{
		name: "position",
		attribute: "position",
		type: "string",
		description: "Component position in page.",
		"default": "'bottom-right'",
		defaultValue: "'bottom-right'",
		tags: [
			{
				text: "'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'",
				name: "choice"
			}
		]
	},
	{
		name: "positionCss",
		attribute: "position-css",
		type: "\"absolute\" | \"fixed\" | \"relative\" | \"static\"",
		description: "CSS property position of button.",
		"default": "'fixed'",
		defaultValue: "'fixed'",
		tags: [
		]
	},
	{
		name: "styling",
		attribute: "styling",
		type: "string",
		description: "Styling.",
		"default": "'default'",
		defaultValue: "'default'",
		tags: [
			{
				text: "'default', 'fluid', 'headless'",
				name: "choice"
			}
		]
	},
	{
		name: "test",
		attribute: "test",
		type: "boolean",
		description: "",
		"default": "false",
		defaultValue: "false",
		tags: [
		]
	},
	{
		name: "textDiscard",
		attribute: "text-discard",
		type: "string",
		description: "Discard button text.",
		"default": "'Discard'",
		defaultValue: "'Discard'",
		tags: [
		]
	},
	{
		name: "textEdit",
		attribute: "text-edit",
		type: "string",
		description: "Edit button text.",
		"default": "'Edit site'",
		defaultValue: "'Edit site'",
		tags: [
		]
	},
	{
		name: "textSave",
		attribute: "text-save",
		type: "string",
		description: "Save button text.",
		"default": "'Save'",
		defaultValue: "'Save'",
		tags: [
		]
	},
	{
		name: "textSuccess",
		attribute: "text-success",
		type: "string",
		description: "Success message.",
		"default": "'Save was successful'",
		defaultValue: "'Save was successful'",
		tags: [
		]
	},
	{
		name: "zIndex",
		attribute: "z-index",
		type: "number",
		description: "",
		"default": "99",
		defaultValue: "99",
		tags: [
		]
	}
];
const events$i = [
	{
		name: "spxEditButtonDidLoad",
		description: "Fires after component has loaded."
	},
	{
		name: "spxEditButtonDiscard",
		description: "Fires after pressing the discard button."
	},
	{
		name: "spxEditButtonSave",
		description: "Fires after pressing the save button."
	}
];
const methods$h = [
	{
		name: "discard",
		description: "Discard changes.",
		signature: "discard() => Promise<void>"
	},
	{
		name: "edit",
		description: "Enable editing.",
		signature: "edit() => Promise<void>"
	},
	{
		name: "save",
		description: "Save changes.",
		signature: "save() => Promise<void>"
	}
];
const slots$h = [
];
const spxEditButton = {
	name: name$h,
	description: description$h,
	shadow: shadow$h,
	properties: properties$h,
	events: events$i,
	methods: methods$h,
	slots: slots$h
};

const editButton = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$h,
  description: description$h,
  shadow: shadow$h,
  properties: properties$h,
  events: events$i,
  methods: methods$h,
  slots: slots$h,
  'default': spxEditButton
});

const name$g = "spx-group";
const description$g = "Pass attributes to all inner (spx) child elements.\nAll attributes that start with g-* will be passed on to child elements.";
const shadow$g = false;
const properties$g = [
	{
		name: "content",
		attribute: "content",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "target",
		attribute: "target",
		type: "string",
		description: "Specifies a target element.",
		tags: [
		]
	}
];
const events$h = [
	{
		name: "spxGroupDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$g = [
];
const slots$g = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxGroup = {
	name: name$g,
	description: description$g,
	shadow: shadow$g,
	properties: properties$g,
	events: events$h,
	methods: methods$g,
	slots: slots$g
};

const group = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$g,
  description: description$g,
  shadow: shadow$g,
  properties: properties$g,
  events: events$h,
  methods: methods$g,
  slots: slots$g,
  'default': spxGroup
});

const name$f = "spx-icon";
const description$f = "Wrapper component for different kinds of icon sets. Currently comes included with Ionicons.";
const shadow$f = false;
const properties$f = [
	{
		name: "color",
		attribute: "color",
		type: "string",
		description: "",
		"default": "'inherit'",
		defaultValue: "'inherit'",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "'inline-block'",
		defaultValue: "'inline-block'",
		tags: [
		]
	},
	{
		name: "icon",
		attribute: "icon",
		type: "string",
		description: "Icon code.",
		tags: [
		]
	},
	{
		name: "size",
		attribute: "size",
		type: "string",
		description: "Icon size.",
		"default": "'1em'",
		defaultValue: "'1em'",
		tags: [
		]
	},
	{
		name: "sizeMax",
		attribute: "size-max",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "sizeMin",
		attribute: "size-min",
		type: "number",
		description: "",
		"default": "0.8",
		defaultValue: "0.8",
		tags: [
		]
	},
	{
		name: "styling",
		attribute: "styling",
		type: "string",
		description: "Styling.",
		"default": "'default'",
		defaultValue: "'default'",
		tags: [
			{
				text: "'default', 'fluid'",
				name: "choice"
			}
		]
	},
	{
		name: "type",
		attribute: "type",
		type: "string",
		description: "Icon type.",
		"default": "'ionicons'",
		defaultValue: "'ionicons'",
		tags: [
			{
				text: "'ionicons', 'caret'",
				name: "choice"
			}
		]
	}
];
const events$g = [
	{
		name: "spxIconDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$f = [
];
const slots$f = [
];
const spxIcon = {
	name: name$f,
	description: description$f,
	shadow: shadow$f,
	properties: properties$f,
	events: events$g,
	methods: methods$f,
	slots: slots$f
};

const icon = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$f,
  description: description$f,
  shadow: shadow$f,
  properties: properties$f,
  events: events$g,
  methods: methods$f,
  slots: slots$f,
  'default': spxIcon
});

const name$e = "spx-iframe";
const description$e = "A wrapper around a standard iframe element, which scales proportionally to\nits parent. Great for showing desktop versions of a website on smaller\nscreens or viewports.";
const shadow$e = false;
const properties$e = [
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "documentBorder",
		attribute: "document-border",
		type: "string",
		description: "",
		"default": "'none'",
		defaultValue: "'none'",
		tags: [
		]
	},
	{
		name: "documentBorderRadius",
		attribute: "document-border-radius",
		type: "string",
		description: "",
		"default": "'none'",
		defaultValue: "'none'",
		tags: [
		]
	},
	{
		name: "documentHeight",
		attribute: "document-height",
		type: "string",
		description: "",
		"default": "'auto'",
		defaultValue: "'auto'",
		tags: [
		]
	},
	{
		name: "documentWidth",
		attribute: "document-width",
		type: "string",
		description: "",
		"default": "'100%'",
		defaultValue: "'100%'",
		tags: [
		]
	},
	{
		name: "fit",
		attribute: "fit",
		type: "boolean",
		description: "Automatically resize iframe to fit content.",
		tags: [
		]
	},
	{
		name: "lazy",
		attribute: "lazy",
		type: "boolean",
		description: "Lazy load content.",
		tags: [
		]
	},
	{
		name: "loaderBackground",
		attribute: "loader-background",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "loaderBorderRadius",
		attribute: "loader-border-radius",
		type: "string",
		description: "",
		"default": "s.borderRadius",
		defaultValue: "'var(--spx-border-radius)'",
		tags: [
		]
	},
	{
		name: "loaderColor",
		attribute: "loader-color",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "minHeight",
		attribute: "min-height",
		type: "string",
		description: "",
		"default": "'400px'",
		defaultValue: "'400px'",
		tags: [
		]
	},
	{
		name: "size",
		attribute: "size",
		type: "string",
		description: "Screen size of the site shown inside the iframe.",
		"default": "'1440px'",
		defaultValue: "'1440px'",
		tags: [
		]
	},
	{
		name: "src",
		attribute: "src",
		type: "string",
		description: "Source for the iframe.",
		"default": "'https://spx.dev'",
		defaultValue: "'https://spx.dev'",
		tags: [
		]
	},
	{
		name: "type",
		attribute: "type",
		type: "string",
		description: "Screen size of the site shown inside the iframe.",
		"default": "'resize'",
		defaultValue: "'resize'",
		tags: [
			{
				text: "'resize', 'document'",
				name: "choice"
			}
		]
	}
];
const events$f = [
	{
		name: "spxIframeDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$e = [
];
const slots$e = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxIframe = {
	name: name$e,
	description: description$e,
	shadow: shadow$e,
	properties: properties$e,
	events: events$f,
	methods: methods$e,
	slots: slots$e
};

const iframe = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$e,
  description: description$e,
  shadow: shadow$e,
  properties: properties$e,
  events: events$f,
  methods: methods$e,
  slots: slots$e,
  'default': spxIframe
});

const name$d = "spx-image-comparison";
const description$d = "Compare two images visually using a slider. Handy for showing subtle (or not\nso subtle) before/after differences.";
const shadow$d = false;
const properties$d = [
	{
		name: "color",
		attribute: "color",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "height",
		attribute: "height",
		type: "string",
		description: "",
		"default": "'100%'",
		defaultValue: "'100%'",
		tags: [
		]
	},
	{
		name: "iconColor",
		attribute: "icon-color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "lazy",
		attribute: "lazy",
		type: "boolean",
		description: "Lazy load images.",
		tags: [
		]
	},
	{
		name: "srcAfter",
		attribute: "src-after",
		type: "string",
		description: "Image URL of the before image.",
		"default": "'https://source.unsplash.com/random/1200x300'",
		defaultValue: "'https://source.unsplash.com/random/1200x300'",
		tags: [
		]
	},
	{
		name: "srcBefore",
		attribute: "src-before",
		type: "string",
		description: "Image URL of the after image.",
		"default": "'https://source.unsplash.com/random/1201x300'",
		defaultValue: "'https://source.unsplash.com/random/1201x300'",
		tags: [
		]
	},
	{
		name: "start",
		attribute: "start",
		type: "number",
		description: "Opening state in pixels.",
		"default": "150",
		defaultValue: "150",
		tags: [
		]
	},
	{
		name: "steps",
		attribute: "steps",
		type: "number",
		description: "Step amount when using component with arrow keys.",
		"default": "10",
		defaultValue: "10",
		tags: [
		]
	}
];
const events$e = [
	{
		name: "spxImageComparisonDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$d = [
];
const slots$d = [
];
const spxImageComparison = {
	name: name$d,
	description: description$d,
	shadow: shadow$d,
	properties: properties$d,
	events: events$e,
	methods: methods$d,
	slots: slots$d
};

const imageComparison = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$d,
  description: description$d,
  shadow: shadow$d,
  properties: properties$d,
  events: events$e,
  methods: methods$d,
  slots: slots$d,
  'default': spxImageComparison
});

const name$c = "spx-lightbox";
const description$c = "Overlay a gallery of images on top of the current page.";
const shadow$c = false;
const properties$c = [
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "'block'",
		defaultValue: "'block'",
		tags: [
		]
	},
	{
		name: "height",
		attribute: "height",
		type: "string",
		description: "",
		"default": "'auto'",
		defaultValue: "'auto'",
		tags: [
		]
	},
	{
		name: "overlayColor",
		attribute: "overlay-color",
		type: "string",
		description: "",
		"default": "'rgba(0, 0, 0, 0.92)'",
		defaultValue: "'rgba(0, 0, 0, 0.92)'",
		tags: [
		]
	},
	{
		name: "width",
		attribute: "width",
		type: "string",
		description: "",
		"default": "'100%'",
		defaultValue: "'100%'",
		tags: [
		]
	}
];
const events$d = [
	{
		name: "spxLightboxDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$c = [
];
const slots$c = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxLightbox = {
	name: name$c,
	description: description$c,
	shadow: shadow$c,
	properties: properties$c,
	events: events$d,
	methods: methods$c,
	slots: slots$c
};

const lightbox = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$c,
  description: description$c,
  shadow: shadow$c,
  properties: properties$c,
  events: events$d,
  methods: methods$c,
  slots: slots$c,
  'default': spxLightbox
});

const name$b = "spx-masonry";
const description$b = "Arrange images in a masonry layout.";
const shadow$b = false;
const properties$b = [
	{
		name: "bpColumns",
		attribute: "bp-columns",
		type: "string",
		description: "Columns for different screen sizes. Example value: 1000:3;600:2 - this will\nswitch to a three column layout when the screen size is under 1000px and to\na two column layout under 600px.",
		tags: [
		]
	},
	{
		name: "columns",
		attribute: "columns",
		type: "number",
		description: "Number of columns.",
		"default": "4",
		defaultValue: "4",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "gap",
		attribute: "gap",
		type: "string",
		description: "Gap between images.",
		"default": "'10px'",
		defaultValue: "'10px'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "imageSize",
		attribute: "image-size",
		type: "string",
		description: "WordPress media size when using the helper function..",
		tags: [
		]
	},
	{
		name: "imageSrc",
		attribute: "image-src",
		type: "string",
		description: "Gets images from an ACF or Metabox field.",
		tags: [
			{
				text: "'acf', 'mb'",
				name: "choice"
			}
		]
	},
	{
		name: "images",
		attribute: "images",
		type: "string",
		description: "Gets images from an ACF or Metabox field.",
		tags: [
			{
				text: "&lt;?php spx\\Get::images($fieldName, $type) ?>",
				name: "helper"
			}
		]
	},
	{
		name: "lazy",
		attribute: "lazy",
		type: "boolean",
		description: "Lazy load images.",
		tags: [
		]
	}
];
const events$c = [
	{
		name: "spxMasonryDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$b = [
];
const slots$b = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxMasonry = {
	name: name$b,
	description: description$b,
	shadow: shadow$b,
	properties: properties$b,
	events: events$c,
	methods: methods$b,
	slots: slots$b
};

const masonry = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$b,
  description: description$b,
  shadow: shadow$b,
  properties: properties$b,
  events: events$c,
  methods: methods$b,
  slots: slots$b,
  'default': spxMasonry
});

const name$a = "spx-mockup";
const description$a = "Display device mockups around your content.";
const shadow$a = false;
const properties$a = [
	{
		name: "colorGalaxyS8",
		attribute: "color-galaxy-s-8",
		type: "string",
		description: "Samsung S8 color.",
		"default": "'black'",
		defaultValue: "'black'",
		tags: [
			{
				text: "'black', 'blue'",
				name: "choice"
			}
		]
	},
	{
		name: "colorGooglePixel",
		attribute: "color-google-pixel",
		type: "string",
		description: "Google Pixel color.",
		"default": "'silver'",
		defaultValue: "'silver'",
		tags: [
			{
				text: "'silver', 'black', 'blue'",
				name: "choice"
			}
		]
	},
	{
		name: "colorIpadPro",
		attribute: "color-ipad-pro",
		type: "string",
		description: "IPad Pro color.",
		"default": "'silver'",
		defaultValue: "'silver'",
		tags: [
			{
				text: "'silver', 'gold', 'rosegold', 'spacegray'",
				name: "choice"
			}
		]
	},
	{
		name: "colorIphone8",
		attribute: "color-iphone-8",
		type: "string",
		description: "IPhone 8 color.",
		"default": "'silver'",
		defaultValue: "'silver'",
		tags: [
			{
				text: "'silver', 'gold', 'spacegray'",
				name: "choice"
			}
		]
	},
	{
		name: "colorMacbook",
		attribute: "color-macbook",
		type: "string",
		description: "MacBook color.",
		"default": "'silver'",
		defaultValue: "'silver'",
		tags: [
			{
				text: "'silver', 'gold', 'rosegold', 'spacegray'",
				name: "choice"
			}
		]
	},
	{
		name: "colorMacbookPro",
		attribute: "color-macbook-pro",
		type: "string",
		description: "MacBook Pro color.",
		"default": "'silver'",
		defaultValue: "'silver'",
		tags: [
			{
				text: "'silver', 'spacegray'",
				name: "choice"
			}
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "'inline-block'",
		defaultValue: "'inline-block'",
		tags: [
		]
	},
	{
		name: "imagePosition",
		attribute: "image-position",
		type: "string",
		description: "",
		"default": "'50% 50%'",
		defaultValue: "'50% 50%'",
		tags: [
		]
	},
	{
		name: "size",
		attribute: "size",
		type: "number",
		description: "Mockup size.",
		tags: [
		]
	},
	{
		name: "sizeMax",
		attribute: "size-max",
		type: "number",
		description: "Mockup size maximum.",
		"default": "0.6",
		defaultValue: "0.6",
		tags: [
		]
	},
	{
		name: "sizeMin",
		attribute: "size-min",
		type: "number",
		description: "Mockup size minimum.",
		"default": "0.3",
		defaultValue: "0.3",
		tags: [
		]
	},
	{
		name: "src",
		attribute: "src",
		type: "string",
		description: "Image src if no inner slot is used.",
		tags: [
		]
	},
	{
		name: "type",
		attribute: "type",
		type: "string",
		description: "Device type.",
		"default": "'iphone-8'",
		defaultValue: "'iphone-8'",
		tags: [
			{
				text: "'iphone-8', 'iphone-x', 'google-pixel-2-xl', 'google-pixel', 'galaxy-s8', 'ipad-pro', 'surface-pro', 'surface-book', 'macbook', 'macbook-pro', 'surface-studio', 'imac-pro', 'apple-watch'",
				name: "choice"
			}
		]
	}
];
const events$b = [
	{
		name: "spxMockupDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$a = [
];
const slots$a = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxMockup = {
	name: name$a,
	description: description$a,
	shadow: shadow$a,
	properties: properties$a,
	events: events$b,
	methods: methods$a,
	slots: slots$a
};

const mockup = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$a,
  description: description$a,
  shadow: shadow$a,
  properties: properties$a,
  events: events$b,
  methods: methods$a,
  slots: slots$a,
  'default': spxMockup
});

const name$9 = "spx-navigation";
const description$9 = "Render a complete WordPress menu with nested submenus and automatic positioning.";
const shadow$9 = true;
const properties$9 = [
	{
		name: "childBorder",
		attribute: "child-border",
		type: "string",
		description: "",
		"default": "'1px solid var(--spx-color-gray-200)'",
		defaultValue: "'1px solid var(--spx-color-gray-200)'",
		tags: [
		]
	},
	{
		name: "childBorderRadius",
		attribute: "child-border-radius",
		type: "string",
		description: "Child menu border-radius.",
		"default": "'0'",
		defaultValue: "'0'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "childBoxShadow",
		attribute: "child-box-shadow",
		type: "string",
		description: "Child menu box-shadow.",
		"default": "'0 3px 10px 0 rgba(0,0,0,0.05)'",
		defaultValue: "'0 3px 10px 0 rgba(0,0,0,0.05)'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "childChildGap",
		attribute: "child-child-gap",
		type: "string",
		description: "Gap between nested child menus.",
		"default": "'0.8em'",
		defaultValue: "'0.8em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "childGap",
		attribute: "child-gap",
		type: "string",
		description: "Gap between top level menu items and child menus.",
		"default": "'0.5em'",
		defaultValue: "'0.5em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "childIcon",
		attribute: "child-icon",
		type: "string",
		description: "Indicator icon.",
		"default": "'arrow-down'",
		defaultValue: "'arrow-down'",
		tags: [
		]
	},
	{
		name: "childIconType",
		attribute: "child-icon-type",
		type: "string",
		description: "Indicator icon type.",
		"default": "'ionicons'",
		defaultValue: "'ionicons'",
		tags: [
		]
	},
	{
		name: "childIndicatorGap",
		attribute: "child-indicator-gap",
		type: "string",
		description: "Gap between child menu indicator and text.",
		"default": "'0.2em'",
		defaultValue: "'0.2em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "childItemBackground",
		attribute: "child-item-background",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "childItemBackgroundHover",
		attribute: "child-item-background-hover",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-100)'",
		defaultValue: "'var(--spx-color-gray-100)'",
		tags: [
		]
	},
	{
		name: "childItemColor",
		attribute: "child-item-color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-700)'",
		defaultValue: "'var(--spx-color-gray-700)'",
		tags: [
		]
	},
	{
		name: "childItemColorHover",
		attribute: "child-item-color-hover",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "childItemPadding",
		attribute: "child-item-padding",
		type: "string",
		description: "",
		"default": "'0.6em 0.8em'",
		defaultValue: "'0.6em 0.8em'",
		tags: [
		]
	},
	{
		name: "childPlacement",
		attribute: "child-placement",
		type: "string",
		description: "Child menu placement.",
		"default": "'start'",
		defaultValue: "'start'",
		tags: [
			{
				name: "CSS"
			},
			{
				text: "'start', 'end'",
				name: "choice"
			}
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "fontSize",
		attribute: "font-size",
		type: "string",
		description: "",
		"default": "'clamp(18px, 1.6vw, 20px)'",
		defaultValue: "'clamp(18px, 1.6vw, 20px)'",
		tags: [
		]
	},
	{
		name: "itemTransitionDuration",
		attribute: "item-transition-duration",
		type: "string",
		description: "",
		"default": "s.transitionDuration",
		defaultValue: "'var(--spx-transition-duration)'",
		tags: [
		]
	},
	{
		name: "itemTransitionTimingFunction",
		attribute: "item-transition-timing-function",
		type: "string",
		description: "",
		"default": "s.transitionTimingFunction",
		defaultValue: "'var(--spx-transition-timing-function)'",
		tags: [
		]
	},
	{
		name: "itemUnderline",
		attribute: "item-underline",
		type: "boolean",
		description: "Underlines all links.",
		tags: [
		]
	},
	{
		name: "itemUnderlineHover",
		attribute: "item-underline-hover",
		type: "boolean",
		description: "Underlines all links on hover.",
		tags: [
		]
	},
	{
		name: "menu",
		attribute: "menu",
		type: "string",
		description: "Renders a WordPress menu.",
		tags: [
			{
				text: "&lt;?php spx\\Get::navigation(\"myMenu\") ?>",
				name: "helper"
			}
		]
	},
	{
		name: "mobile",
		attribute: "mobile",
		type: "number",
		description: "Mobile breakpoint.",
		"default": "s.bpMobileWidth",
		defaultValue: 768,
		tags: [
		]
	},
	{
		name: "mobileIcon",
		attribute: "mobile-icon",
		type: "string",
		description: "Mobile button icon.",
		tags: [
		]
	},
	{
		name: "mobileIconType",
		attribute: "mobile-icon-type",
		type: "string",
		description: "Mobile button icon type.",
		"default": "'ionicons'",
		defaultValue: "'ionicons'",
		tags: [
		]
	},
	{
		name: "mobileItemBackground",
		attribute: "mobile-item-background",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "mobileItemBackgroundHover",
		attribute: "mobile-item-background-hover",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-100)'",
		defaultValue: "'var(--spx-color-gray-100)'",
		tags: [
		]
	},
	{
		name: "mobileItemColor",
		attribute: "mobile-item-color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-800)'",
		defaultValue: "'var(--spx-color-gray-800)'",
		tags: [
		]
	},
	{
		name: "mobileItemColorHover",
		attribute: "mobile-item-color-hover",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "mobileItemNestedMarginLeft",
		attribute: "mobile-item-nested-margin-left",
		type: "string",
		description: "",
		"default": "'0.8em'",
		defaultValue: "'0.8em'",
		tags: [
		]
	},
	{
		name: "mobileItemPadding",
		attribute: "mobile-item-padding",
		type: "string",
		description: "",
		"default": "'0.6em'",
		defaultValue: "'0.6em'",
		tags: [
		]
	},
	{
		name: "mobilePlacement",
		attribute: "mobile-placement",
		type: "string",
		description: "Mobile placement.",
		"default": "'start'",
		defaultValue: "'start'",
		tags: [
			{
				name: "CSS"
			},
			{
				text: "'start', 'end'",
				name: "choice"
			}
		]
	},
	{
		name: "parentItemBackground",
		attribute: "parent-item-background",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "parentItemBackgroundHover",
		attribute: "parent-item-background-hover",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-100)'",
		defaultValue: "'var(--spx-color-gray-100)'",
		tags: [
		]
	},
	{
		name: "parentItemColor",
		attribute: "parent-item-color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-800)'",
		defaultValue: "'var(--spx-color-gray-800)'",
		tags: [
		]
	},
	{
		name: "parentItemColorHover",
		attribute: "parent-item-color-hover",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "parentItemGap",
		attribute: "parent-item-gap",
		type: "string",
		description: "Gap between parent menu items.",
		"default": "'0.4em'",
		defaultValue: "'0.4em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "parentItemPadding",
		attribute: "parent-item-padding",
		type: "string",
		description: "",
		"default": "'0.6em'",
		defaultValue: "'0.6em'",
		tags: [
		]
	},
	{
		name: "vertical",
		attribute: "vertical",
		type: "boolean",
		description: "Renders menu vertically.",
		tags: [
		]
	}
];
const events$a = [
	{
		name: "spxNavigationDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$9 = [
];
const slots$9 = [
];
const spxNavigation = {
	name: name$9,
	description: description$9,
	shadow: shadow$9,
	properties: properties$9,
	events: events$a,
	methods: methods$9,
	slots: slots$9
};

const navigation = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$9,
  description: description$9,
  shadow: shadow$9,
  properties: properties$9,
  events: events$a,
  methods: methods$9,
  slots: slots$9,
  'default': spxNavigation
});

const name$8 = "spx-notation";
const description$8 = "Annotate letters, words or whole sentences.";
const shadow$8 = false;
const properties$8 = [
	{
		name: "animation",
		attribute: "animation",
		type: "boolean",
		description: "Turn animation on or off when animation.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "animationDuration",
		attribute: "animation-duration",
		type: "number",
		description: "Animation duration.",
		"default": "800",
		defaultValue: "800",
		tags: [
		]
	},
	{
		name: "autoplay",
		attribute: "autoplay",
		type: "boolean",
		description: "Autoplay.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "brackets",
		attribute: "brackets",
		type: "string",
		description: "Brackets.",
		"default": "'left, right'",
		defaultValue: "'left, right'",
		tags: [
		]
	},
	{
		name: "color",
		attribute: "color",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-100)'",
		defaultValue: "'var(--spx-color-gray-100)'",
		tags: [
		]
	},
	{
		name: "delay",
		attribute: "delay",
		type: "number",
		description: "",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "'inline-block'",
		defaultValue: "'inline-block'",
		tags: [
		]
	},
	{
		name: "group",
		attribute: "group",
		type: "boolean",
		description: "Create a group on annotations by applying a \"data-spx-annotation\" to elements within.",
		tags: [
		]
	},
	{
		name: "iterations",
		attribute: "iterations",
		type: "number",
		description: "Number of iterations.",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "multiline",
		attribute: "multiline",
		type: "boolean",
		description: "Annotate multiline text.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "padding",
		attribute: "padding",
		type: "number",
		description: "Padding around notations.",
		tags: [
		]
	},
	{
		name: "strokeWidth",
		attribute: "stroke-width",
		type: "number",
		description: "Stroke width.",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "type",
		attribute: "type",
		type: "string",
		description: "Type of notation.",
		"default": "'underline'",
		defaultValue: "'underline'",
		tags: [
			{
				text: "'underline', 'box', 'circle', 'highlight', 'strike-through', 'crossed-off', 'bracket'",
				name: "choice"
			}
		]
	}
];
const events$9 = [
	{
		name: "spxNotationDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$8 = [
	{
		name: "clear",
		description: "Remove the annotation.",
		signature: "clear() => Promise<void>"
	},
	{
		name: "hide",
		description: "Hides the annotation. (non animated)",
		signature: "hide() => Promise<void>"
	},
	{
		name: "redraw",
		description: "Redraw the animation.",
		signature: "redraw() => Promise<void>"
	},
	{
		name: "show",
		description: "Draws the annotation.",
		signature: "show() => Promise<void>"
	}
];
const slots$8 = [
];
const spxNotation = {
	name: name$8,
	description: description$8,
	shadow: shadow$8,
	properties: properties$8,
	events: events$9,
	methods: methods$8,
	slots: slots$8
};

const notation = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$8,
  description: description$8,
  shadow: shadow$8,
  properties: properties$8,
  events: events$9,
  methods: methods$8,
  slots: slots$8,
  'default': spxNotation
});

const name$7 = "spx-offset";
const description$7 = "The component offsets itself to the height of a specified element. It comes\nin handy when dealing with a fixed header and is used on this site. Simply\nwrap your main content container with it and select a target element. The\ndistance will adjust on screen resize.";
const shadow$7 = false;
const properties$7 = [
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "target",
		attribute: "target",
		type: "string",
		description: "Target element.",
		"default": "'header'",
		defaultValue: "'header'",
		tags: [
		]
	}
];
const events$8 = [
	{
		name: "spxOffsetDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$7 = [
	{
		name: "recalc",
		description: "Recalculate distance.",
		signature: "recalc() => Promise<void>"
	}
];
const slots$7 = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxOffset = {
	name: name$7,
	description: description$7,
	shadow: shadow$7,
	properties: properties$7,
	events: events$8,
	methods: methods$7,
	slots: slots$7
};

const offset$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$7,
  description: description$7,
  shadow: shadow$7,
  properties: properties$7,
  events: events$8,
  methods: methods$7,
  slots: slots$7,
  'default': spxOffset
});

const name$6 = "spx-scrollspy";
const description$6 = "Automatically add CSS classes to navigation items\nand content elements depending on the scroll position.";
const shadow$6 = false;
const properties$6 = [
	{
		name: "contentClass",
		attribute: "content-class",
		type: "string",
		description: "Applied class to active content element.",
		"default": "'spx-scrollspy__content--active'",
		defaultValue: "'spx-scrollspy__content--active'",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "navClass",
		attribute: "nav-class",
		type: "string",
		description: "Applied class to active navigation element.",
		"default": "'spx-scrollspy__nav--active'",
		defaultValue: "'spx-scrollspy__nav--active'",
		tags: [
		]
	},
	{
		name: "offset",
		attribute: "offset",
		type: "any",
		description: "Selects the height of an element (any querySelector value) or number that\nis used for offsetting how far from the top the next section is activated.",
		"default": "0",
		defaultValue: "0",
		tags: [
		]
	},
	{
		name: "scrolling",
		attribute: "scrolling",
		type: "number",
		description: "Activates automatic navigation scrolling and sets the offset.",
		tags: [
		]
	},
	{
		name: "target",
		attribute: "target",
		type: "string",
		description: "Target element. Can take any querySelector value. (id, class, tag etc.)",
		"default": "'a'",
		defaultValue: "'a'",
		tags: [
		]
	},
	{
		name: "urlChange",
		attribute: "url-change",
		type: "boolean",
		description: "Appends the currently active link to the end of the URL.",
		"default": "false",
		defaultValue: "false",
		tags: [
		]
	}
];
const events$7 = [
	{
		name: "spxScrollspyActivate",
		description: "Fires after a link is activated."
	},
	{
		name: "spxScrollspyDeactivate",
		description: "Fires after a link is deactivated."
	},
	{
		name: "spxScrollspyDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$6 = [
	{
		name: "reload",
		description: "Reload the Scrollspy.",
		signature: "reload() => Promise<void>"
	}
];
const slots$6 = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxScrollspy = {
	name: name$6,
	description: description$6,
	shadow: shadow$6,
	properties: properties$6,
	events: events$7,
	methods: methods$6,
	slots: slots$6
};

const scrollspy = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$6,
  description: description$6,
  shadow: shadow$6,
  properties: properties$6,
  events: events$7,
  methods: methods$6,
  slots: slots$6,
  'default': spxScrollspy
});

const name$5 = "spx-share";
const description$5 = "Social share buttons. Currently includes Facebook, Twitter, Whatsapp and E-Mail.";
const shadow$5 = false;
const properties$5 = [
	{
		name: "classItem",
		attribute: "class-item",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "fontSize",
		attribute: "font-size",
		type: "string",
		description: "",
		"default": "s.fontSize",
		defaultValue: "'var(--spx-font-size)'",
		tags: [
		]
	},
	{
		name: "fontSizeMax",
		attribute: "font-size-max",
		type: "number",
		description: "",
		"default": "1.4",
		defaultValue: "1.4",
		tags: [
		]
	},
	{
		name: "fontSizeMin",
		attribute: "font-size-min",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "itemBackground",
		attribute: "item-background",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "itemBorderRadius",
		attribute: "item-border-radius",
		type: "string",
		description: "",
		"default": "s.borderRadius",
		defaultValue: "'var(--spx-border-radius)'",
		tags: [
		]
	},
	{
		name: "itemColor",
		attribute: "item-color",
		type: "string",
		description: "Gap between buttons.",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "itemFilterHover",
		attribute: "item-filter-hover",
		type: "string",
		description: "Filter hover.",
		"default": "'brightness(110%) saturate(120%)'",
		defaultValue: "'brightness(110%) saturate(120%)'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "itemGap",
		attribute: "item-gap",
		type: "string",
		description: "Gap between buttons.",
		"default": "'0.5em'",
		defaultValue: "'0.5em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "itemGapMax",
		attribute: "item-gap-max",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "itemGapMin",
		attribute: "item-gap-min",
		type: "number",
		description: "",
		"default": "0.4",
		defaultValue: "0.4",
		tags: [
		]
	},
	{
		name: "itemPadding",
		attribute: "item-padding",
		type: "string",
		description: "",
		"default": "'0.5em'",
		defaultValue: "'0.5em'",
		tags: [
		]
	},
	{
		name: "itemPaddingMax",
		attribute: "item-padding-max",
		type: "number",
		description: "",
		"default": "1.2",
		defaultValue: "1.2",
		tags: [
		]
	},
	{
		name: "itemPaddingMin",
		attribute: "item-padding-min",
		type: "number",
		description: "",
		"default": "0.5",
		defaultValue: "0.5",
		tags: [
		]
	},
	{
		name: "itemSize",
		attribute: "item-size",
		type: "string",
		description: "",
		"default": "'1em'",
		defaultValue: "'1em'",
		tags: [
		]
	},
	{
		name: "itemSizeMax",
		attribute: "item-size-max",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "itemSizeMin",
		attribute: "item-size-min",
		type: "number",
		description: "",
		"default": "0.7",
		defaultValue: "0.7",
		tags: [
		]
	},
	{
		name: "itemTransitionDuration",
		attribute: "item-transition-duration",
		type: "string",
		description: "",
		"default": "s.transitionDuration",
		defaultValue: "'var(--spx-transition-duration)'",
		tags: [
		]
	},
	{
		name: "itemTransitionTimingFunction",
		attribute: "item-transition-timing-function",
		type: "string",
		description: "",
		"default": "s.transitionTimingFunction",
		defaultValue: "'var(--spx-transition-timing-function)'",
		tags: [
		]
	},
	{
		name: "styling",
		attribute: "styling",
		type: "string",
		description: "Styling.",
		"default": "'default'",
		defaultValue: "'default'",
		tags: [
			{
				text: "'default', 'fluid', 'headless'",
				name: "choice"
			}
		]
	},
	{
		name: "target",
		attribute: "target",
		type: "string",
		description: "Button href target.",
		"default": "'_blank'",
		defaultValue: "'_blank'",
		tags: [
		]
	},
	{
		name: "theme",
		attribute: "theme",
		type: "string",
		description: "Button theme.",
		"default": "'default'",
		defaultValue: "'default'",
		tags: [
			{
				text: "'default', 'outline', 'minimal'",
				name: "choice"
			}
		]
	},
	{
		name: "vertical",
		attribute: "vertical",
		type: "boolean",
		description: "Render buttons vertically.",
		tags: [
		]
	}
];
const events$6 = [
	{
		name: "spxShareDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$5 = [
];
const slots$5 = [
];
const spxShare = {
	name: name$5,
	description: description$5,
	shadow: shadow$5,
	properties: properties$5,
	events: events$6,
	methods: methods$5,
	slots: slots$5
};

const share = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$5,
  description: description$5,
  shadow: shadow$5,
  properties: properties$5,
  events: events$6,
  methods: methods$5,
  slots: slots$5,
  'default': spxShare
});

const name$4 = "spx-slider";
const description$4 = "A slider is a revolving carousel that displays photos or other types of content.";
const shadow$4 = false;
const properties$4 = [
	{
		name: "autoheight",
		attribute: "autoheight",
		type: "boolean",
		description: "Automatically adjusts height of slider.",
		"default": "false",
		defaultValue: "false",
		tags: [
		]
	},
	{
		name: "autoplay",
		attribute: "autoplay",
		type: "boolean",
		description: "Starts navigating to the next slide when page is loaded.",
		"default": "false",
		defaultValue: "false",
		tags: [
		]
	},
	{
		name: "autoplayDelay",
		attribute: "autoplay-delay",
		type: "number",
		description: "Autoplay delay.",
		"default": "6000",
		defaultValue: "6000",
		tags: [
		]
	},
	{
		name: "autoplayDisableOnInteraction",
		attribute: "autoplay-disable-on-interaction",
		type: "boolean",
		description: "Disable autoplay after interaction with slides.",
		"default": "false",
		defaultValue: "false",
		tags: [
		]
	},
	{
		name: "centeredSlides",
		attribute: "centered-slides",
		type: "boolean",
		description: "Centers slides in viewport.",
		"default": "false",
		defaultValue: "false",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "effect",
		attribute: "effect",
		type: "string",
		description: "Slider effect.",
		"default": "'slide'",
		defaultValue: "'slide'",
		tags: [
			{
				text: "'slide', 'effect'",
				name: "choice"
			}
		]
	},
	{
		name: "imageObjectFit",
		attribute: "image-object-fit",
		type: "string",
		description: "Image object-fit.",
		"default": "'cover'",
		defaultValue: "'cover'",
		tags: [
			{
				text: "'fill', 'contain', 'cover', 'scale-down', 'none'",
				name: "choice"
			}
		]
	},
	{
		name: "imageSize",
		attribute: "image-size",
		type: "string",
		description: "WordPress media size when using the helper function.",
		tags: [
		]
	},
	{
		name: "imageSrc",
		attribute: "image-src",
		type: "string",
		description: "Gets images from an ACF or Metabox field.",
		tags: [
			{
				text: "'acf', 'mb'",
				name: "choice"
			}
		]
	},
	{
		name: "images",
		attribute: "images",
		type: "string",
		description: "Gets images from an ACF or Metabox field.",
		tags: [
			{
				text: "&lt;?php spx\\Get::gallery($fieldName, $type) ?>",
				name: "helper"
			}
		]
	},
	{
		name: "lazy",
		attribute: "lazy",
		type: "boolean",
		description: "Lazy load images.",
		tags: [
		]
	},
	{
		name: "lazyLoadPrevNext",
		attribute: "lazy-load-prev-next",
		type: "number",
		description: "Amount of images to to be preloaded when lazy is enabled.",
		tags: [
		]
	},
	{
		name: "loop",
		attribute: "loop",
		type: "boolean",
		description: "Loops all slides infinitely.",
		tags: [
		]
	},
	{
		name: "maxHeight",
		attribute: "max-height",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "navigation",
		attribute: "navigation",
		type: "boolean",
		description: "",
		tags: [
		]
	},
	{
		name: "navigationBackdropFilter",
		attribute: "navigation-backdrop-filter",
		type: "string",
		description: "",
		"default": "s.backdropFilter",
		defaultValue: "s.backdropFilter",
		tags: [
		]
	},
	{
		name: "navigationBackground",
		attribute: "navigation-background",
		type: "string",
		description: "",
		"default": "'rgba(0,0,0,0.7)'",
		defaultValue: "'rgba(0,0,0,0.7)'",
		tags: [
		]
	},
	{
		name: "navigationBackgroundHover",
		attribute: "navigation-background-hover",
		type: "string",
		description: "",
		"default": "'rgba(0,0,0,1)'",
		defaultValue: "'rgba(0,0,0,1)'",
		tags: [
		]
	},
	{
		name: "navigationBorderRadius",
		attribute: "navigation-border-radius",
		type: "string",
		description: "",
		"default": "s.borderRadius",
		defaultValue: "'var(--spx-border-radius)'",
		tags: [
		]
	},
	{
		name: "navigationColor",
		attribute: "navigation-color",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "navigationDistanceX",
		attribute: "navigation-distance-x",
		type: "string",
		description: "Navigation distance.",
		"default": "'12px'",
		defaultValue: "'12px'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "navigationIconNext",
		attribute: "navigation-icon-next",
		type: "string",
		description: "Navigation icon type.",
		"default": "'arrow-forward'",
		defaultValue: "'arrow-forward'",
		tags: [
		]
	},
	{
		name: "navigationIconPrev",
		attribute: "navigation-icon-prev",
		type: "string",
		description: "Navigation icon type.",
		"default": "'arrow-back'",
		defaultValue: "'arrow-back'",
		tags: [
		]
	},
	{
		name: "navigationIconType",
		attribute: "navigation-icon-type",
		type: "string",
		description: "Navigation icon type.",
		"default": "'ionicons'",
		defaultValue: "'ionicons'",
		tags: [
		]
	},
	{
		name: "navigationPadding",
		attribute: "navigation-padding",
		type: "string",
		description: "",
		"default": "'12px'",
		defaultValue: "'12px'",
		tags: [
		]
	},
	{
		name: "navigationSize",
		attribute: "navigation-size",
		type: "string",
		description: "Navigation size.",
		"default": "'20px'",
		defaultValue: "'20px'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "navigationTransitionDuration",
		attribute: "navigation-transition-duration",
		type: "string",
		description: "",
		"default": "s.transitionDuration",
		defaultValue: "'var(--spx-transition-duration)'",
		tags: [
		]
	},
	{
		name: "navigationTransitionTimingFunction",
		attribute: "navigation-transition-timing-function",
		type: "string",
		description: "",
		"default": "s.transitionTimingFunction",
		defaultValue: "'var(--spx-transition-timing-function)'",
		tags: [
		]
	},
	{
		name: "pagination",
		attribute: "pagination",
		type: "string",
		description: "Pagination type.",
		"default": "'bullets'",
		defaultValue: "'bullets'",
		tags: [
			{
				text: "'bullets', 'none'",
				name: "choice"
			}
		]
	},
	{
		name: "paginationBackdropFilter",
		attribute: "pagination-backdrop-filter",
		type: "string",
		description: "",
		"default": "s.backdropFilter",
		defaultValue: "s.backdropFilter",
		tags: [
		]
	},
	{
		name: "paginationBackground",
		attribute: "pagination-background",
		type: "string",
		description: "",
		"default": "'rgba(0,0,0,0.7)'",
		defaultValue: "'rgba(0,0,0,0.7)'",
		tags: [
		]
	},
	{
		name: "paginationBulletsBackground",
		attribute: "pagination-bullets-background",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-500)'",
		defaultValue: "'var(--spx-color-gray-500)'",
		tags: [
		]
	},
	{
		name: "paginationBulletsBackgroundActive",
		attribute: "pagination-bullets-background-active",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "paginationBulletsClickable",
		attribute: "pagination-bullets-clickable",
		type: "boolean",
		description: "Make bullets clickable.",
		tags: [
		]
	},
	{
		name: "paginationBulletsDynamic",
		attribute: "pagination-bullets-dynamic",
		type: "boolean",
		description: "Will only keep a selected amount of bullets visible.",
		tags: [
		]
	},
	{
		name: "paginationBulletsDynamicAmount",
		attribute: "pagination-bullets-dynamic-amount",
		type: "number",
		description: "Amount of dynamic bullets.",
		"default": "5",
		defaultValue: "5",
		tags: [
		]
	},
	{
		name: "paginationBulletsSize",
		attribute: "pagination-bullets-size",
		type: "string",
		description: "Size of the bullets.",
		"default": "'6px'",
		defaultValue: "'6px'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "paginationBulletsSpaceBetween",
		attribute: "pagination-bullets-space-between",
		type: "string",
		description: "Space between the bullets.",
		"default": "'6px'",
		defaultValue: "'6px'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "paginationTransitionDuration",
		attribute: "pagination-transition-duration",
		type: "string",
		description: "",
		"default": "s.transitionDuration",
		defaultValue: "'var(--spx-transition-duration)'",
		tags: [
		]
	},
	{
		name: "paginationTransitionTimingFunction",
		attribute: "pagination-transition-timing-function",
		type: "string",
		description: "",
		"default": "s.transitionTimingFunction",
		defaultValue: "'var(--spx-transition-timing-function)'",
		tags: [
		]
	},
	{
		name: "prevNextFilter",
		attribute: "prev-next-filter",
		type: "string",
		description: "Filter property for the previous and next elements.",
		tags: [
		]
	},
	{
		name: "slideMessageFirst",
		attribute: "slide-message-first",
		type: "string",
		description: "Screen reader message for first slide.",
		"default": "'This is the first slide'",
		defaultValue: "'This is the first slide'",
		tags: [
		]
	},
	{
		name: "slideMessageLast",
		attribute: "slide-message-last",
		type: "string",
		description: "Screen reader message for last slide.",
		"default": "'This is the last slide'",
		defaultValue: "'This is the last slide'",
		tags: [
		]
	},
	{
		name: "slideMessageNext",
		attribute: "slide-message-next",
		type: "string",
		description: "Screen reader message for next slide.",
		"default": "'Next slide'",
		defaultValue: "'Next slide'",
		tags: [
		]
	},
	{
		name: "slideMessagePrevious",
		attribute: "slide-message-previous",
		type: "string",
		description: "Screen reader message for previous slide.",
		"default": "'Previous slide'",
		defaultValue: "'Previous slide'",
		tags: [
		]
	},
	{
		name: "slidesPerView",
		attribute: "slides-per-view",
		type: "number",
		description: "Amount of slides shown at once.",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "spaceBetween",
		attribute: "space-between",
		type: "number",
		description: "Space between slides.",
		"default": "0",
		defaultValue: "0",
		tags: [
		]
	},
	{
		name: "speed",
		attribute: "speed",
		type: "number",
		description: "Sliding speed.",
		"default": "1000",
		defaultValue: "1000",
		tags: [
		]
	}
];
const events$5 = [
	{
		name: "spxSliderDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$4 = [
];
const slots$4 = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxSlider = {
	name: name$4,
	description: description$4,
	shadow: shadow$4,
	properties: properties$4,
	events: events$5,
	methods: methods$4,
	slots: slots$4
};

const slider = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$4,
  description: description$4,
  shadow: shadow$4,
  properties: properties$4,
  events: events$5,
  methods: methods$4,
  slots: slots$4,
  'default': spxSlider
});

const name$3 = "spx-slideshow";
const description$3 = "Continuously playing slideshow.";
const shadow$3 = true;
const properties$3 = [
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "'block'",
		defaultValue: "'block'",
		tags: [
		]
	},
	{
		name: "duration",
		attribute: "duration",
		type: "string",
		description: "Duration of slideshow to complete one cycle.",
		"default": "'60s'",
		defaultValue: "'60s'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "gap",
		attribute: "gap",
		type: "string",
		description: "Gap between inner elements.",
		"default": "'1em'",
		defaultValue: "'1em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "height",
		attribute: "height",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "imageSize",
		attribute: "image-size",
		type: "string",
		description: "WordPress media size when using the helper function..",
		tags: [
		]
	},
	{
		name: "imageSrc",
		attribute: "image-src",
		type: "string",
		description: "Gets images from an ACF or Metabox field.",
		tags: [
			{
				text: "'acf', 'mb'",
				name: "choice"
			}
		]
	},
	{
		name: "images",
		attribute: "images",
		type: "string",
		description: "Gets images from an ACF or Metabox field.",
		tags: [
			{
				text: "&lt;?php spx\\get::gallery($fieldName, $type) ?>",
				name: "helper"
			}
		]
	},
	{
		name: "lazy",
		attribute: "lazy",
		type: "boolean",
		description: "Lazy load images.",
		tags: [
		]
	},
	{
		name: "maxWidth",
		attribute: "max-width",
		type: "string",
		description: "Max width of inner elements.",
		"default": "'300px'",
		defaultValue: "'300px'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "objectFit",
		attribute: "object-fit",
		type: "string",
		description: "",
		"default": "'contain'",
		defaultValue: "'contain'",
		tags: [
		]
	},
	{
		name: "overflow",
		attribute: "overflow",
		type: "string",
		description: "If not set with this attribute, overflow should be set on the parent element.",
		tags: [
			{
				name: "CSS"
			}
		]
	}
];
const events$4 = [
	{
		name: "spxSlideshowDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$3 = [
];
const slots$3 = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxSlideshow = {
	name: name$3,
	description: description$3,
	shadow: shadow$3,
	properties: properties$3,
	events: events$4,
	methods: methods$3,
	slots: slots$3
};

const slideshow = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$3,
  description: description$3,
  shadow: shadow$3,
  properties: properties$3,
  events: events$4,
  methods: methods$3,
  slots: slots$3,
  'default': spxSlideshow
});

const name$2 = "spx-snackbar";
const description$2 = "Notification bars with a variety of options. Great for success or failure\nmessages. In default mode, the snackbar will fade out and remove itself from the DOM.";
const shadow$2 = false;
const properties$2 = [
	{
		name: "animationDelay",
		attribute: "animation-delay",
		type: "string",
		description: "",
		"default": "'200ms'",
		defaultValue: "'200ms'",
		tags: [
		]
	},
	{
		name: "animationDuration",
		attribute: "animation-duration",
		type: "string",
		description: "",
		"default": "'2000ms'",
		defaultValue: "'2000ms'",
		tags: [
		]
	},
	{
		name: "background",
		attribute: "background",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-900)'",
		defaultValue: "'var(--spx-color-gray-900)'",
		tags: [
		]
	},
	{
		name: "border",
		attribute: "border",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "borderRadius",
		attribute: "border-radius",
		type: "string",
		description: "",
		"default": "s.borderRadius",
		defaultValue: "'var(--spx-border-radius)'",
		tags: [
		]
	},
	{
		name: "buttonBackground",
		attribute: "button-background",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-700)'",
		defaultValue: "'var(--spx-color-gray-700)'",
		tags: [
		]
	},
	{
		name: "buttonBackgroundHover",
		attribute: "button-background-hover",
		type: "string",
		description: "",
		"default": "'var(--spx-color-gray-800)'",
		defaultValue: "'var(--spx-color-gray-800)'",
		tags: [
		]
	},
	{
		name: "buttonTransitionDuration",
		attribute: "button-transition-duration",
		type: "string",
		description: "",
		"default": "s.transitionDuration",
		defaultValue: "'var(--spx-transition-duration)'",
		tags: [
		]
	},
	{
		name: "buttonTransitionTimingFunction",
		attribute: "button-transition-timing-function",
		type: "string",
		description: "",
		"default": "s.transitionTimingFunction",
		defaultValue: "'var(--spx-transition-timing-function)'",
		tags: [
		]
	},
	{
		name: "classButton",
		attribute: "class-button",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "classText",
		attribute: "class-text",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "closeable",
		attribute: "closeable",
		type: "boolean",
		description: "Adds option to close snackbar after its creation.",
		tags: [
		]
	},
	{
		name: "color",
		attribute: "color",
		type: "string",
		description: "",
		"default": "'#ffffff'",
		defaultValue: "'#ffffff'",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "distanceX",
		attribute: "distance-x",
		type: "string",
		description: "Distance to the edge of the viewport on the x-axis.",
		"default": "'1em'",
		defaultValue: "'1em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "distanceY",
		attribute: "distance-y",
		type: "string",
		description: "Distance to the edge of the viewport on the y-axis.",
		"default": "'1em'",
		defaultValue: "'1em'",
		tags: [
			{
				name: "CSS"
			}
		]
	},
	{
		name: "fixed",
		attribute: "fixed",
		type: "boolean",
		description: "Makes snackbar not removable.",
		tags: [
		]
	},
	{
		name: "fontSize",
		attribute: "font-size",
		type: "string",
		description: "",
		"default": "'18px'",
		defaultValue: "'18px'",
		tags: [
		]
	},
	{
		name: "fontSizeMax",
		attribute: "font-size-max",
		type: "number",
		description: "",
		"default": "1.6",
		defaultValue: "1.6",
		tags: [
		]
	},
	{
		name: "fontSizeMin",
		attribute: "font-size-min",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "identifier",
		attribute: "identifier",
		type: "string",
		description: "Unique identifier for snackbar instance.",
		"default": "'primary'",
		defaultValue: "'primary'",
		tags: [
		]
	},
	{
		name: "padding",
		attribute: "padding",
		type: "string",
		description: "",
		"default": "'0.8em'",
		defaultValue: "'0.8em'",
		tags: [
		]
	},
	{
		name: "paddingMax",
		attribute: "padding-max",
		type: "number",
		description: "",
		"default": "1.4",
		defaultValue: "1.4",
		tags: [
		]
	},
	{
		name: "paddingMin",
		attribute: "padding-min",
		type: "number",
		description: "",
		"default": "1",
		defaultValue: "1",
		tags: [
		]
	},
	{
		name: "position",
		attribute: "position",
		type: "string",
		description: "Component position in page.",
		"default": "'bottom-right'",
		defaultValue: "'bottom-right'",
		tags: [
			{
				text: "'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'",
				name: "choice"
			}
		]
	},
	{
		name: "positionCss",
		attribute: "position-css",
		type: "\"absolute\" | \"fixed\" | \"relative\" | \"static\"",
		description: "CSS property position of button.",
		"default": "'fixed'",
		defaultValue: "'fixed'",
		tags: [
		]
	},
	{
		name: "reverse",
		attribute: "reverse",
		type: "boolean",
		description: "Reverses the close button if \"closable\" prop is true.",
		tags: [
		]
	},
	{
		name: "spaceBetween",
		attribute: "space-between",
		type: "string",
		description: "Space between snackbars.",
		"default": "'12px'",
		defaultValue: "'12px'",
		tags: [
		]
	},
	{
		name: "styling",
		attribute: "styling",
		type: "string",
		description: "Styling.",
		"default": "'default'",
		defaultValue: "'default'",
		tags: [
			{
				text: "'default', 'fluid', 'headless'",
				name: "choice"
			}
		]
	},
	{
		name: "target",
		attribute: "target",
		type: "string",
		description: "Element where snackbars should be created in.",
		"default": "'body'",
		defaultValue: "'body'",
		tags: [
		]
	},
	{
		name: "text",
		attribute: "text",
		type: "string",
		description: "Text inside snackbar.",
		"default": "\"Hello, I'm a snackbar.\"",
		defaultValue: "\"Hello, I'm a snackbar.\"",
		tags: [
		]
	},
	{
		name: "zIndex",
		attribute: "z-index",
		type: "number",
		description: "",
		"default": "103",
		defaultValue: "103",
		tags: [
		]
	}
];
const events$3 = [
	{
		name: "spxSnackbarDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$2 = [
];
const slots$2 = [
];
const spxSnackbar = {
	name: name$2,
	description: description$2,
	shadow: shadow$2,
	properties: properties$2,
	events: events$3,
	methods: methods$2,
	slots: slots$2
};

const snackbar = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$2,
  description: description$2,
  shadow: shadow$2,
  properties: properties$2,
  events: events$3,
  methods: methods$2,
  slots: slots$2,
  'default': spxSnackbar
});

const name$1 = "spx-text-path";
const description$1 = "Write text along a predefined path.";
const shadow$1 = false;
const properties$1 = [
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "'block'",
		defaultValue: "'block'",
		tags: [
		]
	},
	{
		name: "spaceBetween",
		attribute: "space-between",
		type: "string",
		description: "Space between text and path.",
		"default": "'-2%'",
		defaultValue: "'-2%'",
		tags: [
		]
	},
	{
		name: "startOffset",
		attribute: "start-offset",
		type: "string",
		description: "Starting offset off the text.",
		"default": "'25%'",
		defaultValue: "'25%'",
		tags: [
		]
	},
	{
		name: "text",
		attribute: "text",
		type: "string",
		description: "Text to be shown.",
		tags: [
		]
	},
	{
		name: "textColor",
		attribute: "text-color",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "textFontSize",
		attribute: "text-font-size",
		type: "string",
		description: "Text size.",
		"default": "'clamp(20px, 3vw, 24px)'",
		defaultValue: "'clamp(20px, 3vw, 24px)'",
		tags: [
		]
	},
	{
		name: "textFontWeight",
		attribute: "text-font-weight",
		type: "string",
		description: "",
		tags: [
		]
	},
	{
		name: "textTransform",
		attribute: "text-transform",
		type: "string",
		description: "Text transform.",
		"default": "'default'",
		defaultValue: "'default'",
		tags: [
		]
	}
];
const events$2 = [
	{
		name: "spxTextPathDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods$1 = [
];
const slots$1 = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxTextPath = {
	name: name$1,
	description: description$1,
	shadow: shadow$1,
	properties: properties$1,
	events: events$2,
	methods: methods$1,
	slots: slots$1
};

const textPath = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name$1,
  description: description$1,
  shadow: shadow$1,
  properties: properties$1,
  events: events$2,
  methods: methods$1,
  slots: slots$1,
  'default': spxTextPath
});

const name = "spx-typewriter";
const description = "Animates text like it is being written on a typewriter.";
const shadow = false;
const properties = [
	{
		name: "autoStart",
		attribute: "auto-start",
		type: "boolean",
		description: "Automatically starts writing.",
		"default": "true",
		defaultValue: "true",
		tags: [
		]
	},
	{
		name: "delay",
		attribute: "delay",
		type: "any",
		description: "Writing delay in ms. Also accepts 'natural' value.",
		"default": "'natural'",
		defaultValue: "'natural'",
		tags: [
		]
	},
	{
		name: "deleteSpeed",
		attribute: "delete-speed",
		type: "any",
		description: "Delete delay in ms. Also accepts 'natural' value.",
		"default": "'natural'",
		defaultValue: "'natural'",
		tags: [
		]
	},
	{
		name: "display",
		attribute: "display",
		type: "string",
		description: "",
		"default": "s.display",
		defaultValue: "s.display",
		tags: [
		]
	},
	{
		name: "loop",
		attribute: "loop",
		type: "boolean",
		description: "Loops the animation.",
		tags: [
		]
	},
	{
		name: "text",
		attribute: "text",
		type: "string",
		description: "Text that should be written.",
		"default": "\"I'm a typewriter\"",
		defaultValue: "\"I'm a typewriter\"",
		tags: [
		]
	}
];
const events$1 = [
	{
		name: "spxTypewriterDidLoad",
		description: "Fires after component has loaded."
	}
];
const methods = [
	{
		name: "play",
		description: "Start animation.",
		signature: "play() => Promise<void>"
	},
	{
		name: "stop",
		description: "Stop animation.",
		signature: "stop() => Promise<void>"
	}
];
const slots = [
	{
		name: "inner",
		description: "Slot (between HTML tags)."
	}
];
const spxTypewriter = {
	name: name,
	description: description,
	shadow: shadow,
	properties: properties,
	events: events$1,
	methods: methods,
	slots: slots
};

const typewriter = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name,
  description: description,
  shadow: shadow,
  properties: properties,
  events: events$1,
  methods: methods,
  slots: slots,
  'default': spxTypewriter
});

/**
 * Make every first letter from string uppercase.
 *
 * @param {string} str String to make title case.
 * @returns {string} Title case string.
 */
function titleCase(str) {
  const splitStr = str.toLowerCase().split(' ');
  for (let i = 0; i < splitStr.length; i++) {
    splitStr[i] =
      splitStr[i].charAt(0).toUpperCase() + splitStr[i].substring(1);
  }
  return splitStr.join(' ');
}

// eslint-disable-next-line no-unused-vars
/**
 * Text input element.
 *
 * @param {object} obj HTML element props.
 * @returns {HTMLElement} Return an HTML element.
 */
function TextInput(obj) {
  return h$4("input", Object.assign({}, obj, { type: "text" }));
}

function e$2(e,t){if(null==e)return {};var n,r,i=function(e,t){if(null==e)return {};var n,r,i={},u=Object.keys(e);for(r=0;r<u.length;r++)n=u[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(e);for(r=0;r<u.length;r++)n=u[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n]);}return i}var t$2={name:"prettier",version:"2.3.2",description:"Prettier is an opinionated code formatter",bin:"./bin/prettier.js",repository:"prettier/prettier",homepage:"https://prettier.io",author:"James Long",license:"MIT",main:"./index.js",browser:"./standalone.js",unpkg:"./standalone.js",engines:{node:">=12.17.0"},files:["index.js","standalone.js","src","bin"],dependencies:{"@angular/compiler":"12.0.5","@babel/code-frame":"7.14.5","@babel/parser":"7.14.6","@glimmer/syntax":"0.79.3","@iarna/toml":"2.2.5","@typescript-eslint/typescript-estree":"4.27.0","angular-estree-parser":"2.4.0","angular-html-parser":"1.8.0",camelcase:"6.2.0",chalk:"4.1.1","ci-info":"3.2.0","cjk-regex":"2.0.1",cosmiconfig:"7.0.0",dashify:"2.0.0",diff:"5.0.0",editorconfig:"0.15.3","editorconfig-to-prettier":"0.2.0","escape-string-regexp":"4.0.0",espree:"7.3.1",esutils:"2.0.3","fast-glob":"3.2.5","fast-json-stable-stringify":"2.1.0","find-parent-dir":"0.3.1","flow-parser":"0.153.0","get-stdin":"8.0.0",globby:"11.0.4",graphql:"15.5.0","html-element-attributes":"2.3.0","html-styles":"1.0.0","html-tag-names":"1.1.5","html-void-elements":"1.0.5",ignore:"4.0.6","jest-docblock":"27.0.1",json5:"2.2.0",leven:"3.1.0","lines-and-columns":"1.1.6","linguist-languages":"7.15.0",lodash:"4.17.21",mem:"8.1.1",meriyah:"4.1.5",minimatch:"3.0.4",minimist:"1.2.5","n-readlines":"1.0.1",outdent:"0.8.0","parse-srcset":"ikatyang/parse-srcset#54eb9c1cb21db5c62b4d0e275d7249516df6f0ee","please-upgrade-node":"3.2.0","postcss-less":"3.1.4","postcss-media-query-parser":"0.2.3","postcss-scss":"2.1.1","postcss-selector-parser":"2.2.3","postcss-values-parser":"2.0.1","regexp-util":"1.2.2","remark-footnotes":"2.0.0","remark-math":"3.0.1","remark-parse":"8.0.3",resolve:"1.20.0",semver:"7.3.5","string-width":"4.2.2","strip-ansi":"6.0.0",typescript:"4.3.4","unicode-regex":"3.0.0",unified:"9.2.1",vnopts:"1.0.2",wcwidth:"1.0.1","yaml-unist-parser":"1.3.1"},devDependencies:{"@babel/core":"7.14.6","@babel/preset-env":"7.14.5","@babel/types":"7.14.5","@glimmer/reference":"0.79.3","@rollup/plugin-alias":"3.1.2","@rollup/plugin-babel":"5.3.0","@rollup/plugin-commonjs":"18.1.0","@rollup/plugin-json":"4.1.0","@rollup/plugin-node-resolve":"13.0.0","@rollup/plugin-replace":"2.4.2","@types/estree":"0.0.48","babel-jest":"27.0.2","babel-loader":"8.2.2",benchmark:"2.1.4","builtin-modules":"3.2.0","core-js":"3.14.0","cross-env":"7.0.3",cspell:"4.2.8",eslint:"7.29.0","eslint-config-prettier":"8.3.0","eslint-formatter-friendly":"7.0.0","eslint-plugin-import":"2.23.4","eslint-plugin-jest":"24.3.6","eslint-plugin-prettier-internal-rules":"link:scripts/tools/eslint-plugin-prettier-internal-rules","eslint-plugin-react":"7.24.0","eslint-plugin-regexp":"0.12.1","eslint-plugin-unicorn":"33.0.1","esm-utils":"1.1.0",execa:"5.1.1",jest:"27.0.4","jest-snapshot-serializer-ansi":"1.0.0","jest-snapshot-serializer-raw":"1.2.0","jest-watch-typeahead":"0.6.4","npm-run-all":"4.1.5","path-browserify":"1.0.1",prettier:"2.3.1","pretty-bytes":"5.6.0",rimraf:"3.0.2",rollup:"2.52.1","rollup-plugin-polyfill-node":"0.6.2","rollup-plugin-terser":"7.0.2",shelljs:"0.8.4","snapshot-diff":"0.9.0",tempy:"1.0.1","terser-webpack-plugin":"5.1.3",webpack:"5.39.1"},scripts:{prepublishOnly:'echo "Error: must publish from dist/" && exit 1',"prepare-release":"yarn && yarn build && yarn test:dist",test:"jest","test:dev-package":"cross-env INSTALL_PACKAGE=1 jest","test:dist":"cross-env NODE_ENV=production jest","test:dist-standalone":"cross-env NODE_ENV=production TEST_STANDALONE=1 jest","test:integration":"jest tests/integration","perf:repeat":"yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null","perf:repeat-inspect":"yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null","perf:benchmark":"yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",lint:"run-p lint:*","lint:typecheck":"tsc","lint:eslint":"cross-env EFF_NO_LINK_RULES=true eslint . --format friendly","lint:changelog":"node ./scripts/lint-changelog.mjs","lint:prettier":'prettier . "!test*" --check',"lint:dist":'eslint --no-eslintrc --no-ignore --no-inline-config --env=es6,browser --parser-options=ecmaVersion:2019 "dist/!(bin-prettier|index|third-party).js"',"lint:spellcheck":'cspell "**/*" ".github/**/*"',"lint:deps":"node ./scripts/check-deps.mjs",fix:"run-s fix:eslint fix:prettier","fix:eslint":"yarn lint:eslint --fix","fix:prettier":"yarn lint:prettier --write",build:"node --max-old-space-size=3072 ./scripts/build/build.mjs","build-docs":"node ./scripts/build-docs.mjs"}},n$2="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function r$2(e){return e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function i$2(e){var t={exports:{}};return e(t,t.exports),t.exports}var u$2=i$2((function(e,t){function n(){}function r(e,t,n,r,i){for(var u=0,o=t.length,s=0,a=0;u<o;u++){var l=t[u];if(l.removed){if(l.value=e.join(r.slice(a,a+l.count)),a+=l.count,u&&t[u-1].added){var c=t[u-1];t[u-1]=t[u],t[u]=c;}}else {if(!l.added&&i){var p=n.slice(s,s+l.count);p=p.map((function(e,t){var n=r[a+t];return n.length>e.length?n:e})),l.value=e.join(p);}else l.value=e.join(n.slice(s,s+l.count));s+=l.count,l.added||(a+=l.count);}}var f=t[o-1];return o>1&&"string"==typeof f.value&&(f.added||f.removed)&&e.equals("",f.value)&&(t[o-2].value+=f.value,t.pop()),t}function i(e){return {newPos:e.newPos,components:e.components.slice(0)}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=n,n.prototype={diff:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},u=n.callback;"function"==typeof n&&(u=n,n={}),this.options=n;var o=this;function s(e){return u?(setTimeout((function(){u(void 0,e);}),0),!0):e}e=this.castInput(e),t=this.castInput(t),e=this.removeEmpty(this.tokenize(e));var a=(t=this.removeEmpty(this.tokenize(t))).length,l=e.length,c=1,p=a+l,f=[{newPos:-1,components:[]}],d=this.extractCommon(f[0],t,e,0);if(f[0].newPos+1>=a&&d+1>=l)return s([{value:this.join(t),count:t.length}]);function h(){for(var n=-1*c;n<=c;n+=2){var u=void 0,p=f[n-1],d=f[n+1],h=(d?d.newPos:0)-n;p&&(f[n-1]=void 0);var g=p&&p.newPos+1<a,m=d&&0<=h&&h<l;if(g||m){if(!g||m&&p.newPos<d.newPos?(u=i(d),o.pushComponent(u.components,void 0,!0)):((u=p).newPos++,o.pushComponent(u.components,!0,void 0)),h=o.extractCommon(u,t,e,n),u.newPos+1>=a&&h+1>=l)return s(r(o,u.components,t,e,o.useLongestToken));f[n]=u;}else f[n]=void 0;}c++;}if(u)!function e(){setTimeout((function(){if(c>p)return u();h()||e();}),0);}();else for(;c<=p;){var g=h();if(g)return g}},pushComponent:function(e,t,n){var r=e[e.length-1];r&&r.added===t&&r.removed===n?e[e.length-1]={count:r.count+1,added:t,removed:n}:e.push({count:1,added:t,removed:n});},extractCommon:function(e,t,n,r){for(var i=t.length,u=n.length,o=e.newPos,s=o-r,a=0;o+1<i&&s+1<u&&this.equals(t[o+1],n[s+1]);)o++,s++,a++;return a&&e.components.push({count:a}),e.newPos=o,s},equals:function(e,t){return this.options.comparator?this.options.comparator(e,t):e===t||this.options.ignoreCase&&e.toLowerCase()===t.toLowerCase()},removeEmpty:function(e){for(var t=[],n=0;n<e.length;n++)e[n]&&t.push(e[n]);return t},castInput:function(e){return e},tokenize:function(e){return e.split("")},join:function(e){return e.join("")}};})),o$2=i$2((function(e,t){var n;Object.defineProperty(t,"__esModule",{value:!0}),t.diffChars=function(e,t,n){return r.diff(e,t,n)},t.characterDiff=void 0;var r=new((n=u$2)&&n.__esModule?n:{default:n}).default;t.characterDiff=r;})),s$2=function(e,t){if("function"==typeof e)t.callback=e;else if(e)for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t};var a$2=Object.defineProperty({generateOptions:s$2},"__esModule",{value:!0}),l$2=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.diffWords=function(e,t,n){return n=(0, a$2.generateOptions)(n,{ignoreWhitespace:!0}),s.diff(e,t,n)},t.diffWordsWithSpace=function(e,t,n){return s.diff(e,t,n)},t.wordDiff=void 0;var n,r=(n=u$2)&&n.__esModule?n:{default:n};var i=/^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,o=/\S/,s=new r.default;t.wordDiff=s,s.equals=function(e,t){return this.options.ignoreCase&&(e=e.toLowerCase(),t=t.toLowerCase()),e===t||this.options.ignoreWhitespace&&!o.test(e)&&!o.test(t)},s.tokenize=function(e){for(var t=e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/),n=0;n<t.length-1;n++)!t[n+1]&&t[n+2]&&i.test(t[n])&&i.test(t[n+2])&&(t[n]+=t[n+2],t.splice(n+1,2),n--);return t};})),c$2=i$2((function(e,t){var n;Object.defineProperty(t,"__esModule",{value:!0}),t.diffLines=function(e,t,n){return r.diff(e,t,n)},t.diffTrimmedLines=function(e,t,n){var i=(0, a$2.generateOptions)(n,{ignoreWhitespace:!0});return r.diff(e,t,i)},t.lineDiff=void 0;var r=new((n=u$2)&&n.__esModule?n:{default:n}).default;t.lineDiff=r,r.tokenize=function(e){var t=[],n=e.split(/(\n|\r\n)/);n[n.length-1]||n.pop();for(var r=0;r<n.length;r++){var i=n[r];r%2&&!this.options.newlineIsToken?t[t.length-1]+=i:(this.options.ignoreWhitespace&&(i=i.trim()),t.push(i));}return t};})),p$2=i$2((function(e,t){var n;Object.defineProperty(t,"__esModule",{value:!0}),t.diffSentences=function(e,t,n){return r.diff(e,t,n)},t.sentenceDiff=void 0;var r=new((n=u$2)&&n.__esModule?n:{default:n}).default;t.sentenceDiff=r,r.tokenize=function(e){return e.split(/(\S.+?[.!?])(?=\s+|$)/)};})),f$2=i$2((function(e,t){var n;Object.defineProperty(t,"__esModule",{value:!0}),t.diffCss=function(e,t,n){return r.diff(e,t,n)},t.cssDiff=void 0;var r=new((n=u$2)&&n.__esModule?n:{default:n}).default;t.cssDiff=r,r.tokenize=function(e){return e.split(/([{}:;,]|\s+)/)};})),d$2=function(e){return e&&e.Math==Math&&e},h$2=d$2("object"==typeof globalThis&&globalThis)||d$2("object"==typeof window&&window)||d$2("object"==typeof self&&self)||d$2("object"==typeof n$2&&n$2)||function(){return this}()||Function("return this")(),g$2=function(e){try{return !!e()}catch(e){return !0}},m$2=!g$2((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),y$1={}.propertyIsEnumerable,D$1=Object.getOwnPropertyDescriptor,E$1={f:D$1&&!y$1.call({1:2},1)?function(e){var t=D$1(this,e);return !!t&&t.enumerable}:y$1},b$1=function(e,t){return {enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},C$1={}.toString,v$1=function(e){return C$1.call(e).slice(8,-1)},A$1="".split,F$1=g$2((function(){return !Object("z").propertyIsEnumerable(0)}))?function(e){return "String"==v$1(e)?A$1.call(e,""):Object(e)}:Object,x$1=function(e){if(null==e)throw TypeError("Can't call method on "+e);return e},S$1=function(e){return F$1(x$1(e))},w$1=function(e){return "object"==typeof e?null!==e:"function"==typeof e},T$1=function(e,t){if(!w$1(e))return e;var n,r;if(t&&"function"==typeof(n=e.toString)&&!w$1(r=n.call(e)))return r;if("function"==typeof(n=e.valueOf)&&!w$1(r=n.call(e)))return r;if(!t&&"function"==typeof(n=e.toString)&&!w$1(r=n.call(e)))return r;throw TypeError("Can't convert object to primitive value")},B$1=function(e){return Object(x$1(e))},k$1={}.hasOwnProperty,N$1=Object.hasOwn||function(e,t){return k$1.call(B$1(e),t)},P$1=h$2.document,O$1=w$1(P$1)&&w$1(P$1.createElement),I$1=!m$2&&!g$2((function(){return 7!=Object.defineProperty((e="div",O$1?P$1.createElement(e):{}),"a",{get:function(){return 7}}).a;var e;})),j$1=Object.getOwnPropertyDescriptor,L$1={f:m$2?j$1:function(e,t){if(e=S$1(e),t=T$1(t,!0),I$1)try{return j$1(e,t)}catch(e){}if(N$1(e,t))return b$1(!E$1.f.call(e,t),e[t])}},_$2=function(e){if(!w$1(e))throw TypeError(String(e)+" is not an object");return e},M$1=Object.defineProperty,R$1={f:m$2?M$1:function(e,t,n){if(_$2(e),t=T$1(t,!0),_$2(n),I$1)try{return M$1(e,t,n)}catch(e){}if("get"in n||"set"in n)throw TypeError("Accessors not supported");return "value"in n&&(e[t]=n.value),e}},$$2=m$2?function(e,t,n){return R$1.f(e,t,b$1(1,n))}:function(e,t,n){return e[t]=n,e},V$1=function(e,t){try{$$2(h$2,e,t);}catch(n){h$2[e]=t;}return t},q$1=h$2["__core-js_shared__"]||V$1("__core-js_shared__",{}),W$1=Function.toString;"function"!=typeof q$1.inspectSource&&(q$1.inspectSource=function(e){return W$1.call(e)});var U$1,z$1,G$1,H$1,J$1=q$1.inspectSource,X$1=h$2.WeakMap,Y$1="function"==typeof X$1&&/native code/.test(J$1(X$1)),K$1=i$2((function(e){(e.exports=function(e,t){return q$1[e]||(q$1[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.14.0",mode:"global",copyright:"\xa9 2021 Denis Pushkarev (zloirock.ru)"});})),Q$1=0,Z$1=Math.random(),ee$1=function(e){return "Symbol("+String(void 0===e?"":e)+")_"+(++Q$1+Z$1).toString(36)},te$1=K$1("keys"),ne$1={},re$1=h$2.WeakMap;if(Y$1||q$1.state){var ie$1=q$1.state||(q$1.state=new re$1),ue$1=ie$1.get,oe$1=ie$1.has,se$1=ie$1.set;U$1=function(e,t){if(oe$1.call(ie$1,e))throw new TypeError("Object already initialized");return t.facade=e,se$1.call(ie$1,e,t),t},z$1=function(e){return ue$1.call(ie$1,e)||{}},G$1=function(e){return oe$1.call(ie$1,e)};}else {var ae$1=te$1[H$1="state"]||(te$1[H$1]=ee$1(H$1));ne$1[ae$1]=!0,U$1=function(e,t){if(N$1(e,ae$1))throw new TypeError("Object already initialized");return t.facade=e,$$2(e,ae$1,t),t},z$1=function(e){return N$1(e,ae$1)?e[ae$1]:{}},G$1=function(e){return N$1(e,ae$1)};}var le$1,ce$1,pe$1={set:U$1,get:z$1,has:G$1,enforce:function(e){return G$1(e)?z$1(e):U$1(e,{})},getterFor:function(e){return function(t){var n;if(!w$1(t)||(n=z$1(t)).type!==e)throw TypeError("Incompatible receiver, "+e+" required");return n}}},fe$1=i$2((function(e){var t=pe$1.get,n=pe$1.enforce,r=String(String).split("String");(e.exports=function(e,t,i,u){var o,s=!!u&&!!u.unsafe,a=!!u&&!!u.enumerable,l=!!u&&!!u.noTargetGet;"function"==typeof i&&("string"!=typeof t||N$1(i,"name")||$$2(i,"name",t),(o=n(i)).source||(o.source=r.join("string"==typeof t?t:""))),e!==h$2?(s?!l&&e[t]&&(a=!0):delete e[t],a?e[t]=i:$$2(e,t,i)):a?e[t]=i:V$1(t,i);})(Function.prototype,"toString",(function(){return "function"==typeof this&&t(this).source||J$1(this)}));})),de$1=h$2,he$1=function(e){return "function"==typeof e?e:void 0},ge$1=function(e,t){return arguments.length<2?he$1(de$1[e])||he$1(h$2[e]):de$1[e]&&de$1[e][t]||h$2[e]&&h$2[e][t]},me$1=Math.ceil,ye$1=Math.floor,De$1=function(e){return isNaN(e=+e)?0:(e>0?ye$1:me$1)(e)},Ee$1=Math.min,be$1=function(e){return e>0?Ee$1(De$1(e),9007199254740991):0},Ce$1=Math.max,ve$1=Math.min,Ae$1=function(e){return function(t,n,r){var i,u=S$1(t),o=be$1(u.length),s=function(e,t){var n=De$1(e);return n<0?Ce$1(n+t,0):ve$1(n,t)}(r,o);if(e&&n!=n){for(;o>s;)if((i=u[s++])!=i)return !0}else for(;o>s;s++)if((e||s in u)&&u[s]===n)return e||s||0;return !e&&-1}},Fe$1={includes:Ae$1(!0),indexOf:Ae$1(!1)}.indexOf,xe$1=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"].concat("length","prototype"),Se$1={f:Object.getOwnPropertyNames||function(e){return function(e,t){var n,r=S$1(e),i=0,u=[];for(n in r)!N$1(ne$1,n)&&N$1(r,n)&&u.push(n);for(;t.length>i;)N$1(r,n=t[i++])&&(~Fe$1(u,n)||u.push(n));return u}(e,xe$1)}},we$1={f:Object.getOwnPropertySymbols},Te$1=ge$1("Reflect","ownKeys")||function(e){var t=Se$1.f(_$2(e)),n=we$1.f;return n?t.concat(n(e)):t},Be$1=function(e,t){for(var n=Te$1(t),r=R$1.f,i=L$1.f,u=0;u<n.length;u++){var o=n[u];N$1(e,o)||r(e,o,i(t,o));}},ke$1=/#|\.prototype\./,Ne$1=function(e,t){var n=Oe$1[Pe$1(e)];return n==je$1||n!=Ie$1&&("function"==typeof t?g$2(t):!!t)},Pe$1=Ne$1.normalize=function(e){return String(e).replace(ke$1,".").toLowerCase()},Oe$1=Ne$1.data={},Ie$1=Ne$1.NATIVE="N",je$1=Ne$1.POLYFILL="P",Le$1=Ne$1,_e$1=L$1.f,Me$1=function(e,t){var n,r,i,u,o,s=e.target,a=e.global,l=e.stat;if(n=a?h$2:l?h$2[s]||V$1(s,{}):(h$2[s]||{}).prototype)for(r in t){if(u=t[r],i=e.noTargetGet?(o=_e$1(n,r))&&o.value:n[r],!Le$1(a?r:s+(l?".":"#")+r,e.forced)&&void 0!==i){if(typeof u==typeof i)continue;Be$1(u,i);}(e.sham||i&&i.sham)&&$$2(u,"sham",!0),fe$1(n,r,u,e);}},Re$1=function(e){if("function"!=typeof e)throw TypeError(String(e)+" is not a function");return e},$e$1=Math.floor,Ve$1=function(e,t){var n=e.length,r=$e$1(n/2);return n<8?qe$1(e,t):We$1(Ve$1(e.slice(0,r),t),Ve$1(e.slice(r),t),t)},qe$1=function(e,t){for(var n,r,i=e.length,u=1;u<i;){for(r=u,n=e[u];r&&t(e[r-1],n)>0;)e[r]=e[--r];r!==u++&&(e[r]=n);}return e},We$1=function(e,t,n){for(var r=e.length,i=t.length,u=0,o=0,s=[];u<r||o<i;)u<r&&o<i?s.push(n(e[u],t[o])<=0?e[u++]:t[o++]):s.push(u<r?e[u++]:t[o++]);return s},Ue$1=Ve$1,ze$1=ge$1("navigator","userAgent")||"",Ge$1=ze$1.match(/firefox\/(\d+)/i),He$1=!!Ge$1&&+Ge$1[1],Je$1=/MSIE|Trident/.test(ze$1),Xe$1=h$2.process,Ye$1=Xe$1&&Xe$1.versions,Ke$1=Ye$1&&Ye$1.v8;Ke$1?ce$1=(le$1=Ke$1.split("."))[0]<4?1:le$1[0]+le$1[1]:ze$1&&(!(le$1=ze$1.match(/Edge\/(\d+)/))||le$1[1]>=74)&&(le$1=ze$1.match(/Chrome\/(\d+)/))&&(ce$1=le$1[1]);var Ze$1,et$1=ce$1&&+ce$1,tt$1=ze$1.match(/AppleWebKit\/(\d+)\./),nt$1=!!tt$1&&+tt$1[1],rt$1=[],it$1=rt$1.sort,ut$1=g$2((function(){rt$1.sort(void 0);})),ot$1=g$2((function(){rt$1.sort(null);})),st$1=!!(Ze$1=[]["sort"])&&g$2((function(){Ze$1.call(null,function(){throw 1},1);})),at$1=!g$2((function(){if(et$1)return et$1<70;if(!(He$1&&He$1>3)){if(Je$1)return !0;if(nt$1)return nt$1<603;var e,t,n,r,i="";for(e=65;e<76;e++){switch(t=String.fromCharCode(e),e){case 66:case 69:case 70:case 72:n=3;break;case 68:case 71:n=4;break;default:n=2;}for(r=0;r<47;r++)rt$1.push({k:t+r,v:n});}for(rt$1.sort((function(e,t){return t.v-e.v})),r=0;r<rt$1.length;r++)t=rt$1[r].k.charAt(0),i.charAt(i.length-1)!==t&&(i+=t);return "DGBEFHACIJK"!==i}}));Me$1({target:"Array",proto:!0,forced:ut$1||!ot$1||!st$1||!at$1},{sort:function(e){void 0!==e&&Re$1(e);var t=B$1(this);if(at$1)return void 0===e?it$1.call(t):it$1.call(t,e);var n,r,i=[],u=be$1(t.length);for(r=0;r<u;r++)r in t&&i.push(t[r]);for(n=(i=Ue$1(i,function(e){return function(t,n){return void 0===n?-1:void 0===t?1:void 0!==e?+e(t,n)||0:String(t)>String(n)?1:-1}}(e))).length,r=0;r<n;)t[r]=i[r++];for(;r<u;)delete t[r++];return t}});var lt$1=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.diffJson=function(e,t,n){return s.diff(e,t,n)},t.canonicalize=a,t.jsonDiff=void 0;var n,r=(n=u$2)&&n.__esModule?n:{default:n};function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var o=Object.prototype.toString,s=new r.default;function a(e,t,n,r,u){var s,l;for(t=t||[],n=n||[],r&&(e=r(u,e)),s=0;s<t.length;s+=1)if(t[s]===e)return n[s];if("[object Array]"===o.call(e)){for(t.push(e),l=new Array(e.length),n.push(l),s=0;s<e.length;s+=1)l[s]=a(e[s],t,n,r,u);return t.pop(),n.pop(),l}if(e&&e.toJSON&&(e=e.toJSON()),"object"===i(e)&&null!==e){t.push(e),l={},n.push(l);var c,p=[];for(c in e)e.hasOwnProperty(c)&&p.push(c);for(p.sort(),s=0;s<p.length;s+=1)l[c=p[s]]=a(e[c],t,n,r,c);t.pop(),n.pop();}else l=e;return l}t.jsonDiff=s,s.useLongestToken=!0,s.tokenize=c$2.lineDiff.tokenize,s.castInput=function(e){var t=this.options,n=t.undefinedReplacement,r=t.stringifyReplacer,i=void 0===r?function(e,t){return void 0===t?n:t}:r;return "string"==typeof e?e:JSON.stringify(a(e,null,null,i),i,"  ")},s.equals=function(e,t){return r.default.prototype.equals.call(s,e.replace(/,([\r\n])/g,"$1"),t.replace(/,([\r\n])/g,"$1"))};})),ct$1=i$2((function(e,t){var n;Object.defineProperty(t,"__esModule",{value:!0}),t.diffArrays=function(e,t,n){return r.diff(e,t,n)},t.arrayDiff=void 0;var r=new((n=u$2)&&n.__esModule?n:{default:n}).default;t.arrayDiff=r,r.tokenize=function(e){return e.slice()},r.join=r.removeEmpty=function(e){return e};})),pt$1=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.split(/\r\n|[\n\v\f\r\x85]/),r=e.match(/\r\n|[\n\v\f\r\x85]/g)||[],i=[],u=0;function o(){var e={};for(i.push(e);u<n.length;){var r=n[u];if(/^(\-\-\-|\+\+\+|@@)\s/.test(r))break;var o=/^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r);o&&(e.index=o[1]),u++;}for(s(e),s(e),e.hunks=[];u<n.length;){var l=n[u];if(/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(l))break;if(/^@@/.test(l))e.hunks.push(a());else {if(l&&t.strict)throw new Error("Unknown line "+(u+1)+" "+JSON.stringify(l));u++;}}}function s(e){var t=/^(---|\+\+\+)\s+(.*)$/.exec(n[u]);if(t){var r="---"===t[1]?"old":"new",i=t[2].split("\t",2),o=i[0].replace(/\\\\/g,"\\");/^".*"$/.test(o)&&(o=o.substr(1,o.length-2)),e[r+"FileName"]=o,e[r+"Header"]=(i[1]||"").trim(),u++;}}function a(){var e=u,i=n[u++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/),o={oldStart:+i[1],oldLines:void 0===i[2]?1:+i[2],newStart:+i[3],newLines:void 0===i[4]?1:+i[4],lines:[],linedelimiters:[]};0===o.oldLines&&(o.oldStart+=1),0===o.newLines&&(o.newStart+=1);for(var s=0,a=0;u<n.length&&!(0===n[u].indexOf("--- ")&&u+2<n.length&&0===n[u+1].indexOf("+++ ")&&0===n[u+2].indexOf("@@"));u++){var l=0==n[u].length&&u!=n.length-1?" ":n[u][0];if("+"!==l&&"-"!==l&&" "!==l&&"\\"!==l)break;o.lines.push(n[u]),o.linedelimiters.push(r[u]||"\n"),"+"===l?s++:"-"===l?a++:" "===l&&(s++,a++);}if(s||1!==o.newLines||(o.newLines=0),a||1!==o.oldLines||(o.oldLines=0),t.strict){if(s!==o.newLines)throw new Error("Added line count did not match for hunk at line "+(e+1));if(a!==o.oldLines)throw new Error("Removed line count did not match for hunk at line "+(e+1))}return o}for(;u<n.length;)o();return i};var ft$1,dt$1=Object.defineProperty({parsePatch:pt$1},"__esModule",{value:!0}),ht$1=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){var r=!0,i=!1,u=!1,o=1;return function s(){if(r&&!u){if(i?o++:r=!1,e+o<=n)return o;u=!0;}if(!i)return u||(r=!0),t<=e-o?-o++:(i=!0,s())}};})),gt$1=Dt$1,mt$1=function(e,t){"string"==typeof e&&(e=(0, dt$1.parsePatch)(e));var n=0;!function r(){var i=e[n++];if(!i)return t.complete();t.loadFile(i,(function(e,n){if(e)return t.complete(e);var u=Dt$1(n,i,t);t.patched(i,u,(function(e){if(e)return t.complete(e);r();}));}));}();},yt$1=(ft$1=ht$1)&&ft$1.__esModule?ft$1:{default:ft$1};function Dt$1(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("string"==typeof t&&(t=(0, dt$1.parsePatch)(t)),Array.isArray(t)){if(t.length>1)throw new Error("applyPatch only works with a single input.");t=t[0];}var r,i,u=e.split(/\r\n|[\n\v\f\r\x85]/),o=e.match(/\r\n|[\n\v\f\r\x85]/g)||[],s=t.hunks,a=n.compareLine||function(e,t,n,r){return t===r},l=0,c=n.fuzzFactor||0,p=0,f=0;function d(e,t){for(var n=0;n<e.lines.length;n++){var r=e.lines[n],i=r.length>0?r[0]:" ",o=r.length>0?r.substr(1):r;if(" "===i||"-"===i){if(!a(t+1,u[t],i,o)&&++l>c)return !1;t++;}}return !0}for(var h=0;h<s.length;h++){for(var g=s[h],m=u.length-g.oldLines,y=0,D=f+g.oldStart-1,E=(0, yt$1.default)(D,p,m);void 0!==y;y=E())if(d(g,D+y)){g.offset=f+=y;break}if(void 0===y)return !1;p=g.offset+g.oldStart+g.oldLines;}for(var b=0,C=0;C<s.length;C++){var v=s[C],A=v.oldStart+v.offset+b-1;b+=v.newLines-v.oldLines;for(var F=0;F<v.lines.length;F++){var x=v.lines[F],S=x.length>0?x[0]:" ",w=x.length>0?x.substr(1):x,T=v.linedelimiters[F];if(" "===S)A++;else if("-"===S)u.splice(A,1),o.splice(A,1);else if("+"===S)u.splice(A,0,w),o.splice(A,0,T),A++;else if("\\"===S){var B=v.lines[F-1]?v.lines[F-1][0]:null;"+"===B?r=!0:"-"===B&&(i=!0);}}}if(r)for(;!u[u.length-1];)u.pop(),o.pop();else i&&(u.push(""),o.push("\n"));for(var k=0;k<u.length-1;k++)u[k]=u[k]+o[k];return u.join("")}var Et$1=Object.defineProperty({applyPatch:gt$1,applyPatches:mt$1},"__esModule",{value:!0}),bt$1=St$1,Ct$1=wt$1,vt$1=Tt$1,At$1=function(e,t,n,r,i,u){return Tt$1(e,e,t,n,r,i,u)};function Ft$1(e){return function(e){if(Array.isArray(e))return xt$1(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return xt$1(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return xt$1(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function xt$1(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function St$1(e,t,n,r,i,u,o){o||(o={}),void 0===o.context&&(o.context=4);var s=(0, c$2.diffLines)(n,r,o);function a(e){return e.map((function(e){return " "+e}))}s.push({value:"",lines:[]});for(var l=[],p=0,f=0,d=[],h=1,g=1,m=function(e){var t=s[e],i=t.lines||t.value.replace(/\n$/,"").split("\n");if(t.lines=i,t.added||t.removed){var u;if(!p){var c=s[e-1];p=h,f=g,c&&(d=o.context>0?a(c.lines.slice(-o.context)):[],p-=d.length,f-=d.length);}(u=d).push.apply(u,Ft$1(i.map((function(e){return (t.added?"+":"-")+e})))),t.added?g+=i.length:h+=i.length;}else {if(p)if(i.length<=2*o.context&&e<s.length-2){var m;(m=d).push.apply(m,Ft$1(a(i)));}else {var y,D=Math.min(i.length,o.context);(y=d).push.apply(y,Ft$1(a(i.slice(0,D))));var E={oldStart:p,oldLines:h-p+D,newStart:f,newLines:g-f+D,lines:d};if(e>=s.length-2&&i.length<=o.context){var b=/\n$/.test(n),C=/\n$/.test(r),v=0==i.length&&d.length>E.oldLines;!b&&v&&n.length>0&&d.splice(E.oldLines,0,"\\ No newline at end of file"),(b||v)&&C||d.push("\\ No newline at end of file");}l.push(E),p=0,f=0,d=[];}h+=i.length,g+=i.length;}},y=0;y<s.length;y++)m(y);return {oldFileName:e,newFileName:t,oldHeader:i,newHeader:u,hunks:l}}function wt$1(e){var t=[];e.oldFileName==e.newFileName&&t.push("Index: "+e.oldFileName),t.push("==================================================================="),t.push("--- "+e.oldFileName+(void 0===e.oldHeader?"":"\t"+e.oldHeader)),t.push("+++ "+e.newFileName+(void 0===e.newHeader?"":"\t"+e.newHeader));for(var n=0;n<e.hunks.length;n++){var r=e.hunks[n];0===r.oldLines&&(r.oldStart-=1),0===r.newLines&&(r.newStart-=1),t.push("@@ -"+r.oldStart+","+r.oldLines+" +"+r.newStart+","+r.newLines+" @@"),t.push.apply(t,r.lines);}return t.join("\n")+"\n"}function Tt$1(e,t,n,r,i,u,o){return wt$1(St$1(e,t,n,r,i,u,o))}var Bt$1=Object.defineProperty({structuredPatch:bt$1,formatPatch:Ct$1,createTwoFilesPatch:vt$1,createPatch:At$1},"__esModule",{value:!0}),kt$1=function(e,t){if(e.length!==t.length)return !1;return Pt$1(e,t)},Nt$1=Pt$1;function Pt$1(e,t){if(t.length>e.length)return !1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return !1;return !0}var Ot$1=Object.defineProperty({arrayEqual:kt$1,arrayStartsWith:Nt$1},"__esModule",{value:!0}),It$1=Mt$1,jt$1=function(e,t,n){e=Rt$1(e,n),t=Rt$1(t,n);var r={};(e.index||t.index)&&(r.index=e.index||t.index);(e.newFileName||t.newFileName)&&($t$1(e)?$t$1(t)?(r.oldFileName=Vt$1(r,e.oldFileName,t.oldFileName),r.newFileName=Vt$1(r,e.newFileName,t.newFileName),r.oldHeader=Vt$1(r,e.oldHeader,t.oldHeader),r.newHeader=Vt$1(r,e.newHeader,t.newHeader)):(r.oldFileName=e.oldFileName,r.newFileName=e.newFileName,r.oldHeader=e.oldHeader,r.newHeader=e.newHeader):(r.oldFileName=t.oldFileName||e.oldFileName,r.newFileName=t.newFileName||e.newFileName,r.oldHeader=t.oldHeader||e.oldHeader,r.newHeader=t.newHeader||e.newHeader));r.hunks=[];var i=0,u=0,o=0,s=0;for(;i<e.hunks.length||u<t.hunks.length;){var a=e.hunks[i]||{oldStart:1/0},l=t.hunks[u]||{oldStart:1/0};if(qt$1(a,l))r.hunks.push(Wt$1(a,o)),i++,s+=a.newLines-a.oldLines;else if(qt$1(l,a))r.hunks.push(Wt$1(l,s)),u++,o+=l.newLines-l.oldLines;else {var c={oldStart:Math.min(a.oldStart,l.oldStart),oldLines:0,newStart:Math.min(a.newStart+o,l.oldStart+s),newLines:0,lines:[]};Ut(c,a.oldStart,a.lines,l.oldStart,l.lines),u++,i++,r.hunks.push(c);}}return r};function Lt$1(e){return function(e){if(Array.isArray(e))return _t$1(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return _t$1(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _t$1(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _t$1(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function Mt$1(e){var t=Zt$1(e.lines),n=t.oldLines,r=t.newLines;void 0!==n?e.oldLines=n:delete e.oldLines,void 0!==r?e.newLines=r:delete e.newLines;}function Rt$1(e,t){if("string"==typeof e){if(/^@@/m.test(e)||/^Index:/m.test(e))return (0, dt$1.parsePatch)(e)[0];if(!t)throw new Error("Must provide a base reference or pass in a patch");return (0, Bt$1.structuredPatch)(void 0,void 0,t,e)}return e}function $t$1(e){return e.newFileName&&e.newFileName!==e.oldFileName}function Vt$1(e,t,n){return t===n?t:(e.conflict=!0,{mine:t,theirs:n})}function qt$1(e,t){return e.oldStart<t.oldStart&&e.oldStart+e.oldLines<t.oldStart}function Wt$1(e,t){return {oldStart:e.oldStart,oldLines:e.oldLines,newStart:e.newStart+t,newLines:e.newLines,lines:e.lines}}function Ut(e,t,n,r,i){var u={offset:t,lines:n,index:0},o={offset:r,lines:i,index:0};for(Jt$1(e,u,o),Jt$1(e,o,u);u.index<u.lines.length&&o.index<o.lines.length;){var s=u.lines[u.index],a=o.lines[o.index];if("-"!==s[0]&&"+"!==s[0]||"-"!==a[0]&&"+"!==a[0])if("+"===s[0]&&" "===a[0]){var l;(l=e.lines).push.apply(l,Lt$1(Yt$1(u)));}else if("+"===a[0]&&" "===s[0]){var c;(c=e.lines).push.apply(c,Lt$1(Yt$1(o)));}else "-"===s[0]&&" "===a[0]?Gt$1(e,u,o):"-"===a[0]&&" "===s[0]?Gt$1(e,o,u,!0):s===a?(e.lines.push(s),u.index++,o.index++):Ht$1(e,Yt$1(u),Yt$1(o));else zt$1(e,u,o);}Xt$1(e,u),Xt$1(e,o),Mt$1(e);}function zt$1(e,t,n){var r=Yt$1(t),i=Yt$1(n);if(Kt$1(r)&&Kt$1(i)){var u,o;if((0, Ot$1.arrayStartsWith)(r,i)&&Qt$1(n,r,r.length-i.length))return void(u=e.lines).push.apply(u,Lt$1(r));if((0, Ot$1.arrayStartsWith)(i,r)&&Qt$1(t,i,i.length-r.length))return void(o=e.lines).push.apply(o,Lt$1(i))}else if((0, Ot$1.arrayEqual)(r,i)){var s;return void(s=e.lines).push.apply(s,Lt$1(r))}Ht$1(e,r,i);}function Gt$1(e,t,n,r){var i,u=Yt$1(t),o=function(e,t){var n=[],r=[],i=0,u=!1,o=!1;for(;i<t.length&&e.index<e.lines.length;){var s=e.lines[e.index],a=t[i];if("+"===a[0])break;if(u=u||" "!==s[0],r.push(a),i++,"+"===s[0])for(o=!0;"+"===s[0];)n.push(s),s=e.lines[++e.index];a.substr(1)===s.substr(1)?(n.push(s),e.index++):o=!0;}"+"===(t[i]||"")[0]&&u&&(o=!0);if(o)return n;for(;i<t.length;)r.push(t[i++]);return {merged:r,changes:n}}(n,u);o.merged?(i=e.lines).push.apply(i,Lt$1(o.merged)):Ht$1(e,r?o:u,r?u:o);}function Ht$1(e,t,n){e.conflict=!0,e.lines.push({conflict:!0,mine:t,theirs:n});}function Jt$1(e,t,n){for(;t.offset<n.offset&&t.index<t.lines.length;){var r=t.lines[t.index++];e.lines.push(r),t.offset++;}}function Xt$1(e,t){for(;t.index<t.lines.length;){var n=t.lines[t.index++];e.lines.push(n);}}function Yt$1(e){for(var t=[],n=e.lines[e.index][0];e.index<e.lines.length;){var r=e.lines[e.index];if("-"===n&&"+"===r[0]&&(n="+"),n!==r[0])break;t.push(r),e.index++;}return t}function Kt$1(e){return e.reduce((function(e,t){return e&&"-"===t[0]}),!0)}function Qt$1(e,t,n){for(var r=0;r<n;r++){var i=t[t.length-n+r].substr(1);if(e.lines[e.index+r]!==" "+i)return !1}return e.index+=n,!0}function Zt$1(e){var t=0,n=0;return e.forEach((function(e){if("string"!=typeof e){var r=Zt$1(e.mine),i=Zt$1(e.theirs);void 0!==t&&(r.oldLines===i.oldLines?t+=r.oldLines:t=void 0),void 0!==n&&(r.newLines===i.newLines?n+=r.newLines:n=void 0);}else void 0===n||"+"!==e[0]&&" "!==e[0]||n++,void 0===t||"-"!==e[0]&&" "!==e[0]||t++;})),{oldLines:t,newLines:n}}var en$1=Object.defineProperty({calcLineCount:It$1,merge:jt$1},"__esModule",{value:!0}),tn$1=function(e){for(var t,n,r=[],i=0;i<e.length;i++)t=e[i],n=t.added?1:t.removed?-1:0,r.push([n,t.value]);return r};var nn$1=Object.defineProperty({convertChangesToDMP:tn$1},"__esModule",{value:!0}),rn$1=function(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];r.added?t.push("<ins>"):r.removed&&t.push("<del>"),t.push(un$1(r.value)),r.added?t.push("</ins>"):r.removed&&t.push("</del>");}return t.join("")};function un$1(e){var t=e;return t=(t=(t=(t=t.replace(/&/g,"&amp;")).replace(/</g,"&lt;")).replace(/>/g,"&gt;")).replace(/"/g,"&quot;")}var on$2=Object.defineProperty({convertChangesToXML:rn$1},"__esModule",{value:!0}),sn$1=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"Diff",{enumerable:!0,get:function(){return n.default}}),Object.defineProperty(t,"diffChars",{enumerable:!0,get:function(){return o$2.diffChars}}),Object.defineProperty(t,"diffWords",{enumerable:!0,get:function(){return l$2.diffWords}}),Object.defineProperty(t,"diffWordsWithSpace",{enumerable:!0,get:function(){return l$2.diffWordsWithSpace}}),Object.defineProperty(t,"diffLines",{enumerable:!0,get:function(){return c$2.diffLines}}),Object.defineProperty(t,"diffTrimmedLines",{enumerable:!0,get:function(){return c$2.diffTrimmedLines}}),Object.defineProperty(t,"diffSentences",{enumerable:!0,get:function(){return p$2.diffSentences}}),Object.defineProperty(t,"diffCss",{enumerable:!0,get:function(){return f$2.diffCss}}),Object.defineProperty(t,"diffJson",{enumerable:!0,get:function(){return lt$1.diffJson}}),Object.defineProperty(t,"canonicalize",{enumerable:!0,get:function(){return lt$1.canonicalize}}),Object.defineProperty(t,"diffArrays",{enumerable:!0,get:function(){return ct$1.diffArrays}}),Object.defineProperty(t,"applyPatch",{enumerable:!0,get:function(){return Et$1.applyPatch}}),Object.defineProperty(t,"applyPatches",{enumerable:!0,get:function(){return Et$1.applyPatches}}),Object.defineProperty(t,"parsePatch",{enumerable:!0,get:function(){return dt$1.parsePatch}}),Object.defineProperty(t,"merge",{enumerable:!0,get:function(){return en$1.merge}}),Object.defineProperty(t,"structuredPatch",{enumerable:!0,get:function(){return Bt$1.structuredPatch}}),Object.defineProperty(t,"createTwoFilesPatch",{enumerable:!0,get:function(){return Bt$1.createTwoFilesPatch}}),Object.defineProperty(t,"createPatch",{enumerable:!0,get:function(){return Bt$1.createPatch}}),Object.defineProperty(t,"convertChangesToDMP",{enumerable:!0,get:function(){return nn$1.convertChangesToDMP}}),Object.defineProperty(t,"convertChangesToXML",{enumerable:!0,get:function(){return on$2.convertChangesToXML}});var n=function(e){return e&&e.__esModule?e:{default:e}}(u$2);}));function an$1(e){return {type:"concat",parts:e}}function ln$1(e){return {type:"indent",contents:e}}function cn$1(e,t){return {type:"align",contents:t,n:e}}function pn$1(e,t={}){return {type:"group",id:t.id,contents:e,break:Boolean(t.shouldBreak),expandedStates:t.expandedStates}}const fn$1={type:"break-parent"},dn$1={type:"line",hard:!0},hn$1={type:"line",hard:!0,literal:!0},gn$1=an$1([dn$1,fn$1]),mn$1=an$1([hn$1,fn$1]);var yn$1={concat:an$1,join:function(e,t){const n=[];for(let r=0;r<t.length;r++)0!==r&&n.push(e),n.push(t[r]);return an$1(n)},line:{type:"line"},softline:{type:"line",soft:!0},hardline:gn$1,literalline:mn$1,group:pn$1,conditionalGroup:function(e,t){return pn$1(e[0],Object.assign(Object.assign({},t),{},{expandedStates:e}))},fill:function(e){return {type:"fill",parts:e}},lineSuffix:function(e){return {type:"line-suffix",contents:e}},lineSuffixBoundary:{type:"line-suffix-boundary"},cursor:{type:"cursor",placeholder:Symbol("cursor")},breakParent:fn$1,ifBreak:function(e,t,n={}){return {type:"if-break",breakContents:e,flatContents:t,groupId:n.groupId}},trim:{type:"trim"},indent:ln$1,indentIfBreak:function(e,t){return {type:"indent-if-break",contents:e,groupId:t.groupId,negate:t.negate}},align:cn$1,addAlignmentToDoc:function(e,t,n){let r=e;if(t>0){for(let e=0;e<Math.floor(t/n);++e)r=ln$1(r);r=cn$1(t%n,r),r=cn$1(Number.NEGATIVE_INFINITY,r);}return r},markAsRoot:function(e){return cn$1({type:"root"},e)},dedentToRoot:function(e){return cn$1(Number.NEGATIVE_INFINITY,e)},dedent:function(e){return cn$1(-1,e)},hardlineWithoutBreakParent:dn$1,literallineWithoutBreakParent:hn$1,label:function(e,t){return {type:"label",label:e,contents:t}}},Dn$1=e=>"string"==typeof e?e.replace((({onlyFirst:e=!1}={})=>{const t=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(t,e?void 0:"g")})(),""):e;const En$1=e=>!Number.isNaN(e)&&(e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141));var bn$1=En$1,Cn$1=En$1;bn$1.default=Cn$1;const vn$1=e=>{if("string"!=typeof e||0===e.length)return 0;if(0===(e=Dn$1(e)).length)return 0;e=e.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g,"  ");let t=0;for(let n=0;n<e.length;n++){const r=e.codePointAt(n);r<=31||r>=127&&r<=159||(r>=768&&r<=879||(r>65535&&n++,t+=bn$1(r)?2:1));}return t};var An$1=vn$1,Fn$1=vn$1;An$1.default=Fn$1;var xn$1=e=>{if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")};var Sn$1=e=>e[e.length-1],wn$1=Array.isArray||function(e){return "Array"==v$1(e)},Tn$1=function(e,t,n){if(Re$1(e),void 0===t)return e;switch(n){case 0:return function(){return e.call(t)};case 1:return function(n){return e.call(t,n)};case 2:return function(n,r){return e.call(t,n,r)};case 3:return function(n,r,i){return e.call(t,n,r,i)}}return function(){return e.apply(t,arguments)}},Bn$1=function(e,t,n,r,i,u,o,s){for(var a,l=i,c=0,p=!!o&&Tn$1(o,s,3);c<r;){if(c in n){if(a=p?p(n[c],c,t):n[c],u>0&&wn$1(a))l=Bn$1(e,t,a,be$1(a.length),l,u-1)-1;else {if(l>=9007199254740991)throw TypeError("Exceed the acceptable array length");e[l]=a;}l++;}c++;}return l},kn$1=Bn$1,Nn$1=!!Object.getOwnPropertySymbols&&!g$2((function(){var e=Symbol();return !String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&et$1&&et$1<41})),Pn$1=Nn$1&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,On$1=K$1("wks"),In$1=h$2.Symbol,jn$1=Pn$1?In$1:In$1&&In$1.withoutSetter||ee$1,Ln$1=function(e){return N$1(On$1,e)&&(Nn$1||"string"==typeof On$1[e])||(Nn$1&&N$1(In$1,e)?On$1[e]=In$1[e]:On$1[e]=jn$1("Symbol."+e)),On$1[e]},_n$1=Ln$1("species"),Mn$1=function(e,t){var n;return wn$1(e)&&("function"!=typeof(n=e.constructor)||n!==Array&&!wn$1(n.prototype)?w$1(n)&&null===(n=n[_n$1])&&(n=void 0):n=void 0),new(void 0===n?Array:n)(0===t?0:t)};Me$1({target:"Array",proto:!0},{flatMap:function(e){var t,n=B$1(this),r=be$1(n.length);return Re$1(e),(t=Mn$1(n,0)).length=kn$1(t,n,n,r,0,1,e,arguments.length>1?arguments[1]:void 0),t}});var Rn$1={},$n$1=Ln$1("iterator"),Vn$1=Array.prototype,qn$1={};qn$1[Ln$1("toStringTag")]="z";var Wn$1="[object z]"===String(qn$1),Un$1=Ln$1("toStringTag"),zn$1="Arguments"==v$1(function(){return arguments}()),Gn$1=Wn$1?v$1:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=Object(e),Un$1))?n:zn$1?v$1(t):"Object"==(r=v$1(t))&&"function"==typeof t.callee?"Arguments":r},Hn$1=Ln$1("iterator"),Jn$1=function(e){var t=e.return;if(void 0!==t)return _$2(t.call(e)).value},Xn$1=function(e,t){this.stopped=e,this.result=t;},Yn$1=function(e,t,n){var r,i,u,o,s,a,l,c,p=n&&n.that,f=!(!n||!n.AS_ENTRIES),d=!(!n||!n.IS_ITERATOR),h=!(!n||!n.INTERRUPTED),g=Tn$1(t,p,1+f+h),m=function(e){return r&&Jn$1(r),new Xn$1(!0,e)},y=function(e){return f?(_$2(e),h?g(e[0],e[1],m):g(e[0],e[1])):h?g(e,m):g(e)};if(d)r=e;else {if("function"!=typeof(i=function(e){if(null!=e)return e[Hn$1]||e["@@iterator"]||Rn$1[Gn$1(e)]}(e)))throw TypeError("Target is not iterable");if(void 0!==(c=i)&&(Rn$1.Array===c||Vn$1[$n$1]===c)){for(u=0,o=be$1(e.length);o>u;u++)if((s=y(e[u]))&&s instanceof Xn$1)return s;return new Xn$1(!1)}r=i.call(e);}for(a=r.next;!(l=a.call(r)).done;){try{s=y(l.value);}catch(e){throw Jn$1(r),e}if("object"==typeof s&&s&&s instanceof Xn$1)return s}return new Xn$1(!1)};Me$1({target:"Object",stat:!0},{fromEntries:function(e){var t={};return Yn$1(e,(function(e,n){!function(e,t,n){var r=T$1(t);r in e?R$1.f(e,r,b$1(0,n)):e[r]=n;}(t,e,n);}),{AS_ENTRIES:!0}),t}});var Kn$1=void 0!==Kn$1?Kn$1:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{};function Qn$1(){throw new Error("setTimeout has not been defined")}function Zn$1(){throw new Error("clearTimeout has not been defined")}var er$1=Qn$1,tr$1=Zn$1;function nr$1(e){if(er$1===setTimeout)return setTimeout(e,0);if((er$1===Qn$1||!er$1)&&setTimeout)return er$1=setTimeout,setTimeout(e,0);try{return er$1(e,0)}catch(t){try{return er$1.call(null,e,0)}catch(t){return er$1.call(this,e,0)}}}"function"==typeof Kn$1.setTimeout&&(er$1=setTimeout),"function"==typeof Kn$1.clearTimeout&&(tr$1=clearTimeout);var rr$1,ir$1=[],ur$1=!1,or$1=-1;function sr$1(){ur$1&&rr$1&&(ur$1=!1,rr$1.length?ir$1=rr$1.concat(ir$1):or$1=-1,ir$1.length&&ar$1());}function ar$1(){if(!ur$1){var e=nr$1(sr$1);ur$1=!0;for(var t=ir$1.length;t;){for(rr$1=ir$1,ir$1=[];++or$1<t;)rr$1&&rr$1[or$1].run();or$1=-1,t=ir$1.length;}rr$1=null,ur$1=!1,function(e){if(tr$1===clearTimeout)return clearTimeout(e);if((tr$1===Zn$1||!tr$1)&&clearTimeout)return tr$1=clearTimeout,clearTimeout(e);try{tr$1(e);}catch(t){try{return tr$1.call(null,e)}catch(t){return tr$1.call(this,e)}}}(e);}}function lr$1(e,t){this.fun=e,this.array=t;}lr$1.prototype.run=function(){this.fun.apply(null,this.array);};function cr$1(){}var pr$1=cr$1,fr$1=cr$1,dr$1=cr$1,hr$1=cr$1,gr$1=cr$1,mr$1=cr$1,yr$1=cr$1;var Dr$1=Kn$1.performance||{},Er$1=Dr$1.now||Dr$1.mozNow||Dr$1.msNow||Dr$1.oNow||Dr$1.webkitNow||function(){return (new Date).getTime()};var br$1=new Date;var Cr$1={nextTick:function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];ir$1.push(new lr$1(e,t)),1!==ir$1.length||ur$1||nr$1(ar$1);},title:"browser",browser:!0,env:{},argv:[],version:"",versions:{},on:pr$1,addListener:fr$1,once:dr$1,off:hr$1,removeListener:gr$1,removeAllListeners:mr$1,emit:yr$1,binding:function(e){throw new Error("process.binding is not supported")},cwd:function(){return "/"},chdir:function(e){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(e){var t=.001*Er$1.call(Dr$1),n=Math.floor(t),r=Math.floor(t%1*1e9);return e&&(n-=e[0],(r-=e[1])<0&&(n--,r+=1e9)),[n,r]},platform:"browser",release:{},config:{},uptime:function(){return (new Date-br$1)/1e3}};var vr$1="object"==typeof Cr$1&&Cr$1.env&&Cr$1.env.NODE_DEBUG&&/\bsemver\b/i.test(Cr$1.env.NODE_DEBUG)?(...e)=>console.error("SEMVER",...e):()=>{};var Ar$1={SEMVER_SPEC_VERSION:"2.0.0",MAX_LENGTH:256,MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER||9007199254740991,MAX_SAFE_COMPONENT_LENGTH:16},Fr$1=i$2((function(e,t){const{MAX_SAFE_COMPONENT_LENGTH:n}=Ar$1,r=(t=e.exports={}).re=[],i=t.src=[],u=t.t={};let o=0;const s=(e,t,n)=>{const s=o++;vr$1(s,t),u[e]=s,i[s]=t,r[s]=new RegExp(t,n?"g":void 0);};s("NUMERICIDENTIFIER","0|[1-9]\\d*"),s("NUMERICIDENTIFIERLOOSE","[0-9]+"),s("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),s("MAINVERSION",`(${i[u.NUMERICIDENTIFIER]})\\.(${i[u.NUMERICIDENTIFIER]})\\.(${i[u.NUMERICIDENTIFIER]})`),s("MAINVERSIONLOOSE",`(${i[u.NUMERICIDENTIFIERLOOSE]})\\.(${i[u.NUMERICIDENTIFIERLOOSE]})\\.(${i[u.NUMERICIDENTIFIERLOOSE]})`),s("PRERELEASEIDENTIFIER",`(?:${i[u.NUMERICIDENTIFIER]}|${i[u.NONNUMERICIDENTIFIER]})`),s("PRERELEASEIDENTIFIERLOOSE",`(?:${i[u.NUMERICIDENTIFIERLOOSE]}|${i[u.NONNUMERICIDENTIFIER]})`),s("PRERELEASE",`(?:-(${i[u.PRERELEASEIDENTIFIER]}(?:\\.${i[u.PRERELEASEIDENTIFIER]})*))`),s("PRERELEASELOOSE",`(?:-?(${i[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i[u.PRERELEASEIDENTIFIERLOOSE]})*))`),s("BUILDIDENTIFIER","[0-9A-Za-z-]+"),s("BUILD",`(?:\\+(${i[u.BUILDIDENTIFIER]}(?:\\.${i[u.BUILDIDENTIFIER]})*))`),s("FULLPLAIN",`v?${i[u.MAINVERSION]}${i[u.PRERELEASE]}?${i[u.BUILD]}?`),s("FULL",`^${i[u.FULLPLAIN]}$`),s("LOOSEPLAIN",`[v=\\s]*${i[u.MAINVERSIONLOOSE]}${i[u.PRERELEASELOOSE]}?${i[u.BUILD]}?`),s("LOOSE",`^${i[u.LOOSEPLAIN]}$`),s("GTLT","((?:<|>)?=?)"),s("XRANGEIDENTIFIERLOOSE",`${i[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),s("XRANGEIDENTIFIER",`${i[u.NUMERICIDENTIFIER]}|x|X|\\*`),s("XRANGEPLAIN",`[v=\\s]*(${i[u.XRANGEIDENTIFIER]})(?:\\.(${i[u.XRANGEIDENTIFIER]})(?:\\.(${i[u.XRANGEIDENTIFIER]})(?:${i[u.PRERELEASE]})?${i[u.BUILD]}?)?)?`),s("XRANGEPLAINLOOSE",`[v=\\s]*(${i[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[u.XRANGEIDENTIFIERLOOSE]})(?:${i[u.PRERELEASELOOSE]})?${i[u.BUILD]}?)?)?`),s("XRANGE",`^${i[u.GTLT]}\\s*${i[u.XRANGEPLAIN]}$`),s("XRANGELOOSE",`^${i[u.GTLT]}\\s*${i[u.XRANGEPLAINLOOSE]}$`),s("COERCE",`(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`),s("COERCERTL",i[u.COERCE],!0),s("LONETILDE","(?:~>?)"),s("TILDETRIM",`(\\s*)${i[u.LONETILDE]}\\s+`,!0),t.tildeTrimReplace="$1~",s("TILDE",`^${i[u.LONETILDE]}${i[u.XRANGEPLAIN]}$`),s("TILDELOOSE",`^${i[u.LONETILDE]}${i[u.XRANGEPLAINLOOSE]}$`),s("LONECARET","(?:\\^)"),s("CARETTRIM",`(\\s*)${i[u.LONECARET]}\\s+`,!0),t.caretTrimReplace="$1^",s("CARET",`^${i[u.LONECARET]}${i[u.XRANGEPLAIN]}$`),s("CARETLOOSE",`^${i[u.LONECARET]}${i[u.XRANGEPLAINLOOSE]}$`),s("COMPARATORLOOSE",`^${i[u.GTLT]}\\s*(${i[u.LOOSEPLAIN]})$|^$`),s("COMPARATOR",`^${i[u.GTLT]}\\s*(${i[u.FULLPLAIN]})$|^$`),s("COMPARATORTRIM",`(\\s*)${i[u.GTLT]}\\s*(${i[u.LOOSEPLAIN]}|${i[u.XRANGEPLAIN]})`,!0),t.comparatorTrimReplace="$1$2$3",s("HYPHENRANGE",`^\\s*(${i[u.XRANGEPLAIN]})\\s+-\\s+(${i[u.XRANGEPLAIN]})\\s*$`),s("HYPHENRANGELOOSE",`^\\s*(${i[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${i[u.XRANGEPLAINLOOSE]})\\s*$`),s("STAR","(<|>)?=?\\s*\\*"),s("GTE0","^\\s*>=\\s*0.0.0\\s*$"),s("GTE0PRE","^\\s*>=\\s*0.0.0-0\\s*$");}));const xr$1=["includePrerelease","loose","rtl"];var Sr$1=e=>e?"object"!=typeof e?{loose:!0}:xr$1.filter((t=>e[t])).reduce(((e,t)=>(e[t]=!0,e)),{}):{};const wr$1=/^[0-9]+$/,Tr$1=(e,t)=>{const n=wr$1.test(e),r=wr$1.test(t);return n&&r&&(e=+e,t=+t),e===t?0:n&&!r?-1:r&&!n?1:e<t?-1:1};var Br$1={compareIdentifiers:Tr$1,rcompareIdentifiers:(e,t)=>Tr$1(t,e)};const{MAX_LENGTH:kr$1,MAX_SAFE_INTEGER:Nr$1}=Ar$1,{re:Pr$1,t:Or$1}=Fr$1,{compareIdentifiers:Ir$1}=Br$1;class jr$1{constructor(e,t){if(t=Sr$1(t),e instanceof jr$1){if(e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease)return e;e=e.version;}else if("string"!=typeof e)throw new TypeError(`Invalid Version: ${e}`);if(e.length>kr$1)throw new TypeError(`version is longer than ${kr$1} characters`);vr$1("SemVer",e,t),this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease;const n=e.trim().match(t.loose?Pr$1[Or$1.LOOSE]:Pr$1[Or$1.FULL]);if(!n)throw new TypeError(`Invalid Version: ${e}`);if(this.raw=e,this.major=+n[1],this.minor=+n[2],this.patch=+n[3],this.major>Nr$1||this.major<0)throw new TypeError("Invalid major version");if(this.minor>Nr$1||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>Nr$1||this.patch<0)throw new TypeError("Invalid patch version");n[4]?this.prerelease=n[4].split(".").map((e=>{if(/^[0-9]+$/.test(e)){const t=+e;if(t>=0&&t<Nr$1)return t}return e})):this.prerelease=[],this.build=n[5]?n[5].split("."):[],this.format();}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(e){if(vr$1("SemVer.compare",this.version,this.options,e),!(e instanceof jr$1)){if("string"==typeof e&&e===this.version)return 0;e=new jr$1(e,this.options);}return e.version===this.version?0:this.compareMain(e)||this.comparePre(e)}compareMain(e){return e instanceof jr$1||(e=new jr$1(e,this.options)),Ir$1(this.major,e.major)||Ir$1(this.minor,e.minor)||Ir$1(this.patch,e.patch)}comparePre(e){if(e instanceof jr$1||(e=new jr$1(e,this.options)),this.prerelease.length&&!e.prerelease.length)return -1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;let t=0;do{const n=this.prerelease[t],r=e.prerelease[t];if(vr$1("prerelease compare",t,n,r),void 0===n&&void 0===r)return 0;if(void 0===r)return 1;if(void 0===n)return -1;if(n!==r)return Ir$1(n,r)}while(++t)}compareBuild(e){e instanceof jr$1||(e=new jr$1(e,this.options));let t=0;do{const n=this.build[t],r=e.build[t];if(vr$1("prerelease compare",t,n,r),void 0===n&&void 0===r)return 0;if(void 0===r)return 1;if(void 0===n)return -1;if(n!==r)return Ir$1(n,r)}while(++t)}inc(e,t){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t),this.inc("pre",t);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",t),this.inc("pre",t);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {let e=this.prerelease.length;for(;--e>=0;)"number"==typeof this.prerelease[e]&&(this.prerelease[e]++,e=-2);-1===e&&this.prerelease.push(0);}t&&(this.prerelease[0]===t?isNaN(this.prerelease[1])&&(this.prerelease=[t,0]):this.prerelease=[t,0]);break;default:throw new Error(`invalid increment argument: ${e}`)}return this.format(),this.raw=this.version,this}}var Lr$1=jr$1;var _r$1=(e,t,n)=>new Lr$1(e,n).compare(new Lr$1(t,n));var Mr$1=(e,t,n)=>_r$1(e,t,n)<0;var Rr$1=(e,t,n)=>_r$1(e,t,n)>=0,$r$1=i$2((function(e,t){function n(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];}function r(){return "undefined"!=typeof WeakMap?new WeakMap:{add:n,delete:n,get:n,set:n,has:function(e){return !1}}}Object.defineProperty(t,"__esModule",{value:!0}),t.outdent=void 0;var i=Object.prototype.hasOwnProperty,u=function(e,t){return i.call(e,t)};function o(e,t){for(var n in t)u(t,n)&&(e[n]=t[n]);return e}var s=/^[ \t]*(?:\r\n|\r|\n)/,a=/(?:\r\n|\r|\n)[ \t]*$/,l=/^(?:[\r\n]|$)/,c=/(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/,p=/^[ \t]*[\r\n][ \t\r\n]*$/;function f(e,t,n){var r=0,i=e[0].match(c);i&&(r=i[1].length);var u=new RegExp("(\\r\\n|\\r|\\n).{0,"+r+"}","g");t&&(e=e.slice(1));var o=n.newline,l=n.trimLeadingNewline,p=n.trimTrailingNewline,f="string"==typeof o,d=e.length;return e.map((function(e,t){return e=e.replace(u,"$1"),0===t&&l&&(e=e.replace(s,"")),t===d-1&&p&&(e=e.replace(a,"")),f&&(e=e.replace(/\r\n|\n|\r/g,(function(e){return o}))),e}))}function d(e,t){for(var n="",r=0,i=e.length;r<i;r++)n+=e[r],r<i-1&&(n+=t[r]);return n}function h(e){return u(e,"raw")&&u(e,"length")}var g=function e(t){var n=r(),i=r();return o((function r(u){for(var s=[],a=1;a<arguments.length;a++)s[a-1]=arguments[a];if(h(u)){var c=u,m=(s[0]===r||s[0]===g)&&p.test(c[0])&&l.test(c[1]),y=m?i:n,D=y.get(c);if(D||(D=f(c,m,t),y.set(c,D)),0===s.length)return D[0];var E=d(D,m?s.slice(1):s);return E}return e(o(o({},t),u||{}))}),{string:function(e){return f([e],!1,t)[0]}})}({trimLeadingNewline:!0,trimTrailingNewline:!0});t.outdent=g,t.default=g;try{e.exports=g,Object.defineProperty(g,"__esModule",{value:!0}),g.default=g,g.outdent=g;}catch(e){}}));const{outdent:Vr$1}=$r$1,qr$1={cursorOffset:{since:"1.4.0",category:"Special",type:"int",default:-1,range:{start:-1,end:Number.POSITIVE_INFINITY,step:1},description:Vr$1`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,cliCategory:"Editor"},endOfLine:{since:"1.15.0",category:"Global",type:"choice",default:[{since:"1.15.0",value:"auto"},{since:"2.0.0",value:"lf"}],description:"Which end of line characters to apply.",choices:[{value:"lf",description:"Line Feed only (\\n), common on Linux and macOS as well as inside git repos"},{value:"crlf",description:"Carriage Return + Line Feed characters (\\r\\n), common on Windows"},{value:"cr",description:"Carriage Return character only (\\r), used very rarely"},{value:"auto",description:Vr$1`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]},filepath:{since:"1.4.0",category:"Special",type:"path",description:"Specify the input filepath. This will be used to do parser inference.",cliName:"stdin-filepath",cliCategory:"Other",cliDescription:"Path to the file to pretend that stdin comes from."},insertPragma:{since:"1.8.0",category:"Special",type:"boolean",default:!1,description:"Insert @format pragma into file's first docblock comment.",cliCategory:"Other"},parser:{since:"0.0.10",category:"Global",type:"choice",default:[{since:"0.0.10",value:"babylon"},{since:"1.13.0",value:void 0}],description:"Which parser to use.",exception:e=>"string"==typeof e||"function"==typeof e,choices:[{value:"flow",description:"Flow"},{value:"babel",since:"1.16.0",description:"JavaScript"},{value:"babel-flow",since:"1.16.0",description:"Flow"},{value:"babel-ts",since:"2.0.0",description:"TypeScript"},{value:"typescript",since:"1.4.0",description:"TypeScript"},{value:"espree",since:"2.2.0",description:"JavaScript"},{value:"meriyah",since:"2.2.0",description:"JavaScript"},{value:"css",since:"1.7.1",description:"CSS"},{value:"less",since:"1.7.1",description:"Less"},{value:"scss",since:"1.7.1",description:"SCSS"},{value:"json",since:"1.5.0",description:"JSON"},{value:"json5",since:"1.13.0",description:"JSON5"},{value:"json-stringify",since:"1.13.0",description:"JSON.stringify"},{value:"graphql",since:"1.5.0",description:"GraphQL"},{value:"markdown",since:"1.8.0",description:"Markdown"},{value:"mdx",since:"1.15.0",description:"MDX"},{value:"vue",since:"1.10.0",description:"Vue"},{value:"yaml",since:"1.14.0",description:"YAML"},{value:"glimmer",since:"2.3.0",description:"Ember / Handlebars"},{value:"html",since:"1.15.0",description:"HTML"},{value:"angular",since:"1.15.0",description:"Angular"},{value:"lwc",since:"1.17.0",description:"Lightning Web Components"}]},plugins:{since:"1.10.0",type:"path",array:!0,default:[{value:[]}],category:"Global",description:"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",exception:e=>"string"==typeof e||"object"==typeof e,cliName:"plugin",cliCategory:"Config"},pluginSearchDirs:{since:"1.13.0",type:"path",array:!0,default:[{value:[]}],category:"Global",description:Vr$1`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,exception:e=>"string"==typeof e||"object"==typeof e,cliName:"plugin-search-dir",cliCategory:"Config"},printWidth:{since:"0.0.0",category:"Global",type:"int",default:80,description:"The line length where Prettier will try wrap.",range:{start:0,end:Number.POSITIVE_INFINITY,step:1}},rangeEnd:{since:"1.4.0",category:"Special",type:"int",default:Number.POSITIVE_INFINITY,range:{start:0,end:Number.POSITIVE_INFINITY,step:1},description:Vr$1`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,cliCategory:"Editor"},rangeStart:{since:"1.4.0",category:"Special",type:"int",default:0,range:{start:0,end:Number.POSITIVE_INFINITY,step:1},description:Vr$1`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,cliCategory:"Editor"},requirePragma:{since:"1.7.0",category:"Special",type:"boolean",default:!1,description:Vr$1`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,cliCategory:"Other"},tabWidth:{type:"int",category:"Global",default:2,description:"Number of spaces per indentation level.",range:{start:0,end:Number.POSITIVE_INFINITY,step:1}},useTabs:{since:"1.0.0",category:"Global",type:"boolean",default:!1,description:"Indent with tabs instead of spaces."},embeddedLanguageFormatting:{since:"2.1.0",category:"Global",type:"choice",default:[{since:"2.1.0",value:"auto"}],description:"Control how Prettier formats quoted code embedded in the file.",choices:[{value:"auto",description:"Format embedded code if Prettier can automatically identify it."},{value:"off",description:"Never automatically format embedded code."}]}};const Wr$1=["cliName","cliCategory","cliDescription"],Ur$1={compare:_r$1,lt:Mr$1,gte:Rr$1},zr$1=t$2.version,Gr$1={CATEGORY_CONFIG:"Config",CATEGORY_EDITOR:"Editor",CATEGORY_FORMAT:"Format",CATEGORY_OTHER:"Other",CATEGORY_OUTPUT:"Output",CATEGORY_GLOBAL:"Global",CATEGORY_SPECIAL:"Special",options:qr$1}.options;var Hr$1={getSupportInfo:function({plugins:t=[],showUnreleased:n=!1,showDeprecated:r=!1,showInternal:i=!1}={}){const u=zr$1.split("-",1)[0],o=t.flatMap((e=>e.languages||[])).filter(a),s=((e,t)=>Object.entries(e).map((([e,n])=>Object.assign({[t]:e},n))))(Object.assign({},...t.map((({options:e})=>e)),Gr$1),"name").filter((e=>a(e)&&l(e))).sort(((e,t)=>e.name===t.name?0:e.name<t.name?-1:1)).map((function(t){if(i)return t;return e$2(t,Wr$1)})).map((e=>{e=Object.assign({},e),Array.isArray(e.default)&&(e.default=1===e.default.length?e.default[0].value:e.default.filter(a).sort(((e,t)=>Ur$1.compare(t.since,e.since)))[0].value),Array.isArray(e.choices)&&(e.choices=e.choices.filter((e=>a(e)&&l(e))),"parser"===e.name&&function(e,t,n){const r=new Set(e.choices.map((e=>e.value)));for(const i of t)if(i.parsers)for(const t of i.parsers)if(!r.has(t)){r.add(t);const u=n.find((e=>e.parsers&&e.parsers[t]));let o=i.name;u&&u.name&&(o+=` (plugin: ${u.name})`),e.choices.push({value:t,description:o});}}(e,o,t));const n=Object.fromEntries(t.filter((t=>t.defaultOptions&&void 0!==t.defaultOptions[e.name])).map((t=>[t.name,t.defaultOptions[e.name]])));return Object.assign(Object.assign({},e),{},{pluginDefaults:n})}));return {languages:o,options:s};function a(e){return n||!("since"in e)||e.since&&Ur$1.gte(u,e.since)}function l(e){return r||!("deprecated"in e)||e.deprecated&&Ur$1.lt(u,e.deprecated)}}};const{getSupportInfo:Jr$1}=Hr$1,Xr$1=/[^\x20-\x7F]/;function Yr$1(e){return (t,n,r)=>{const i=r&&r.backwards;if(!1===n)return !1;const{length:u}=t;let o=n;for(;o>=0&&o<u;){const n=t.charAt(o);if(e instanceof RegExp){if(!e.test(n))return o}else if(!e.includes(n))return o;i?o--:o++;}return (-1===o||o===u)&&o}}const Kr$1=Yr$1(/\s/),Qr$1=Yr$1(" \t"),Zr$1=Yr$1(",; \t"),ei$1=Yr$1(/[^\n\r]/);function ti$1(e,t){if(!1===t)return !1;if("/"===e.charAt(t)&&"*"===e.charAt(t+1))for(let n=t+2;n<e.length;++n)if("*"===e.charAt(n)&&"/"===e.charAt(n+1))return n+2;return t}function ni$1(e,t){return !1!==t&&("/"===e.charAt(t)&&"/"===e.charAt(t+1)?ei$1(e,t):t)}function ri$1(e,t,n){const r=n&&n.backwards;if(!1===t)return !1;const i=e.charAt(t);if(r){if("\r"===e.charAt(t-1)&&"\n"===i)return t-2;if("\n"===i||"\r"===i||"\u2028"===i||"\u2029"===i)return t-1}else {if("\r"===i&&"\n"===e.charAt(t+1))return t+2;if("\n"===i||"\r"===i||"\u2028"===i||"\u2029"===i)return t+1}return t}function ii$1(e,t,n={}){const r=Qr$1(e,n.backwards?t-1:t,n);return r!==ri$1(e,r,n)}function ui$1(e,t){let n=null,r=t;for(;r!==n;)n=r,r=Zr$1(e,r),r=ti$1(e,r),r=Qr$1(e,r);return r=ni$1(e,r),r=ri$1(e,r),!1!==r&&ii$1(e,r)}function oi$1(e,t){let n=null,r=t;for(;r!==n;)n=r,r=Qr$1(e,r),r=ti$1(e,r),r=ni$1(e,r),r=ri$1(e,r);return r}function si$1(e,t,n){return oi$1(e,n(t))}function ai$1(e,t,n=0){let r=0;for(let i=n;i<e.length;++i)"\t"===e[i]?r=r+t-r%t:r++;return r}function li$1(e,t){const n=e.slice(1,-1),r={quote:'"',regex:/"/g},i={quote:"'",regex:/'/g},u="'"===t?i:r,o=u===i?r:i;let s=u.quote;if(n.includes(u.quote)||n.includes(o.quote)){s=(n.match(u.regex)||[]).length>(n.match(o.regex)||[]).length?o.quote:u.quote;}return s}function ci$1(e,t,n){const r='"'===t?"'":'"',i=e.replace(/\\(.)|(["'])/gs,((e,i,u)=>i===r?i:u===t?"\\"+u:u||(n&&/^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i)?i:"\\"+i)));return t+i+t}function pi$1(e,t){(e.comments||(e.comments=[])).push(t),t.printed=!1,t.nodeDescription=function(e){const t=e.type||e.kind||"(unknown type)";let n=String(e.name||e.id&&("object"==typeof e.id?e.id.name:e.id)||e.key&&("object"==typeof e.key?e.key.name:e.key)||e.value&&("object"==typeof e.value?"":String(e.value))||e.operator||"");n.length>20&&(n=n.slice(0,19)+"\u2026");return t+(n?" "+n:"")}(e);}var fi$1={inferParserByLanguage:function(e,t){const{languages:n}=Jr$1({plugins:t.plugins}),r=n.find((({name:t})=>t.toLowerCase()===e))||n.find((({aliases:t})=>Array.isArray(t)&&t.includes(e)))||n.find((({extensions:t})=>Array.isArray(t)&&t.includes(`.${e}`)));return r&&r.parsers[0]},getStringWidth:function(e){return e?Xr$1.test(e)?An$1(e):e.length:0},getMaxContinuousCount:function(e,t){const n=e.match(new RegExp(`(${xn$1(t)})+`,"g"));return null===n?0:n.reduce(((e,n)=>Math.max(e,n.length/t.length)),0)},getMinNotPresentContinuousCount:function(e,t){const n=e.match(new RegExp(`(${xn$1(t)})+`,"g"));if(null===n)return 0;const r=new Map;let i=0;for(const e of n){const n=e.length/t.length;r.set(n,!0),n>i&&(i=n);}for(let e=1;e<i;e++)if(!r.get(e))return e;return i+1},getPenultimate:e=>e[e.length-2],getLast:Sn$1,getNextNonSpaceNonCommentCharacterIndexWithStartIndex:oi$1,getNextNonSpaceNonCommentCharacterIndex:si$1,getNextNonSpaceNonCommentCharacter:function(e,t,n){return e.charAt(si$1(e,t,n))},skip:Yr$1,skipWhitespace:Kr$1,skipSpaces:Qr$1,skipToLineEnd:Zr$1,skipEverythingButNewLine:ei$1,skipInlineComment:ti$1,skipTrailingComment:ni$1,skipNewline:ri$1,isNextLineEmptyAfterIndex:ui$1,isNextLineEmpty:function(e,t,n){return ui$1(e,n(t))},isPreviousLineEmpty:function(e,t,n){let r=n(t)-1;return r=Qr$1(e,r,{backwards:!0}),r=ri$1(e,r,{backwards:!0}),r=Qr$1(e,r,{backwards:!0}),r!==ri$1(e,r,{backwards:!0})},hasNewline:ii$1,hasNewlineInRange:function(e,t,n){for(let r=t;r<n;++r)if("\n"===e.charAt(r))return !0;return !1},hasSpaces:function(e,t,n={}){return Qr$1(e,n.backwards?t-1:t,n)!==t},getAlignmentSize:ai$1,getIndentSize:function(e,t){const n=e.lastIndexOf("\n");return -1===n?0:ai$1(e.slice(n+1).match(/^[\t ]*/)[0],t)},getPreferredQuote:li$1,printString:function(e,t){return ci$1(e.slice(1,-1),"json"===t.parser||"json5"===t.parser&&"preserve"===t.quoteProps&&!t.singleQuote?'"':t.__isInHtmlAttribute?"'":li$1(e,t.singleQuote?"'":'"'),!("css"===t.parser||"less"===t.parser||"scss"===t.parser||t.__embeddedInHtml))},printNumber:function(e){return e.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/,"$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/,"$1").replace(/^([+-])?\./,"$10.").replace(/(\.\d+?)0+(?=e|$)/,"$1").replace(/\.(?=e|$)/,"")},makeString:ci$1,addLeadingComment:function(e,t){t.leading=!0,t.trailing=!1,pi$1(e,t);},addDanglingComment:function(e,t,n){t.leading=!1,t.trailing=!1,n&&(t.marker=n),pi$1(e,t);},addTrailingComment:function(e,t){t.leading=!1,t.trailing=!0,pi$1(e,t);},isFrontMatterNode:function(e){return e&&"front-matter"===e.type},getShebang:function(e){if(!e.startsWith("#!"))return "";const t=e.indexOf("\n");return -1===t?e:e.slice(0,t)},isNonEmptyArray:function(e){return Array.isArray(e)&&e.length>0},createGroupIdMapper:function(e){const t=new WeakMap;return function(n){return t.has(n)||t.set(n,Symbol(e)),t.get(n)}}};var di$1={guessEndOfLine:function(e){const t=e.indexOf("\r");return t>=0?"\n"===e.charAt(t+1)?"crlf":"cr":"lf"},convertEndOfLineToChars:function(e){switch(e){case"cr":return "\r";case"crlf":return "\r\n";default:return "\n"}},countEndOfLineChars:function(e,t){let n;if("\n"===t)n=/\n/g;else if("\r"===t)n=/\r/g;else {if("\r\n"!==t)throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);n=/\r\n/g;}const r=e.match(n);return r?r.length:0},normalizeEndOfLine:function(e){return e.replace(/\r\n?/g,"\n")}};const{literalline:hi$1,join:gi$1}=yn$1,mi$1=e=>Array.isArray(e)||e&&"concat"===e.type,yi$1=e=>{if(Array.isArray(e))return e;if("concat"!==e.type&&"fill"!==e.type)throw new Error("Expect doc type to be `concat` or `fill`.");return e.parts},Di$1={};function Ei$1(e,t,n,r){const i=[e];for(;i.length>0;){const e=i.pop();if(e!==Di$1){if(n&&i.push(e,Di$1),!t||!1!==t(e))if(mi$1(e)||"fill"===e.type){const t=yi$1(e);for(let e=t.length-1;e>=0;--e)i.push(t[e]);}else if("if-break"===e.type)e.flatContents&&i.push(e.flatContents),e.breakContents&&i.push(e.breakContents);else if("group"===e.type&&e.expandedStates)if(r)for(let t=e.expandedStates.length-1;t>=0;--t)i.push(e.expandedStates[t]);else i.push(e.contents);else e.contents&&i.push(e.contents);}else n(i.pop());}}function bi$1(e,t){const n=new Map;return r(e);function r(e){if(n.has(e))return n.get(e);const i=function(e){if(Array.isArray(e))return t(e.map(r));if("concat"===e.type||"fill"===e.type){const n=e.parts.map(r);return t(Object.assign(Object.assign({},e),{},{parts:n}))}if("if-break"===e.type){const n=e.breakContents&&r(e.breakContents),i=e.flatContents&&r(e.flatContents);return t(Object.assign(Object.assign({},e),{},{breakContents:n,flatContents:i}))}if("group"===e.type&&e.expandedStates){const n=e.expandedStates.map(r),i=n[0];return t(Object.assign(Object.assign({},e),{},{contents:i,expandedStates:n}))}if(e.contents){const n=r(e.contents);return t(Object.assign(Object.assign({},e),{},{contents:n}))}return t(e)}(e);return n.set(e,i),i}}function Ci$1(e,t,n){let r=n,i=!1;return Ei$1(e,(function(e){const n=t(e);if(void 0!==n&&(i=!0,r=n),i)return !1})),r}function vi$1(e){return !("group"!==e.type||!e.break)||(!("line"!==e.type||!e.hard)||("break-parent"===e.type||void 0))}function Ai$1(e){if(e.length>0){const t=Sn$1(e);t.expandedStates||t.break||(t.break="propagated");}return null}function Fi$1(e){return "line"!==e.type||e.hard?"if-break"===e.type?e.flatContents||"":e:e.soft?"":" "}const xi$1=(e,t)=>e&&"line"===e.type&&e.hard&&t&&"break-parent"===t.type;function Si$1(e){if(!e)return e;if(mi$1(e)||"fill"===e.type){const t=yi$1(e);for(;t.length>1&&xi$1(...t.slice(-2));)t.length-=2;if(t.length>0){const e=Si$1(Sn$1(t));t[t.length-1]=e;}return Array.isArray(e)?t:Object.assign(Object.assign({},e),{},{parts:t})}switch(e.type){case"align":case"indent":case"indent-if-break":case"group":case"line-suffix":case"label":{const t=Si$1(e.contents);return Object.assign(Object.assign({},e),{},{contents:t})}case"if-break":{const t=Si$1(e.breakContents),n=Si$1(e.flatContents);return Object.assign(Object.assign({},e),{},{breakContents:t,flatContents:n})}}return e}function wi$1(e){return bi$1(e,(e=>function(e){switch(e.type){case"fill":if(0===e.parts.length||e.parts.every((e=>""===e)))return "";break;case"group":if(!(e.contents||e.id||e.break||e.expandedStates))return "";if("group"===e.contents.type&&e.contents.id===e.id&&e.contents.break===e.break&&e.contents.expandedStates===e.expandedStates)return e.contents;break;case"align":case"indent":case"indent-if-break":case"line-suffix":if(!e.contents)return "";break;case"if-break":if(!e.flatContents&&!e.breakContents)return ""}if(!mi$1(e))return e;const t=[];for(const n of yi$1(e)){if(!n)continue;const[e,...r]=mi$1(n)?yi$1(n):[n];"string"==typeof e&&"string"==typeof Sn$1(t)?t[t.length-1]+=e:t.push(e),t.push(...r);}return 0===t.length?"":1===t.length?t[0]:Array.isArray(e)?t:Object.assign(Object.assign({},e),{},{parts:t})}(e)))}function Ti$1(e){const t=[],n=e.filter(Boolean);for(;n.length>0;){const e=n.shift();e&&(mi$1(e)?n.unshift(...yi$1(e)):t.length>0&&"string"==typeof Sn$1(t)&&"string"==typeof e?t[t.length-1]+=e:t.push(e));}return t}var Bi$1={isConcat:mi$1,getDocParts:yi$1,willBreak:function(e){return Ci$1(e,vi$1,!1)},traverseDoc:Ei$1,findInDoc:Ci$1,mapDoc:bi$1,propagateBreaks:function(e){const t=new Set,n=[];Ei$1(e,(function(e){if("break-parent"===e.type&&Ai$1(n),"group"===e.type){if(n.push(e),t.has(e))return !1;t.add(e);}}),(function(e){if("group"===e.type){n.pop().break&&Ai$1(n);}}),!0);},removeLines:function(e){return bi$1(e,Fi$1)},stripTrailingHardline:function(e){return Si$1(wi$1(e))},normalizeParts:Ti$1,normalizeDoc:function(e){return bi$1(e,(e=>Array.isArray(e)?Ti$1(e):e.parts?Object.assign(Object.assign({},e),{},{parts:Ti$1(e.parts)}):e))},cleanDoc:wi$1,replaceEndOfLineWith:function(e,t){return gi$1(t,e.split("\n")).parts},replaceNewlinesWithLiterallines:function(e){return bi$1(e,(e=>"string"==typeof e&&e.includes("\n")?gi$1(hi$1,e.split("\n")):e))}};const{getStringWidth:ki$1,getLast:Ni$1}=fi$1,{convertEndOfLineToChars:Pi$1}=di$1,{fill:Oi$1,cursor:Ii$1,indent:ji$1}=yn$1,{isConcat:Li$1,getDocParts:_i$1}=Bi$1;let Mi$1;function Ri$1(e,t){return Vi$1(e,{type:"indent"},t)}function $i$1(e,t,n){if(t===Number.NEGATIVE_INFINITY)return e.root||{value:"",length:0,queue:[]};if(t<0)return Vi$1(e,{type:"dedent"},n);if(!t)return e;if("root"===t.type)return Object.assign(Object.assign({},e),{},{root:e});return Vi$1(e,{type:"string"==typeof t?"stringAlign":"numberAlign",n:t},n)}function Vi$1(e,t,n){const r="dedent"===t.type?e.queue.slice(0,-1):[...e.queue,t];let i="",u=0,o=0,s=0;for(const e of r)switch(e.type){case"indent":c(),n.useTabs?a(1):l(n.tabWidth);break;case"stringAlign":c(),i+=e.n,u+=e.n.length;break;case"numberAlign":o+=1,s+=e.n;break;default:throw new Error(`Unexpected type '${e.type}'`)}return p(),Object.assign(Object.assign({},e),{},{value:i,length:u,queue:r});function a(e){i+="\t".repeat(e),u+=n.tabWidth*e;}function l(e){i+=" ".repeat(e),u+=e;}function c(){n.useTabs?function(){o>0&&a(o);f();}():p();}function p(){s>0&&l(s),f();}function f(){o=0,s=0;}}function qi$1(e){if(0===e.length)return 0;let t=0;for(;e.length>0&&"string"==typeof Ni$1(e)&&/^[\t ]*$/.test(Ni$1(e));)t+=e.pop().length;if(e.length>0&&"string"==typeof Ni$1(e)){const n=Ni$1(e).replace(/[\t ]*$/,"");t+=Ni$1(e).length-n.length,e[e.length-1]=n;}return t}function Wi$1(e,t,n,r,i,u){let o=t.length;const s=[e],a=[];for(;n>=0;){if(0===s.length){if(0===o)return !0;s.push(t[o-1]),o--;continue}const[e,l,c]=s.pop();if("string"==typeof c)a.push(c),n-=ki$1(c);else if(Li$1(c)){const t=_i$1(c);for(let n=t.length-1;n>=0;n--)s.push([e,l,t[n]]);}else switch(c.type){case"indent":s.push([Ri$1(e,r),l,c.contents]);break;case"align":s.push([$i$1(e,c.n,r),l,c.contents]);break;case"trim":n+=qi$1(a);break;case"group":{if(u&&c.break)return !1;const t=c.break?1:l;s.push([e,t,c.expandedStates&&1===t?Ni$1(c.expandedStates):c.contents]),c.id&&(Mi$1[c.id]=t);break}case"fill":for(let t=c.parts.length-1;t>=0;t--)s.push([e,l,c.parts[t]]);break;case"if-break":case"indent-if-break":{const t=c.groupId?Mi$1[c.groupId]:l;if(1===t){const t="if-break"===c.type?c.breakContents:c.negate?c.contents:ji$1(c.contents);t&&s.push([e,l,t]);}if(2===t){const t="if-break"===c.type?c.flatContents:c.negate?ji$1(c.contents):c.contents;t&&s.push([e,l,t]);}break}case"line":switch(l){case 2:if(!c.hard){c.soft||(a.push(" "),n-=1);break}return !0;case 1:return !0}break;case"line-suffix":i=!0;break;case"line-suffix-boundary":if(i)return !1;break;case"label":s.push([e,l,c.contents]);}}return !1}var Ui$1={printDocToString:function(e,t){Mi$1={};const n=t.printWidth,r=Pi$1(t.endOfLine);let i=0;const u=[[{value:"",length:0,queue:[]},1,e]],o=[];let s=!1,a=[];for(;u.length>0;){const[e,l,c]=u.pop();if("string"==typeof c){const e="\n"!==r?c.replace(/\n/g,r):c;o.push(e),i+=ki$1(e);}else if(Li$1(c)){const t=_i$1(c);for(let n=t.length-1;n>=0;n--)u.push([e,l,t[n]]);}else switch(c.type){case"cursor":o.push(Ii$1.placeholder);break;case"indent":u.push([Ri$1(e,t),l,c.contents]);break;case"align":u.push([$i$1(e,c.n,t),l,c.contents]);break;case"trim":i-=qi$1(o);break;case"group":switch(l){case 2:if(!s){u.push([e,c.break?1:2,c.contents]);break}case 1:{s=!1;const r=[e,2,c.contents],o=n-i,l=a.length>0;if(!c.break&&Wi$1(r,u,o,t,l))u.push(r);else if(c.expandedStates){const n=Ni$1(c.expandedStates);if(c.break){u.push([e,1,n]);break}for(let r=1;r<c.expandedStates.length+1;r++){if(r>=c.expandedStates.length){u.push([e,1,n]);break}{const n=[e,2,c.expandedStates[r]];if(Wi$1(n,u,o,t,l)){u.push(n);break}}}}else u.push([e,1,c.contents]);break}}c.id&&(Mi$1[c.id]=Ni$1(u)[1]);break;case"fill":{const r=n-i,{parts:o}=c;if(0===o.length)break;const[s,p]=o,f=[e,2,s],d=[e,1,s],h=Wi$1(f,[],r,t,a.length>0,!0);if(1===o.length){h?u.push(f):u.push(d);break}const g=[e,2,p],m=[e,1,p];if(2===o.length){h?u.push(g,f):u.push(m,d);break}o.splice(0,2);const y=[e,l,Oi$1(o)];Wi$1([e,2,[s,p,o[0]]],[],r,t,a.length>0,!0)?u.push(y,g,f):h?u.push(y,m,f):u.push(y,m,d);break}case"if-break":case"indent-if-break":{const t=c.groupId?Mi$1[c.groupId]:l;if(1===t){const t="if-break"===c.type?c.breakContents:c.negate?c.contents:ji$1(c.contents);t&&u.push([e,l,t]);}if(2===t){const t="if-break"===c.type?c.flatContents:c.negate?ji$1(c.contents):c.contents;t&&u.push([e,l,t]);}break}case"line-suffix":a.push([e,l,c.contents]);break;case"line-suffix-boundary":a.length>0&&u.push([e,l,{type:"line",hard:!0}]);break;case"line":switch(l){case 2:if(!c.hard){c.soft||(o.push(" "),i+=1);break}s=!0;case 1:if(a.length>0){u.push([e,l,c],...a.reverse()),a=[];break}c.literal?e.root?(o.push(r,e.root.value),i=e.root.length):(o.push(r),i=0):(i-=qi$1(o),o.push(r+e.value),i=e.length);}break;case"label":u.push([e,l,c.contents]);}0===u.length&&a.length>0&&(u.push(...a.reverse()),a=[]);}const l=o.indexOf(Ii$1.placeholder);if(-1!==l){const e=o.indexOf(Ii$1.placeholder,l+1),t=o.slice(0,l).join(""),n=o.slice(l+1,e).join("");return {formatted:t+n+o.slice(e+1).join(""),cursorNodeStart:t.length,cursorNodeText:n}}return {formatted:o.join("")}}};const{isConcat:zi$1,getDocParts:Gi$1}=Bi$1;function Hi$1(e){if(!e)return "";if(zi$1(e)){const t=[];for(const n of Gi$1(e))if(zi$1(n))t.push(...Hi$1(n).parts);else {const e=Hi$1(n);""!==e&&t.push(e);}return {type:"concat",parts:t}}return "if-break"===e.type?Object.assign(Object.assign({},e),{},{breakContents:Hi$1(e.breakContents),flatContents:Hi$1(e.flatContents)}):"group"===e.type?Object.assign(Object.assign({},e),{},{contents:Hi$1(e.contents),expandedStates:e.expandedStates&&e.expandedStates.map(Hi$1)}):"fill"===e.type?{type:"fill",parts:e.parts.map(Hi$1)}:e.contents?Object.assign(Object.assign({},e),{},{contents:Hi$1(e.contents)}):e}var Ji$1={builders:yn$1,printer:Ui$1,utils:Bi$1,debug:{printDocToDebug:function(e){const t=Object.create(null),n=new Set;return function e(t,n,i){if("string"==typeof t)return JSON.stringify(t);if(zi$1(t)){const n=Gi$1(t).map(e).filter(Boolean);return 1===n.length?n[0]:`[${n.join(", ")}]`}if("line"===t.type){const e=Array.isArray(i)&&i[n+1]&&"break-parent"===i[n+1].type;return t.literal?e?"literalline":"literallineWithoutBreakParent":t.hard?e?"hardline":"hardlineWithoutBreakParent":t.soft?"softline":"line"}if("break-parent"===t.type){return Array.isArray(i)&&i[n-1]&&"line"===i[n-1].type&&i[n-1].hard?void 0:"breakParent"}if("trim"===t.type)return "trim";if("indent"===t.type)return "indent("+e(t.contents)+")";if("align"===t.type)return t.n===Number.NEGATIVE_INFINITY?"dedentToRoot("+e(t.contents)+")":t.n<0?"dedent("+e(t.contents)+")":"root"===t.n.type?"markAsRoot("+e(t.contents)+")":"align("+JSON.stringify(t.n)+", "+e(t.contents)+")";if("if-break"===t.type)return "ifBreak("+e(t.breakContents)+(t.flatContents?", "+e(t.flatContents):"")+(t.groupId?(t.flatContents?"":', ""')+`, { groupId: ${r(t.groupId)} }`:"")+")";if("indent-if-break"===t.type){const n=[];t.negate&&n.push("negate: true"),t.groupId&&n.push(`groupId: ${r(t.groupId)}`);const i=n.length>0?`, { ${n.join(", ")} }`:"";return `indentIfBreak(${e(t.contents)}${i})`}if("group"===t.type){const n=[];t.break&&"propagated"!==t.break&&n.push("shouldBreak: true"),t.id&&n.push(`id: ${r(t.id)}`);const i=n.length>0?`, { ${n.join(", ")} }`:"";return t.expandedStates?`conditionalGroup([${t.expandedStates.map((t=>e(t))).join(",")}]${i})`:`group(${e(t.contents)}${i})`}if("fill"===t.type)return `fill([${t.parts.map((t=>e(t))).join(", ")}])`;if("line-suffix"===t.type)return "lineSuffix("+e(t.contents)+")";if("line-suffix-boundary"===t.type)return "lineSuffixBoundary";if("label"===t.type)return `label(${JSON.stringify(t.label)}, ${e(t.contents)})`;throw new Error("Unknown doc type "+t.type)}(Hi$1(e));function r(e){if("symbol"!=typeof e)return JSON.stringify(String(e));if(e in t)return t[e];const r=String(e).slice(7,-1)||"symbol";for(let i=0;;i++){const u=r+(i>0?` #${i}`:"");if(!n.has(u))return n.add(u),t[e]=`Symbol.for(${JSON.stringify(u)})`}}}}},Xi$1=Object.freeze({__proto__:null,default:{}});function Yi$1(e,t){for(var n=0,r=e.length-1;r>=0;r--){var i=e[r];"."===i?e.splice(r,1):".."===i?(e.splice(r,1),n++):n&&(e.splice(r,1),n--);}if(t)for(;n--;n)e.unshift("..");return e}var Ki$1=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,Qi$1=function(e){return Ki$1.exec(e).slice(1)};function Zi$1(){for(var e="",t=!1,n=arguments.length-1;n>=-1&&!t;n--){var r=n>=0?arguments[n]:"/";if("string"!=typeof r)throw new TypeError("Arguments to path.resolve must be strings");r&&(e=r+"/"+e,t="/"===r.charAt(0));}return (t?"/":"")+(e=Yi$1(au(e.split("/"),(function(e){return !!e})),!t).join("/"))||"."}function eu(e){var t=tu(e),n="/"===lu(e,-1);return (e=Yi$1(au(e.split("/"),(function(e){return !!e})),!t).join("/"))||t||(e="."),e&&n&&(e+="/"),(t?"/":"")+e}function tu(e){return "/"===e.charAt(0)}function nu(){var e=Array.prototype.slice.call(arguments,0);return eu(au(e,(function(e,t){if("string"!=typeof e)throw new TypeError("Arguments to path.join must be strings");return e})).join("/"))}function ru(e,t){function n(e){for(var t=0;t<e.length&&""===e[t];t++);for(var n=e.length-1;n>=0&&""===e[n];n--);return t>n?[]:e.slice(t,n-t+1)}e=Zi$1(e).substr(1),t=Zi$1(t).substr(1);for(var r=n(e.split("/")),i=n(t.split("/")),u=Math.min(r.length,i.length),o=u,s=0;s<u;s++)if(r[s]!==i[s]){o=s;break}var a=[];for(s=o;s<r.length;s++)a.push("..");return (a=a.concat(i.slice(o))).join("/")}function iu(e){var t=Qi$1(e),n=t[0],r=t[1];return n||r?(r&&(r=r.substr(0,r.length-1)),n+r):"."}function uu(e,t){var n=Qi$1(e)[2];return t&&n.substr(-1*t.length)===t&&(n=n.substr(0,n.length-t.length)),n}function ou(e){return Qi$1(e)[3]}var su={extname:ou,basename:uu,dirname:iu,sep:"/",delimiter:":",relative:ru,join:nu,isAbsolute:tu,normalize:eu,resolve:Zi$1};function au(e,t){if(e.filter)return e.filter(t);for(var n=[],r=0;r<e.length;r++)t(e[r],r,e)&&n.push(e[r]);return n}var lu="b"==="ab".substr(-1)?function(e,t,n){return e.substr(t,n)}:function(e,t,n){return t<0&&(t=e.length+t),e.substr(t,n)},cu=Object.freeze({__proto__:null,resolve:Zi$1,normalize:eu,isAbsolute:tu,join:nu,relative:ru,sep:"/",delimiter:":",dirname:iu,basename:uu,extname:ou,default:su}),pu=[],fu=[],du="undefined"!=typeof Uint8Array?Uint8Array:Array,hu=!1;function gu(){hu=!0;for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=0,n=e.length;t<n;++t)pu[t]=e[t],fu[e.charCodeAt(t)]=t;fu["-".charCodeAt(0)]=62,fu["_".charCodeAt(0)]=63;}function mu(e,t,n){for(var r,i,u=[],o=t;o<n;o+=3)r=(e[o]<<16)+(e[o+1]<<8)+e[o+2],u.push(pu[(i=r)>>18&63]+pu[i>>12&63]+pu[i>>6&63]+pu[63&i]);return u.join("")}function yu(e){var t;hu||gu();for(var n=e.length,r=n%3,i="",u=[],o=16383,s=0,a=n-r;s<a;s+=o)u.push(mu(e,s,s+o>a?a:s+o));return 1===r?(t=e[n-1],i+=pu[t>>2],i+=pu[t<<4&63],i+="=="):2===r&&(t=(e[n-2]<<8)+e[n-1],i+=pu[t>>10],i+=pu[t>>4&63],i+=pu[t<<2&63],i+="="),u.push(i),u.join("")}function Du(e,t,n,r,i){var u,o,s=8*i-r-1,a=(1<<s)-1,l=a>>1,c=-7,p=n?i-1:0,f=n?-1:1,d=e[t+p];for(p+=f,u=d&(1<<-c)-1,d>>=-c,c+=s;c>0;u=256*u+e[t+p],p+=f,c-=8);for(o=u&(1<<-c)-1,u>>=-c,c+=r;c>0;o=256*o+e[t+p],p+=f,c-=8);if(0===u)u=1-l;else {if(u===a)return o?NaN:1/0*(d?-1:1);o+=Math.pow(2,r),u-=l;}return (d?-1:1)*o*Math.pow(2,u-r)}function Eu(e,t,n,r,i,u){var o,s,a,l=8*u-i-1,c=(1<<l)-1,p=c>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=r?0:u-1,h=r?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,o=c):(o=Math.floor(Math.log(t)/Math.LN2),t*(a=Math.pow(2,-o))<1&&(o--,a*=2),(t+=o+p>=1?f/a:f*Math.pow(2,1-p))*a>=2&&(o++,a/=2),o+p>=c?(s=0,o=c):o+p>=1?(s=(t*a-1)*Math.pow(2,i),o+=p):(s=t*Math.pow(2,p-1)*Math.pow(2,i),o=0));i>=8;e[n+d]=255&s,d+=h,s/=256,i-=8);for(o=o<<i|s,l+=i;l>0;e[n+d]=255&o,d+=h,o/=256,l-=8);e[n+d-h]|=128*g;}var bu={}.toString,Cu=Array.isArray||function(e){return "[object Array]"==bu.call(e)};function vu(){return Fu.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function Au(e,t){if(vu()<t)throw new RangeError("Invalid typed array length");return Fu.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=Fu.prototype:(null===e&&(e=new Fu(t)),e.length=t),e}function Fu(e,t,n){if(!(Fu.TYPED_ARRAY_SUPPORT||this instanceof Fu))return new Fu(e,t,n);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return wu(this,e)}return xu(this,e,t,n)}function xu(e,t,n,r){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return "undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,r){if(n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r);Fu.TYPED_ARRAY_SUPPORT?(e=t).__proto__=Fu.prototype:e=Tu(e,t);return e}(e,t,n,r):"string"==typeof t?function(e,t,n){"string"==typeof n&&""!==n||(n="utf8");if(!Fu.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|Nu(t,n),i=(e=Au(e,r)).write(t,n);i!==r&&(e=e.slice(0,i));return e}(e,t,n):function(e,t){if(ku(t)){var n=0|Bu(t.length);return 0===(e=Au(e,n)).length||t.copy(e,0,0,n),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return "number"!=typeof t.length||(r=t.length)!=r?Au(e,0):Tu(e,t);if("Buffer"===t.type&&Cu(t.data))return Tu(e,t.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function Su(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function wu(e,t){if(Su(t),e=Au(e,t<0?0:0|Bu(t)),!Fu.TYPED_ARRAY_SUPPORT)for(var n=0;n<t;++n)e[n]=0;return e}function Tu(e,t){var n=t.length<0?0:0|Bu(t.length);e=Au(e,n);for(var r=0;r<n;r+=1)e[r]=255&t[r];return e}function Bu(e){if(e>=vu())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+vu().toString(16)+" bytes");return 0|e}function ku(e){return !(null==e||!e._isBuffer)}function Nu(e,t){if(ku(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var r=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return ro(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return io(e).length;default:if(r)return ro(e).length;t=(""+t).toLowerCase(),r=!0;}}function Pu(e,t,n){var r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return "";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return "";if((n>>>=0)<=(t>>>=0))return "";for(e||(e="utf8");;)switch(e){case"hex":return Gu(this,t,n);case"utf8":case"utf-8":return Wu(this,t,n);case"ascii":return Uu(this,t,n);case"latin1":case"binary":return zu(this,t,n);case"base64":return qu(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Hu(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0;}}function Ou(e,t,n){var r=e[t];e[t]=e[n],e[n]=r;}function Iu(e,t,n,r,i){if(0===e.length)return -1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=i?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(i)return -1;n=e.length-1;}else if(n<0){if(!i)return -1;n=0;}if("string"==typeof t&&(t=Fu.from(t,r)),ku(t))return 0===t.length?-1:ju(e,t,n,r,i);if("number"==typeof t)return t&=255,Fu.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):ju(e,[t],n,r,i);throw new TypeError("val must be string, number or Buffer")}function ju(e,t,n,r,i){var u,o=1,s=e.length,a=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return -1;o=2,s/=2,a/=2,n/=2;}function l(e,t){return 1===o?e[t]:e.readUInt16BE(t*o)}if(i){var c=-1;for(u=n;u<s;u++)if(l(e,u)===l(t,-1===c?0:u-c)){if(-1===c&&(c=u),u-c+1===a)return c*o}else -1!==c&&(u-=u-c),c=-1;}else for(n+a>s&&(n=s-a),u=n;u>=0;u--){for(var p=!0,f=0;f<a;f++)if(l(e,u+f)!==l(t,f)){p=!1;break}if(p)return u}return -1}function Lu(e,t,n,r){n=Number(n)||0;var i=e.length-n;r?(r=Number(r))>i&&(r=i):r=i;var u=t.length;if(u%2!=0)throw new TypeError("Invalid hex string");r>u/2&&(r=u/2);for(var o=0;o<r;++o){var s=parseInt(t.substr(2*o,2),16);if(isNaN(s))return o;e[n+o]=s;}return o}function _u(e,t,n,r){return uo(ro(t,e.length-n),e,n,r)}function Mu(e,t,n,r){return uo(function(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function Ru(e,t,n,r){return Mu(e,t,n,r)}function $u(e,t,n,r){return uo(io(t),e,n,r)}function Vu(e,t,n,r){return uo(function(e,t){for(var n,r,i,u=[],o=0;o<e.length&&!((t-=2)<0);++o)r=(n=e.charCodeAt(o))>>8,i=n%256,u.push(i),u.push(r);return u}(t,e.length-n),e,n,r)}function qu(e,t,n){return 0===t&&n===e.length?yu(e):yu(e.slice(t,n))}function Wu(e,t,n){n=Math.min(e.length,n);for(var r=[],i=t;i<n;){var u,o,s,a,l=e[i],c=null,p=l>239?4:l>223?3:l>191?2:1;if(i+p<=n)switch(p){case 1:l<128&&(c=l);break;case 2:128==(192&(u=e[i+1]))&&(a=(31&l)<<6|63&u)>127&&(c=a);break;case 3:u=e[i+1],o=e[i+2],128==(192&u)&&128==(192&o)&&(a=(15&l)<<12|(63&u)<<6|63&o)>2047&&(a<55296||a>57343)&&(c=a);break;case 4:u=e[i+1],o=e[i+2],s=e[i+3],128==(192&u)&&128==(192&o)&&128==(192&s)&&(a=(15&l)<<18|(63&u)<<12|(63&o)<<6|63&s)>65535&&a<1114112&&(c=a);}null===c?(c=65533,p=1):c>65535&&(c-=65536,r.push(c>>>10&1023|55296),c=56320|1023&c),r.push(c),i+=p;}return function(e){var t=e.length;if(t<=4096)return String.fromCharCode.apply(String,e);var n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=4096));return n}(r)}Fu.TYPED_ARRAY_SUPPORT=void 0===Kn$1.TYPED_ARRAY_SUPPORT||Kn$1.TYPED_ARRAY_SUPPORT,Fu.poolSize=8192,Fu._augment=function(e){return e.__proto__=Fu.prototype,e},Fu.from=function(e,t,n){return xu(null,e,t,n)},Fu.TYPED_ARRAY_SUPPORT&&(Fu.prototype.__proto__=Uint8Array.prototype,Fu.__proto__=Uint8Array),Fu.alloc=function(e,t,n){return function(e,t,n,r){return Su(t),t<=0?Au(e,t):void 0!==n?"string"==typeof r?Au(e,t).fill(n,r):Au(e,t).fill(n):Au(e,t)}(null,e,t,n)},Fu.allocUnsafe=function(e){return wu(null,e)},Fu.allocUnsafeSlow=function(e){return wu(null,e)},Fu.isBuffer=oo,Fu.compare=function(e,t){if(!ku(e)||!ku(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var n=e.length,r=t.length,i=0,u=Math.min(n,r);i<u;++i)if(e[i]!==t[i]){n=e[i],r=t[i];break}return n<r?-1:r<n?1:0},Fu.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},Fu.concat=function(e,t){if(!Cu(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return Fu.alloc(0);var n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;var r=Fu.allocUnsafe(t),i=0;for(n=0;n<e.length;++n){var u=e[n];if(!ku(u))throw new TypeError('"list" argument must be an Array of Buffers');u.copy(r,i),i+=u.length;}return r},Fu.byteLength=Nu,Fu.prototype._isBuffer=!0,Fu.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)Ou(this,t,t+1);return this},Fu.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)Ou(this,t,t+3),Ou(this,t+1,t+2);return this},Fu.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)Ou(this,t,t+7),Ou(this,t+1,t+6),Ou(this,t+2,t+5),Ou(this,t+3,t+4);return this},Fu.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?Wu(this,0,e):Pu.apply(this,arguments)},Fu.prototype.equals=function(e){if(!ku(e))throw new TypeError("Argument must be a Buffer");return this===e||0===Fu.compare(this,e)},Fu.prototype.inspect=function(){var e="";return this.length>0&&(e=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(e+=" ... ")),"<Buffer "+e+">"},Fu.prototype.compare=function(e,t,n,r,i){if(!ku(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===i&&(i=this.length),t<0||n>e.length||r<0||i>this.length)throw new RangeError("out of range index");if(r>=i&&t>=n)return 0;if(r>=i)return -1;if(t>=n)return 1;if(this===e)return 0;for(var u=(i>>>=0)-(r>>>=0),o=(n>>>=0)-(t>>>=0),s=Math.min(u,o),a=this.slice(r,i),l=e.slice(t,n),c=0;c<s;++c)if(a[c]!==l[c]){u=a[c],o=l[c];break}return u<o?-1:o<u?1:0},Fu.prototype.includes=function(e,t,n){return -1!==this.indexOf(e,t,n)},Fu.prototype.indexOf=function(e,t,n){return Iu(this,e,t,n,!0)},Fu.prototype.lastIndexOf=function(e,t,n){return Iu(this,e,t,n,!1)},Fu.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else {if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0);}var i=this.length-t;if((void 0===n||n>i)&&(n=i),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var u=!1;;)switch(r){case"hex":return Lu(this,e,t,n);case"utf8":case"utf-8":return _u(this,e,t,n);case"ascii":return Mu(this,e,t,n);case"latin1":case"binary":return Ru(this,e,t,n);case"base64":return $u(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Vu(this,e,t,n);default:if(u)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),u=!0;}},Fu.prototype.toJSON=function(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Uu(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(127&e[i]);return r}function zu(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(e[i]);return r}function Gu(e,t,n){var r=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>r)&&(n=r);for(var i="",u=t;u<n;++u)i+=no(e[u]);return i}function Hu(e,t,n){for(var r=e.slice(t,n),i="",u=0;u<r.length;u+=2)i+=String.fromCharCode(r[u]+256*r[u+1]);return i}function Ju(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function Xu(e,t,n,r,i,u){if(!ku(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<u)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function Yu(e,t,n,r){t<0&&(t=65535+t+1);for(var i=0,u=Math.min(e.length-n,2);i<u;++i)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i);}function Ku(e,t,n,r){t<0&&(t=4294967295+t+1);for(var i=0,u=Math.min(e.length-n,4);i<u;++i)e[n+i]=t>>>8*(r?i:3-i)&255;}function Qu(e,t,n,r,i,u){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function Zu(e,t,n,r,i){return i||Qu(e,0,n,4),Eu(e,t,n,r,23,4),n+4}function eo(e,t,n,r,i){return i||Qu(e,0,n,8),Eu(e,t,n,r,52,8),n+8}Fu.prototype.slice=function(e,t){var n,r=this.length;if((e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e),Fu.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=Fu.prototype;else {var i=t-e;n=new Fu(i,void 0);for(var u=0;u<i;++u)n[u]=this[u+e];}return n},Fu.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||Ju(e,t,this.length);for(var r=this[e],i=1,u=0;++u<t&&(i*=256);)r+=this[e+u]*i;return r},Fu.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||Ju(e,t,this.length);for(var r=this[e+--t],i=1;t>0&&(i*=256);)r+=this[e+--t]*i;return r},Fu.prototype.readUInt8=function(e,t){return t||Ju(e,1,this.length),this[e]},Fu.prototype.readUInt16LE=function(e,t){return t||Ju(e,2,this.length),this[e]|this[e+1]<<8},Fu.prototype.readUInt16BE=function(e,t){return t||Ju(e,2,this.length),this[e]<<8|this[e+1]},Fu.prototype.readUInt32LE=function(e,t){return t||Ju(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},Fu.prototype.readUInt32BE=function(e,t){return t||Ju(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},Fu.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||Ju(e,t,this.length);for(var r=this[e],i=1,u=0;++u<t&&(i*=256);)r+=this[e+u]*i;return r>=(i*=128)&&(r-=Math.pow(2,8*t)),r},Fu.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||Ju(e,t,this.length);for(var r=t,i=1,u=this[e+--r];r>0&&(i*=256);)u+=this[e+--r]*i;return u>=(i*=128)&&(u-=Math.pow(2,8*t)),u},Fu.prototype.readInt8=function(e,t){return t||Ju(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},Fu.prototype.readInt16LE=function(e,t){t||Ju(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},Fu.prototype.readInt16BE=function(e,t){t||Ju(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},Fu.prototype.readInt32LE=function(e,t){return t||Ju(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},Fu.prototype.readInt32BE=function(e,t){return t||Ju(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},Fu.prototype.readFloatLE=function(e,t){return t||Ju(e,4,this.length),Du(this,e,!0,23,4)},Fu.prototype.readFloatBE=function(e,t){return t||Ju(e,4,this.length),Du(this,e,!1,23,4)},Fu.prototype.readDoubleLE=function(e,t){return t||Ju(e,8,this.length),Du(this,e,!0,52,8)},Fu.prototype.readDoubleBE=function(e,t){return t||Ju(e,8,this.length),Du(this,e,!1,52,8)},Fu.prototype.writeUIntLE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||Xu(this,e,t,n,Math.pow(2,8*n)-1,0);var i=1,u=0;for(this[t]=255&e;++u<n&&(i*=256);)this[t+u]=e/i&255;return t+n},Fu.prototype.writeUIntBE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||Xu(this,e,t,n,Math.pow(2,8*n)-1,0);var i=n-1,u=1;for(this[t+i]=255&e;--i>=0&&(u*=256);)this[t+i]=e/u&255;return t+n},Fu.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,1,255,0),Fu.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},Fu.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,2,65535,0),Fu.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):Yu(this,e,t,!0),t+2},Fu.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,2,65535,0),Fu.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):Yu(this,e,t,!1),t+2},Fu.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,4,4294967295,0),Fu.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):Ku(this,e,t,!0),t+4},Fu.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,4,4294967295,0),Fu.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):Ku(this,e,t,!1),t+4},Fu.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);Xu(this,e,t,n,i-1,-i);}var u=0,o=1,s=0;for(this[t]=255&e;++u<n&&(o*=256);)e<0&&0===s&&0!==this[t+u-1]&&(s=1),this[t+u]=(e/o>>0)-s&255;return t+n},Fu.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);Xu(this,e,t,n,i-1,-i);}var u=n-1,o=1,s=0;for(this[t+u]=255&e;--u>=0&&(o*=256);)e<0&&0===s&&0!==this[t+u+1]&&(s=1),this[t+u]=(e/o>>0)-s&255;return t+n},Fu.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,1,127,-128),Fu.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},Fu.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,2,32767,-32768),Fu.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):Yu(this,e,t,!0),t+2},Fu.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,2,32767,-32768),Fu.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):Yu(this,e,t,!1),t+2},Fu.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,4,2147483647,-2147483648),Fu.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):Ku(this,e,t,!0),t+4},Fu.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||Xu(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),Fu.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):Ku(this,e,t,!1),t+4},Fu.prototype.writeFloatLE=function(e,t,n){return Zu(this,e,t,!0,n)},Fu.prototype.writeFloatBE=function(e,t,n){return Zu(this,e,t,!1,n)},Fu.prototype.writeDoubleLE=function(e,t,n){return eo(this,e,t,!0,n)},Fu.prototype.writeDoubleBE=function(e,t,n){return eo(this,e,t,!1,n)},Fu.prototype.copy=function(e,t,n,r){if(n||(n=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var i,u=r-n;if(this===e&&n<t&&t<r)for(i=u-1;i>=0;--i)e[i+t]=this[i+n];else if(u<1e3||!Fu.TYPED_ARRAY_SUPPORT)for(i=0;i<u;++i)e[i+t]=this[i+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+u),t);return u},Fu.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i);}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!Fu.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else "number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var u;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(u=t;u<n;++u)this[u]=e;else {var o=ku(e)?e:ro(new Fu(e,r).toString()),s=o.length;for(u=0;u<n-t;++u)this[u+t]=o[u%s];}return this};var to=/[^+\/0-9A-Za-z-_]/g;function no(e){return e<16?"0"+e.toString(16):e.toString(16)}function ro(e,t){var n;t=t||1/0;for(var r=e.length,i=null,u=[],o=0;o<r;++o){if((n=e.charCodeAt(o))>55295&&n<57344){if(!i){if(n>56319){(t-=3)>-1&&u.push(239,191,189);continue}if(o+1===r){(t-=3)>-1&&u.push(239,191,189);continue}i=n;continue}if(n<56320){(t-=3)>-1&&u.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320);}else i&&(t-=3)>-1&&u.push(239,191,189);if(i=null,n<128){if((t-=1)<0)break;u.push(n);}else if(n<2048){if((t-=2)<0)break;u.push(n>>6|192,63&n|128);}else if(n<65536){if((t-=3)<0)break;u.push(n>>12|224,n>>6&63|128,63&n|128);}else {if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;u.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128);}}return u}function io(e){return function(e){var t,n,r,i,u,o;hu||gu();var s=e.length;if(s%4>0)throw new Error("Invalid string. Length must be a multiple of 4");u="="===e[s-2]?2:"="===e[s-1]?1:0,o=new du(3*s/4-u),r=u>0?s-4:s;var a=0;for(t=0,n=0;t<r;t+=4,n+=3)i=fu[e.charCodeAt(t)]<<18|fu[e.charCodeAt(t+1)]<<12|fu[e.charCodeAt(t+2)]<<6|fu[e.charCodeAt(t+3)],o[a++]=i>>16&255,o[a++]=i>>8&255,o[a++]=255&i;return 2===u?(i=fu[e.charCodeAt(t)]<<2|fu[e.charCodeAt(t+1)]>>4,o[a++]=255&i):1===u&&(i=fu[e.charCodeAt(t)]<<10|fu[e.charCodeAt(t+1)]<<4|fu[e.charCodeAt(t+2)]>>2,o[a++]=i>>8&255,o[a++]=255&i),o}(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(to,"")).length<2)return "";for(;e.length%4!=0;)e+="=";return e}(e))}function uo(e,t,n,r){for(var i=0;i<r&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}function oo(e){return null!=e&&(!!e._isBuffer||so(e)||function(e){return "function"==typeof e.readFloatLE&&"function"==typeof e.slice&&so(e.slice(0,0))}(e))}function so(e){return !!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}var ao=r$2(Xi$1);var lo=class{constructor(e,t){(t=t||{}).readChunk||(t.readChunk=1024),t.newLineCharacter?t.newLineCharacter=t.newLineCharacter.charCodeAt(0):t.newLineCharacter=10,this.fd="number"==typeof e?e:ao.openSync(e,"r"),this.options=t,this.newLineCharacter=t.newLineCharacter,this.reset();}_searchInBuffer(e,t){let n=-1;for(let r=0;r<=e.length;r++){if(e[r]===t){n=r;break}}return n}reset(){this.eofReached=!1,this.linesCache=[],this.fdPosition=0;}close(){ao.closeSync(this.fd),this.fd=null;}_extractLines(e){let t;const n=[];let r=0,i=0;for(;;){let u=e[r++];if(u===this.newLineCharacter)t=e.slice(i,r),n.push(t),i=r;else if(void 0===u)break}let u=e.slice(i,r);return u.length&&n.push(u),n}_readChunk(e){let t,n=0;const r=[];do{const e=new Fu(this.options.readChunk);t=ao.readSync(this.fd,e,0,this.options.readChunk,this.fdPosition),n+=t,this.fdPosition=this.fdPosition+t,r.push(e);}while(t&&-1===this._searchInBuffer(r[r.length-1],this.options.newLineCharacter));let i=Fu.concat(r);return t<this.options.readChunk&&(this.eofReached=!0,i=i.slice(0,n)),n&&(this.linesCache=this._extractLines(i),e&&(this.linesCache[0]=Fu.concat([e,this.linesCache[0]]))),n}next(){if(!this.fd)return !1;let e,t=!1;if(this.eofReached&&0===this.linesCache.length)return t;if(this.linesCache.length||(e=this._readChunk()),this.linesCache.length){t=this.linesCache.shift();t[t.length-1]!==this.newLineCharacter&&(e=this._readChunk(t),e&&(t=this.linesCache.shift()));}return this.eofReached&&0===this.linesCache.length&&this.close(),t&&t[t.length-1]===this.newLineCharacter&&(t=t.slice(0,t.length-1)),t}};class co extends Error{}class po extends Error{}class fo extends Error{}class ho extends Error{}var go={ConfigError:co,DebugError:po,UndefinedParserError:fo,ArgExpansionBailout:ho},mo=function(e,t){return (mo=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);})(e,t)};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var yo=function(){return (yo=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function Do(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return {next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function Eo(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,i,u=n.call(e),o=[];try{for(;(void 0===t||t-- >0)&&!(r=u.next()).done;)o.push(r.value);}catch(e){i={error:e};}finally{try{r&&!r.done&&(n=u.return)&&n.call(u);}finally{if(i)throw i.error}}return o}function bo(e){return this instanceof bo?(this.v=e,this):new bo(e)}var Co=Object.freeze({__proto__:null,__extends:function(e,t){function n(){this.constructor=e;}mo(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n);},get __assign(){return yo},__rest:function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(e);i<r.length;i++)t.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(e,r[i])&&(n[r[i]]=e[r[i]]);}return n},__decorate:function(e,t,n,r){var i,u=arguments.length,o=u<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var s=e.length-1;s>=0;s--)(i=e[s])&&(o=(u<3?i(o):u>3?i(t,n,o):i(t,n))||o);return u>3&&o&&Object.defineProperty(t,n,o),o},__param:function(e,t){return function(n,r){t(n,r,e);}},__metadata:function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)},__awaiter:function(e,t,n,r){return new(n||(n=Promise))((function(i,u){function o(e){try{a(r.next(e));}catch(e){u(e);}}function s(e){try{a(r.throw(e));}catch(e){u(e);}}function a(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t);}))).then(o,s);}a((r=r.apply(e,t||[])).next());}))},__generator:function(e,t){var n,r,i,u,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return u={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(u[Symbol.iterator]=function(){return this}),u;function s(u){return function(s){return function(u){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&u[0]?r.return:u[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,u[1])).done)return i;switch(r=0,i&&(u=[2&u[0],i.value]),u[0]){case 0:case 1:i=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(!(i=o.trys,(i=i.length>0&&i[i.length-1])||6!==u[0]&&2!==u[0])){o=0;continue}if(3===u[0]&&(!i||u[1]>i[0]&&u[1]<i[3])){o.label=u[1];break}if(6===u[0]&&o.label<i[1]){o.label=i[1],i=u;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(u);break}i[2]&&o.ops.pop(),o.trys.pop();continue}u=t.call(e,o);}catch(e){u=[6,e],r=0;}finally{n=i=0;}if(5&u[0])throw u[1];return {value:u[0]?u[1]:void 0,done:!0}}([u,s])}}},__createBinding:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n];},__exportStar:function(e,t){for(var n in e)"default"===n||t.hasOwnProperty(n)||(t[n]=e[n]);},__values:Do,__read:Eo,__spread:function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(Eo(arguments[t]));return e},__spreadArrays:function(){for(var e=0,t=0,n=arguments.length;t<n;t++)e+=arguments[t].length;var r=Array(e),i=0;for(t=0;t<n;t++)for(var u=arguments[t],o=0,s=u.length;o<s;o++,i++)r[i]=u[o];return r},__await:bo,__asyncGenerator:function(e,t,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,i=n.apply(e,t||[]),u=[];return r={},o("next"),o("throw"),o("return"),r[Symbol.asyncIterator]=function(){return this},r;function o(e){i[e]&&(r[e]=function(t){return new Promise((function(n,r){u.push([e,t,n,r])>1||s(e,t);}))});}function s(e,t){try{(n=i[e](t)).value instanceof bo?Promise.resolve(n.value.v).then(a,l):c(u[0][2],n);}catch(e){c(u[0][3],e);}var n;}function a(e){s("next",e);}function l(e){s("throw",e);}function c(e,t){e(t),u.shift(),u.length&&s(u[0][0],u[0][1]);}},__asyncDelegator:function(e){var t,n;return t={},r("next"),r("throw",(function(e){throw e})),r("return"),t[Symbol.iterator]=function(){return this},t;function r(r,i){t[r]=e[r]?function(t){return (n=!n)?{value:bo(e[r](t)),done:"return"===r}:i?i(t):t}:i;}},__asyncValues:function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,n=e[Symbol.asyncIterator];return n?n.call(e):(e=Do(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(n){t[n]=e[n]&&function(t){return new Promise((function(r,i){(function(e,t,n,r){Promise.resolve(r).then((function(t){e({value:t,done:n});}),t);})(r,i,(t=e[n](t)).done,t.value);}))};}},__makeTemplateObject:function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e},__importStar:function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t},__importDefault:function(e){return e&&e.__esModule?e:{default:e}},__classPrivateFieldGet:function(e,t){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");return t.get(e)},__classPrivateFieldSet:function(e,t,n){if(!t.has(e))throw new TypeError("attempted to set private field on non-instance");return t.set(e,n),n}}),vo=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.apiDescriptor={key:e=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e)?e:JSON.stringify(e),value(e){if(null===e||"object"!=typeof e)return JSON.stringify(e);if(Array.isArray(e))return `[${e.map((e=>t.apiDescriptor.value(e))).join(", ")}]`;const n=Object.keys(e);return 0===n.length?"{}":`{ ${n.map((n=>`${t.apiDescriptor.key(n)}: ${t.apiDescriptor.value(e[n])}`)).join(", ")} }`},pair:({key:e,value:n})=>t.apiDescriptor.value({[e]:n})};})),Ao=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Co.__exportStar(vo,t);})),Fo=/[|\\{}()[\]^$+*?.]/g,xo=function(e){if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(Fo,"\\$&")},So={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},wo=i$2((function(e){var t={};for(var n in So)So.hasOwnProperty(n)&&(t[So[n]]=n);var r=e.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var i in r)if(r.hasOwnProperty(i)){if(!("channels"in r[i]))throw new Error("missing channels property: "+i);if(!("labels"in r[i]))throw new Error("missing channel labels property: "+i);if(r[i].labels.length!==r[i].channels)throw new Error("channel and label counts mismatch: "+i);var u=r[i].channels,o=r[i].labels;delete r[i].channels,delete r[i].labels,Object.defineProperty(r[i],"channels",{value:u}),Object.defineProperty(r[i],"labels",{value:o});}r.rgb.hsl=function(e){var t,n,r=e[0]/255,i=e[1]/255,u=e[2]/255,o=Math.min(r,i,u),s=Math.max(r,i,u),a=s-o;return s===o?t=0:r===s?t=(i-u)/a:i===s?t=2+(u-r)/a:u===s&&(t=4+(r-i)/a),(t=Math.min(60*t,360))<0&&(t+=360),n=(o+s)/2,[t,100*(s===o?0:n<=.5?a/(s+o):a/(2-s-o)),100*n]},r.rgb.hsv=function(e){var t,n,r,i,u,o=e[0]/255,s=e[1]/255,a=e[2]/255,l=Math.max(o,s,a),c=l-Math.min(o,s,a),p=function(e){return (l-e)/6/c+.5};return 0===c?i=u=0:(u=c/l,t=p(o),n=p(s),r=p(a),o===l?i=r-n:s===l?i=1/3+t-r:a===l&&(i=2/3+n-t),i<0?i+=1:i>1&&(i-=1)),[360*i,100*u,100*l]},r.rgb.hwb=function(e){var t=e[0],n=e[1],i=e[2];return [r.rgb.hsl(e)[0],100*(1/255*Math.min(t,Math.min(n,i))),100*(i=1-1/255*Math.max(t,Math.max(n,i)))]},r.rgb.cmyk=function(e){var t,n=e[0]/255,r=e[1]/255,i=e[2]/255;return [100*((1-n-(t=Math.min(1-n,1-r,1-i)))/(1-t)||0),100*((1-r-t)/(1-t)||0),100*((1-i-t)/(1-t)||0),100*t]},r.rgb.keyword=function(e){var n=t[e];if(n)return n;var r,i,u,o=1/0;for(var s in So)if(So.hasOwnProperty(s)){var a=So[s],l=(i=e,u=a,Math.pow(i[0]-u[0],2)+Math.pow(i[1]-u[1],2)+Math.pow(i[2]-u[2],2));l<o&&(o=l,r=s);}return r},r.keyword.rgb=function(e){return So[e]},r.rgb.xyz=function(e){var t=e[0]/255,n=e[1]/255,r=e[2]/255;return [100*(.4124*(t=t>.04045?Math.pow((t+.055)/1.055,2.4):t/12.92)+.3576*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)+.1805*(r=r>.04045?Math.pow((r+.055)/1.055,2.4):r/12.92)),100*(.2126*t+.7152*n+.0722*r),100*(.0193*t+.1192*n+.9505*r)]},r.rgb.lab=function(e){var t=r.rgb.xyz(e),n=t[0],i=t[1],u=t[2];return i/=100,u/=108.883,n=(n/=95.047)>.008856?Math.pow(n,1/3):7.787*n+16/116,[116*(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116)-16,500*(n-i),200*(i-(u=u>.008856?Math.pow(u,1/3):7.787*u+16/116))]},r.hsl.rgb=function(e){var t,n,r,i,u,o=e[0]/360,s=e[1]/100,a=e[2]/100;if(0===s)return [u=255*a,u,u];t=2*a-(n=a<.5?a*(1+s):a+s-a*s),i=[0,0,0];for(var l=0;l<3;l++)(r=o+1/3*-(l-1))<0&&r++,r>1&&r--,u=6*r<1?t+6*(n-t)*r:2*r<1?n:3*r<2?t+(n-t)*(2/3-r)*6:t,i[l]=255*u;return i},r.hsl.hsv=function(e){var t=e[0],n=e[1]/100,r=e[2]/100,i=n,u=Math.max(r,.01);return n*=(r*=2)<=1?r:2-r,i*=u<=1?u:2-u,[t,100*(0===r?2*i/(u+i):2*n/(r+n)),100*((r+n)/2)]},r.hsv.rgb=function(e){var t=e[0]/60,n=e[1]/100,r=e[2]/100,i=Math.floor(t)%6,u=t-Math.floor(t),o=255*r*(1-n),s=255*r*(1-n*u),a=255*r*(1-n*(1-u));switch(r*=255,i){case 0:return [r,a,o];case 1:return [s,r,o];case 2:return [o,r,a];case 3:return [o,s,r];case 4:return [a,o,r];case 5:return [r,o,s]}},r.hsv.hsl=function(e){var t,n,r,i=e[0],u=e[1]/100,o=e[2]/100,s=Math.max(o,.01);return r=(2-u)*o,n=u*s,[i,100*(n=(n/=(t=(2-u)*s)<=1?t:2-t)||0),100*(r/=2)]},r.hwb.rgb=function(e){var t,n,r,i,u,o,s,a=e[0]/360,l=e[1]/100,c=e[2]/100,p=l+c;switch(p>1&&(l/=p,c/=p),r=6*a-(t=Math.floor(6*a)),0!=(1&t)&&(r=1-r),i=l+r*((n=1-c)-l),t){default:case 6:case 0:u=n,o=i,s=l;break;case 1:u=i,o=n,s=l;break;case 2:u=l,o=n,s=i;break;case 3:u=l,o=i,s=n;break;case 4:u=i,o=l,s=n;break;case 5:u=n,o=l,s=i;}return [255*u,255*o,255*s]},r.cmyk.rgb=function(e){var t=e[0]/100,n=e[1]/100,r=e[2]/100,i=e[3]/100;return [255*(1-Math.min(1,t*(1-i)+i)),255*(1-Math.min(1,n*(1-i)+i)),255*(1-Math.min(1,r*(1-i)+i))]},r.xyz.rgb=function(e){var t,n,r,i=e[0]/100,u=e[1]/100,o=e[2]/100;return n=-.9689*i+1.8758*u+.0415*o,r=.0557*i+-.204*u+1.057*o,t=(t=3.2406*i+-1.5372*u+-.4986*o)>.0031308?1.055*Math.pow(t,1/2.4)-.055:12.92*t,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,r=r>.0031308?1.055*Math.pow(r,1/2.4)-.055:12.92*r,[255*(t=Math.min(Math.max(0,t),1)),255*(n=Math.min(Math.max(0,n),1)),255*(r=Math.min(Math.max(0,r),1))]},r.xyz.lab=function(e){var t=e[0],n=e[1],r=e[2];return n/=100,r/=108.883,t=(t/=95.047)>.008856?Math.pow(t,1/3):7.787*t+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(t-n),200*(n-(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116))]},r.lab.xyz=function(e){var t,n,r,i=e[0];t=e[1]/500+(n=(i+16)/116),r=n-e[2]/200;var u=Math.pow(n,3),o=Math.pow(t,3),s=Math.pow(r,3);return n=u>.008856?u:(n-16/116)/7.787,t=o>.008856?o:(t-16/116)/7.787,r=s>.008856?s:(r-16/116)/7.787,[t*=95.047,n*=100,r*=108.883]},r.lab.lch=function(e){var t,n=e[0],r=e[1],i=e[2];return (t=360*Math.atan2(i,r)/2/Math.PI)<0&&(t+=360),[n,Math.sqrt(r*r+i*i),t]},r.lch.lab=function(e){var t,n=e[0],r=e[1];return t=e[2]/360*2*Math.PI,[n,r*Math.cos(t),r*Math.sin(t)]},r.rgb.ansi16=function(e){var t=e[0],n=e[1],i=e[2],u=1 in arguments?arguments[1]:r.rgb.hsv(e)[2];if(0===(u=Math.round(u/50)))return 30;var o=30+(Math.round(i/255)<<2|Math.round(n/255)<<1|Math.round(t/255));return 2===u&&(o+=60),o},r.hsv.ansi16=function(e){return r.rgb.ansi16(r.hsv.rgb(e),e[2])},r.rgb.ansi256=function(e){var t=e[0],n=e[1],r=e[2];return t===n&&n===r?t<8?16:t>248?231:Math.round((t-8)/247*24)+232:16+36*Math.round(t/255*5)+6*Math.round(n/255*5)+Math.round(r/255*5)},r.ansi16.rgb=function(e){var t=e%10;if(0===t||7===t)return e>50&&(t+=3.5),[t=t/10.5*255,t,t];var n=.5*(1+~~(e>50));return [(1&t)*n*255,(t>>1&1)*n*255,(t>>2&1)*n*255]},r.ansi256.rgb=function(e){if(e>=232){var t=10*(e-232)+8;return [t,t,t]}var n;return e-=16,[Math.floor(e/36)/5*255,Math.floor((n=e%36)/6)/5*255,n%6/5*255]},r.rgb.hex=function(e){var t=(((255&Math.round(e[0]))<<16)+((255&Math.round(e[1]))<<8)+(255&Math.round(e[2]))).toString(16).toUpperCase();return "000000".substring(t.length)+t},r.hex.rgb=function(e){var t=e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!t)return [0,0,0];var n=t[0];3===t[0].length&&(n=n.split("").map((function(e){return e+e})).join(""));var r=parseInt(n,16);return [r>>16&255,r>>8&255,255&r]},r.rgb.hcg=function(e){var t,n=e[0]/255,r=e[1]/255,i=e[2]/255,u=Math.max(Math.max(n,r),i),o=Math.min(Math.min(n,r),i),s=u-o;return t=s<=0?0:u===n?(r-i)/s%6:u===r?2+(i-n)/s:4+(n-r)/s+4,t/=6,[360*(t%=1),100*s,100*(s<1?o/(1-s):0)]},r.hsl.hcg=function(e){var t=e[1]/100,n=e[2]/100,r=1,i=0;return (r=n<.5?2*t*n:2*t*(1-n))<1&&(i=(n-.5*r)/(1-r)),[e[0],100*r,100*i]},r.hsv.hcg=function(e){var t=e[1]/100,n=e[2]/100,r=t*n,i=0;return r<1&&(i=(n-r)/(1-r)),[e[0],100*r,100*i]},r.hcg.rgb=function(e){var t=e[0]/360,n=e[1]/100,r=e[2]/100;if(0===n)return [255*r,255*r,255*r];var i,u=[0,0,0],o=t%1*6,s=o%1,a=1-s;switch(Math.floor(o)){case 0:u[0]=1,u[1]=s,u[2]=0;break;case 1:u[0]=a,u[1]=1,u[2]=0;break;case 2:u[0]=0,u[1]=1,u[2]=s;break;case 3:u[0]=0,u[1]=a,u[2]=1;break;case 4:u[0]=s,u[1]=0,u[2]=1;break;default:u[0]=1,u[1]=0,u[2]=a;}return i=(1-n)*r,[255*(n*u[0]+i),255*(n*u[1]+i),255*(n*u[2]+i)]},r.hcg.hsv=function(e){var t=e[1]/100,n=t+e[2]/100*(1-t),r=0;return n>0&&(r=t/n),[e[0],100*r,100*n]},r.hcg.hsl=function(e){var t=e[1]/100,n=e[2]/100*(1-t)+.5*t,r=0;return n>0&&n<.5?r=t/(2*n):n>=.5&&n<1&&(r=t/(2*(1-n))),[e[0],100*r,100*n]},r.hcg.hwb=function(e){var t=e[1]/100,n=t+e[2]/100*(1-t);return [e[0],100*(n-t),100*(1-n)]},r.hwb.hcg=function(e){var t=e[1]/100,n=1-e[2]/100,r=n-t,i=0;return r<1&&(i=(n-r)/(1-r)),[e[0],100*r,100*i]},r.apple.rgb=function(e){return [e[0]/65535*255,e[1]/65535*255,e[2]/65535*255]},r.rgb.apple=function(e){return [e[0]/255*65535,e[1]/255*65535,e[2]/255*65535]},r.gray.rgb=function(e){return [e[0]/100*255,e[0]/100*255,e[0]/100*255]},r.gray.hsl=r.gray.hsv=function(e){return [0,0,e[0]]},r.gray.hwb=function(e){return [0,100,e[0]]},r.gray.cmyk=function(e){return [0,0,0,e[0]]},r.gray.lab=function(e){return [e[0],0,0]},r.gray.hex=function(e){var t=255&Math.round(e[0]/100*255),n=((t<<16)+(t<<8)+t).toString(16).toUpperCase();return "000000".substring(n.length)+n},r.rgb.gray=function(e){return [(e[0]+e[1]+e[2])/3/255*100]};}));function To(e){var t=function(){for(var e={},t=Object.keys(wo),n=t.length,r=0;r<n;r++)e[t[r]]={distance:-1,parent:null};return e}(),n=[e];for(t[e].distance=0;n.length;)for(var r=n.pop(),i=Object.keys(wo[r]),u=i.length,o=0;o<u;o++){var s=i[o],a=t[s];-1===a.distance&&(a.distance=t[r].distance+1,a.parent=r,n.unshift(s));}return t}function Bo(e,t){return function(n){return t(e(n))}}function ko(e,t){for(var n=[t[e].parent,e],r=wo[t[e].parent][e],i=t[e].parent;t[i].parent;)n.unshift(t[i].parent),r=Bo(wo[t[i].parent][i],r),i=t[i].parent;return r.conversion=n,r}var No={};Object.keys(wo).forEach((function(e){No[e]={},Object.defineProperty(No[e],"channels",{value:wo[e].channels}),Object.defineProperty(No[e],"labels",{value:wo[e].labels});var t=function(e){for(var t=To(e),n={},r=Object.keys(t),i=r.length,u=0;u<i;u++){var o=r[u];null!==t[o].parent&&(n[o]=ko(o,t));}return n}(e);Object.keys(t).forEach((function(n){var r=t[n];No[e][n]=function(e){var t=function(t){if(null==t)return t;arguments.length>1&&(t=Array.prototype.slice.call(arguments));var n=e(t);if("object"==typeof n)for(var r=n.length,i=0;i<r;i++)n[i]=Math.round(n[i]);return n};return "conversion"in e&&(t.conversion=e.conversion),t}(r),No[e][n].raw=function(e){var t=function(t){return null==t?t:(arguments.length>1&&(t=Array.prototype.slice.call(arguments)),e(t))};return "conversion"in e&&(t.conversion=e.conversion),t}(r);}));}));var Po,Oo=No,Io=i$2((function(e){const t=(e,t)=>function(){const n=e.apply(Oo,arguments);return `\x1b[${n+t}m`},n=(e,t)=>function(){const n=e.apply(Oo,arguments);return `\x1b[${38+t};5;${n}m`},r=(e,t)=>function(){const n=e.apply(Oo,arguments);return `\x1b[${38+t};2;${n[0]};${n[1]};${n[2]}m`};Object.defineProperty(e,"exports",{enumerable:!0,get:function(){const e=new Map,i={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};i.color.grey=i.color.gray;for(const t of Object.keys(i)){const n=i[t];for(const t of Object.keys(n)){const r=n[t];i[t]={open:`\x1b[${r[0]}m`,close:`\x1b[${r[1]}m`},n[t]=i[t],e.set(r[0],r[1]);}Object.defineProperty(i,t,{value:n,enumerable:!1}),Object.defineProperty(i,"codes",{value:e,enumerable:!1});}const u=e=>e,o=(e,t,n)=>[e,t,n];i.color.close="\x1b[39m",i.bgColor.close="\x1b[49m",i.color.ansi={ansi:t(u,0)},i.color.ansi256={ansi256:n(u,0)},i.color.ansi16m={rgb:r(o,0)},i.bgColor.ansi={ansi:t(u,10)},i.bgColor.ansi256={ansi256:n(u,10)},i.bgColor.ansi16m={rgb:r(o,10)};for(let e of Object.keys(Oo)){if("object"!=typeof Oo[e])continue;const u=Oo[e];"ansi16"===e&&(e="ansi"),"ansi16"in u&&(i.color.ansi[e]=t(u.ansi16,0),i.bgColor.ansi[e]=t(u.ansi16,10)),"ansi256"in u&&(i.color.ansi256[e]=n(u.ansi256,0),i.bgColor.ansi256[e]=n(u.ansi256,10)),"rgb"in u&&(i.color.ansi16m[e]=r(u.rgb,0),i.bgColor.ansi16m[e]=r(u.rgb,10));}return i}});}));function jo(){if(void 0===Po){var e=new ArrayBuffer(2),t=new Uint8Array(e),n=new Uint16Array(e);if(t[0]=1,t[1]=2,258===n[0])Po="BE";else {if(513!==n[0])throw new Error("unable to figure out endianess");Po="LE";}}return Po}function Lo(){return void 0!==Kn$1.location?Kn$1.location.hostname:""}function _o(){return []}function Mo(){return 0}function Ro(){return Number.MAX_VALUE}function $o(){return Number.MAX_VALUE}function Vo(){return []}function qo(){return "Browser"}function Wo(){return void 0!==Kn$1.navigator?Kn$1.navigator.appVersion:""}function Uo(){}function zo(){}function Go(){return "javascript"}function Ho(){return "browser"}function Jo(){return "/tmp"}var Xo=Jo,Yo={EOL:"\n",arch:Go,platform:Ho,tmpdir:Xo,tmpDir:Jo,networkInterfaces:Uo,getNetworkInterfaces:zo,release:Wo,type:qo,cpus:Vo,totalmem:$o,freemem:Ro,uptime:Mo,loadavg:_o,hostname:Lo,endianness:jo},Ko=(e,t)=>{t=t||Cr$1.argv;const n=e.startsWith("-")?"":1===e.length?"-":"--",r=t.indexOf(n+e),i=t.indexOf("--");return -1!==r&&(-1===i||r<i)},Qo=r$2(Object.freeze({__proto__:null,endianness:jo,hostname:Lo,loadavg:_o,uptime:Mo,freemem:Ro,totalmem:$o,cpus:Vo,type:qo,release:Wo,networkInterfaces:Uo,getNetworkInterfaces:zo,arch:Go,platform:Ho,tmpDir:Jo,tmpdir:Xo,EOL:"\n",default:Yo}));const Zo=Cr$1.env;let es$1;function ts$1(e){return function(e){return 0!==e&&{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}(function(e){if(!1===es$1)return 0;if(Ko("color=16m")||Ko("color=full")||Ko("color=truecolor"))return 3;if(Ko("color=256"))return 2;if(e&&!e.isTTY&&!0!==es$1)return 0;const t=es$1?1:0;if("CI"in Zo)return ["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI"].some((e=>e in Zo))||"codeship"===Zo.CI_NAME?1:t;if("TEAMCITY_VERSION"in Zo)return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Zo.TEAMCITY_VERSION)?1:0;if("truecolor"===Zo.COLORTERM)return 3;if("TERM_PROGRAM"in Zo){const e=parseInt((Zo.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(Zo.TERM_PROGRAM){case"iTerm.app":return e>=3?3:2;case"Apple_Terminal":return 2}}return /-256(color)?$/i.test(Zo.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Zo.TERM)||"COLORTERM"in Zo?1:(t)}(e))}Ko("no-color")||Ko("no-colors")||Ko("color=false")?es$1=!1:(Ko("color")||Ko("colors")||Ko("color=true")||Ko("color=always"))&&(es$1=!0),"FORCE_COLOR"in Zo&&(es$1=0===Zo.FORCE_COLOR.length||0!==parseInt(Zo.FORCE_COLOR,10));var ns$1={supportsColor:ts$1,stdout:ts$1(Cr$1.stdout),stderr:ts$1(Cr$1.stderr)};const rs$1=/(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,is$2=/(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,us$1=/^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,os$1=/\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi,ss$1=new Map([["n","\n"],["r","\r"],["t","\t"],["b","\b"],["f","\f"],["v","\v"],["0","\0"],["\\","\\"],["e","\x1b"],["a","\x07"]]);function as$1(e){return "u"===e[0]&&5===e.length||"x"===e[0]&&3===e.length?String.fromCharCode(parseInt(e.slice(1),16)):ss$1.get(e)||e}function ls$1(e,t){const n=[],r=t.trim().split(/\s*,\s*/g);let i;for(const t of r)if(isNaN(t)){if(!(i=t.match(us$1)))throw new Error(`Invalid Chalk template style argument: ${t} (in style '${e}')`);n.push(i[2].replace(os$1,((e,t,n)=>t?as$1(t):n)));}else n.push(Number(t));return n}function cs$1(e){is$2.lastIndex=0;const t=[];let n;for(;null!==(n=is$2.exec(e));){const e=n[1];if(n[2]){const r=ls$1(e,n[2]);t.push([e].concat(r));}else t.push([e]);}return t}function ps$1(e,t){const n={};for(const e of t)for(const t of e.styles)n[t[0]]=e.inverse?null:t.slice(1);let r=e;for(const e of Object.keys(n))if(Array.isArray(n[e])){if(!(e in r))throw new Error(`Unknown Chalk style: ${e}`);r=n[e].length>0?r[e].apply(r,n[e]):r[e];}return r}var fs$1=(e,t)=>{const n=[],r=[];let i=[];if(t.replace(rs$1,((t,u,o,s,a,l)=>{if(u)i.push(as$1(u));else if(s){const t=i.join("");i=[],r.push(0===n.length?t:ps$1(e,n)(t)),n.push({inverse:o,styles:cs$1(s)});}else if(a){if(0===n.length)throw new Error("Found extraneous } in Chalk template literal");r.push(ps$1(e,n)(i.join(""))),i=[],n.pop();}else i.push(l);})),r.push(i.join("")),n.length>0){const e=`Chalk template literal is missing ${n.length} closing bracket${1===n.length?"":"s"} (\`}\`)`;throw new Error(e)}return r.join("")},ds$1=i$2((function(e){const t=ns$1.stdout,n=["ansi","ansi","ansi256","ansi16m"],r=new Set(["gray"]),i=Object.create(null);function u(e,n){n=n||{};const r=t?t.level:0;e.level=void 0===n.level?r:n.level,e.enabled="enabled"in n?n.enabled:e.level>0;}function o(e){if(!this||!(this instanceof o)||this.template){const t={};return u(t,e),t.template=function(){const e=[].slice.call(arguments);return c.apply(null,[t.template].concat(e))},Object.setPrototypeOf(t,o.prototype),Object.setPrototypeOf(t.template,t),t.template.constructor=o,t.template}u(this,e);}for(const e of Object.keys(Io))Io[e].closeRe=new RegExp(xo(Io[e].close),"g"),i[e]={get(){const t=Io[e];return a.call(this,this._styles?this._styles.concat(t):[t],this._empty,e)}};i.visible={get(){return a.call(this,this._styles||[],!0,"visible")}},Io.color.closeRe=new RegExp(xo(Io.color.close),"g");for(const e of Object.keys(Io.color.ansi))r.has(e)||(i[e]={get(){const t=this.level;return function(){const r=Io.color[n[t]][e].apply(null,arguments),i={open:r,close:Io.color.close,closeRe:Io.color.closeRe};return a.call(this,this._styles?this._styles.concat(i):[i],this._empty,e)}}});Io.bgColor.closeRe=new RegExp(xo(Io.bgColor.close),"g");for(const e of Object.keys(Io.bgColor.ansi)){if(r.has(e))continue;i["bg"+e[0].toUpperCase()+e.slice(1)]={get(){const t=this.level;return function(){const r=Io.bgColor[n[t]][e].apply(null,arguments),i={open:r,close:Io.bgColor.close,closeRe:Io.bgColor.closeRe};return a.call(this,this._styles?this._styles.concat(i):[i],this._empty,e)}}};}const s=Object.defineProperties((()=>{}),i);function a(e,t,n){const r=function(){return l.apply(r,arguments)};r._styles=e,r._empty=t;const i=this;return Object.defineProperty(r,"level",{enumerable:!0,get:()=>i.level,set(e){i.level=e;}}),Object.defineProperty(r,"enabled",{enumerable:!0,get:()=>i.enabled,set(e){i.enabled=e;}}),r.hasGrey=this.hasGrey||"gray"===n||"grey"===n,r.__proto__=s,r}function l(){const e=arguments,t=e.length;let n=String(arguments[0]);if(0===t)return "";if(t>1)for(let r=1;r<t;r++)n+=" "+e[r];if(!this.enabled||this.level<=0||!n)return this._empty?"":n;const r=Io.dim.open;for(const e of this._styles.slice().reverse())n=e.open+n.replace(e.closeRe,e.open)+e.close,n=n.replace(/\r?\n/g,`${e.close}$&${e.open}`);return Io.dim.open=r,n}function c(e,t){if(!Array.isArray(t))return [].slice.call(arguments,1).join(" ");const n=[].slice.call(arguments,2),r=[t.raw[0]];for(let e=1;e<t.length;e++)r.push(String(n[e-1]).replace(/[{}\\]/g,"\\$&")),r.push(String(t.raw[e]));return fs$1(e,r.join(""))}Object.defineProperties(o.prototype,i),e.exports=o(),e.exports.supportsColor=t,e.exports.default=e.exports;})),hs$1=Object.defineProperty({commonDeprecatedHandler:(e,t,{descriptor:n})=>{const r=[`${ds$1.default.yellow("string"==typeof e?n.key(e):n.pair(e))} is deprecated`];return t&&r.push(`we now treat it as ${ds$1.default.blue("string"==typeof t?n.key(t):n.pair(t))}`),r.join("; ")+"."}},"__esModule",{value:!0}),gs$1=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Co.__exportStar(hs$1,t);})),ms$1=Object.defineProperty({commonInvalidHandler:(e,t,n)=>[`Invalid ${ds$1.default.red(n.descriptor.key(e))} value.`,`Expected ${ds$1.default.blue(n.schemas[e].expected(n))},`,`but received ${ds$1.default.red(n.descriptor.value(t))}.`].join(" ")},"__esModule",{value:!0}),ys$1=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Co.__exportStar(ms$1,t);})),Ds$1=[],Es$1=[],bs$1=Object.defineProperty({levenUnknownHandler:(e,t,{descriptor:n,logger:r,schemas:i})=>{const u=[`Ignored unknown option ${ds$1.default.yellow(n.pair({key:e,value:t}))}.`],o=Object.keys(i).sort().find((t=>function(e,t){if(e===t)return 0;var n=e;e.length>t.length&&(e=t,t=n);var r=e.length,i=t.length;if(0===r)return i;if(0===i)return r;for(;r>0&&e.charCodeAt(~-r)===t.charCodeAt(~-i);)r--,i--;if(0===r)return i;for(var u,o,s,a,l=0;l<r&&e.charCodeAt(l)===t.charCodeAt(l);)l++;if(i-=l,0==(r-=l))return i;for(var c=0,p=0;c<r;)Es$1[l+c]=e.charCodeAt(l+c),Ds$1[c]=++c;for(;p<i;)for(u=t.charCodeAt(l+p),s=p++,o=p,c=0;c<r;c++)a=u===Es$1[l+c]?s:s+1,s=Ds$1[c],o=Ds$1[c]=s>o?a>o?o+1:a:a>s?s+1:a;return o}(e,t)<3));o&&u.push(`Did you mean ${ds$1.default.blue(n.key(o))}?`),r.warn(u.join(" "));}},"__esModule",{value:!0}),Cs$1=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Co.__exportStar(bs$1,t);})),vs$1=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Co.__exportStar(gs$1,t),Co.__exportStar(ys$1,t),Co.__exportStar(Cs$1,t);}));const As$1=["default","expected","validate","deprecated","forward","redirect","overlap","preprocess","postprocess"];function Fs$1(e,t){const n=new e(t),r=Object.create(n);for(const e of As$1)e in t&&(r[e]=Ts$1(t[e],n,Ss$1.prototype[e].length));return r}var xs$1=Fs$1;class Ss$1{constructor(e){this.name=e.name;}static create(e){return Fs$1(this,e)}default(e){}expected(e){return "nothing"}validate(e,t){return !1}deprecated(e,t){return !1}forward(e,t){}redirect(e,t){}overlap(e,t,n){return e}preprocess(e,t){return e}postprocess(e,t){return e}}var ws$1=Ss$1;function Ts$1(e,t,n){return "function"==typeof e?(...r)=>e(...r.slice(0,n-1),t,...r.slice(n-1)):()=>e}var Bs=Object.defineProperty({createSchema:xs$1,Schema:ws$1},"__esModule",{value:!0});class ks$1 extends Bs.Schema{constructor(e){super(e),this._sourceName=e.sourceName;}expected(e){return e.schemas[this._sourceName].expected(e)}validate(e,t){return t.schemas[this._sourceName].validate(e,t)}redirect(e,t){return this._sourceName}}var Ns$1=ks$1,Ps$1=Object.defineProperty({AliasSchema:Ns$1},"__esModule",{value:!0});class Os$1 extends Bs.Schema{expected(){return "anything"}validate(){return !0}}var Is$1=Os$1,js=Object.defineProperty({AnySchema:Is$1},"__esModule",{value:!0});class Ls extends Bs.Schema{constructor(e){var{valueSchema:t,name:n=t.name}=e,r=Co.__rest(e,["valueSchema","name"]);super(Object.assign({},r,{name:n})),this._valueSchema=t;}expected(e){return `an array of ${this._valueSchema.expected(e)}`}validate(e,t){if(!Array.isArray(e))return !1;const n=[];for(const r of e){const e=t.normalizeValidateResult(this._valueSchema.validate(r,t),r);!0!==e&&n.push(e.value);}return 0===n.length||{value:n}}deprecated(e,t){const n=[];for(const r of e){const e=t.normalizeDeprecatedResult(this._valueSchema.deprecated(r,t),r);!1!==e&&n.push(...e.map((({value:e})=>({value:[e]}))));}return n}forward(e,t){const n=[];for(const r of e){const e=t.normalizeForwardResult(this._valueSchema.forward(r,t),r);n.push(...e.map(Ms));}return n}redirect(e,t){const n=[],r=[];for(const i of e){const e=t.normalizeRedirectResult(this._valueSchema.redirect(i,t),i);"remain"in e&&n.push(e.remain),r.push(...e.redirect.map(Ms));}return 0===n.length?{redirect:r}:{redirect:r,remain:n}}overlap(e,t){return e.concat(t)}}var _s$1=Ls;function Ms({from:e,to:t}){return {from:[e],to:t}}var Rs=Object.defineProperty({ArraySchema:_s$1},"__esModule",{value:!0});class $s extends Bs.Schema{expected(){return "true or false"}validate(e){return "boolean"==typeof e}}var Vs=$s,qs=Object.defineProperty({BooleanSchema:Vs},"__esModule",{value:!0});var Ws=function(e,t){const n=Object.create(null);for(const r of e){const e=r[t];if(n[e])throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);n[e]=r;}return n};var Us=function(e,t){const n=new Map;for(const r of e){const e=r[t];if(n.has(e))throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);n.set(e,r);}return n};var zs=function(){const e=Object.create(null);return t=>{const n=JSON.stringify(t);return !!e[n]||(e[n]=!0,!1)}};var Gs=function(e,t){const n=[],r=[];for(const i of e)t(i)?n.push(i):r.push(i);return [n,r]};var Hs=function(e){return e===Math.floor(e)};var Js=function(e,t){if(e===t)return 0;const n=typeof e,r=typeof t,i=["undefined","object","boolean","number","string"];return n!==r?i.indexOf(n)-i.indexOf(r):"string"!==n?Number(e)-Number(t):e.localeCompare(t)};var Xs=function(e){return void 0===e?{}:e};var Ys=function(e,t){return !0===e||(!1===e?{value:t}:e)};var Ks=function(e,t,n=!1){return !1!==e&&(!0===e?!!n||[{value:t}]:"value"in e?[e]:0!==e.length&&e)};function Qs(e,t){return "string"==typeof e||"key"in e?{from:t,to:e}:"from"in e?{from:e.from,to:e.to}:{from:t,to:e.to}}var Zs=Qs;function ea(e,t){return void 0===e?[]:Array.isArray(e)?e.map((e=>Qs(e,t))):[Qs(e,t)]}var ta=ea;var na=function(e,t){const n=ea("object"==typeof e&&"redirect"in e?e.redirect:e,t);return 0===n.length?{remain:t,redirect:n}:"object"==typeof e&&"remain"in e?{remain:e.remain,redirect:n}:{redirect:n}},ra=Object.defineProperty({recordFromArray:Ws,mapFromArray:Us,createAutoChecklist:zs,partition:Gs,isInt:Hs,comparePrimitive:Js,normalizeDefaultResult:Xs,normalizeValidateResult:Ys,normalizeDeprecatedResult:Ks,normalizeTransferResult:Zs,normalizeForwardResult:ta,normalizeRedirectResult:na},"__esModule",{value:!0});class ia extends Bs.Schema{constructor(e){super(e),this._choices=ra.mapFromArray(e.choices.map((e=>e&&"object"==typeof e?e:{value:e})),"value");}expected({descriptor:e}){const t=Array.from(this._choices.keys()).map((e=>this._choices.get(e))).filter((e=>!e.deprecated)).map((e=>e.value)).sort(ra.comparePrimitive).map(e.value),n=t.slice(0,-2),r=t.slice(-2);return n.concat(r.join(" or ")).join(", ")}validate(e){return this._choices.has(e)}deprecated(e){const t=this._choices.get(e);return !(!t||!t.deprecated)&&{value:e}}forward(e){const t=this._choices.get(e);return t?t.forward:void 0}redirect(e){const t=this._choices.get(e);return t?t.redirect:void 0}}var ua=ia,oa=Object.defineProperty({ChoiceSchema:ua},"__esModule",{value:!0});class sa extends Bs.Schema{expected(){return "a number"}validate(e,t){return "number"==typeof e}}var aa=sa,la=Object.defineProperty({NumberSchema:aa},"__esModule",{value:!0});class ca extends la.NumberSchema{expected(){return "an integer"}validate(e,t){return !0===t.normalizeValidateResult(super.validate(e,t),e)&&ra.isInt(e)}}var pa=ca,fa=Object.defineProperty({IntegerSchema:pa},"__esModule",{value:!0});class da extends Bs.Schema{expected(){return "a string"}validate(e){return "string"==typeof e}}var ha=da,ga=Object.defineProperty({StringSchema:ha},"__esModule",{value:!0}),ma=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Co.__exportStar(Ps$1,t),Co.__exportStar(js,t),Co.__exportStar(Rs,t),Co.__exportStar(qs,t),Co.__exportStar(oa,t),Co.__exportStar(fa,t),Co.__exportStar(la,t),Co.__exportStar(ga,t);})),ya=vo.apiDescriptor,Da=bs$1.levenUnknownHandler,Ea=ys$1.commonInvalidHandler,ba=hs$1.commonDeprecatedHandler,Ca=Object.defineProperty({defaultDescriptor:ya,defaultUnknownHandler:Da,defaultInvalidHandler:Ea,defaultDeprecatedHandler:ba},"__esModule",{value:!0});class va{constructor(e,t){const{logger:n=console,descriptor:r=Ca.defaultDescriptor,unknown:i=Ca.defaultUnknownHandler,invalid:u=Ca.defaultInvalidHandler,deprecated:o=Ca.defaultDeprecatedHandler}=t||{};this._utils={descriptor:r,logger:n||{warn:()=>{}},schemas:ra.recordFromArray(e,"name"),normalizeDefaultResult:ra.normalizeDefaultResult,normalizeDeprecatedResult:ra.normalizeDeprecatedResult,normalizeForwardResult:ra.normalizeForwardResult,normalizeRedirectResult:ra.normalizeRedirectResult,normalizeValidateResult:ra.normalizeValidateResult},this._unknownHandler=i,this._invalidHandler=u,this._deprecatedHandler=o,this.cleanHistory();}cleanHistory(){this._hasDeprecationWarned=ra.createAutoChecklist();}normalize(e){const t={},n=[e],r=()=>{for(;0!==n.length;){const e=n.shift(),r=this._applyNormalization(e,t);n.push(...r);}};r();for(const e of Object.keys(this._utils.schemas)){const r=this._utils.schemas[e];if(!(e in t)){const t=ra.normalizeDefaultResult(r.default(this._utils));"value"in t&&n.push({[e]:t.value});}}r();for(const e of Object.keys(this._utils.schemas)){const n=this._utils.schemas[e];e in t&&(t[e]=n.postprocess(t[e],this._utils));}return t}_applyNormalization(e,t){const n=[],[r,i]=ra.partition(Object.keys(e),(e=>e in this._utils.schemas));for(const i of r){const r=this._utils.schemas[i],u=r.preprocess(e[i],this._utils),o=ra.normalizeValidateResult(r.validate(u,this._utils),u);if(!0!==o){const{value:e}=o,t=this._invalidHandler(i,e,this._utils);throw "string"==typeof t?new Error(t):t}const s=({from:e,to:t})=>{n.push("string"==typeof t?{[t]:e}:{[t.key]:t.value});},a=({value:e,redirectTo:t})=>{const n=ra.normalizeDeprecatedResult(r.deprecated(e,this._utils),u,!0);if(!1!==n)if(!0===n)this._hasDeprecationWarned(i)||this._utils.logger.warn(this._deprecatedHandler(i,t,this._utils));else for(const{value:e}of n){const n={key:i,value:e};if(!this._hasDeprecationWarned(n)){const r="string"==typeof t?{key:t,value:e}:t;this._utils.logger.warn(this._deprecatedHandler(n,r,this._utils));}}};ra.normalizeForwardResult(r.forward(u,this._utils),u).forEach(s);const l=ra.normalizeRedirectResult(r.redirect(u,this._utils),u);if(l.redirect.forEach(s),"remain"in l){const e=l.remain;t[i]=i in t?r.overlap(t[i],e,this._utils):e,a({value:e});}for(const{from:e,to:t}of l.redirect)a({value:e,redirectTo:t});}for(const r of i){const i=e[r],u=this._unknownHandler(r,i,this._utils);if(u)for(const e of Object.keys(u)){const r={[e]:u[e]};e in this._utils.schemas?n.push(r):Object.assign(t,r);}}return n}}var Aa=va,Fa=Object.defineProperty({normalize:(e,t,n)=>new va(t,n).normalize(e),Normalizer:Aa},"__esModule",{value:!0}),xa=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Co.__exportStar(Ao,t),Co.__exportStar(vs$1,t),Co.__exportStar(ma,t),Co.__exportStar(Fa,t),Co.__exportStar(Bs,t);}));const Sa=[],wa=[],Ta=(e,t)=>{if(e===t)return 0;const n=e;e.length>t.length&&(e=t,t=n);let r=e.length,i=t.length;for(;r>0&&e.charCodeAt(~-r)===t.charCodeAt(~-i);)r--,i--;let u,o,s,a,l=0;for(;l<r&&e.charCodeAt(l)===t.charCodeAt(l);)l++;if(r-=l,i-=l,0===r)return i;let c=0,p=0;for(;c<r;)wa[c]=e.charCodeAt(l+c),Sa[c]=++c;for(;p<i;)for(u=t.charCodeAt(l+p),s=p++,o=p,c=0;c<r;c++)a=u===wa[c]?s:s+1,s=Sa[c],o=Sa[c]=s>o?a>o?o+1:a:a>s?s+1:a;return o};var Ba=Ta,ka=Ta;Ba.default=ka;var Na={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]};const Pa={};for(const e of Object.keys(Na))Pa[Na[e]]=e;const Oa={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};var Ia=Oa;for(const e of Object.keys(Oa)){if(!("channels"in Oa[e]))throw new Error("missing channels property: "+e);if(!("labels"in Oa[e]))throw new Error("missing channel labels property: "+e);if(Oa[e].labels.length!==Oa[e].channels)throw new Error("channel and label counts mismatch: "+e);const{channels:t,labels:n}=Oa[e];delete Oa[e].channels,delete Oa[e].labels,Object.defineProperty(Oa[e],"channels",{value:t}),Object.defineProperty(Oa[e],"labels",{value:n});}function ja(e){const t=function(){const e={},t=Object.keys(Ia);for(let n=t.length,r=0;r<n;r++)e[t[r]]={distance:-1,parent:null};return e}(),n=[e];for(t[e].distance=0;n.length;){const e=n.pop(),r=Object.keys(Ia[e]);for(let i=r.length,u=0;u<i;u++){const i=r[u],o=t[i];-1===o.distance&&(o.distance=t[e].distance+1,o.parent=e,n.unshift(i));}}return t}function La(e,t){return function(n){return t(e(n))}}function _a(e,t){const n=[t[e].parent,e];let r=Ia[t[e].parent][e],i=t[e].parent;for(;t[i].parent;)n.unshift(t[i].parent),r=La(Ia[t[i].parent][i],r),i=t[i].parent;return r.conversion=n,r}Oa.rgb.hsl=function(e){const t=e[0]/255,n=e[1]/255,r=e[2]/255,i=Math.min(t,n,r),u=Math.max(t,n,r),o=u-i;let s,a;u===i?s=0:t===u?s=(n-r)/o:n===u?s=2+(r-t)/o:r===u&&(s=4+(t-n)/o),s=Math.min(60*s,360),s<0&&(s+=360);const l=(i+u)/2;return a=u===i?0:l<=.5?o/(u+i):o/(2-u-i),[s,100*a,100*l]},Oa.rgb.hsv=function(e){let t,n,r,i,u;const o=e[0]/255,s=e[1]/255,a=e[2]/255,l=Math.max(o,s,a),c=l-Math.min(o,s,a),p=function(e){return (l-e)/6/c+.5};return 0===c?(i=0,u=0):(u=c/l,t=p(o),n=p(s),r=p(a),o===l?i=r-n:s===l?i=1/3+t-r:a===l&&(i=2/3+n-t),i<0?i+=1:i>1&&(i-=1)),[360*i,100*u,100*l]},Oa.rgb.hwb=function(e){const t=e[0],n=e[1];let r=e[2];const i=Oa.rgb.hsl(e)[0],u=1/255*Math.min(t,Math.min(n,r));return r=1-1/255*Math.max(t,Math.max(n,r)),[i,100*u,100*r]},Oa.rgb.cmyk=function(e){const t=e[0]/255,n=e[1]/255,r=e[2]/255,i=Math.min(1-t,1-n,1-r);return [100*((1-t-i)/(1-i)||0),100*((1-n-i)/(1-i)||0),100*((1-r-i)/(1-i)||0),100*i]},Oa.rgb.keyword=function(e){const t=Pa[e];if(t)return t;let n,r=1/0;for(const t of Object.keys(Na)){const o=(u=Na[t],((i=e)[0]-u[0])**2+(i[1]-u[1])**2+(i[2]-u[2])**2);o<r&&(r=o,n=t);}var i,u;return n},Oa.keyword.rgb=function(e){return Na[e]},Oa.rgb.xyz=function(e){let t=e[0]/255,n=e[1]/255,r=e[2]/255;t=t>.04045?((t+.055)/1.055)**2.4:t/12.92,n=n>.04045?((n+.055)/1.055)**2.4:n/12.92,r=r>.04045?((r+.055)/1.055)**2.4:r/12.92;return [100*(.4124*t+.3576*n+.1805*r),100*(.2126*t+.7152*n+.0722*r),100*(.0193*t+.1192*n+.9505*r)]},Oa.rgb.lab=function(e){const t=Oa.rgb.xyz(e);let n=t[0],r=t[1],i=t[2];n/=95.047,r/=100,i/=108.883,n=n>.008856?n**(1/3):7.787*n+16/116,r=r>.008856?r**(1/3):7.787*r+16/116,i=i>.008856?i**(1/3):7.787*i+16/116;return [116*r-16,500*(n-r),200*(r-i)]},Oa.hsl.rgb=function(e){const t=e[0]/360,n=e[1]/100,r=e[2]/100;let i,u,o;if(0===n)return o=255*r,[o,o,o];i=r<.5?r*(1+n):r+n-r*n;const s=2*r-i,a=[0,0,0];for(let e=0;e<3;e++)u=t+1/3*-(e-1),u<0&&u++,u>1&&u--,o=6*u<1?s+6*(i-s)*u:2*u<1?i:3*u<2?s+(i-s)*(2/3-u)*6:s,a[e]=255*o;return a},Oa.hsl.hsv=function(e){const t=e[0];let n=e[1]/100,r=e[2]/100,i=n;const u=Math.max(r,.01);r*=2,n*=r<=1?r:2-r,i*=u<=1?u:2-u;return [t,100*(0===r?2*i/(u+i):2*n/(r+n)),100*((r+n)/2)]},Oa.hsv.rgb=function(e){const t=e[0]/60,n=e[1]/100;let r=e[2]/100;const i=Math.floor(t)%6,u=t-Math.floor(t),o=255*r*(1-n),s=255*r*(1-n*u),a=255*r*(1-n*(1-u));switch(r*=255,i){case 0:return [r,a,o];case 1:return [s,r,o];case 2:return [o,r,a];case 3:return [o,s,r];case 4:return [a,o,r];case 5:return [r,o,s]}},Oa.hsv.hsl=function(e){const t=e[0],n=e[1]/100,r=e[2]/100,i=Math.max(r,.01);let u,o;o=(2-n)*r;const s=(2-n)*i;return u=n*i,u/=s<=1?s:2-s,u=u||0,o/=2,[t,100*u,100*o]},Oa.hwb.rgb=function(e){const t=e[0]/360;let n=e[1]/100,r=e[2]/100;const i=n+r;let u;i>1&&(n/=i,r/=i);const o=Math.floor(6*t),s=1-r;u=6*t-o,0!=(1&o)&&(u=1-u);const a=n+u*(s-n);let l,c,p;switch(o){default:case 6:case 0:l=s,c=a,p=n;break;case 1:l=a,c=s,p=n;break;case 2:l=n,c=s,p=a;break;case 3:l=n,c=a,p=s;break;case 4:l=a,c=n,p=s;break;case 5:l=s,c=n,p=a;}return [255*l,255*c,255*p]},Oa.cmyk.rgb=function(e){const t=e[0]/100,n=e[1]/100,r=e[2]/100,i=e[3]/100;return [255*(1-Math.min(1,t*(1-i)+i)),255*(1-Math.min(1,n*(1-i)+i)),255*(1-Math.min(1,r*(1-i)+i))]},Oa.xyz.rgb=function(e){const t=e[0]/100,n=e[1]/100,r=e[2]/100;let i,u,o;return i=3.2406*t+-1.5372*n+-.4986*r,u=-.9689*t+1.8758*n+.0415*r,o=.0557*t+-.204*n+1.057*r,i=i>.0031308?1.055*i**(1/2.4)-.055:12.92*i,u=u>.0031308?1.055*u**(1/2.4)-.055:12.92*u,o=o>.0031308?1.055*o**(1/2.4)-.055:12.92*o,i=Math.min(Math.max(0,i),1),u=Math.min(Math.max(0,u),1),o=Math.min(Math.max(0,o),1),[255*i,255*u,255*o]},Oa.xyz.lab=function(e){let t=e[0],n=e[1],r=e[2];t/=95.047,n/=100,r/=108.883,t=t>.008856?t**(1/3):7.787*t+16/116,n=n>.008856?n**(1/3):7.787*n+16/116,r=r>.008856?r**(1/3):7.787*r+16/116;return [116*n-16,500*(t-n),200*(n-r)]},Oa.lab.xyz=function(e){let t,n,r;n=(e[0]+16)/116,t=e[1]/500+n,r=n-e[2]/200;const i=n**3,u=t**3,o=r**3;return n=i>.008856?i:(n-16/116)/7.787,t=u>.008856?u:(t-16/116)/7.787,r=o>.008856?o:(r-16/116)/7.787,t*=95.047,n*=100,r*=108.883,[t,n,r]},Oa.lab.lch=function(e){const t=e[0],n=e[1],r=e[2];let i;i=360*Math.atan2(r,n)/2/Math.PI,i<0&&(i+=360);return [t,Math.sqrt(n*n+r*r),i]},Oa.lch.lab=function(e){const t=e[0],n=e[1],r=e[2]/360*2*Math.PI;return [t,n*Math.cos(r),n*Math.sin(r)]},Oa.rgb.ansi16=function(e,t=null){const[n,r,i]=e;let u=null===t?Oa.rgb.hsv(e)[2]:t;if(u=Math.round(u/50),0===u)return 30;let o=30+(Math.round(i/255)<<2|Math.round(r/255)<<1|Math.round(n/255));return 2===u&&(o+=60),o},Oa.hsv.ansi16=function(e){return Oa.rgb.ansi16(Oa.hsv.rgb(e),e[2])},Oa.rgb.ansi256=function(e){const t=e[0],n=e[1],r=e[2];if(t===n&&n===r)return t<8?16:t>248?231:Math.round((t-8)/247*24)+232;return 16+36*Math.round(t/255*5)+6*Math.round(n/255*5)+Math.round(r/255*5)},Oa.ansi16.rgb=function(e){let t=e%10;if(0===t||7===t)return e>50&&(t+=3.5),t=t/10.5*255,[t,t,t];const n=.5*(1+~~(e>50));return [(1&t)*n*255,(t>>1&1)*n*255,(t>>2&1)*n*255]},Oa.ansi256.rgb=function(e){if(e>=232){const t=10*(e-232)+8;return [t,t,t]}let t;e-=16;return [Math.floor(e/36)/5*255,Math.floor((t=e%36)/6)/5*255,t%6/5*255]},Oa.rgb.hex=function(e){const t=(((255&Math.round(e[0]))<<16)+((255&Math.round(e[1]))<<8)+(255&Math.round(e[2]))).toString(16).toUpperCase();return "000000".substring(t.length)+t},Oa.hex.rgb=function(e){const t=e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!t)return [0,0,0];let n=t[0];3===t[0].length&&(n=n.split("").map((e=>e+e)).join(""));const r=parseInt(n,16);return [r>>16&255,r>>8&255,255&r]},Oa.rgb.hcg=function(e){const t=e[0]/255,n=e[1]/255,r=e[2]/255,i=Math.max(Math.max(t,n),r),u=Math.min(Math.min(t,n),r),o=i-u;let s,a;return s=o<1?u/(1-o):0,a=o<=0?0:i===t?(n-r)/o%6:i===n?2+(r-t)/o:4+(t-n)/o,a/=6,a%=1,[360*a,100*o,100*s]},Oa.hsl.hcg=function(e){const t=e[1]/100,n=e[2]/100,r=n<.5?2*t*n:2*t*(1-n);let i=0;return r<1&&(i=(n-.5*r)/(1-r)),[e[0],100*r,100*i]},Oa.hsv.hcg=function(e){const t=e[1]/100,n=e[2]/100,r=t*n;let i=0;return r<1&&(i=(n-r)/(1-r)),[e[0],100*r,100*i]},Oa.hcg.rgb=function(e){const t=e[0]/360,n=e[1]/100,r=e[2]/100;if(0===n)return [255*r,255*r,255*r];const i=[0,0,0],u=t%1*6,o=u%1,s=1-o;let a=0;switch(Math.floor(u)){case 0:i[0]=1,i[1]=o,i[2]=0;break;case 1:i[0]=s,i[1]=1,i[2]=0;break;case 2:i[0]=0,i[1]=1,i[2]=o;break;case 3:i[0]=0,i[1]=s,i[2]=1;break;case 4:i[0]=o,i[1]=0,i[2]=1;break;default:i[0]=1,i[1]=0,i[2]=s;}return a=(1-n)*r,[255*(n*i[0]+a),255*(n*i[1]+a),255*(n*i[2]+a)]},Oa.hcg.hsv=function(e){const t=e[1]/100,n=t+e[2]/100*(1-t);let r=0;return n>0&&(r=t/n),[e[0],100*r,100*n]},Oa.hcg.hsl=function(e){const t=e[1]/100,n=e[2]/100*(1-t)+.5*t;let r=0;return n>0&&n<.5?r=t/(2*n):n>=.5&&n<1&&(r=t/(2*(1-n))),[e[0],100*r,100*n]},Oa.hcg.hwb=function(e){const t=e[1]/100,n=t+e[2]/100*(1-t);return [e[0],100*(n-t),100*(1-n)]},Oa.hwb.hcg=function(e){const t=e[1]/100,n=1-e[2]/100,r=n-t;let i=0;return r<1&&(i=(n-r)/(1-r)),[e[0],100*r,100*i]},Oa.apple.rgb=function(e){return [e[0]/65535*255,e[1]/65535*255,e[2]/65535*255]},Oa.rgb.apple=function(e){return [e[0]/255*65535,e[1]/255*65535,e[2]/255*65535]},Oa.gray.rgb=function(e){return [e[0]/100*255,e[0]/100*255,e[0]/100*255]},Oa.gray.hsl=function(e){return [0,0,e[0]]},Oa.gray.hsv=Oa.gray.hsl,Oa.gray.hwb=function(e){return [0,100,e[0]]},Oa.gray.cmyk=function(e){return [0,0,0,e[0]]},Oa.gray.lab=function(e){return [e[0],0,0]},Oa.gray.hex=function(e){const t=255&Math.round(e[0]/100*255),n=((t<<16)+(t<<8)+t).toString(16).toUpperCase();return "000000".substring(n.length)+n},Oa.rgb.gray=function(e){return [(e[0]+e[1]+e[2])/3/255*100]};const Ma={};Object.keys(Ia).forEach((e=>{Ma[e]={},Object.defineProperty(Ma[e],"channels",{value:Ia[e].channels}),Object.defineProperty(Ma[e],"labels",{value:Ia[e].labels});const t=function(e){const t=ja(e),n={},r=Object.keys(t);for(let e=r.length,i=0;i<e;i++){const e=r[i];null!==t[e].parent&&(n[e]=_a(e,t));}return n}(e);Object.keys(t).forEach((n=>{const r=t[n];Ma[e][n]=function(e){const t=function(...t){const n=t[0];if(null==n)return n;n.length>1&&(t=n);const r=e(t);if("object"==typeof r)for(let e=r.length,t=0;t<e;t++)r[t]=Math.round(r[t]);return r};return "conversion"in e&&(t.conversion=e.conversion),t}(r),Ma[e][n].raw=function(e){const t=function(...t){const n=t[0];return null==n?n:(n.length>1&&(t=n),e(t))};return "conversion"in e&&(t.conversion=e.conversion),t}(r);}));}));var Ra=Ma,$a=i$2((function(e){const t=(e,t)=>(...n)=>`\x1b[${e(...n)+t}m`,n=(e,t)=>(...n)=>{const r=e(...n);return `\x1b[${38+t};5;${r}m`},r=(e,t)=>(...n)=>{const r=e(...n);return `\x1b[${38+t};2;${r[0]};${r[1]};${r[2]}m`},i=e=>e,u=(e,t,n)=>[e,t,n],o=(e,t,n)=>{Object.defineProperty(e,t,{get:()=>{const r=n();return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0}),r},enumerable:!0,configurable:!0});};let s;const a=(e,t,n,r)=>{void 0===s&&(s=Ra);const i=r?10:0,u={};for(const[r,o]of Object.entries(s)){const s="ansi16"===r?"ansi":r;r===t?u[s]=e(n,i):"object"==typeof o&&(u[s]=e(o[t],i));}return u};Object.defineProperty(e,"exports",{enumerable:!0,get:function(){const e=new Map,s={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};s.color.gray=s.color.blackBright,s.bgColor.bgGray=s.bgColor.bgBlackBright,s.color.grey=s.color.blackBright,s.bgColor.bgGrey=s.bgColor.bgBlackBright;for(const[t,n]of Object.entries(s)){for(const[t,r]of Object.entries(n))s[t]={open:`\x1b[${r[0]}m`,close:`\x1b[${r[1]}m`},n[t]=s[t],e.set(r[0],r[1]);Object.defineProperty(s,t,{value:n,enumerable:!1});}return Object.defineProperty(s,"codes",{value:e,enumerable:!1}),s.color.close="\x1b[39m",s.bgColor.close="\x1b[49m",o(s.color,"ansi",(()=>a(t,"ansi16",i,!1))),o(s.color,"ansi256",(()=>a(n,"ansi256",i,!1))),o(s.color,"ansi16m",(()=>a(r,"rgb",u,!1))),o(s.bgColor,"ansi",(()=>a(t,"ansi16",i,!0))),o(s.bgColor,"ansi256",(()=>a(n,"ansi256",i,!0))),o(s.bgColor,"ansi16m",(()=>a(r,"rgb",u,!0))),s}});}));function Va(){return !1}function qa(){throw new Error("tty.ReadStream is not implemented")}function Wa(){throw new Error("tty.ReadStream is not implemented")}var Ua={isatty:Va,ReadStream:qa,WriteStream:Wa},za=(e,t=Cr$1.argv)=>{const n=e.startsWith("-")?"":1===e.length?"-":"--",r=t.indexOf(n+e),i=t.indexOf("--");return -1!==r&&(-1===i||r<i)},Ga=r$2(Object.freeze({__proto__:null,isatty:Va,ReadStream:qa,WriteStream:Wa,default:Ua}));const{env:Ha}=Cr$1;let Ja;function Xa(e){return 0!==e&&{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}function Ya(e,t){if(0===Ja)return 0;if(za("color=16m")||za("color=full")||za("color=truecolor"))return 3;if(za("color=256"))return 2;if(e&&!t&&void 0===Ja)return 0;const n=Ja||0;if("dumb"===Ha.TERM)return n;if("CI"in Ha)return ["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some((e=>e in Ha))||"codeship"===Ha.CI_NAME?1:n;if("TEAMCITY_VERSION"in Ha)return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Ha.TEAMCITY_VERSION)?1:0;if("truecolor"===Ha.COLORTERM)return 3;if("TERM_PROGRAM"in Ha){const e=parseInt((Ha.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(Ha.TERM_PROGRAM){case"iTerm.app":return e>=3?3:2;case"Apple_Terminal":return 2}}return /-256(color)?$/i.test(Ha.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Ha.TERM)||"COLORTERM"in Ha?1:n}za("no-color")||za("no-colors")||za("color=false")||za("color=never")?Ja=0:(za("color")||za("colors")||za("color=true")||za("color=always"))&&(Ja=1),"FORCE_COLOR"in Ha&&(Ja="true"===Ha.FORCE_COLOR?1:"false"===Ha.FORCE_COLOR?0:0===Ha.FORCE_COLOR.length?1:Math.min(parseInt(Ha.FORCE_COLOR,10),3));var Ka={supportsColor:function(e){return Xa(Ya(e,e&&e.isTTY))},stdout:Xa(Ya(!0,Ga.isatty(1))),stderr:Xa(Ya(!0,Ga.isatty(2)))};var Qa={stringReplaceAll:(e,t,n)=>{let r=e.indexOf(t);if(-1===r)return e;const i=t.length;let u=0,o="";do{o+=e.substr(u,r-u)+t+n,u=r+i,r=e.indexOf(t,u);}while(-1!==r);return o+=e.substr(u),o},stringEncaseCRLFWithFirstIndex:(e,t,n,r)=>{let i=0,u="";do{const o="\r"===e[r-1];u+=e.substr(i,(o?r-1:r)-i)+t+(o?"\r\n":"\n")+n,i=r+1,r=e.indexOf("\n",i);}while(-1!==r);return u+=e.substr(i),u}};const Za=/(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,el=/(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,tl=/^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,nl=/\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi,rl=new Map([["n","\n"],["r","\r"],["t","\t"],["b","\b"],["f","\f"],["v","\v"],["0","\0"],["\\","\\"],["e","\x1b"],["a","\x07"]]);function il(e){const t="u"===e[0],n="{"===e[1];return t&&!n&&5===e.length||"x"===e[0]&&3===e.length?String.fromCharCode(parseInt(e.slice(1),16)):t&&n?String.fromCodePoint(parseInt(e.slice(2,-1),16)):rl.get(e)||e}function ul(e,t){const n=[],r=t.trim().split(/\s*,\s*/g);let i;for(const t of r){const r=Number(t);if(Number.isNaN(r)){if(!(i=t.match(tl)))throw new Error(`Invalid Chalk template style argument: ${t} (in style '${e}')`);n.push(i[2].replace(nl,((e,t,n)=>t?il(t):n)));}else n.push(r);}return n}function ol(e){el.lastIndex=0;const t=[];let n;for(;null!==(n=el.exec(e));){const e=n[1];if(n[2]){const r=ul(e,n[2]);t.push([e].concat(r));}else t.push([e]);}return t}function sl(e,t){const n={};for(const e of t)for(const t of e.styles)n[t[0]]=e.inverse?null:t.slice(1);let r=e;for(const[e,t]of Object.entries(n))if(Array.isArray(t)){if(!(e in r))throw new Error(`Unknown Chalk style: ${e}`);r=t.length>0?r[e](...t):r[e];}return r}var al=(e,t)=>{const n=[],r=[];let i=[];if(t.replace(Za,((t,u,o,s,a,l)=>{if(u)i.push(il(u));else if(s){const t=i.join("");i=[],r.push(0===n.length?t:sl(e,n)(t)),n.push({inverse:o,styles:ol(s)});}else if(a){if(0===n.length)throw new Error("Found extraneous } in Chalk template literal");r.push(sl(e,n)(i.join(""))),i=[],n.pop();}else i.push(l);})),r.push(i.join("")),n.length>0){const e=`Chalk template literal is missing ${n.length} closing bracket${1===n.length?"":"s"} (\`}\`)`;throw new Error(e)}return r.join("")};const{stdout:ll,stderr:cl}=Ka,{stringReplaceAll:pl,stringEncaseCRLFWithFirstIndex:fl}=Qa,{isArray:dl}=Array,hl=["ansi","ansi","ansi256","ansi16m"],gl=Object.create(null);class ml{constructor(e){return yl(e)}}const yl=e=>{const t={};return ((e,t={})=>{if(t.level&&!(Number.isInteger(t.level)&&t.level>=0&&t.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const n=ll?ll.level:0;e.level=void 0===t.level?n:t.level;})(t,e),t.template=(...e)=>xl(t.template,...e),Object.setPrototypeOf(t,Dl.prototype),Object.setPrototypeOf(t.template,t),t.template.constructor=()=>{throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.")},t.template.Instance=ml,t.template};function Dl(e){return yl(e)}for(const[e,t]of Object.entries($a))gl[e]={get(){const n=vl(this,Cl(t.open,t.close,this._styler),this._isEmpty);return Object.defineProperty(this,e,{value:n}),n}};gl.visible={get(){const e=vl(this,this._styler,!0);return Object.defineProperty(this,"visible",{value:e}),e}};const El=["rgb","hex","keyword","hsl","hsv","hwb","ansi","ansi256"];for(const e of El)gl[e]={get(){const{level:t}=this;return function(...n){const r=Cl($a.color[hl[t]][e](...n),$a.color.close,this._styler);return vl(this,r,this._isEmpty)}}};for(const e of El){gl["bg"+e[0].toUpperCase()+e.slice(1)]={get(){const{level:t}=this;return function(...n){const r=Cl($a.bgColor[hl[t]][e](...n),$a.bgColor.close,this._styler);return vl(this,r,this._isEmpty)}}};}const bl=Object.defineProperties((()=>{}),Object.assign(Object.assign({},gl),{},{level:{enumerable:!0,get(){return this._generator.level},set(e){this._generator.level=e;}}})),Cl=(e,t,n)=>{let r,i;return void 0===n?(r=e,i=t):(r=n.openAll+e,i=t+n.closeAll),{open:e,close:t,openAll:r,closeAll:i,parent:n}},vl=(e,t,n)=>{const r=(...e)=>dl(e[0])&&dl(e[0].raw)?Al(r,xl(r,...e)):Al(r,1===e.length?""+e[0]:e.join(" "));return Object.setPrototypeOf(r,bl),r._generator=e,r._styler=t,r._isEmpty=n,r},Al=(e,t)=>{if(e.level<=0||!t)return e._isEmpty?"":t;let n=e._styler;if(void 0===n)return t;const{openAll:r,closeAll:i}=n;if(-1!==t.indexOf("\x1b"))for(;void 0!==n;)t=pl(t,n.close,n.open),n=n.parent;const u=t.indexOf("\n");return -1!==u&&(t=fl(t,i,r,u)),r+t+i};let Fl;const xl=(e,...t)=>{const[n]=t;if(!dl(n)||!dl(n.raw))return t.join(" ");const r=t.slice(1),i=[n.raw[0]];for(let e=1;e<n.length;e++)i.push(String(r[e-1]).replace(/[{}\\]/g,"\\$&"),String(n.raw[e]));return void 0===Fl&&(Fl=al),Fl(e,i.join(""))};Object.defineProperties(Dl.prototype,gl);const Sl=Dl();Sl.supportsColor=ll,Sl.stderr=Dl({level:cl?cl.level:0}),Sl.stderr.supportsColor=cl;var wl=Sl;const Tl=["_"],Bl={key:e=>1===e.length?`-${e}`:`--${e}`,value:e=>xa.apiDescriptor.value(e),pair:({key:e,value:t})=>!1===t?`--no-${e}`:!0===t?Bl.key(e):""===t?`${Bl.key(e)} without an argument`:`${Bl.key(e)}=${t}`};class kl extends xa.ChoiceSchema{constructor({name:e,flags:t}){super({name:e,choices:t}),this._flags=[...t].sort();}preprocess(e,t){if("string"==typeof e&&e.length>0&&!this._flags.includes(e)){const n=this._flags.find((t=>Ba(t,e)<3));if(n)return t.logger.warn([`Unknown flag ${wl.yellow(t.descriptor.value(e))},`,`did you mean ${wl.blue(t.descriptor.value(n))}?`].join(" ")),n}return e}expected(){return "a flag"}}let Nl;function Pl(t,n,{logger:r,isCLI:i=!1,passThrough:u=!1}={}){const o=u?Array.isArray(u)?(e,t)=>u.includes(e)?{[e]:t}:void 0:(e,t)=>({[e]:t}):(t,n,r)=>{const i=e$2(r.schemas,Tl);return xa.levenUnknownHandler(t,n,Object.assign(Object.assign({},r),{},{schemas:i}))},s=i?Bl:xa.apiDescriptor,a=function(e,{isCLI:t}){const n=[];t&&n.push(xa.AnySchema.create({name:"_"}));for(const r of e)n.push(Ol(r,{isCLI:t,optionInfos:e})),r.alias&&t&&n.push(xa.AliasSchema.create({name:r.alias,sourceName:r.name}));return n}(n,{isCLI:i}),l=new xa.Normalizer(a,{logger:r,unknown:o,descriptor:s}),c=!1!==r;c&&Nl&&(l._hasDeprecationWarned=Nl);const p=l.normalize(t);return c&&(Nl=l._hasDeprecationWarned),p}function Ol(e,{isCLI:t,optionInfos:n}){let r;const i={name:e.name},u={};switch(e.type){case"int":r=xa.IntegerSchema,t&&(i.preprocess=e=>Number(e));break;case"string":r=xa.StringSchema;break;case"choice":r=xa.ChoiceSchema,i.choices=e.choices.map((t=>"object"==typeof t&&t.redirect?Object.assign(Object.assign({},t),{},{redirect:{to:{key:e.name,value:t.redirect}}}):t));break;case"boolean":r=xa.BooleanSchema;break;case"flag":r=kl,i.flags=n.flatMap((e=>[e.alias,e.description&&e.name,e.oppositeDescription&&`no-${e.name}`].filter(Boolean)));break;case"path":r=xa.StringSchema;break;default:throw new Error(`Unexpected type ${e.type}`)}if(e.exception?i.validate=(t,n,r)=>e.exception(t)||n.validate(t,r):i.validate=(e,t,n)=>void 0===e||t.validate(e,n),e.redirect&&(u.redirect=t=>t?{to:{key:e.redirect.option,value:e.redirect.value}}:void 0),e.deprecated&&(u.deprecated=!0),t&&!e.array){const e=i.preprocess||(e=>e);i.preprocess=(t,n,r)=>n.preprocess(e(Array.isArray(t)?Sn$1(t):t),r);}return e.array?xa.ArraySchema.create(Object.assign(Object.assign(Object.assign({},t?{preprocess:e=>Array.isArray(e)?e:[e]}:{}),u),{},{valueSchema:r.create(i)})):r.create(Object.assign(Object.assign({},i),u))}var Il={normalizeApiOptions:function(e,t,n){return Pl(e,t,n)},normalizeCliOptions:function(e,t,n){return Pl(e,t,Object.assign({isCLI:!0},n))}};const{isNonEmptyArray:jl}=fi$1;function Ll(e,t){const{ignoreDecorators:n}=t||{};if(!n){const t=e.declaration&&e.declaration.decorators||e.decorators;if(jl(t))return Ll(t[0])}return e.range?e.range[0]:e.start}function _l(e){return e.range?e.range[1]:e.end}function Ml(e,t){return Ll(e)===Ll(t)}var Rl={locStart:Ll,locEnd:_l,hasSameLocStart:Ml,hasSameLoc:function(e,t){return Ml(e,t)&&function(e,t){return _l(e)===_l(t)}(e,t)}},$l=Object.defineProperty({default:/((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g,matchToToken:function(e){var t={type:"invalid",value:e[0],closed:void 0};return e[1]?(t.type="string",t.closed=!(!e[3]&&!e[4])):e[5]?t.type="comment":e[6]?(t.type="comment",t.closed=!!e[7]):e[8]?t.type="regex":e[9]?t.type="number":e[10]?t.type="name":e[11]?t.type="punctuator":e[12]&&(t.type="whitespace"),t}},"__esModule",{value:!0}),Vl=Kl,ql=Ql,Wl=function(e){let t=!0;for(let n=0;n<e.length;n++){let r=e.charCodeAt(n);if(55296==(64512&r)&&n+1<e.length){const t=e.charCodeAt(++n);56320==(64512&t)&&(r=65536+((1023&r)<<10)+(1023&t));}if(t){if(t=!1,!Kl(r))return !1}else if(!Ql(r))return !1}return !t};let Ul="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",zl="\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";const Gl=new RegExp("["+Ul+"]"),Hl=new RegExp("["+Ul+zl+"]");Ul=zl=null;const Jl=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938],Xl=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];function Yl(e,t){let n=65536;for(let r=0,i=t.length;r<i;r+=2){if(n+=t[r],n>e)return !1;if(n+=t[r+1],n>=e)return !0}return !1}function Kl(e){return e<65?36===e:e<=90||(e<97?95===e:e<=122||(e<=65535?e>=170&&Gl.test(String.fromCharCode(e)):Yl(e,Jl)))}function Ql(e){return e<48?36===e:e<58||!(e<65)&&(e<=90||(e<97?95===e:e<=122||(e<=65535?e>=170&&Hl.test(String.fromCharCode(e)):Yl(e,Jl)||Yl(e,Xl))))}var Zl=Object.defineProperty({isIdentifierStart:Vl,isIdentifierChar:ql,isIdentifierName:Wl},"__esModule",{value:!0}),ec=cc,tc=pc,nc=fc,rc=function(e,t){return pc(e,t)||fc(e)},ic=function(e){return sc.has(e)};const uc=["implements","interface","let","package","private","protected","public","static","yield"],oc=["eval","arguments"],sc=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),ac=new Set(uc),lc=new Set(oc);function cc(e,t){return t&&"await"===e||"enum"===e}function pc(e,t){return cc(e,t)||ac.has(e)}function fc(e){return lc.has(e)}var dc=Object.defineProperty({isReservedWord:ec,isStrictReservedWord:tc,isStrictBindOnlyReservedWord:nc,isStrictBindReservedWord:rc,isKeyword:ic},"__esModule",{value:!0}),hc=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"isIdentifierName",{enumerable:!0,get:function(){return Zl.isIdentifierName}}),Object.defineProperty(t,"isIdentifierChar",{enumerable:!0,get:function(){return Zl.isIdentifierChar}}),Object.defineProperty(t,"isIdentifierStart",{enumerable:!0,get:function(){return Zl.isIdentifierStart}}),Object.defineProperty(t,"isReservedWord",{enumerable:!0,get:function(){return dc.isReservedWord}}),Object.defineProperty(t,"isStrictBindOnlyReservedWord",{enumerable:!0,get:function(){return dc.isStrictBindOnlyReservedWord}}),Object.defineProperty(t,"isStrictBindReservedWord",{enumerable:!0,get:function(){return dc.isStrictBindReservedWord}}),Object.defineProperty(t,"isStrictReservedWord",{enumerable:!0,get:function(){return dc.isStrictReservedWord}}),Object.defineProperty(t,"isKeyword",{enumerable:!0,get:function(){return dc.isKeyword}});})),gc=/[|\\{}()[\]^$+*?.]/g,mc=function(e){if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(gc,"\\$&")},yc={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},Dc=i$2((function(e){var t={};for(var n in yc)yc.hasOwnProperty(n)&&(t[yc[n]]=n);var r=e.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var i in r)if(r.hasOwnProperty(i)){if(!("channels"in r[i]))throw new Error("missing channels property: "+i);if(!("labels"in r[i]))throw new Error("missing channel labels property: "+i);if(r[i].labels.length!==r[i].channels)throw new Error("channel and label counts mismatch: "+i);var u=r[i].channels,o=r[i].labels;delete r[i].channels,delete r[i].labels,Object.defineProperty(r[i],"channels",{value:u}),Object.defineProperty(r[i],"labels",{value:o});}r.rgb.hsl=function(e){var t,n,r=e[0]/255,i=e[1]/255,u=e[2]/255,o=Math.min(r,i,u),s=Math.max(r,i,u),a=s-o;return s===o?t=0:r===s?t=(i-u)/a:i===s?t=2+(u-r)/a:u===s&&(t=4+(r-i)/a),(t=Math.min(60*t,360))<0&&(t+=360),n=(o+s)/2,[t,100*(s===o?0:n<=.5?a/(s+o):a/(2-s-o)),100*n]},r.rgb.hsv=function(e){var t,n,r,i,u,o=e[0]/255,s=e[1]/255,a=e[2]/255,l=Math.max(o,s,a),c=l-Math.min(o,s,a),p=function(e){return (l-e)/6/c+.5};return 0===c?i=u=0:(u=c/l,t=p(o),n=p(s),r=p(a),o===l?i=r-n:s===l?i=1/3+t-r:a===l&&(i=2/3+n-t),i<0?i+=1:i>1&&(i-=1)),[360*i,100*u,100*l]},r.rgb.hwb=function(e){var t=e[0],n=e[1],i=e[2];return [r.rgb.hsl(e)[0],100*(1/255*Math.min(t,Math.min(n,i))),100*(i=1-1/255*Math.max(t,Math.max(n,i)))]},r.rgb.cmyk=function(e){var t,n=e[0]/255,r=e[1]/255,i=e[2]/255;return [100*((1-n-(t=Math.min(1-n,1-r,1-i)))/(1-t)||0),100*((1-r-t)/(1-t)||0),100*((1-i-t)/(1-t)||0),100*t]},r.rgb.keyword=function(e){var n=t[e];if(n)return n;var r,i,u,o=1/0;for(var s in yc)if(yc.hasOwnProperty(s)){var a=yc[s],l=(i=e,u=a,Math.pow(i[0]-u[0],2)+Math.pow(i[1]-u[1],2)+Math.pow(i[2]-u[2],2));l<o&&(o=l,r=s);}return r},r.keyword.rgb=function(e){return yc[e]},r.rgb.xyz=function(e){var t=e[0]/255,n=e[1]/255,r=e[2]/255;return [100*(.4124*(t=t>.04045?Math.pow((t+.055)/1.055,2.4):t/12.92)+.3576*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)+.1805*(r=r>.04045?Math.pow((r+.055)/1.055,2.4):r/12.92)),100*(.2126*t+.7152*n+.0722*r),100*(.0193*t+.1192*n+.9505*r)]},r.rgb.lab=function(e){var t=r.rgb.xyz(e),n=t[0],i=t[1],u=t[2];return i/=100,u/=108.883,n=(n/=95.047)>.008856?Math.pow(n,1/3):7.787*n+16/116,[116*(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116)-16,500*(n-i),200*(i-(u=u>.008856?Math.pow(u,1/3):7.787*u+16/116))]},r.hsl.rgb=function(e){var t,n,r,i,u,o=e[0]/360,s=e[1]/100,a=e[2]/100;if(0===s)return [u=255*a,u,u];t=2*a-(n=a<.5?a*(1+s):a+s-a*s),i=[0,0,0];for(var l=0;l<3;l++)(r=o+1/3*-(l-1))<0&&r++,r>1&&r--,u=6*r<1?t+6*(n-t)*r:2*r<1?n:3*r<2?t+(n-t)*(2/3-r)*6:t,i[l]=255*u;return i},r.hsl.hsv=function(e){var t=e[0],n=e[1]/100,r=e[2]/100,i=n,u=Math.max(r,.01);return n*=(r*=2)<=1?r:2-r,i*=u<=1?u:2-u,[t,100*(0===r?2*i/(u+i):2*n/(r+n)),100*((r+n)/2)]},r.hsv.rgb=function(e){var t=e[0]/60,n=e[1]/100,r=e[2]/100,i=Math.floor(t)%6,u=t-Math.floor(t),o=255*r*(1-n),s=255*r*(1-n*u),a=255*r*(1-n*(1-u));switch(r*=255,i){case 0:return [r,a,o];case 1:return [s,r,o];case 2:return [o,r,a];case 3:return [o,s,r];case 4:return [a,o,r];case 5:return [r,o,s]}},r.hsv.hsl=function(e){var t,n,r,i=e[0],u=e[1]/100,o=e[2]/100,s=Math.max(o,.01);return r=(2-u)*o,n=u*s,[i,100*(n=(n/=(t=(2-u)*s)<=1?t:2-t)||0),100*(r/=2)]},r.hwb.rgb=function(e){var t,n,r,i,u,o,s,a=e[0]/360,l=e[1]/100,c=e[2]/100,p=l+c;switch(p>1&&(l/=p,c/=p),r=6*a-(t=Math.floor(6*a)),0!=(1&t)&&(r=1-r),i=l+r*((n=1-c)-l),t){default:case 6:case 0:u=n,o=i,s=l;break;case 1:u=i,o=n,s=l;break;case 2:u=l,o=n,s=i;break;case 3:u=l,o=i,s=n;break;case 4:u=i,o=l,s=n;break;case 5:u=n,o=l,s=i;}return [255*u,255*o,255*s]},r.cmyk.rgb=function(e){var t=e[0]/100,n=e[1]/100,r=e[2]/100,i=e[3]/100;return [255*(1-Math.min(1,t*(1-i)+i)),255*(1-Math.min(1,n*(1-i)+i)),255*(1-Math.min(1,r*(1-i)+i))]},r.xyz.rgb=function(e){var t,n,r,i=e[0]/100,u=e[1]/100,o=e[2]/100;return n=-.9689*i+1.8758*u+.0415*o,r=.0557*i+-.204*u+1.057*o,t=(t=3.2406*i+-1.5372*u+-.4986*o)>.0031308?1.055*Math.pow(t,1/2.4)-.055:12.92*t,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,r=r>.0031308?1.055*Math.pow(r,1/2.4)-.055:12.92*r,[255*(t=Math.min(Math.max(0,t),1)),255*(n=Math.min(Math.max(0,n),1)),255*(r=Math.min(Math.max(0,r),1))]},r.xyz.lab=function(e){var t=e[0],n=e[1],r=e[2];return n/=100,r/=108.883,t=(t/=95.047)>.008856?Math.pow(t,1/3):7.787*t+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(t-n),200*(n-(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116))]},r.lab.xyz=function(e){var t,n,r,i=e[0];t=e[1]/500+(n=(i+16)/116),r=n-e[2]/200;var u=Math.pow(n,3),o=Math.pow(t,3),s=Math.pow(r,3);return n=u>.008856?u:(n-16/116)/7.787,t=o>.008856?o:(t-16/116)/7.787,r=s>.008856?s:(r-16/116)/7.787,[t*=95.047,n*=100,r*=108.883]},r.lab.lch=function(e){var t,n=e[0],r=e[1],i=e[2];return (t=360*Math.atan2(i,r)/2/Math.PI)<0&&(t+=360),[n,Math.sqrt(r*r+i*i),t]},r.lch.lab=function(e){var t,n=e[0],r=e[1];return t=e[2]/360*2*Math.PI,[n,r*Math.cos(t),r*Math.sin(t)]},r.rgb.ansi16=function(e){var t=e[0],n=e[1],i=e[2],u=1 in arguments?arguments[1]:r.rgb.hsv(e)[2];if(0===(u=Math.round(u/50)))return 30;var o=30+(Math.round(i/255)<<2|Math.round(n/255)<<1|Math.round(t/255));return 2===u&&(o+=60),o},r.hsv.ansi16=function(e){return r.rgb.ansi16(r.hsv.rgb(e),e[2])},r.rgb.ansi256=function(e){var t=e[0],n=e[1],r=e[2];return t===n&&n===r?t<8?16:t>248?231:Math.round((t-8)/247*24)+232:16+36*Math.round(t/255*5)+6*Math.round(n/255*5)+Math.round(r/255*5)},r.ansi16.rgb=function(e){var t=e%10;if(0===t||7===t)return e>50&&(t+=3.5),[t=t/10.5*255,t,t];var n=.5*(1+~~(e>50));return [(1&t)*n*255,(t>>1&1)*n*255,(t>>2&1)*n*255]},r.ansi256.rgb=function(e){if(e>=232){var t=10*(e-232)+8;return [t,t,t]}var n;return e-=16,[Math.floor(e/36)/5*255,Math.floor((n=e%36)/6)/5*255,n%6/5*255]},r.rgb.hex=function(e){var t=(((255&Math.round(e[0]))<<16)+((255&Math.round(e[1]))<<8)+(255&Math.round(e[2]))).toString(16).toUpperCase();return "000000".substring(t.length)+t},r.hex.rgb=function(e){var t=e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!t)return [0,0,0];var n=t[0];3===t[0].length&&(n=n.split("").map((function(e){return e+e})).join(""));var r=parseInt(n,16);return [r>>16&255,r>>8&255,255&r]},r.rgb.hcg=function(e){var t,n=e[0]/255,r=e[1]/255,i=e[2]/255,u=Math.max(Math.max(n,r),i),o=Math.min(Math.min(n,r),i),s=u-o;return t=s<=0?0:u===n?(r-i)/s%6:u===r?2+(i-n)/s:4+(n-r)/s+4,t/=6,[360*(t%=1),100*s,100*(s<1?o/(1-s):0)]},r.hsl.hcg=function(e){var t=e[1]/100,n=e[2]/100,r=1,i=0;return (r=n<.5?2*t*n:2*t*(1-n))<1&&(i=(n-.5*r)/(1-r)),[e[0],100*r,100*i]},r.hsv.hcg=function(e){var t=e[1]/100,n=e[2]/100,r=t*n,i=0;return r<1&&(i=(n-r)/(1-r)),[e[0],100*r,100*i]},r.hcg.rgb=function(e){var t=e[0]/360,n=e[1]/100,r=e[2]/100;if(0===n)return [255*r,255*r,255*r];var i,u=[0,0,0],o=t%1*6,s=o%1,a=1-s;switch(Math.floor(o)){case 0:u[0]=1,u[1]=s,u[2]=0;break;case 1:u[0]=a,u[1]=1,u[2]=0;break;case 2:u[0]=0,u[1]=1,u[2]=s;break;case 3:u[0]=0,u[1]=a,u[2]=1;break;case 4:u[0]=s,u[1]=0,u[2]=1;break;default:u[0]=1,u[1]=0,u[2]=a;}return i=(1-n)*r,[255*(n*u[0]+i),255*(n*u[1]+i),255*(n*u[2]+i)]},r.hcg.hsv=function(e){var t=e[1]/100,n=t+e[2]/100*(1-t),r=0;return n>0&&(r=t/n),[e[0],100*r,100*n]},r.hcg.hsl=function(e){var t=e[1]/100,n=e[2]/100*(1-t)+.5*t,r=0;return n>0&&n<.5?r=t/(2*n):n>=.5&&n<1&&(r=t/(2*(1-n))),[e[0],100*r,100*n]},r.hcg.hwb=function(e){var t=e[1]/100,n=t+e[2]/100*(1-t);return [e[0],100*(n-t),100*(1-n)]},r.hwb.hcg=function(e){var t=e[1]/100,n=1-e[2]/100,r=n-t,i=0;return r<1&&(i=(n-r)/(1-r)),[e[0],100*r,100*i]},r.apple.rgb=function(e){return [e[0]/65535*255,e[1]/65535*255,e[2]/65535*255]},r.rgb.apple=function(e){return [e[0]/255*65535,e[1]/255*65535,e[2]/255*65535]},r.gray.rgb=function(e){return [e[0]/100*255,e[0]/100*255,e[0]/100*255]},r.gray.hsl=r.gray.hsv=function(e){return [0,0,e[0]]},r.gray.hwb=function(e){return [0,100,e[0]]},r.gray.cmyk=function(e){return [0,0,0,e[0]]},r.gray.lab=function(e){return [e[0],0,0]},r.gray.hex=function(e){var t=255&Math.round(e[0]/100*255),n=((t<<16)+(t<<8)+t).toString(16).toUpperCase();return "000000".substring(n.length)+n},r.rgb.gray=function(e){return [(e[0]+e[1]+e[2])/3/255*100]};}));function Ec(e){var t=function(){for(var e={},t=Object.keys(Dc),n=t.length,r=0;r<n;r++)e[t[r]]={distance:-1,parent:null};return e}(),n=[e];for(t[e].distance=0;n.length;)for(var r=n.pop(),i=Object.keys(Dc[r]),u=i.length,o=0;o<u;o++){var s=i[o],a=t[s];-1===a.distance&&(a.distance=t[r].distance+1,a.parent=r,n.unshift(s));}return t}function bc(e,t){return function(n){return t(e(n))}}function Cc(e,t){for(var n=[t[e].parent,e],r=Dc[t[e].parent][e],i=t[e].parent;t[i].parent;)n.unshift(t[i].parent),r=bc(Dc[t[i].parent][i],r),i=t[i].parent;return r.conversion=n,r}var vc={};Object.keys(Dc).forEach((function(e){vc[e]={},Object.defineProperty(vc[e],"channels",{value:Dc[e].channels}),Object.defineProperty(vc[e],"labels",{value:Dc[e].labels});var t=function(e){for(var t=Ec(e),n={},r=Object.keys(t),i=r.length,u=0;u<i;u++){var o=r[u];null!==t[o].parent&&(n[o]=Cc(o,t));}return n}(e);Object.keys(t).forEach((function(n){var r=t[n];vc[e][n]=function(e){var t=function(t){if(null==t)return t;arguments.length>1&&(t=Array.prototype.slice.call(arguments));var n=e(t);if("object"==typeof n)for(var r=n.length,i=0;i<r;i++)n[i]=Math.round(n[i]);return n};return "conversion"in e&&(t.conversion=e.conversion),t}(r),vc[e][n].raw=function(e){var t=function(t){return null==t?t:(arguments.length>1&&(t=Array.prototype.slice.call(arguments)),e(t))};return "conversion"in e&&(t.conversion=e.conversion),t}(r);}));}));var Ac=vc,Fc=i$2((function(e){const t=(e,t)=>function(){const n=e.apply(Ac,arguments);return `\x1b[${n+t}m`},n=(e,t)=>function(){const n=e.apply(Ac,arguments);return `\x1b[${38+t};5;${n}m`},r=(e,t)=>function(){const n=e.apply(Ac,arguments);return `\x1b[${38+t};2;${n[0]};${n[1]};${n[2]}m`};Object.defineProperty(e,"exports",{enumerable:!0,get:function(){const e=new Map,i={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};i.color.grey=i.color.gray;for(const t of Object.keys(i)){const n=i[t];for(const t of Object.keys(n)){const r=n[t];i[t]={open:`\x1b[${r[0]}m`,close:`\x1b[${r[1]}m`},n[t]=i[t],e.set(r[0],r[1]);}Object.defineProperty(i,t,{value:n,enumerable:!1}),Object.defineProperty(i,"codes",{value:e,enumerable:!1});}const u=e=>e,o=(e,t,n)=>[e,t,n];i.color.close="\x1b[39m",i.bgColor.close="\x1b[49m",i.color.ansi={ansi:t(u,0)},i.color.ansi256={ansi256:n(u,0)},i.color.ansi16m={rgb:r(o,0)},i.bgColor.ansi={ansi:t(u,10)},i.bgColor.ansi256={ansi256:n(u,10)},i.bgColor.ansi16m={rgb:r(o,10)};for(let e of Object.keys(Ac)){if("object"!=typeof Ac[e])continue;const u=Ac[e];"ansi16"===e&&(e="ansi"),"ansi16"in u&&(i.color.ansi[e]=t(u.ansi16,0),i.bgColor.ansi[e]=t(u.ansi16,10)),"ansi256"in u&&(i.color.ansi256[e]=n(u.ansi256,0),i.bgColor.ansi256[e]=n(u.ansi256,10)),"rgb"in u&&(i.color.ansi16m[e]=r(u.rgb,0),i.bgColor.ansi16m[e]=r(u.rgb,10));}return i}});})),xc=(e,t)=>{t=t||Cr$1.argv;const n=e.startsWith("-")?"":1===e.length?"-":"--",r=t.indexOf(n+e),i=t.indexOf("--");return -1!==r&&(-1===i||r<i)};const Sc=Cr$1.env;let wc;function Tc(e){return function(e){return 0!==e&&{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}(function(e){if(!1===wc)return 0;if(xc("color=16m")||xc("color=full")||xc("color=truecolor"))return 3;if(xc("color=256"))return 2;if(e&&!e.isTTY&&!0!==wc)return 0;const t=wc?1:0;if("CI"in Sc)return ["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI"].some((e=>e in Sc))||"codeship"===Sc.CI_NAME?1:t;if("TEAMCITY_VERSION"in Sc)return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Sc.TEAMCITY_VERSION)?1:0;if("truecolor"===Sc.COLORTERM)return 3;if("TERM_PROGRAM"in Sc){const e=parseInt((Sc.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(Sc.TERM_PROGRAM){case"iTerm.app":return e>=3?3:2;case"Apple_Terminal":return 2}}return /-256(color)?$/i.test(Sc.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Sc.TERM)||"COLORTERM"in Sc?1:(t)}(e))}xc("no-color")||xc("no-colors")||xc("color=false")?wc=!1:(xc("color")||xc("colors")||xc("color=true")||xc("color=always"))&&(wc=!0),"FORCE_COLOR"in Sc&&(wc=0===Sc.FORCE_COLOR.length||0!==parseInt(Sc.FORCE_COLOR,10));var Bc={supportsColor:Tc,stdout:Tc(Cr$1.stdout),stderr:Tc(Cr$1.stderr)};const kc=/(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,Nc=/(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,Pc=/^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,Oc=/\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi,Ic=new Map([["n","\n"],["r","\r"],["t","\t"],["b","\b"],["f","\f"],["v","\v"],["0","\0"],["\\","\\"],["e","\x1b"],["a","\x07"]]);function jc(e){return "u"===e[0]&&5===e.length||"x"===e[0]&&3===e.length?String.fromCharCode(parseInt(e.slice(1),16)):Ic.get(e)||e}function Lc(e,t){const n=[],r=t.trim().split(/\s*,\s*/g);let i;for(const t of r)if(isNaN(t)){if(!(i=t.match(Pc)))throw new Error(`Invalid Chalk template style argument: ${t} (in style '${e}')`);n.push(i[2].replace(Oc,((e,t,n)=>t?jc(t):n)));}else n.push(Number(t));return n}function _c(e){Nc.lastIndex=0;const t=[];let n;for(;null!==(n=Nc.exec(e));){const e=n[1];if(n[2]){const r=Lc(e,n[2]);t.push([e].concat(r));}else t.push([e]);}return t}function Mc(e,t){const n={};for(const e of t)for(const t of e.styles)n[t[0]]=e.inverse?null:t.slice(1);let r=e;for(const e of Object.keys(n))if(Array.isArray(n[e])){if(!(e in r))throw new Error(`Unknown Chalk style: ${e}`);r=n[e].length>0?r[e].apply(r,n[e]):r[e];}return r}var Rc=(e,t)=>{const n=[],r=[];let i=[];if(t.replace(kc,((t,u,o,s,a,l)=>{if(u)i.push(jc(u));else if(s){const t=i.join("");i=[],r.push(0===n.length?t:Mc(e,n)(t)),n.push({inverse:o,styles:_c(s)});}else if(a){if(0===n.length)throw new Error("Found extraneous } in Chalk template literal");r.push(Mc(e,n)(i.join(""))),i=[],n.pop();}else i.push(l);})),r.push(i.join("")),n.length>0){const e=`Chalk template literal is missing ${n.length} closing bracket${1===n.length?"":"s"} (\`}\`)`;throw new Error(e)}return r.join("")},$c=i$2((function(e){const t=Bc.stdout,n=["ansi","ansi","ansi256","ansi16m"],r=new Set(["gray"]),i=Object.create(null);function u(e,n){n=n||{};const r=t?t.level:0;e.level=void 0===n.level?r:n.level,e.enabled="enabled"in n?n.enabled:e.level>0;}function o(e){if(!this||!(this instanceof o)||this.template){const t={};return u(t,e),t.template=function(){const e=[].slice.call(arguments);return c.apply(null,[t.template].concat(e))},Object.setPrototypeOf(t,o.prototype),Object.setPrototypeOf(t.template,t),t.template.constructor=o,t.template}u(this,e);}for(const e of Object.keys(Fc))Fc[e].closeRe=new RegExp(mc(Fc[e].close),"g"),i[e]={get(){const t=Fc[e];return a.call(this,this._styles?this._styles.concat(t):[t],this._empty,e)}};i.visible={get(){return a.call(this,this._styles||[],!0,"visible")}},Fc.color.closeRe=new RegExp(mc(Fc.color.close),"g");for(const e of Object.keys(Fc.color.ansi))r.has(e)||(i[e]={get(){const t=this.level;return function(){const r=Fc.color[n[t]][e].apply(null,arguments),i={open:r,close:Fc.color.close,closeRe:Fc.color.closeRe};return a.call(this,this._styles?this._styles.concat(i):[i],this._empty,e)}}});Fc.bgColor.closeRe=new RegExp(mc(Fc.bgColor.close),"g");for(const e of Object.keys(Fc.bgColor.ansi)){if(r.has(e))continue;i["bg"+e[0].toUpperCase()+e.slice(1)]={get(){const t=this.level;return function(){const r=Fc.bgColor[n[t]][e].apply(null,arguments),i={open:r,close:Fc.bgColor.close,closeRe:Fc.bgColor.closeRe};return a.call(this,this._styles?this._styles.concat(i):[i],this._empty,e)}}};}const s=Object.defineProperties((()=>{}),i);function a(e,t,n){const r=function(){return l.apply(r,arguments)};r._styles=e,r._empty=t;const i=this;return Object.defineProperty(r,"level",{enumerable:!0,get:()=>i.level,set(e){i.level=e;}}),Object.defineProperty(r,"enabled",{enumerable:!0,get:()=>i.enabled,set(e){i.enabled=e;}}),r.hasGrey=this.hasGrey||"gray"===n||"grey"===n,r.__proto__=s,r}function l(){const e=arguments,t=e.length;let n=String(arguments[0]);if(0===t)return "";if(t>1)for(let r=1;r<t;r++)n+=" "+e[r];if(!this.enabled||this.level<=0||!n)return this._empty?"":n;const r=Fc.dim.open;for(const e of this._styles.slice().reverse())n=e.open+n.replace(e.closeRe,e.open)+e.close,n=n.replace(/\r?\n/g,`${e.close}$&${e.open}`);return Fc.dim.open=r,n}function c(e,t){if(!Array.isArray(t))return [].slice.call(arguments,1).join(" ");const n=[].slice.call(arguments,2),r=[t.raw[0]];for(let e=1;e<t.length;e++)r.push(String(n[e-1]).replace(/[{}\\]/g,"\\$&")),r.push(String(t.raw[e]));return Rc(e,r.join(""))}Object.defineProperties(o.prototype,i),e.exports=o(),e.exports.supportsColor=t,e.exports.default=e.exports;})),Vc=Jc,qc=Xc,Wc=function(e,t={}){if(Jc(t)){const n=Xc(t);return function(e,t){let n="";for(const{type:r,value:i}of Hc(t)){const t=e[r];n+=t?i.split(zc).map((e=>t(e))).join("\n"):i;}return n}(function(e){return {keyword:e.cyan,capitalized:e.yellow,jsxIdentifier:e.yellow,punctuator:e.yellow,number:e.magenta,string:e.green,regex:e.magenta,comment:e.grey,invalid:e.white.bgRed.bold}}(n),e)}return e};const Uc=new Set(["as","async","from","get","of","set"]);const zc=/\r\n|[\n\r\u2028\u2029]/,Gc=/^[()[\]{}]$/;let Hc;{const e=/^[a-z][\w-]*$/i,t=function(t,n,r){if("name"===t.type){if((0, hc.isKeyword)(t.value)||(0, hc.isStrictReservedWord)(t.value,!0)||Uc.has(t.value))return "keyword";if(e.test(t.value)&&("<"===r[n-1]||"</"==r.substr(n-2,2)))return "jsxIdentifier";if(t.value[0]!==t.value[0].toLowerCase())return "capitalized"}return "punctuator"===t.type&&Gc.test(t.value)?"bracket":"invalid"!==t.type||"@"!==t.value&&"#"!==t.value?t.type:"punctuator"};Hc=function*(e){let n;for(;n=$l.default.exec(e);){const r=$l.matchToToken(n);yield {type:t(r,n.index,e),value:r.value};}};}function Jc(e){return !!$c.supportsColor||e.forceColor}function Xc(e){return e.forceColor?new $c.constructor({enabled:!0,level:1}):$c}var Yc=Object.defineProperty({shouldHighlight:Vc,getChalk:qc,default:Wc},"__esModule",{value:!0}),Kc=tp,Qc=function(e,t,n,r={}){if(!Zc){Zc=!0;const e="Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";new Error(e).name="DeprecationWarning",console.warn(new Error(e));}n=Math.max(n,0);return tp(e,{start:{column:n,line:t}},r)};let Zc=!1;const ep=/\r\n|[\n\r\u2028\u2029]/;function tp(e,t,n={}){const r=(n.highlightCode||n.forceColor)&&(0, Yc.shouldHighlight)(n),i=(0, Yc.getChalk)(n),u=function(e){return {gutter:e.grey,marker:e.red.bold,message:e.red.bold}}(i),o=(e,t)=>r?e(t):t,s=e.split(ep),{start:a,end:l,markerLines:c}=function(e,t,n){const r=Object.assign({column:0,line:-1},e.start),i=Object.assign({},r,e.end),{linesAbove:u=2,linesBelow:o=3}=n||{},s=r.line,a=r.column,l=i.line,c=i.column;let p=Math.max(s-(u+1),0),f=Math.min(t.length,l+o);-1===s&&(p=0),-1===l&&(f=t.length);const d=l-s,h={};if(d)for(let e=0;e<=d;e++){const n=e+s;if(a)if(0===e){const e=t[n-1].length;h[n]=[a,e-a+1];}else if(e===d)h[n]=[0,c];else {const r=t[n-e].length;h[n]=[0,r];}else h[n]=!0;}else h[s]=a===c?!a||[a,0]:[a,c-a];return {start:p,end:f,markerLines:h}}(t,s,n),p=t.start&&"number"==typeof t.start.column,f=String(l).length;let d=(r?(0, Yc.default)(e,n):e).split(ep).slice(a,l).map(((e,t)=>{const r=a+1+t,i=` ${` ${r}`.slice(-f)} |`,s=c[r],l=!c[r+1];if(s){let t="";if(Array.isArray(s)){const r=e.slice(0,Math.max(s[0]-1,0)).replace(/[^\t]/g," "),a=s[1]||1;t=["\n ",o(u.gutter,i.replace(/\d/g," "))," ",r,o(u.marker,"^").repeat(a)].join(""),l&&n.message&&(t+=" "+o(u.message,n.message));}return [o(u.marker,">"),o(u.gutter,i),e.length>0?` ${e}`:"",t].join("")}return ` ${o(u.gutter,i)}${e.length>0?` ${e}`:""}`})).join("\n");return n.message&&!p&&(d=`${" ".repeat(f+1)}${n.message}\n${d}`),r?i.reset(d):d}var np=Object.defineProperty({codeFrameColumns:Kc,default:Qc},"__esModule",{value:!0}),rp=r$2(cu);const{ConfigError:ip}=go,{locStart:up,locEnd:op}=Rl,sp=Object.getOwnPropertyNames,ap=Object.getOwnPropertyDescriptor;function lp(e){const t={};for(const n of e.plugins)if(n.parsers)for(const e of sp(n.parsers))Object.defineProperty(t,e,ap(n.parsers,e));return t}function cp(e,t=lp(e)){if("function"==typeof e.parser)return {parse:e.parser,astFormat:"estree",locStart:up,locEnd:op};if("string"==typeof e.parser){if(Object.prototype.hasOwnProperty.call(t,e.parser))return t[e.parser];throw new ip(`Couldn't resolve parser "${e.parser}". Parsers must be explicitly added to the standalone bundle.`)}}var pp={parse:function(e,t){const n=lp(t),r=Object.defineProperties({},Object.fromEntries(Object.keys(n).map((e=>[e,{enumerable:!0,get:()=>n[e].parse}])))),i=cp(t,n);try{return i.preprocess&&(e=i.preprocess(e,t)),{text:e,ast:i.parse(e,r,t)}}catch(t){const{loc:n}=t;if(n){const{codeFrameColumns:r}=np;throw t.codeFrame=r(e,n,{highlightCode:!0}),t.message+="\n"+t.codeFrame,t}throw t.stack}},resolveParser:cp};const{UndefinedParserError:fp}=go,{getSupportInfo:dp}=Hr$1,{resolveParser:hp}=pp,gp={astFormat:"estree",printer:{},originalText:void 0,locStart:null,locEnd:null};function mp(e,t){const n=rp.basename(e).toLowerCase(),r=dp({plugins:t}).languages.filter((e=>null!==e.since));let i=r.find((e=>e.extensions&&e.extensions.some((e=>n.endsWith(e)))||e.filenames&&e.filenames.some((e=>e.toLowerCase()===n))));if(!i&&!n.includes(".")){const t=function(e){if("string"!=typeof e)return "";let t;try{t=ao.openSync(e,"r");}catch{return ""}try{const e=new lo(t).next().toString("utf8"),n=e.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);if(n)return n[1];const r=e.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);return r?r[1]:""}catch{return ""}finally{try{ao.closeSync(t);}catch{}}}(e);i=r.find((e=>e.interpreters&&e.interpreters.includes(t)));}return i&&i.parsers[0]}var yp={normalize:function(e,t={}){const n=Object.assign({},e),r=dp({plugins:e.plugins,showUnreleased:!0,showDeprecated:!0}).options,i=Object.assign(Object.assign({},gp),Object.fromEntries(r.filter((e=>void 0!==e.default)).map((e=>[e.name,e.default]))));if(!n.parser)if(n.filepath){if(n.parser=mp(n.filepath,n.plugins),!n.parser)throw new fp(`No parser could be inferred for file: ${n.filepath}`)}else {(t.logger||console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."),n.parser="babel";}const u=hp(Il.normalizeApiOptions(n,[r.find((e=>"parser"===e.name))],{passThrough:!0,logger:!1}));n.astFormat=u.astFormat,n.locEnd=u.locEnd,n.locStart=u.locStart;const o=function(e){const{astFormat:t}=e;if(!t)throw new Error("getPlugin() requires astFormat to be set");const n=e.plugins.find((e=>e.printers&&e.printers[t]));if(!n)throw new Error(`Couldn't find plugin for AST format "${t}"`);return n}(n);n.printer=o.printers[n.astFormat];const s=Object.fromEntries(r.filter((e=>e.pluginDefaults&&void 0!==e.pluginDefaults[o.name])).map((e=>[e.name,e.pluginDefaults[o.name]]))),a=Object.assign(Object.assign({},i),s);for(const[e,t]of Object.entries(a))null!==n[e]&&void 0!==n[e]||(n[e]=t);return "json"===n.parser&&(n.trailingComma="none"),Il.normalizeApiOptions(n,r,Object.assign({passThrough:Object.keys(gp)},t))},hiddenDefaults:gp,inferParser:mp};var Dp=function e(t,n,r){if(Array.isArray(t))return t.map((t=>e(t,n,r))).filter(Boolean);if(!t||"object"!=typeof t)return t;const i=n.printer.massageAstNode;let u;u=i&&i.ignoredProperties?i.ignoredProperties:new Set;const o={};for(const[r,i]of Object.entries(t))u.has(r)||"function"==typeof i||(o[r]=e(i,n,t));if(i){const e=i(t,o,r);if(null===e)return;if(e)return e}return o},Ep="function"==typeof Object.create?function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}});}:function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e;};function bp(e,t){var n={seen:[],stylize:vp};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),Sp(t)?n.showHidden=t:t&&_p(n,t),Bp(n.showHidden)&&(n.showHidden=!1),Bp(n.depth)&&(n.depth=2),Bp(n.colors)&&(n.colors=!1),Bp(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=Cp),Ap(n,e,n.depth)}function Cp(e,t){var n=bp.styles[t];return n?"\x1b["+bp.colors[n][0]+"m"+e+"\x1b["+bp.colors[n][1]+"m":e}function vp(e,t){return e}function Ap(e,t,n){if(e.customInspect&&t&&Ip(t.inspect)&&t.inspect!==bp&&(!t.constructor||t.constructor.prototype!==t)){var r=t.inspect(n,e);return Tp(r)||(r=Ap(e,r,n)),r}var i=function(e,t){if(Bp(t))return e.stylize("undefined","undefined");if(Tp(t)){var n="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(n,"string")}if(r=t,"number"==typeof r)return e.stylize(""+t,"number");var r;if(Sp(t))return e.stylize(""+t,"boolean");if(wp(t))return e.stylize("null","null")}(e,t);if(i)return i;var u=Object.keys(t),o=function(e){var t={};return e.forEach((function(e,n){t[e]=!0;})),t}(u);if(e.showHidden&&(u=Object.getOwnPropertyNames(t)),Op(t)&&(u.indexOf("message")>=0||u.indexOf("description")>=0))return Fp(t);if(0===u.length){if(Ip(t)){var s=t.name?": "+t.name:"";return e.stylize("[Function"+s+"]","special")}if(kp(t))return e.stylize(RegExp.prototype.toString.call(t),"regexp");if(Pp(t))return e.stylize(Date.prototype.toString.call(t),"date");if(Op(t))return Fp(t)}var a,l,c="",p=!1,f=["{","}"];(a=t,Array.isArray(a)&&(p=!0,f=["[","]"]),Ip(t))&&(c=" [Function"+(t.name?": "+t.name:"")+"]");return kp(t)&&(c=" "+RegExp.prototype.toString.call(t)),Pp(t)&&(c=" "+Date.prototype.toUTCString.call(t)),Op(t)&&(c=" "+Fp(t)),0!==u.length||p&&0!=t.length?n<0?kp(t)?e.stylize(RegExp.prototype.toString.call(t),"regexp"):e.stylize("[Object]","special"):(e.seen.push(t),l=p?function(e,t,n,r,i){for(var u=[],o=0,s=t.length;o<s;++o)Mp(t,String(o))?u.push(xp(e,t,n,r,String(o),!0)):u.push("");return i.forEach((function(i){i.match(/^\d+$/)||u.push(xp(e,t,n,r,i,!0));})),u}(e,t,n,o,u):u.map((function(r){return xp(e,t,n,o,r,p)})),e.seen.pop(),function(e,t,n){if(e.reduce((function(e,t){return t.indexOf("\n"),e+t.replace(/\u001b\[\d\d?m/g,"").length+1}),0)>60)return n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1];return n[0]+t+" "+e.join(", ")+" "+n[1]}(l,c,f)):f[0]+c+f[1]}function Fp(e){return "["+Error.prototype.toString.call(e)+"]"}function xp(e,t,n,r,i,u){var o,s,a;if((a=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?s=a.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):a.set&&(s=e.stylize("[Setter]","special")),Mp(r,i)||(o="["+i+"]"),s||(e.seen.indexOf(a.value)<0?(s=wp(n)?Ap(e,a.value,null):Ap(e,a.value,n-1)).indexOf("\n")>-1&&(s=u?s.split("\n").map((function(e){return "  "+e})).join("\n").substr(2):"\n"+s.split("\n").map((function(e){return "   "+e})).join("\n")):s=e.stylize("[Circular]","special")),Bp(o)){if(u&&i.match(/^\d+$/))return s;(o=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(o=o.substr(1,o.length-2),o=e.stylize(o,"name")):(o=o.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),o=e.stylize(o,"string"));}return o+": "+s}function Sp(e){return "boolean"==typeof e}function wp(e){return null===e}function Tp(e){return "string"==typeof e}function Bp(e){return void 0===e}function kp(e){return Np(e)&&"[object RegExp]"===Lp(e)}function Np(e){return "object"==typeof e&&null!==e}function Pp(e){return Np(e)&&"[object Date]"===Lp(e)}function Op(e){return Np(e)&&("[object Error]"===Lp(e)||e instanceof Error)}function Ip(e){return "function"==typeof e}function jp(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e}function Lp(e){return Object.prototype.toString.call(e)}function _p(e,t){if(!t||!Np(t))return e;for(var n=Object.keys(t),r=n.length;r--;)e[n[r]]=t[n[r]];return e}function Mp(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function Rp(e,t){if(e===t)return 0;for(var n=e.length,r=t.length,i=0,u=Math.min(n,r);i<u;++i)if(e[i]!==t[i]){n=e[i],r=t[i];break}return n<r?-1:r<n?1:0}bp.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},bp.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};var $p,Vp=Object.prototype.hasOwnProperty,qp=Object.keys||function(e){var t=[];for(var n in e)Vp.call(e,n)&&t.push(n);return t},Wp=Array.prototype.slice;function Up(){return void 0!==$p?$p:$p="foo"===function(){}.name}function zp(e){return Object.prototype.toString.call(e)}function Gp(e){return !oo(e)&&("function"==typeof Kn$1.ArrayBuffer&&("function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):!!e&&(e instanceof DataView||!!(e.buffer&&e.buffer instanceof ArrayBuffer))))}function Hp(e,t){e||Zp(e,!0,t,"==",ef);}var Jp=/\s*function\s+([^\(\s]*)\s*/;function Xp(e){if(Ip(e)){if(Up())return e.name;var t=e.toString().match(Jp);return t&&t[1]}}function Yp(e){this.name="AssertionError",this.actual=e.actual,this.expected=e.expected,this.operator=e.operator,e.message?(this.message=e.message,this.generatedMessage=!1):(this.message=function(e){return Kp(Qp(e.actual),128)+" "+e.operator+" "+Kp(Qp(e.expected),128)}(this),this.generatedMessage=!0);var t=e.stackStartFunction||Zp;if(Error.captureStackTrace)Error.captureStackTrace(this,t);else {var n=new Error;if(n.stack){var r=n.stack,i=Xp(t),u=r.indexOf("\n"+i);if(u>=0){var o=r.indexOf("\n",u+1);r=r.substring(o+1);}this.stack=r;}}}function Kp(e,t){return "string"==typeof e?e.length<t?e:e.slice(0,t):e}function Qp(e){if(Up()||!Ip(e))return bp(e);var t=Xp(e);return "[Function"+(t?": "+t:"")+"]"}function Zp(e,t,n,r,i){throw new Yp({message:n,actual:e,expected:t,operator:r,stackStartFunction:i})}function ef(e,t){e||Zp(e,!0,t,"==",ef);}function tf(e,t,n){e!=t&&Zp(e,t,n,"==",tf);}function nf(e,t,n){e==t&&Zp(e,t,n,"!=",nf);}function rf(e,t,n){of(e,t,!1)||Zp(e,t,n,"deepEqual",rf);}function uf(e,t,n){of(e,t,!0)||Zp(e,t,n,"deepStrictEqual",uf);}function of(e,t,n,r){if(e===t)return !0;if(oo(e)&&oo(t))return 0===Rp(e,t);if(Pp(e)&&Pp(t))return e.getTime()===t.getTime();if(kp(e)&&kp(t))return e.source===t.source&&e.global===t.global&&e.multiline===t.multiline&&e.lastIndex===t.lastIndex&&e.ignoreCase===t.ignoreCase;if(null!==e&&"object"==typeof e||null!==t&&"object"==typeof t){if(Gp(e)&&Gp(t)&&zp(e)===zp(t)&&!(e instanceof Float32Array||e instanceof Float64Array))return 0===Rp(new Uint8Array(e.buffer),new Uint8Array(t.buffer));if(oo(e)!==oo(t))return !1;var i=(r=r||{actual:[],expected:[]}).actual.indexOf(e);return -1!==i&&i===r.expected.indexOf(t)||(r.actual.push(e),r.expected.push(t),function(e,t,n,r){if(null==e||null==t)return !1;if(jp(e)||jp(t))return e===t;if(n&&Object.getPrototypeOf(e)!==Object.getPrototypeOf(t))return !1;var i=sf(e),u=sf(t);if(i&&!u||!i&&u)return !1;if(i)return of(e=Wp.call(e),t=Wp.call(t),n);var o,s,a=qp(e),l=qp(t);if(a.length!==l.length)return !1;for(a.sort(),l.sort(),s=a.length-1;s>=0;s--)if(a[s]!==l[s])return !1;for(s=a.length-1;s>=0;s--)if(!of(e[o=a[s]],t[o],n,r))return !1;return !0}(e,t,n,r))}return n?e===t:e==t}function sf(e){return "[object Arguments]"==Object.prototype.toString.call(e)}function af(e,t,n){of(e,t,!1)&&Zp(e,t,n,"notDeepEqual",af);}function lf(e,t,n){of(e,t,!0)&&Zp(e,t,n,"notDeepStrictEqual",lf);}function cf(e,t,n){e!==t&&Zp(e,t,n,"===",cf);}function pf(e,t,n){e===t&&Zp(e,t,n,"!==",pf);}function ff(e,t){if(!e||!t)return !1;if("[object RegExp]"==Object.prototype.toString.call(t))return t.test(e);try{if(e instanceof t)return !0}catch(e){}return !Error.isPrototypeOf(t)&&!0===t.call({},e)}function df(e,t,n,r){var i;if("function"!=typeof t)throw new TypeError('"block" argument must be a function');"string"==typeof n&&(r=n,n=null),i=function(e){var t;try{e();}catch(e){t=e;}return t}(t),r=(n&&n.name?" ("+n.name+").":".")+(r?" "+r:"."),e&&!i&&Zp(i,n,"Missing expected exception"+r);var u="string"==typeof r,o=!e&&i&&!n;if((!e&&Op(i)&&u&&ff(i,n)||o)&&Zp(i,n,"Got unwanted exception"+r),e&&i&&n&&!ff(i,n)||!e&&i)throw i}function hf(e,t,n){df(!0,e,t,n);}function gf(e,t,n){df(!1,e,t,n);}function mf(e){if(e)throw e}Hp.AssertionError=Yp,Ep(Yp,Error),Hp.fail=Zp,Hp.ok=ef,Hp.equal=tf,Hp.notEqual=nf,Hp.deepEqual=rf,Hp.deepStrictEqual=uf,Hp.notDeepEqual=af,Hp.notDeepStrictEqual=lf,Hp.strictEqual=cf,Hp.notStrictEqual=pf,Hp.throws=hf,Hp.doesNotThrow=gf,Hp.ifError=mf;var yf=r$2(Object.freeze({__proto__:null,default:Hp,AssertionError:Yp,fail:Zp,ok:ef,assert:ef,equal:tf,notEqual:nf,deepEqual:rf,deepStrictEqual:uf,notDeepEqual:af,notDeepStrictEqual:lf,strictEqual:cf,notStrictEqual:pf,throws:hf,doesNotThrow:gf,ifError:mf}));const{builders:{line:Df,hardline:Ef,breakParent:bf,indent:Cf,lineSuffix:vf,join:Af,cursor:Ff}}=Ji$1,{hasNewline:xf,skipNewline:Sf,skipSpaces:wf,isPreviousLineEmpty:Tf,addLeadingComment:Bf,addDanglingComment:kf,addTrailingComment:Nf}=fi$1,Pf=new WeakMap;function Of(e,t,n){if(!e)return;const{printer:r,locStart:i,locEnd:u}=t;if(n){if(r.canAttachComment&&r.canAttachComment(e)){let t;for(t=n.length-1;t>=0&&!(i(n[t])<=i(e)&&u(n[t])<=u(e));--t);return void n.splice(t+1,0,e)}}else if(Pf.has(e))return Pf.get(e);const o=r.getCommentChildNodes&&r.getCommentChildNodes(e,t)||"object"==typeof e&&Object.entries(e).filter((([e])=>"enclosingNode"!==e&&"precedingNode"!==e&&"followingNode"!==e&&"tokens"!==e&&"comments"!==e)).map((([,e])=>e));if(o){n||(n=[],Pf.set(e,n));for(const e of o)Of(e,t,n);return n}}function If(e,t,n,r){const{locStart:i,locEnd:u}=n,o=i(t),s=u(t),a=Of(e,n);let l,c,p=0,f=a.length;for(;p<f;){const e=p+f>>1,r=a[e],d=i(r),h=u(r);if(d<=o&&s<=h)return If(r,t,n,r);if(h<=o)l=r,p=e+1;else {if(!(s<=d))throw new Error("Comment location overlaps with node location");c=r,f=e;}}if(r&&"TemplateLiteral"===r.type){const{quasis:e}=r,i=Vf(e,t,n);l&&Vf(e,l,n)!==i&&(l=null),c&&Vf(e,c,n)!==i&&(c=null);}return {enclosingNode:r,precedingNode:l,followingNode:c}}const jf=()=>!1;const Lf=e=>!/[\S\n\u2028\u2029]/.test(e);function _f(e,t,n,r){const{comment:i,precedingNode:u}=n[r],{locStart:o,locEnd:s}=t;let a=o(i);if(u)for(let t=r-1;t>=0;t--){const{comment:r,precedingNode:i}=n[t];if(i!==u||!Lf(e.slice(s(r),a)))break;a=o(r);}return xf(e,a,{backwards:!0})}function Mf(e,t,n,r){const{comment:i,followingNode:u}=n[r],{locStart:o,locEnd:s}=t;let a=s(i);if(u)for(let t=r+1;t<n.length;t++){const{comment:r,followingNode:i}=n[t];if(i!==u||!Lf(e.slice(a,o(r))))break;a=s(r);}return xf(e,a)}function Rf(e,t,n){const r=e.length;if(0===r)return;const{precedingNode:i,followingNode:u,enclosingNode:o}=e[0],s=n.printer.getGapRegex&&n.printer.getGapRegex(o)||/^[\s(]*$/;let a,l=n.locStart(u);for(a=r;a>0;--a){const{comment:r,precedingNode:o,followingNode:c}=e[a-1];yf.strictEqual(o,i),yf.strictEqual(c,u);const p=t.slice(n.locEnd(r),l);if(!s.test(p))break;l=n.locStart(r);}for(const[t,{comment:n}]of e.entries())t<a?Nf(i,n):Bf(u,n);for(const e of [i,u])e.comments&&e.comments.length>1&&e.comments.sort(((e,t)=>n.locStart(e)-n.locStart(t)));e.length=0;}function $f(e,t){return e.getValue().printed=!0,t.printer.printComment(e,t)}function Vf(e,t,n){const r=n.locStart(t)-1;for(let t=1;t<e.length;++t)if(r<n.locStart(e[t]))return t-1;return 0}function qf(e,t,n){const r=e.getValue();if(!r)return {};let i=r.comments||[];n&&(i=i.filter((e=>!n.has(e))));const u=r===t.cursorNode;if(0===i.length){const e=u?Ff:"";return {leading:e,trailing:e}}const o=[],s=[];return e.each((()=>{const r=e.getValue();if(n&&n.has(r))return;const{leading:i,trailing:u}=r;i?o.push(function(e,t){const n=e.getValue(),r=[$f(e,t)],{printer:i,originalText:u,locStart:o,locEnd:s}=t;if(i.isBlockComment&&i.isBlockComment(n)){const e=xf(u,s(n))?xf(u,o(n),{backwards:!0})?Ef:Df:" ";r.push(e);}else r.push(Ef);const a=Sf(u,wf(u,s(n)));return !1!==a&&xf(u,a)&&r.push(Ef),r}(e,t)):u&&s.push(function(e,t){const n=e.getValue(),r=$f(e,t),{printer:i,originalText:u,locStart:o}=t,s=i.isBlockComment&&i.isBlockComment(n);if(xf(u,o(n),{backwards:!0})){const e=Tf(u,n,o);return vf([Ef,e?Ef:"",r])}let a=[" ",r];return s||(a=[vf(a),bf]),a}(e,t));}),"comments"),u&&(o.unshift(Ff),s.push(Ff)),{leading:o,trailing:s}}var Wf={attach:function(e,t,n,r){if(!Array.isArray(e))return;const i=[],{locStart:u,locEnd:o,printer:{handleComments:s={}}}=r,{avoidAstMutation:a,ownLine:l=jf,endOfLine:c=jf,remaining:p=jf}=s,f=e.map(((i,u)=>Object.assign(Object.assign({},If(t,i,r)),{},{comment:i,text:n,options:r,ast:t,isLastComment:e.length-1===u})));for(const[e,t]of f.entries()){const{comment:n,precedingNode:r,enclosingNode:s,followingNode:d,text:h,options:g,ast:m,isLastComment:y}=t;if("json"===g.parser||"json5"===g.parser||"__js_expression"===g.parser||"__vue_expression"===g.parser){if(u(n)-u(m)<=0){Bf(m,n);continue}if(o(n)-o(m)>=0){Nf(m,n);continue}}let D;if(a?D=[t]:(n.enclosingNode=s,n.precedingNode=r,n.followingNode=d,D=[n,h,g,m,y]),_f(h,g,f,e))n.placement="ownLine",l(...D)||(d?Bf(d,n):r?Nf(r,n):kf(s||m,n));else if(Mf(h,g,f,e))n.placement="endOfLine",c(...D)||(r?Nf(r,n):d?Bf(d,n):kf(s||m,n));else if(n.placement="remaining",p(...D));else if(r&&d){const e=i.length;if(e>0){i[e-1].followingNode!==d&&Rf(i,h,g);}i.push(t);}else r?Nf(r,n):d?Bf(d,n):kf(s||m,n);}if(Rf(i,n,r),!a)for(const t of e)delete t.precedingNode,delete t.enclosingNode,delete t.followingNode;},printComments:function(e,t,n,r){const{leading:i,trailing:u}=qf(e,n,r);return i||u?[i,t,u]:t},printCommentsSeparately:qf,printDanglingComments:function(e,t,n,r){const i=[],u=e.getValue();return u&&u.comments?(e.each((()=>{const n=e.getValue();n.leading||n.trailing||r&&!r(n)||i.push($f(e,t));}),"comments"),0===i.length?"":n?Af(Ef,i):Cf([Ef,Af(Ef,i)])):""},getSortedChildNodes:Of,ensureAllCommentsPrinted:function(e){if(e)for(const t of e){if(!t.printed)throw new Error('Comment "'+t.value.trim()+'" was not printed. Please report this error!');delete t.printed;}}};function Uf(e,t){const n=zf(e.stack,t);return -1===n?null:e.stack[n]}function zf(e,t){for(let n=e.length-1;n>=0;n-=2){const r=e[n];if(r&&!Array.isArray(r)&&--t<0)return n}return -1}var Gf=class{constructor(e){this.stack=[e];}getName(){const{stack:e}=this,{length:t}=e;return t>1?e[t-2]:null}getValue(){return Sn$1(this.stack)}getNode(e=0){return Uf(this,e)}getParentNode(e=0){return Uf(this,e+1)}call(e,...t){const{stack:n}=this,{length:r}=n;let i=Sn$1(n);for(const e of t)i=i[e],n.push(e,i);const u=e(this);return n.length=r,u}callParent(e,t=0){const n=zf(this.stack,t+1),r=this.stack.splice(n+1),i=e(this);return this.stack.push(...r),i}each(e,...t){const{stack:n}=this,{length:r}=n;let i=Sn$1(n);for(const e of t)i=i[e],n.push(e,i);for(let t=0;t<i.length;++t)n.push(t,i[t]),e(this,t,i),n.length-=2;n.length=r;}map(e,...t){const n=[];return this.each(((t,r,i)=>{n[r]=e(t,r,i);}),...t),n}try(e){const{stack:t}=this,n=[...t];try{return e()}finally{t.length=0,t.push(...n);}}match(...e){let t=this.stack.length-1,n=null,r=this.stack[t--];for(const i of e){if(void 0===r)return !1;let e=null;if("number"==typeof n&&(e=n,n=this.stack[t--],r=this.stack[t--]),i&&!i(r,n,e))return !1;n=this.stack[t--],r=this.stack[t--];}return !0}findAncestor(e){let t=this.stack.length-1,n=null,r=this.stack[t--];for(;r;){let i=null;if("number"==typeof n&&(i=n,n=this.stack[t--],r=this.stack[t--]),null!==n&&e(r,n,i))return r;n=this.stack[t--],r=this.stack[t--];}}};const{utils:{stripTrailingHardline:Hf}}=Ji$1,{normalize:Jf}=yp;var Xf={printSubtree:function(e,t,n,r){if(n.printer.embed&&"auto"===n.embeddedLanguageFormatting)return n.printer.embed(e,t,((e,t,i)=>function(e,t,n,r,{stripTrailingHardline:i=!1}={}){const u=Jf(Object.assign(Object.assign(Object.assign({},n),t),{},{parentParser:n.parser,originalText:e}),{passThrough:!0}),o=pp.parse(e,u),{ast:s}=o;e=o.text;const a=s.comments;delete s.comments,Wf.attach(a,s,e,u),u[Symbol.for("comments")]=a||[],u[Symbol.for("tokens")]=s.tokens||[];const l=r(s,u);if(Wf.ensureAllCommentsPrinted(a),i)return "string"==typeof l?l.replace(/(?:\r?\n)*$/,""):Hf(l);return l}(e,t,n,r,i)),n)}};const{builders:{hardline:Yf,addAlignmentToDoc:Kf},utils:{propagateBreaks:Qf}}=Ji$1,{printComments:Zf}=Wf;function ed(e,t,r=0){const{printer:i}=t;i.preprocess&&(e=i.preprocess(e,t));const u=new Map,o=new Gf(e);let s=a();return r>0&&(s=Kf([Yf,s],r,t.tabWidth)),Qf(s),s;function a(e,t){return void 0===e||e===o?l(t):Array.isArray(e)?o.call((()=>l(t)),...e):o.call((()=>l(t)),e)}function l(e){const r=o.getValue(),i=r&&"object"==typeof r&&void 0===e;if(i&&u.has(r))return u.get(r);const s=function(e,t,r,i){const u=e.getValue(),{printer:o}=t;let s,a;if(o.hasPrettierIgnore&&o.hasPrettierIgnore(e))({doc:s,printedComments:a}=function(e,t){const{originalText:n,[Symbol.for("comments")]:r,locStart:i,locEnd:u}=t,o=i(e),s=u(e),a=new Set;for(const e of r)i(e)>=o&&u(e)<=s&&(e.printed=!0,a.add(e));return {doc:n.slice(o,s),printedComments:a}}(u,t));else {if(u)try{s=Xf.printSubtree(e,r,t,ed);}catch(e){if(n$2.PRETTIER_DEBUG)throw e}s||(s=o.print(e,t,r,i));}o.willPrintOwnComments&&o.willPrintOwnComments(e,t)||(s=Zf(e,s,t,a));return s}(o,t,a,e);return i&&u.set(r,s),s}}var td=ed;function nd(e){let t=e.length-1;for(;;){const n=e[t];if(!n||"Program"!==n.type&&"File"!==n.type)break;t--;}return e.slice(0,t+1)}function rd(e,t,n,r,i=[],u){const{locStart:o,locEnd:s}=n,a=o(e),l=s(e);if(!(t>l||t<a||"rangeEnd"===u&&t===a||"rangeStart"===u&&t===l)){for(const o of Wf.getSortedChildNodes(e,n)){const s=rd(o,t,n,r,[e,...i],u);if(s)return s}return !r||r(e,i[0])?{node:e,parentNodes:i}:void 0}}const id=new Set(["ObjectExpression","ArrayExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","UnaryExpression","TemplateLiteral"]),ud=new Set(["OperationDefinition","FragmentDefinition","VariableDefinition","TypeExtensionDefinition","ObjectTypeDefinition","FieldDefinition","DirectiveDefinition","EnumTypeDefinition","EnumValueDefinition","InputValueDefinition","InputObjectTypeDefinition","SchemaDefinition","OperationTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","ScalarTypeDefinition"]);function od(e,t,n){if(!t)return !1;switch(e.parser){case"flow":case"babel":case"babel-flow":case"babel-ts":case"typescript":case"espree":case"meriyah":case"__babel_estree":return function(e,t){return "DeclareExportDeclaration"!==t&&"TypeParameterDeclaration"!==e&&("Directive"===e||"TypeAlias"===e||"TSExportAssignment"===e||e.startsWith("Declare")||e.startsWith("TSDeclare")||e.endsWith("Statement")||e.endsWith("Declaration"))}(t.type,n&&n.type);case"json":case"json5":case"json-stringify":return id.has(t.type);case"graphql":return ud.has(t.kind);case"vue":return "root"!==t.tag}return !1}var sd={calculateRange:function(e,t,n){let{rangeStart:r,rangeEnd:i,locStart:u,locEnd:o}=t;yf.ok(i>r);const s=e.slice(r,i).search(/\S/),a=-1===s;if(!a)for(r+=s;i>r&&!/\S/.test(e[i-1]);--i);const l=rd(n,r,t,((e,n)=>od(t,e,n)),[],"rangeStart"),c=a?l:rd(n,i,t,(e=>od(t,e)),[],"rangeEnd");if(!l||!c)return {rangeStart:0,rangeEnd:0};let p,f;if((({parser:e})=>"json"===e||"json5"===e||"json-stringify"===e)(t)){const e=function(e,t){const n=[e.node,...e.parentNodes],r=new Set([t.node,...t.parentNodes]);return n.find((e=>id.has(e.type)&&r.has(e)))}(l,c);p=e,f=e;}else ({startNode:p,endNode:f}=function(e,t,{locStart:n,locEnd:r}){let i=e.node,u=t.node;if(i===u)return {startNode:i,endNode:u};const o=n(e.node);for(const e of nd(t.parentNodes)){if(!(n(e)>=o))break;u=e;}const s=r(t.node);for(const t of nd(e.parentNodes)){if(!(r(t)<=s))break;i=t;}return {startNode:i,endNode:u}}(l,c,t));return {rangeStart:Math.min(u(p),u(f)),rangeEnd:Math.max(o(p),o(f))}},findNodeAtOffset:rd};const{printer:{printDocToString:ad},debug:{printDocToDebug:ld}}=Ji$1,{getAlignmentSize:cd}=fi$1,{guessEndOfLine:pd,convertEndOfLineToChars:fd,countEndOfLineChars:dd,normalizeEndOfLine:hd}=di$1,gd=yp.normalize,md=Symbol("cursor");function yd(e,t,n){const r=t.comments;return r&&(delete t.comments,Wf.attach(r,t,e,n)),n[Symbol.for("comments")]=r||[],n[Symbol.for("tokens")]=t.tokens||[],n.originalText=e,r}function Dd(e,t,n=0){if(!e||0===e.trim().length)return {formatted:"",cursorOffset:-1,comments:[]};const{ast:r,text:i}=pp.parse(e,t);if(t.cursorOffset>=0){const e=sd.findNodeAtOffset(r,t.cursorOffset,t);e&&e.node&&(t.cursorNode=e.node);}const u=yd(i,r,t),o=td(r,t,n),s=ad(o,t);if(Wf.ensureAllCommentsPrinted(u),n>0){const e=s.formatted.trim();void 0!==s.cursorNodeStart&&(s.cursorNodeStart-=s.formatted.indexOf(e)),s.formatted=e+fd(t.endOfLine);}if(t.cursorOffset>=0){let e,n,r,o,a;if(t.cursorNode&&s.cursorNodeText?(e=t.locStart(t.cursorNode),n=i.slice(e,t.locEnd(t.cursorNode)),r=t.cursorOffset-e,o=s.cursorNodeStart,a=s.cursorNodeText):(e=0,n=i,r=t.cursorOffset,o=0,a=s.formatted),n===a)return {formatted:s.formatted,cursorOffset:o+r,comments:u};const l=n.split("");l.splice(r,0,md);const c=a.split(""),p=sn$1.diffArrays(l,c);let f=o;for(const e of p)if(e.removed){if(e.value.includes(md))break}else f+=e.count;return {formatted:s.formatted,cursorOffset:f,comments:u}}return {formatted:s.formatted,cursorOffset:-1,comments:u}}function Ed(e,t,n){return "number"!=typeof t||Number.isNaN(t)||t<0||t>e.length?n:t}function bd(e,t){let{cursorOffset:n,rangeStart:r,rangeEnd:i}=t;return n=Ed(e,n,-1),r=Ed(e,r,0),i=Ed(e,i,e.length),Object.assign(Object.assign({},t),{},{cursorOffset:n,rangeStart:r,rangeEnd:i})}function Cd(e,t){let{cursorOffset:n,rangeStart:r,rangeEnd:i,endOfLine:u}=bd(e,t);const o="\ufeff"===e.charAt(0);if(o&&(e=e.slice(1),n--,r--,i--),"auto"===u&&(u=pd(e)),e.includes("\r")){const t=t=>dd(e.slice(0,Math.max(t,0)),"\r\n");n-=t(n),r-=t(r),i-=t(i),e=hd(e);}return {hasBOM:o,text:e,options:bd(e,Object.assign(Object.assign({},t),{},{cursorOffset:n,rangeStart:r,rangeEnd:i,endOfLine:u}))}}function vd(e,t){const n=pp.resolveParser(t);return !n.hasPragma||n.hasPragma(e)}function Ad(e,t){let n,{hasBOM:r,text:i,options:u}=Cd(e,gd(t));return u.rangeStart>=u.rangeEnd&&""!==i||u.requirePragma&&!vd(i,u)?{formatted:e,cursorOffset:t.cursorOffset,comments:[]}:(u.rangeStart>0||u.rangeEnd<i.length?n=function(e,t){const{ast:n,text:r}=pp.parse(e,t),{rangeStart:i,rangeEnd:u}=sd.calculateRange(r,t,n),o=r.slice(i,u),s=Math.min(i,r.lastIndexOf("\n",i)+1),a=r.slice(s,i).match(/^\s*/)[0],l=cd(a,t.tabWidth),c=Dd(o,Object.assign(Object.assign({},t),{},{rangeStart:0,rangeEnd:Number.POSITIVE_INFINITY,cursorOffset:t.cursorOffset>i&&t.cursorOffset<=u?t.cursorOffset-i:-1,endOfLine:"lf"}),l),p=c.formatted.trimEnd();let{cursorOffset:f}=t;f>u?f+=p.length-o.length:c.cursorOffset>=0&&(f=c.cursorOffset+i);let d=r.slice(0,i)+p+r.slice(u);if("lf"!==t.endOfLine){const e=fd(t.endOfLine);f>=0&&"\r\n"===e&&(f+=dd(d.slice(0,f),"\n")),d=d.replace(/\n/g,e);}return {formatted:d,cursorOffset:f,comments:c.comments}}(i,u):(!u.requirePragma&&u.insertPragma&&u.printer.insertPragma&&!vd(i,u)&&(i=u.printer.insertPragma(i)),n=Dd(i,u)),r&&(n.formatted="\ufeff"+n.formatted,n.cursorOffset>=0&&n.cursorOffset++),n)}var Fd={formatWithCursor:Ad,parse(e,t,n){const{text:r,options:i}=Cd(e,gd(t)),u=pp.parse(r,i);return n&&(u.ast=Dp(u.ast,i)),u},formatAST(e,t){t=gd(t);const n=td(e,t);return ad(n,t)},formatDoc:(e,t)=>Ad(ld(e),Object.assign(Object.assign({},t),{},{parser:"__js_expression"})).formatted,printToDoc(e,t){t=gd(t);const{ast:n,text:r}=pp.parse(e,t);return yd(r,n,t),td(n,t)},printDocToString:(e,t)=>ad(e,gd(t))};const{getMaxContinuousCount:xd,getStringWidth:Sd,getAlignmentSize:wd,getIndentSize:Td,skip:Bd,skipWhitespace:kd,skipSpaces:Nd,skipNewline:Pd,skipToLineEnd:Od,skipEverythingButNewLine:Id,skipInlineComment:jd,skipTrailingComment:Ld,hasNewline:_d,hasNewlineInRange:Md,hasSpaces:Rd,isNextLineEmpty:$d,isNextLineEmptyAfterIndex:Vd,isPreviousLineEmpty:qd,getNextNonSpaceNonCommentCharacterIndex:Wd,makeString:Ud,addLeadingComment:zd,addDanglingComment:Gd,addTrailingComment:Hd}=fi$1;var Jd={getMaxContinuousCount:xd,getStringWidth:Sd,getAlignmentSize:wd,getIndentSize:Td,skip:Bd,skipWhitespace:kd,skipSpaces:Nd,skipNewline:Pd,skipToLineEnd:Od,skipEverythingButNewLine:Id,skipInlineComment:jd,skipTrailingComment:Ld,hasNewline:_d,hasNewlineInRange:Md,hasSpaces:Rd,isNextLineEmpty:$d,isNextLineEmptyAfterIndex:Vd,isPreviousLineEmpty:qd,getNextNonSpaceNonCommentCharacterIndex:Wd,makeString:Ud,addLeadingComment:zd,addDanglingComment:Gd,addTrailingComment:Hd};const Xd=["languageId"];var Yd=function(t,n){const{languageId:r}=t,i=e$2(t,Xd);return Object.assign(Object.assign({linguistLanguageId:r},i),n(t))},Kd=i$2((function(e){!function(){function t(e){if(null==e)return !1;switch(e.type){case"BlockStatement":case"BreakStatement":case"ContinueStatement":case"DebuggerStatement":case"DoWhileStatement":case"EmptyStatement":case"ExpressionStatement":case"ForInStatement":case"ForStatement":case"IfStatement":case"LabeledStatement":case"ReturnStatement":case"SwitchStatement":case"ThrowStatement":case"TryStatement":case"VariableDeclaration":case"WhileStatement":case"WithStatement":return !0}return !1}function n(e){switch(e.type){case"IfStatement":return null!=e.alternate?e.alternate:e.consequent;case"LabeledStatement":case"ForStatement":case"ForInStatement":case"WhileStatement":case"WithStatement":return e.body}return null}e.exports={isExpression:function(e){if(null==e)return !1;switch(e.type){case"ArrayExpression":case"AssignmentExpression":case"BinaryExpression":case"CallExpression":case"ConditionalExpression":case"FunctionExpression":case"Identifier":case"Literal":case"LogicalExpression":case"MemberExpression":case"NewExpression":case"ObjectExpression":case"SequenceExpression":case"ThisExpression":case"UnaryExpression":case"UpdateExpression":return !0}return !1},isStatement:t,isIterationStatement:function(e){if(null==e)return !1;switch(e.type){case"DoWhileStatement":case"ForInStatement":case"ForStatement":case"WhileStatement":return !0}return !1},isSourceElement:function(e){return t(e)||null!=e&&"FunctionDeclaration"===e.type},isProblematicIfStatement:function(e){var t;if("IfStatement"!==e.type)return !1;if(null==e.alternate)return !1;t=e.consequent;do{if("IfStatement"===t.type&&null==t.alternate)return !0;t=n(t);}while(t);return !1},trailingStatement:n};}();})),Qd=i$2((function(e){!function(){var t,n,r,i,u,o;function s(e){return e<=65535?String.fromCharCode(e):String.fromCharCode(Math.floor((e-65536)/1024)+55296)+String.fromCharCode((e-65536)%1024+56320)}for(n={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,NonAsciiIdentifierPart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/},t={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,NonAsciiIdentifierPart:/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/},r=[5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279],i=new Array(128),o=0;o<128;++o)i[o]=o>=97&&o<=122||o>=65&&o<=90||36===o||95===o;for(u=new Array(128),o=0;o<128;++o)u[o]=o>=97&&o<=122||o>=65&&o<=90||o>=48&&o<=57||36===o||95===o;e.exports={isDecimalDigit:function(e){return 48<=e&&e<=57},isHexDigit:function(e){return 48<=e&&e<=57||97<=e&&e<=102||65<=e&&e<=70},isOctalDigit:function(e){return e>=48&&e<=55},isWhiteSpace:function(e){return 32===e||9===e||11===e||12===e||160===e||e>=5760&&r.indexOf(e)>=0},isLineTerminator:function(e){return 10===e||13===e||8232===e||8233===e},isIdentifierStartES5:function(e){return e<128?i[e]:n.NonAsciiIdentifierStart.test(s(e))},isIdentifierPartES5:function(e){return e<128?u[e]:n.NonAsciiIdentifierPart.test(s(e))},isIdentifierStartES6:function(e){return e<128?i[e]:t.NonAsciiIdentifierStart.test(s(e))},isIdentifierPartES6:function(e){return e<128?u[e]:t.NonAsciiIdentifierPart.test(s(e))}};}();})),Zd=i$2((function(e){!function(){var t=Qd;function n(e,t){return !(!t&&"yield"===e)&&r(e,t)}function r(e,t){if(t&&function(e){switch(e){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"let":return !0;default:return !1}}(e))return !0;switch(e.length){case 2:return "if"===e||"in"===e||"do"===e;case 3:return "var"===e||"for"===e||"new"===e||"try"===e;case 4:return "this"===e||"else"===e||"case"===e||"void"===e||"with"===e||"enum"===e;case 5:return "while"===e||"break"===e||"catch"===e||"throw"===e||"const"===e||"yield"===e||"class"===e||"super"===e;case 6:return "return"===e||"typeof"===e||"delete"===e||"switch"===e||"export"===e||"import"===e;case 7:return "default"===e||"finally"===e||"extends"===e;case 8:return "function"===e||"continue"===e||"debugger"===e;case 10:return "instanceof"===e;default:return !1}}function i(e,t){return "null"===e||"true"===e||"false"===e||n(e,t)}function u(e,t){return "null"===e||"true"===e||"false"===e||r(e,t)}function o(e){var n,r,i;if(0===e.length)return !1;if(i=e.charCodeAt(0),!t.isIdentifierStartES5(i))return !1;for(n=1,r=e.length;n<r;++n)if(i=e.charCodeAt(n),!t.isIdentifierPartES5(i))return !1;return !0}function s(e){var n,r,i,u,o;if(0===e.length)return !1;for(o=t.isIdentifierStartES6,n=0,r=e.length;n<r;++n){if(55296<=(i=e.charCodeAt(n))&&i<=56319){if(++n>=r)return !1;if(!(56320<=(u=e.charCodeAt(n))&&u<=57343))return !1;i=1024*(i-55296)+(u-56320)+65536;}if(!o(i))return !1;o=t.isIdentifierPartES6;}return !0}e.exports={isKeywordES5:n,isKeywordES6:r,isReservedWordES5:i,isReservedWordES6:u,isRestrictedWord:function(e){return "eval"===e||"arguments"===e},isIdentifierNameES5:o,isIdentifierNameES6:s,isIdentifierES5:function(e,t){return o(e)&&!i(e,t)},isIdentifierES6:function(e,t){return s(e)&&!u(e,t)}};}();}));const eh=i$2((function(e,t){t.ast=Kd,t.code=Qd,t.keyword=Zd;})).keyword.isIdentifierNameES5,{getLast:th,hasNewline:nh,skipWhitespace:rh,isNonEmptyArray:ih,isNextLineEmptyAfterIndex:uh}=fi$1,{locStart:oh,locEnd:sh,hasSameLocStart:ah}=Rl,lh=new RegExp("^(?:(?=.)\\s)*:"),ch=new RegExp("^(?:(?=.)\\s)*::");function ph(e){return "Block"===e.type||"CommentBlock"===e.type||"MultiLine"===e.type}function fh(e){return "Line"===e.type||"CommentLine"===e.type||"SingleLine"===e.type||"HashbangComment"===e.type||"HTMLOpen"===e.type||"HTMLClose"===e.type}const dh=new Set(["ExportDefaultDeclaration","ExportDefaultSpecifier","DeclareExportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"]);function hh(e){return e&&dh.has(e.type)}function gh(e){return "NumericLiteral"===e.type||"Literal"===e.type&&"number"==typeof e.value}function mh(e){return "StringLiteral"===e.type||"Literal"===e.type&&"string"==typeof e.value}function yh(e){return "FunctionExpression"===e.type||"ArrowFunctionExpression"===e.type}function Dh(e){return xh(e)&&"Identifier"===e.callee.type&&("async"===e.callee.name||"inject"===e.callee.name||"fakeAsync"===e.callee.name)}function Eh(e){return "JSXElement"===e.type||"JSXFragment"===e.type}function bh(e){return "get"===e.kind||"set"===e.kind}function Ch(e){return bh(e)||ah(e,e.value)}const vh=new Set(["BinaryExpression","LogicalExpression","NGPipeExpression"]);const Ah=new Set(["AnyTypeAnnotation","TSAnyKeyword","NullLiteralTypeAnnotation","TSNullKeyword","ThisTypeAnnotation","TSThisType","NumberTypeAnnotation","TSNumberKeyword","VoidTypeAnnotation","TSVoidKeyword","BooleanTypeAnnotation","TSBooleanKeyword","BigIntTypeAnnotation","TSBigIntKeyword","SymbolTypeAnnotation","TSSymbolKeyword","StringTypeAnnotation","TSStringKeyword","BooleanLiteralTypeAnnotation","StringLiteralTypeAnnotation","BigIntLiteralTypeAnnotation","NumberLiteralTypeAnnotation","TSLiteralType","TSTemplateLiteralType","EmptyTypeAnnotation","MixedTypeAnnotation","TSNeverKeyword","TSObjectKeyword","TSUndefinedKeyword","TSUnknownKeyword"]);const Fh=/^(skip|[fx]?(it|describe|test))$/;function xh(e){return e&&("CallExpression"===e.type||"OptionalCallExpression"===e.type)}function Sh(e){return e&&("MemberExpression"===e.type||"OptionalMemberExpression"===e.type)}function wh(e){return /^(\d+|\d+\.\d+)$/.test(e)}function Th(e){return e.quasis.some((e=>e.value.raw.includes("\n")))}function Bh(e){return e.extra?e.extra.raw:e.raw}const kh={"==":!0,"!=":!0,"===":!0,"!==":!0},Nh={"*":!0,"/":!0,"%":!0},Ph={">>":!0,">>>":!0,"<<":!0};const Oh={};for(const[e,t]of [["|>"],["??"],["||"],["&&"],["|"],["^"],["&"],["==","===","!=","!=="],["<",">","<=",">=","in","instanceof"],[">>","<<",">>>"],["+","-"],["*","/","%"],["**"]].entries())for(const n of t)Oh[n]=e;function Ih(e){return Oh[e]}const jh=new WeakMap;function Lh(e){if(jh.has(e))return jh.get(e);const t=[];return e.this&&t.push(e.this),Array.isArray(e.parameters)?t.push(...e.parameters):Array.isArray(e.params)&&t.push(...e.params),e.rest&&t.push(e.rest),jh.set(e,t),t}const _h=new WeakMap;function Mh(e){if(_h.has(e))return _h.get(e);let t=e.arguments;return "ImportExpression"===e.type&&(t=[e.source],e.attributes&&t.push(e.attributes)),_h.set(e,t),t}function Rh(e){return "prettier-ignore"===e.value.trim()&&!e.unignore}function $h(e){return e&&(e.prettierIgnore||Wh(e,Vh.PrettierIgnore))}const Vh={Leading:2,Trailing:4,Dangling:8,Block:16,Line:32,PrettierIgnore:64,First:128,Last:256},qh=(e,t)=>{if("function"==typeof e&&(t=e,e=0),e||t)return (n,r,i)=>!(e&Vh.Leading&&!n.leading||e&Vh.Trailing&&!n.trailing||e&Vh.Dangling&&(n.leading||n.trailing)||e&Vh.Block&&!ph(n)||e&Vh.Line&&!fh(n)||e&Vh.First&&0!==r||e&Vh.Last&&r!==i.length-1||e&Vh.PrettierIgnore&&!Rh(n)||t&&!t(n))};function Wh(e,t,n){if(!e||!ih(e.comments))return !1;const r=qh(t,n);return !r||e.comments.some(r)}function Uh(e,t,n){if(!e||!Array.isArray(e.comments))return [];const r=qh(t,n);return r?e.comments.filter(r):e.comments}function zh(e){return xh(e)||"NewExpression"===e.type||"ImportExpression"===e.type}var Gh={getFunctionParameters:Lh,iterateFunctionParametersPath:function(e,t){const n=e.getValue();let r=0;const i=e=>t(e,r++);n.this&&e.call(i,"this"),Array.isArray(n.parameters)?e.each(i,"parameters"):Array.isArray(n.params)&&e.each(i,"params"),n.rest&&e.call(i,"rest");},getCallArguments:Mh,iterateCallArgumentsPath:function(e,t){const n=e.getValue();"ImportExpression"===n.type?(e.call((e=>t(e,0)),"source"),n.attributes&&e.call((e=>t(e,1)),"attributes")):e.each(t,"arguments");},hasRestParameter:function(e){if(e.rest)return !0;const t=Lh(e);return t.length>0&&"RestElement"===th(t).type},getLeftSide:function(e){return e.expressions?e.expressions[0]:e.left||e.test||e.callee||e.object||e.tag||e.argument||e.expression},getLeftSidePathName:function(e,t){if(t.expressions)return ["expressions",0];if(t.left)return ["left"];if(t.test)return ["test"];if(t.object)return ["object"];if(t.callee)return ["callee"];if(t.tag)return ["tag"];if(t.argument)return ["argument"];if(t.expression)return ["expression"];throw new Error("Unexpected node has no left side.")},getParentExportDeclaration:function(e){const t=e.getParentNode();return "declaration"===e.getName()&&hh(t)?t:null},getTypeScriptMappedTypeModifier:function(e,t){return "+"===e?"+"+t:"-"===e?"-"+t:t},hasFlowAnnotationComment:function(e){return e&&ph(e[0])&&ch.test(e[0].value)},hasFlowShorthandAnnotationComment:function(e){return e.extra&&e.extra.parenthesized&&ih(e.trailingComments)&&ph(e.trailingComments[0])&&lh.test(e.trailingComments[0].value)},hasLeadingOwnLineComment:function(e,t){return Eh(t)?$h(t):Wh(t,Vh.Leading,(t=>nh(e,sh(t))))},hasNakedLeftSide:function(e){return "AssignmentExpression"===e.type||"BinaryExpression"===e.type||"LogicalExpression"===e.type||"NGPipeExpression"===e.type||"ConditionalExpression"===e.type||xh(e)||Sh(e)||"SequenceExpression"===e.type||"TaggedTemplateExpression"===e.type||"BindExpression"===e.type||"UpdateExpression"===e.type&&!e.prefix||"TSAsExpression"===e.type||"TSNonNullExpression"===e.type},hasNode:function e(t,n){if(!t||"object"!=typeof t)return !1;if(Array.isArray(t))return t.some((t=>e(t,n)));const r=n(t);return "boolean"==typeof r?r:Object.values(t).some((t=>e(t,n)))},hasIgnoreComment:function(e){return $h(e.getValue())},hasNodeIgnoreComment:$h,identity:function(e){return e},isBinaryish:function(e){return vh.has(e.type)},isBlockComment:ph,isCallLikeExpression:zh,isLineComment:fh,isPrettierIgnoreComment:Rh,isCallExpression:xh,isMemberExpression:Sh,isExportDeclaration:hh,isFlowAnnotationComment:function(e,t){const n=oh(t),r=rh(e,sh(t));return !1!==r&&"/*"===e.slice(n,n+2)&&"*/"===e.slice(r,r+2)},isFunctionCompositionArgs:function(e){if(e.length<=1)return !1;let t=0;for(const n of e)if(yh(n)){if(t+=1,t>1)return !0}else if(xh(n))for(const e of n.arguments)if(yh(e))return !0;return !1},isFunctionNotation:Ch,isFunctionOrArrowExpression:yh,isGetterOrSetter:bh,isJestEachTemplateLiteral:function(e,t){const n=/^[fx]?(describe|it|test)$/;return "TaggedTemplateExpression"===t.type&&t.quasi===e&&"MemberExpression"===t.tag.type&&"Identifier"===t.tag.property.type&&"each"===t.tag.property.name&&("Identifier"===t.tag.object.type&&n.test(t.tag.object.name)||"MemberExpression"===t.tag.object.type&&"Identifier"===t.tag.object.property.type&&("only"===t.tag.object.property.name||"skip"===t.tag.object.property.name)&&"Identifier"===t.tag.object.object.type&&n.test(t.tag.object.object.name))},isJsxNode:Eh,isLiteral:function(e){return "BooleanLiteral"===e.type||"DirectiveLiteral"===e.type||"Literal"===e.type||"NullLiteral"===e.type||"NumericLiteral"===e.type||"BigIntLiteral"===e.type||"DecimalLiteral"===e.type||"RegExpLiteral"===e.type||"StringLiteral"===e.type||"TemplateLiteral"===e.type||"TSTypeLiteral"===e.type||"JSXText"===e.type},isLongCurriedCallExpression:function(e){const t=e.getValue(),n=e.getParentNode();return xh(t)&&xh(n)&&n.callee===t&&t.arguments.length>n.arguments.length&&n.arguments.length>0},isSimpleCallArgument:function e(t,n){if(n>=2)return !1;const r=t=>e(t,n+1),i="Literal"===t.type&&"regex"in t&&t.regex.pattern||"RegExpLiteral"===t.type&&t.pattern;return !(i&&i.length>5)&&("Literal"===t.type||"BigIntLiteral"===t.type||"DecimalLiteral"===t.type||"BooleanLiteral"===t.type||"NullLiteral"===t.type||"NumericLiteral"===t.type||"RegExpLiteral"===t.type||"StringLiteral"===t.type||"Identifier"===t.type||"ThisExpression"===t.type||"Super"===t.type||"PrivateName"===t.type||"PrivateIdentifier"===t.type||"ArgumentPlaceholder"===t.type||"Import"===t.type||("TemplateLiteral"===t.type?t.quasis.every((e=>!e.value.raw.includes("\n")))&&t.expressions.every(r):"ObjectExpression"===t.type?t.properties.every((e=>!e.computed&&(e.shorthand||e.value&&r(e.value)))):"ArrayExpression"===t.type?t.elements.every((e=>null===e||r(e))):zh(t)?("ImportExpression"===t.type||e(t.callee,n))&&Mh(t).every(r):Sh(t)?e(t.object,n)&&e(t.property,n):"UnaryExpression"!==t.type||"!"!==t.operator&&"-"!==t.operator?"TSNonNullExpression"===t.type&&e(t.expression,n):e(t.argument,n)))},isMemberish:function(e){return Sh(e)||"BindExpression"===e.type&&Boolean(e.object)},isNumericLiteral:gh,isSignedNumericLiteral:function(e){return "UnaryExpression"===e.type&&("+"===e.operator||"-"===e.operator)&&gh(e.argument)},isObjectProperty:function(e){return e&&("ObjectProperty"===e.type||"Property"===e.type&&!e.method&&"init"===e.kind)},isObjectType:function(e){return "ObjectTypeAnnotation"===e.type||"TSTypeLiteral"===e.type},isObjectTypePropertyAFunction:function(e){return !("ObjectTypeProperty"!==e.type&&"ObjectTypeInternalSlot"!==e.type||"FunctionTypeAnnotation"!==e.value.type||e.static||Ch(e))},isSimpleType:function(e){return !!e&&(!("GenericTypeAnnotation"!==e.type&&"TSTypeReference"!==e.type||e.typeParameters)||!!Ah.has(e.type))},isSimpleNumber:wh,isSimpleTemplateLiteral:function(e){let t="expressions";"TSTemplateLiteralType"===e.type&&(t="types");const n=e[t];return 0!==n.length&&n.every((e=>{if(Wh(e))return !1;if("Identifier"===e.type||"ThisExpression"===e.type)return !0;if(Sh(e)){let t=e;for(;Sh(t);){if("Identifier"!==t.property.type&&"Literal"!==t.property.type&&"StringLiteral"!==t.property.type&&"NumericLiteral"!==t.property.type)return !1;if(t=t.object,Wh(t))return !1}return "Identifier"===t.type||"ThisExpression"===t.type}return !1}))},isStringLiteral:mh,isStringPropSafeToUnquote:function(e,t){return "json"!==t.parser&&mh(e.key)&&Bh(e.key).slice(1,-1)===e.key.value&&(eh(e.key.value)&&!(("typescript"===t.parser||"babel-ts"===t.parser)&&"ClassProperty"===e.type)||wh(e.key.value)&&String(Number(e.key.value))===e.key.value&&("babel"===t.parser||"espree"===t.parser||"meriyah"===t.parser||"__babel_estree"===t.parser))},isTemplateOnItsOwnLine:function(e,t){return ("TemplateLiteral"===e.type&&Th(e)||"TaggedTemplateExpression"===e.type&&Th(e.quasi))&&!nh(t,oh(e),{backwards:!0})},isTestCall:function e(t,n){if("CallExpression"!==t.type)return !1;if(1===t.arguments.length){if(Dh(t)&&n&&e(n))return yh(t.arguments[0]);if(function(e){return "Identifier"===e.callee.type&&/^(before|after)(Each|All)$/.test(e.callee.name)&&1===e.arguments.length}(t))return Dh(t.arguments[0])}else if((2===t.arguments.length||3===t.arguments.length)&&("Identifier"===t.callee.type&&Fh.test(t.callee.name)||function(e){return Sh(e.callee)&&"Identifier"===e.callee.object.type&&"Identifier"===e.callee.property.type&&Fh.test(e.callee.object.name)&&("only"===e.callee.property.name||"skip"===e.callee.property.name)}(t))&&(function(e){return "TemplateLiteral"===e.type}(t.arguments[0])||mh(t.arguments[0])))return !(t.arguments[2]&&!gh(t.arguments[2]))&&((2===t.arguments.length?yh(t.arguments[1]):function(e){return "FunctionExpression"===e.type||"ArrowFunctionExpression"===e.type&&"BlockStatement"===e.body.type}(t.arguments[1])&&Lh(t.arguments[1]).length<=1)||Dh(t.arguments[1]));return !1},isTheOnlyJsxElementInMarkdown:function(e,t){if("markdown"!==e.parentParser&&"mdx"!==e.parentParser)return !1;const n=t.getNode();if(!n.expression||!Eh(n.expression))return !1;const r=t.getParentNode();return "Program"===r.type&&1===r.body.length},isTSXFile:function(e){return e.filepath&&/\.tsx$/i.test(e.filepath)},isTypeAnnotationAFunction:function(e){return !("TypeAnnotation"!==e.type&&"TSTypeAnnotation"!==e.type||"FunctionTypeAnnotation"!==e.typeAnnotation.type||e.static||ah(e,e.typeAnnotation))},isNextLineEmpty:(e,{originalText:t})=>uh(t,sh(e)),needsHardlineAfterDanglingComment:function(e){if(!Wh(e))return !1;const t=th(Uh(e,Vh.Dangling));return t&&!ph(t)},rawText:Bh,shouldPrintComma:function(e,t="es5"){return "es5"===e.trailingComma&&"es5"===t||"all"===e.trailingComma&&("all"===t||"es5"===t)},isBitwiseOperator:function(e){return Boolean(Ph[e])||"|"===e||"^"===e||"&"===e},shouldFlatten:function(e,t){return Ih(t)===Ih(e)&&("**"!==e&&((!kh[e]||!kh[t])&&(!("%"===t&&Nh[e]||"%"===e&&Nh[t])&&((t===e||!Nh[t]||!Nh[e])&&(!Ph[e]||!Ph[t])))))},startsWithNoLookaheadToken:function e(t,n){switch((t=function(e){for(;e.left;)e=e.left;return e}(t)).type){case"FunctionExpression":case"ClassExpression":case"DoExpression":return n;case"ObjectExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":return e(t.object,n);case"TaggedTemplateExpression":return "FunctionExpression"!==t.tag.type&&e(t.tag,n);case"CallExpression":case"OptionalCallExpression":return "FunctionExpression"!==t.callee.type&&e(t.callee,n);case"ConditionalExpression":return e(t.test,n);case"UpdateExpression":return !t.prefix&&e(t.argument,n);case"BindExpression":return t.object&&e(t.object,n);case"SequenceExpression":return e(t.expressions[0],n);case"TSAsExpression":case"TSNonNullExpression":return e(t.expression,n);default:return !1}},getPrecedence:Ih,hasComment:Wh,getComments:Uh,CommentCheckFlags:Vh};const{getStringWidth:Hh,getIndentSize:Jh}=fi$1,{builders:{join:Xh,hardline:Yh,softline:Kh,group:Qh,indent:Zh,align:eg,lineSuffixBoundary:tg,addAlignmentToDoc:ng},printer:{printDocToString:rg},utils:{mapDoc:ig}}=Ji$1,{isBinaryish:ug,isJestEachTemplateLiteral:og,isSimpleTemplateLiteral:sg,hasComment:ag,isMemberExpression:lg}=Gh;function cg(e){return e.replace(/([\\`]|\${)/g,"\\$1")}var pg={printTemplateLiteral:function(e,t,n){const r=e.getValue();if("TemplateLiteral"===r.type&&og(r,e.getParentNode())){const r=function(e,t,n){const r=e.getNode(),i=r.quasis[0].value.raw.trim().split(/\s*\|\s*/);if(i.length>1||i.some((e=>e.length>0))){t.__inJestEach=!0;const u=e.map(n,"expressions");t.__inJestEach=!1;const o=[],s=u.map((e=>"${"+rg(e,Object.assign(Object.assign({},t),{},{printWidth:Number.POSITIVE_INFINITY,endOfLine:"lf"})).formatted+"}")),a=[{hasLineBreak:!1,cells:[]}];for(let e=1;e<r.quasis.length;e++){const t=Sn$1(a),n=s[e-1];t.cells.push(n),n.includes("\n")&&(t.hasLineBreak=!0),r.quasis[e].value.raw.includes("\n")&&a.push({hasLineBreak:!1,cells:[]});}const l=Math.max(i.length,...a.map((e=>e.cells.length))),c=Array.from({length:l}).fill(0),p=[{cells:i},...a.filter((e=>e.cells.length>0))];for(const{cells:e}of p.filter((e=>!e.hasLineBreak)))for(const[t,n]of e.entries())c[t]=Math.max(c[t],Hh(n));return o.push(tg,"`",Zh([Yh,Xh(Yh,p.map((e=>Xh(" | ",e.cells.map(((t,n)=>e.hasLineBreak?t:t+" ".repeat(c[n]-Hh(t))))))))]),Yh,"`"),o}}(e,n,t);if(r)return r}let i="expressions";"TSTemplateLiteralType"===r.type&&(i="types");const u=[];let o=e.map(t,i);const s=sg(r);return s&&(o=o.map((e=>rg(e,Object.assign(Object.assign({},n),{},{printWidth:Number.POSITIVE_INFINITY})).formatted))),u.push(tg,"`"),e.each((e=>{const a=e.getName();if(u.push(t()),a<o.length){const{tabWidth:t}=n,l=e.getValue(),c=Jh(l.value.raw,t);let p=o[a];if(!s){const e=r[i][a];(ag(e)||lg(e)||"ConditionalExpression"===e.type||"SequenceExpression"===e.type||"TSAsExpression"===e.type||ug(e))&&(p=[Zh([Kh,p]),Kh]);}const f=0===c&&l.value.raw.endsWith("\n")?eg(Number.NEGATIVE_INFINITY,p):ng(p,c,t);u.push(Qh(["${",f,tg,"}"]));}}),"quasis"),u.push("`"),u},printTemplateExpressions:function(e,t){return e.map((e=>function(e,t){const n=e.getValue();let r=t();return ag(n)&&(r=Qh([Zh([Kh,r]),Kh])),["${",r,tg,"}"]}(e,t)),"expressions")},escapeTemplateCharacters:function(e,t){return ig(e,(e=>"string"==typeof e?t?e.replace(/(\\*)`/g,"$1$1\\`"):cg(e):e))},uncookTemplateElementValue:cg};const{builders:{indent:fg,softline:dg,literalline:hg,dedentToRoot:gg}}=Ji$1,{escapeTemplateCharacters:mg}=pg;var yg=function(e,t,n){let r=e.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g,((e,t)=>"\\".repeat(t.length/2)+"`"));const i=function(e){const t=e.match(/^([^\S\n]*)\S/m);return null===t?"":t[1]}(r),u=""!==i;u&&(r=r.replace(new RegExp(`^${i}`,"gm"),""));const o=mg(n(r,{parser:"markdown",__inJsTemplate:!0},{stripTrailingHardline:!0}),!0);return ["`",u?fg([dg,o]):[hg,gg(o)],dg,"`"]};const{isNonEmptyArray:Dg}=fi$1,{builders:{indent:Eg,hardline:bg,softline:Cg},utils:{mapDoc:vg,replaceNewlinesWithLiterallines:Ag,cleanDoc:Fg}}=Ji$1,{printTemplateExpressions:xg}=pg;var Sg=function(e,t,n){const r=e.getValue(),i=r.quasis.map((e=>e.value.raw));let u=0;return function(e,t,n){if(1===t.quasis.length&&!t.quasis[0].value.raw.trim())return "``";const r=function(e,t){if(!Dg(t))return e;let n=0;const r=vg(Fg(e),(e=>"string"==typeof e&&e.includes("@prettier-placeholder")?e.split(/@prettier-placeholder-(\d+)-id/).map(((e,r)=>r%2==0?Ag(e):(n++,t[e]))):e));return t.length===n?r:null}(e,n);if(!r)throw new Error("Couldn't insert all the expressions");return ["`",Eg([bg,r]),Cg,"`"]}(n(i.reduce(((e,t,n)=>0===n?t:e+"@prettier-placeholder-"+u+++"-id"+t),""),{parser:"scss"},{stripTrailingHardline:!0}),r,xg(e,t))};const{builders:{indent:wg,join:Tg,hardline:Bg}}=Ji$1,{escapeTemplateCharacters:kg,printTemplateExpressions:Ng}=pg;function Pg(e){const t=[];let n=!1;const r=e.map((e=>e.trim()));for(const[e,i]of r.entries())""!==i&&(""===r[e-1]&&n?t.push([Bg,i]):t.push(i),n=!0);return 0===t.length?null:Tg(Bg,t)}var Og=function(e,t,n){const r=e.getValue(),i=r.quasis.length;if(1===i&&""===r.quasis[0].value.raw.trim())return "``";const u=Ng(e,t),o=[];for(let e=0;e<i;e++){const t=0===e,s=e===i-1,a=r.quasis[e].value.cooked,l=a.split("\n"),c=l.length,p=u[e],f=c>2&&""===l[0].trim()&&""===l[1].trim(),d=c>2&&""===l[c-1].trim()&&""===l[c-2].trim(),h=l.every((e=>/^\s*(?:#[^\n\r]*)?$/.test(e)));if(!s&&/#[^\n\r]*$/.test(l[c-1]))return null;let g=null;g=h?Pg(l):n(a,{parser:"graphql"},{stripTrailingHardline:!0}),g?(g=kg(g,!1),!t&&f&&o.push(""),o.push(g),!s&&d&&o.push("")):t||s||!f||o.push(""),p&&o.push(p);}return ["`",wg([Bg,Tg(Bg,o)]),Bg,"`"]};const{builders:{indent:Ig,line:jg,hardline:Lg,group:_g},utils:{mapDoc:Mg}}=Ji$1,{printTemplateExpressions:Rg,uncookTemplateElementValue:$g}=pg;let Vg=0;var qg=function(e,t,n,r,{parser:i}){const u=e.getValue(),o=Vg;Vg=Vg+1>>>0;const s=e=>`PRETTIER_HTML_PLACEHOLDER_${e}_${o}_IN_JS`,a=u.quasis.map(((e,t,n)=>t===n.length-1?e.value.cooked:e.value.cooked+s(t))).join(""),l=Rg(e,t);if(0===l.length&&0===a.trim().length)return "``";const c=new RegExp(s("(\\d+)"),"g");let p=0;const f=n(a,{parser:i,__onHtmlRoot(e){p=e.children.length;}},{stripTrailingHardline:!0}),d=Mg(f,(e=>{if("string"!=typeof e)return e;const t=[],n=e.split(c);for(let e=0;e<n.length;e++){let i=n[e];if(e%2==0){i&&(i=$g(i),r.__embeddedInHtml&&(i=i.replace(/<\/(script)\b/gi,"<\\/$1")),t.push(i));continue}const u=Number(i);t.push(l[u]);}return t})),h=/^\s/.test(a)?" ":"",g=/\s$/.test(a)?" ":"",m="ignore"===r.htmlWhitespaceSensitivity?Lg:h&&g?jg:null;return _g(m?["`",Ig([m,_g(d)]),m,"`"]:["`",h,p>1?Ig(_g(d)):_g(d),g,"`"])};const{hasComment:Wg,CommentCheckFlags:Ug,isObjectProperty:zg}=Gh;function Gg(e){return function(e){const t=e.getValue(),n=e.getParentNode(),r=e.getParentNode(1);return r&&t.quasis&&"JSXExpressionContainer"===n.type&&"JSXElement"===r.type&&"style"===r.openingElement.name.name&&r.openingElement.attributes.some((e=>"jsx"===e.name.name))||n&&"TaggedTemplateExpression"===n.type&&"Identifier"===n.tag.type&&"css"===n.tag.name||n&&"TaggedTemplateExpression"===n.type&&"MemberExpression"===n.tag.type&&"css"===n.tag.object.name&&("global"===n.tag.property.name||"resolve"===n.tag.property.name)}(e)||function(e){const t=e.getParentNode();if(!t||"TaggedTemplateExpression"!==t.type)return !1;const{tag:n}=t;switch(n.type){case"MemberExpression":return Jg(n.object)||Xg(n);case"CallExpression":return Jg(n.callee)||"MemberExpression"===n.callee.type&&("MemberExpression"===n.callee.object.type&&(Jg(n.callee.object.object)||Xg(n.callee.object))||"CallExpression"===n.callee.object.type&&Jg(n.callee.object.callee));case"Identifier":return "css"===n.name;default:return !1}}(e)||function(e){const t=e.getParentNode(),n=e.getParentNode(1);return n&&"JSXExpressionContainer"===t.type&&"JSXAttribute"===n.type&&"JSXIdentifier"===n.name.type&&"css"===n.name.name}(e)||function(e){return e.match((e=>"TemplateLiteral"===e.type),((e,t)=>"ArrayExpression"===e.type&&"elements"===t),((e,t)=>zg(e)&&"Identifier"===e.key.type&&"styles"===e.key.name&&"value"===t),...Hg)}(e)?"css":function(e){const t=e.getValue(),n=e.getParentNode();return Yg(t,"GraphQL")||n&&("TaggedTemplateExpression"===n.type&&("MemberExpression"===n.tag.type&&"graphql"===n.tag.object.name&&"experimental"===n.tag.property.name||"Identifier"===n.tag.type&&("gql"===n.tag.name||"graphql"===n.tag.name))||"CallExpression"===n.type&&"Identifier"===n.callee.type&&"graphql"===n.callee.name)}(e)?"graphql":function(e){return Yg(e.getValue(),"HTML")||e.match((e=>"TemplateLiteral"===e.type),((e,t)=>"TaggedTemplateExpression"===e.type&&"Identifier"===e.tag.type&&"html"===e.tag.name&&"quasi"===t))}(e)?"html":function(e){return e.match((e=>"TemplateLiteral"===e.type),((e,t)=>zg(e)&&"Identifier"===e.key.type&&"template"===e.key.name&&"value"===t),...Hg)}(e)?"angular":function(e){const t=e.getValue(),n=e.getParentNode();return n&&"TaggedTemplateExpression"===n.type&&1===t.quasis.length&&"Identifier"===n.tag.type&&("md"===n.tag.name||"markdown"===n.tag.name)}(e)?"markdown":void 0}const Hg=[(e,t)=>"ObjectExpression"===e.type&&"properties"===t,(e,t)=>"CallExpression"===e.type&&"Identifier"===e.callee.type&&"Component"===e.callee.name&&"arguments"===t,(e,t)=>"Decorator"===e.type&&"expression"===t];function Jg(e){return "Identifier"===e.type&&"styled"===e.name}function Xg(e){return /^[A-Z]/.test(e.object.name)&&"extend"===e.property.name}function Yg(e,t){return Wg(e,Ug.Block|Ug.Leading,(({value:e})=>e===` ${t} `))}var Kg=function(e,t,n,r){const i=e.getValue();if("TemplateLiteral"!==i.type||function({quasis:e}){return e.some((({value:{cooked:e}})=>null===e))}(i))return;const u=Gg(e);return u?"markdown"===u?yg(e,t,n):"css"===u?Sg(e,t,n):"graphql"===u?Og(e,t,n):"html"===u||"angular"===u?qg(e,t,n,r,{parser:u}):void 0:void 0};const{isBlockComment:Qg}=Gh,Zg=new Set(["range","raw","comments","leadingComments","trailingComments","innerComments","extra","start","end","loc","flags","errors","tokens"]),em=e=>{for(const t of e.quasis)delete t.value;};function tm(e,t,n){if("Program"===e.type&&delete t.sourceType,"BigIntLiteral"!==e.type&&"BigIntLiteralTypeAnnotation"!==e.type||t.value&&(t.value=t.value.toLowerCase()),"BigIntLiteral"!==e.type&&"Literal"!==e.type||t.bigint&&(t.bigint=t.bigint.toLowerCase()),"DecimalLiteral"===e.type&&(t.value=Number(t.value)),"Literal"===e.type&&t.decimal&&(t.decimal=Number(t.decimal)),"EmptyStatement"===e.type)return null;if("JSXText"===e.type)return null;if("JSXExpressionContainer"===e.type&&("Literal"===e.expression.type||"StringLiteral"===e.expression.type)&&" "===e.expression.value)return null;if("Property"!==e.type&&"ObjectProperty"!==e.type&&"MethodDefinition"!==e.type&&"ClassProperty"!==e.type&&"ClassMethod"!==e.type&&"PropertyDefinition"!==e.type&&"TSDeclareMethod"!==e.type&&"TSPropertySignature"!==e.type&&"ObjectTypeProperty"!==e.type||"object"!=typeof e.key||!e.key||"Literal"!==e.key.type&&"NumericLiteral"!==e.key.type&&"StringLiteral"!==e.key.type&&"Identifier"!==e.key.type||delete t.key,"JSXElement"===e.type&&"style"===e.openingElement.name.name&&e.openingElement.attributes.some((e=>"jsx"===e.name.name)))for(const{type:e,expression:n}of t.children)"JSXExpressionContainer"===e&&"TemplateLiteral"===n.type&&em(n);"JSXAttribute"===e.type&&"css"===e.name.name&&"JSXExpressionContainer"===e.value.type&&"TemplateLiteral"===e.value.expression.type&&em(t.value.expression),"JSXAttribute"===e.type&&e.value&&"Literal"===e.value.type&&/["']|&quot;|&apos;/.test(e.value.value)&&(t.value.value=t.value.value.replace(/["']|&quot;|&apos;/g,'"'));const r=e.expression||e.callee;if("Decorator"===e.type&&"CallExpression"===r.type&&"Component"===r.callee.name&&1===r.arguments.length){const n=e.expression.arguments[0].properties;for(const[e,r]of t.expression.arguments[0].properties.entries())switch(n[e].key.name){case"styles":"ArrayExpression"===r.value.type&&em(r.value.elements[0]);break;case"template":"TemplateLiteral"===r.value.type&&em(r.value);}}if("TaggedTemplateExpression"!==e.type||"MemberExpression"!==e.tag.type&&("Identifier"!==e.tag.type||"gql"!==e.tag.name&&"graphql"!==e.tag.name&&"css"!==e.tag.name&&"md"!==e.tag.name&&"markdown"!==e.tag.name&&"html"!==e.tag.name)&&"CallExpression"!==e.tag.type||em(t.quasi),"TemplateLiteral"===e.type){(e.leadingComments&&e.leadingComments.some((e=>Qg(e)&&["GraphQL","HTML"].some((t=>e.value===` ${t} `))))||"CallExpression"===n.type&&"graphql"===n.callee.name||!e.leadingComments)&&em(t);}return "InterpreterDirective"===e.type&&(t.value=t.value.trimEnd()),"TSIntersectionType"!==e.type&&"TSUnionType"!==e.type||1!==e.types.length?void 0:t.types[0]}tm.ignoredProperties=Zg;var nm=tm;const rm=e=>{if("string"!=typeof e)throw new TypeError("Expected a string");const t=e.match(/(?:\r?\n)/g)||[];if(0===t.length)return;const n=t.filter((e=>"\r\n"===e)).length;return n>t.length-n?"\r\n":"\n"};var im=rm;im.graceful=e=>"string"==typeof e&&rm(e)||"\n";var um=function(e){const t=e.match(hm);return t?t[0].trimLeft():""},om=function(e){const t=e.match(hm);return t&&t[0]?e.substring(t[0].length):e},sm=function(e){return Cm(e).pragmas},am=Cm,lm=function({comments:e="",pragmas:t={}}){const n=(0, pm().default)(e)||cm().EOL,r=" *",i=Object.keys(t),u=i.map((e=>vm(e,t[e]))).reduce(((e,t)=>e.concat(t)),[]).map((e=>" * "+e+n)).join("");if(!e){if(0===i.length)return "";if(1===i.length&&!Array.isArray(t[i[0]])){const e=t[i[0]];return `/** ${vm(i[0],e)[0]} */`}}const o=e.split(n).map((e=>` * ${e}`)).join(n)+n;return "/**"+n+(e?o:"")+(e&&i.length?r+n:"")+u+" */"};function cm(){const e=Qo;return cm=function(){return e},e}function pm(){const e=function(e){return e&&e.__esModule?e:{default:e}}(im);return pm=function(){return e},e}const fm=/\*\/$/,dm=/^\/\*\*/,hm=/^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,gm=/(^|\s+)\/\/([^\r\n]*)/g,mm=/^(\r?\n)+/,ym=/(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,Dm=/(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,Em=/(\r?\n|^) *\* ?/g,bm=[];function Cm(e){const t=(0, pm().default)(e)||cm().EOL;e=e.replace(dm,"").replace(fm,"").replace(Em,"$1");let n="";for(;n!==e;)n=e,e=e.replace(ym,`${t}$1 $2${t}`);e=e.replace(mm,"").trimRight();const r=Object.create(null),i=e.replace(Dm,"").replace(mm,"").trimRight();let u;for(;u=Dm.exec(e);){const e=u[2].replace(gm,"");"string"==typeof r[u[1]]||Array.isArray(r[u[1]])?r[u[1]]=bm.concat(r[u[1]],e):r[u[1]]=e;}return {comments:i,pragmas:r}}function vm(e,t){return bm.concat(t).map((t=>`@${e} ${t}`.trim()))}var Am=Object.defineProperty({extract:um,strip:om,parse:sm,parseWithComments:am,print:lm},"__esModule",{value:!0});const{parseWithComments:Fm,strip:xm,extract:Sm,print:wm}=Am,{getShebang:Tm}=fi$1,{normalizeEndOfLine:Bm}=di$1;function km(e){const t=Tm(e);t&&(e=e.slice(t.length+1));const n=Sm(e),{pragmas:r,comments:i}=Fm(n);return {shebang:t,text:e,pragmas:r,comments:i}}var Nm={hasPragma:function(e){const t=Object.keys(km(e).pragmas);return t.includes("prettier")||t.includes("format")},insertPragma:function(e){const{shebang:t,text:n,pragmas:r,comments:i}=km(e),u=xm(n),o=wm({pragmas:Object.assign({format:""},r),comments:i.trimStart()});return (t?`${t}\n`:"")+Bm(o)+(u.startsWith("\n")?"\n":"\n\n")+u}};const{getLast:Pm,hasNewline:Om,getNextNonSpaceNonCommentCharacterIndexWithStartIndex:Im,getNextNonSpaceNonCommentCharacter:jm,hasNewlineInRange:Lm,addLeadingComment:_m,addTrailingComment:Mm,addDanglingComment:Rm,getNextNonSpaceNonCommentCharacterIndex:$m,isNonEmptyArray:Vm}=fi$1,{isBlockComment:qm,getFunctionParameters:Wm,isPrettierIgnoreComment:Um,isJsxNode:zm,hasFlowShorthandAnnotationComment:Gm,hasFlowAnnotationComment:Hm,hasIgnoreComment:Jm,isCallLikeExpression:Xm,getCallArguments:Ym,isCallExpression:Km,isMemberExpression:Qm,isObjectProperty:Zm}=Gh,{locStart:ey,locEnd:ty}=Rl;function ny(e,t){const n=(e.body||e.properties).find((({type:e})=>"EmptyStatement"!==e));n?_m(n,t):Rm(e,t);}function ry(e,t){"BlockStatement"===e.type?ny(e,t):_m(e,t);}function iy({comment:e,followingNode:t}){return !(!t||!Oy(e))&&(_m(t,e),!0)}function uy({comment:e,precedingNode:t,enclosingNode:n,followingNode:r,text:i}){if(!n||"IfStatement"!==n.type||!r)return !1;return ")"===jm(i,e,ty)?(Mm(t,e),!0):t===n.consequent&&r===n.alternate?("BlockStatement"===t.type?Mm(t,e):Rm(n,e),!0):"BlockStatement"===r.type?(ny(r,e),!0):"IfStatement"===r.type?(ry(r.consequent,e),!0):n.consequent===r&&(_m(r,e),!0)}function oy({comment:e,precedingNode:t,enclosingNode:n,followingNode:r,text:i}){if(!n||"WhileStatement"!==n.type||!r)return !1;return ")"===jm(i,e,ty)?(Mm(t,e),!0):"BlockStatement"===r.type?(ny(r,e),!0):n.body===r&&(_m(r,e),!0)}function sy({comment:e,precedingNode:t,enclosingNode:n,followingNode:r}){return !(!n||"TryStatement"!==n.type&&"CatchClause"!==n.type||!r)&&("CatchClause"===n.type&&t?(Mm(t,e),!0):"BlockStatement"===r.type?(ny(r,e),!0):"TryStatement"===r.type?(ry(r.finalizer,e),!0):"CatchClause"===r.type&&(ry(r.body,e),!0))}function ay({comment:e,enclosingNode:t,followingNode:n}){return !(!Qm(t)||!n||"Identifier"!==n.type)&&(_m(t,e),!0)}function ly({comment:e,precedingNode:t,enclosingNode:n,followingNode:r,text:i}){const u=t&&!Lm(i,ty(t),ey(e));return !(t&&u||!n||"ConditionalExpression"!==n.type&&"TSConditionalType"!==n.type||!r)&&(_m(r,e),!0)}function cy({comment:e,precedingNode:t,enclosingNode:n}){return !(!Zm(n)||!n.shorthand||n.key!==t||"AssignmentPattern"!==n.value.type)&&(Mm(n.value.left,e),!0)}function py({comment:e,precedingNode:t,enclosingNode:n,followingNode:r}){if(n&&("ClassDeclaration"===n.type||"ClassExpression"===n.type||"DeclareClass"===n.type||"DeclareInterface"===n.type||"InterfaceDeclaration"===n.type||"TSInterfaceDeclaration"===n.type)){if(Vm(n.decorators)&&(!r||"Decorator"!==r.type))return Mm(Pm(n.decorators),e),!0;if(n.body&&r===n.body)return ny(n.body,e),!0;if(r)for(const i of ["implements","extends","mixins"])if(n[i]&&r===n[i][0])return !t||t!==n.id&&t!==n.typeParameters&&t!==n.superClass?Rm(n,e,i):Mm(t,e),!0}return !1}function fy({comment:e,precedingNode:t,enclosingNode:n,text:r}){return (n&&t&&("Property"===n.type||"TSDeclareMethod"===n.type||"TSAbstractMethodDefinition"===n.type)&&"Identifier"===t.type&&n.key===t&&":"!==jm(r,t,ty)||!(!t||!n||"Decorator"!==t.type||"ClassMethod"!==n.type&&"ClassProperty"!==n.type&&"PropertyDefinition"!==n.type&&"TSAbstractClassProperty"!==n.type&&"TSAbstractMethodDefinition"!==n.type&&"TSDeclareMethod"!==n.type&&"MethodDefinition"!==n.type))&&(Mm(t,e),!0)}function dy({comment:e,precedingNode:t,enclosingNode:n,text:r}){return "("===jm(r,e,ty)&&(!(!t||!n||"FunctionDeclaration"!==n.type&&"FunctionExpression"!==n.type&&"ClassMethod"!==n.type&&"MethodDefinition"!==n.type&&"ObjectMethod"!==n.type)&&(Mm(t,e),!0))}function hy({comment:e,enclosingNode:t,text:n}){if(!t||"ArrowFunctionExpression"!==t.type)return !1;const r=$m(n,e,ty);return !1!==r&&"=>"===n.slice(r,r+2)&&(Rm(t,e),!0)}function gy({comment:e,enclosingNode:t,text:n}){return ")"===jm(n,e,ty)&&(t&&(Py(t)&&0===Wm(t).length||Xm(t)&&0===Ym(t).length)?(Rm(t,e),!0):!(!t||"MethodDefinition"!==t.type&&"TSAbstractMethodDefinition"!==t.type||0!==Wm(t.value).length)&&(Rm(t.value,e),!0))}function my({comment:e,precedingNode:t,enclosingNode:n,followingNode:r,text:i}){if(t&&"FunctionTypeParam"===t.type&&n&&"FunctionTypeAnnotation"===n.type&&r&&"FunctionTypeParam"!==r.type)return Mm(t,e),!0;if(t&&("Identifier"===t.type||"AssignmentPattern"===t.type)&&n&&Py(n)&&")"===jm(i,e,ty))return Mm(t,e),!0;if(n&&"FunctionDeclaration"===n.type&&r&&"BlockStatement"===r.type){const t=(()=>{const e=Wm(n);if(e.length>0)return Im(i,ty(Pm(e)));const t=Im(i,ty(n.id));return !1!==t&&Im(i,t+1)})();if(ey(e)>t)return ny(r,e),!0}return !1}function yy({comment:e,enclosingNode:t}){return !(!t||"ImportSpecifier"!==t.type)&&(_m(t,e),!0)}function Dy({comment:e,enclosingNode:t}){return !(!t||"LabeledStatement"!==t.type)&&(_m(t,e),!0)}function Ey({comment:e,enclosingNode:t}){return !(!t||"ContinueStatement"!==t.type&&"BreakStatement"!==t.type||t.label)&&(Mm(t,e),!0)}function by({comment:e,precedingNode:t,enclosingNode:n}){return !!(Km(n)&&t&&n.callee===t&&n.arguments.length>0)&&(_m(n.arguments[0],e),!0)}function Cy({comment:e,precedingNode:t,enclosingNode:n,followingNode:r}){return !n||"UnionTypeAnnotation"!==n.type&&"TSUnionType"!==n.type?(r&&("UnionTypeAnnotation"===r.type||"TSUnionType"===r.type)&&Um(e)&&(r.types[0].prettierIgnore=!0,e.unignore=!0),!1):(Um(e)&&(r.prettierIgnore=!0,e.unignore=!0),!!t&&(Mm(t,e),!0))}function vy({comment:e,enclosingNode:t}){return !!Zm(t)&&(_m(t,e),!0)}function Ay({comment:e,enclosingNode:t,followingNode:n,ast:r,isLastComment:i}){return r&&r.body&&0===r.body.length?(i?Rm(r,e):_m(r,e),!0):t&&"Program"===t.type&&0===t.body.length&&!Vm(t.directives)?(i?Rm(t,e):_m(t,e),!0):!(!n||"Program"!==n.type||0!==n.body.length||!t||"ModuleExpression"!==t.type)&&(Rm(n,e),!0)}function Fy({comment:e,enclosingNode:t}){return !(!t||"ForInStatement"!==t.type&&"ForOfStatement"!==t.type)&&(_m(t,e),!0)}function xy({comment:e,precedingNode:t,enclosingNode:n,text:r}){return !!(t&&"ImportSpecifier"===t.type&&n&&"ImportDeclaration"===n.type&&Om(r,ty(e)))&&(Mm(t,e),!0)}function Sy({comment:e,enclosingNode:t}){return !(!t||"AssignmentPattern"!==t.type)&&(_m(t,e),!0)}function wy({comment:e,enclosingNode:t}){return !(!t||"TypeAlias"!==t.type)&&(_m(t,e),!0)}function Ty({comment:e,enclosingNode:t,followingNode:n}){return !(!t||"VariableDeclarator"!==t.type&&"AssignmentExpression"!==t.type||!n||"ObjectExpression"!==n.type&&"ArrayExpression"!==n.type&&"TemplateLiteral"!==n.type&&"TaggedTemplateExpression"!==n.type&&!qm(e))&&(_m(n,e),!0)}function By({comment:e,enclosingNode:t,followingNode:n,text:r}){return !(n||!t||"TSMethodSignature"!==t.type&&"TSDeclareFunction"!==t.type&&"TSAbstractMethodDefinition"!==t.type||";"!==jm(r,e,ty))&&(Mm(t,e),!0)}function ky({comment:e,enclosingNode:t,followingNode:n}){if(Um(e)&&t&&"TSMappedType"===t.type&&n&&"TSTypeParameter"===n.type&&n.constraint)return t.prettierIgnore=!0,e.unignore=!0,!0}function Ny({comment:e,precedingNode:t,enclosingNode:n,followingNode:r}){return !(!n||"TSMappedType"!==n.type)&&(r&&"TSTypeParameter"===r.type&&r.name?(_m(r.name,e),!0):!(!t||"TSTypeParameter"!==t.type||!t.constraint)&&(Mm(t.constraint,e),!0))}function Py(e){return "ArrowFunctionExpression"===e.type||"FunctionExpression"===e.type||"FunctionDeclaration"===e.type||"ObjectMethod"===e.type||"ClassMethod"===e.type||"TSDeclareFunction"===e.type||"TSCallSignatureDeclaration"===e.type||"TSConstructSignatureDeclaration"===e.type||"TSMethodSignature"===e.type||"TSConstructorType"===e.type||"TSFunctionType"===e.type||"TSDeclareMethod"===e.type}function Oy(e){return qm(e)&&"*"===e.value[0]&&/@type\b/.test(e.value)}var Iy={handleOwnLineComment:function(e){return [ky,my,ay,uy,oy,sy,py,yy,Fy,Cy,Ay,xy,Sy,fy,Dy].some((t=>t(e)))},handleEndOfLineComment:function(e){return [iy,my,ly,yy,uy,oy,sy,py,Dy,by,vy,Ay,wy,Ty].some((t=>t(e)))},handleRemainingComment:function(e){return [ky,uy,oy,cy,gy,fy,Ay,hy,dy,Ny,Ey,By].some((t=>t(e)))},isTypeCastComment:Oy,getCommentChildNodes:function(e,t){if(("typescript"===t.parser||"flow"===t.parser||"espree"===t.parser||"meriyah"===t.parser||"__babel_estree"===t.parser)&&"MethodDefinition"===e.type&&e.value&&"FunctionExpression"===e.value.type&&0===Wm(e.value).length&&!e.value.returnType&&!Vm(e.value.typeParameters)&&e.value.body)return [...e.decorators||[],e.key,e.value.body]},willPrintOwnComments:function(e){const t=e.getValue(),n=e.getParentNode();return (t&&(zm(t)||Gm(t)||Km(n)&&(Hm(t.leadingComments)||Hm(t.trailingComments)))||n&&("JSXSpreadAttribute"===n.type||"JSXSpreadChild"===n.type||"UnionTypeAnnotation"===n.type||"TSUnionType"===n.type||("ClassDeclaration"===n.type||"ClassExpression"===n.type)&&n.superClass===t))&&(!Jm(e)||"UnionTypeAnnotation"===n.type||"TSUnionType"===n.type)}};const{getFunctionParameters:jy,getLeftSidePathName:Ly,hasFlowShorthandAnnotationComment:_y,hasNakedLeftSide:My,hasNode:Ry,isBitwiseOperator:$y,startsWithNoLookaheadToken:Vy,shouldFlatten:qy,getPrecedence:Wy,isCallExpression:Uy,isMemberExpression:zy,isObjectProperty:Gy}=Gh;function Hy(e,t){const n=e.getParentNode();if(!n)return !1;const r=e.getName(),i=e.getNode();if(t.__isInHtmlInterpolation&&!t.bracketSpacing&&function(e){switch(e.type){case"ObjectExpression":return !0;default:return !1}}(i)&&Jy(e))return !0;if(function(e){return "BlockStatement"===e.type||"BreakStatement"===e.type||"ClassBody"===e.type||"ClassDeclaration"===e.type||"ClassMethod"===e.type||"ClassProperty"===e.type||"PropertyDefinition"===e.type||"ClassPrivateProperty"===e.type||"ContinueStatement"===e.type||"DebuggerStatement"===e.type||"DeclareClass"===e.type||"DeclareExportAllDeclaration"===e.type||"DeclareExportDeclaration"===e.type||"DeclareFunction"===e.type||"DeclareInterface"===e.type||"DeclareModule"===e.type||"DeclareModuleExports"===e.type||"DeclareVariable"===e.type||"DoWhileStatement"===e.type||"EnumDeclaration"===e.type||"ExportAllDeclaration"===e.type||"ExportDefaultDeclaration"===e.type||"ExportNamedDeclaration"===e.type||"ExpressionStatement"===e.type||"ForInStatement"===e.type||"ForOfStatement"===e.type||"ForStatement"===e.type||"FunctionDeclaration"===e.type||"IfStatement"===e.type||"ImportDeclaration"===e.type||"InterfaceDeclaration"===e.type||"LabeledStatement"===e.type||"MethodDefinition"===e.type||"ReturnStatement"===e.type||"SwitchStatement"===e.type||"ThrowStatement"===e.type||"TryStatement"===e.type||"TSDeclareFunction"===e.type||"TSEnumDeclaration"===e.type||"TSImportEqualsDeclaration"===e.type||"TSInterfaceDeclaration"===e.type||"TSModuleDeclaration"===e.type||"TSNamespaceExportDeclaration"===e.type||"TypeAlias"===e.type||"VariableDeclaration"===e.type||"WhileStatement"===e.type||"WithStatement"===e.type}(i))return !1;if("flow"!==t.parser&&_y(e.getValue()))return !0;if("Identifier"===i.type)return !!(i.extra&&i.extra.parenthesized&&/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(i.name))||"left"===r&&"async"===i.name&&"ForOfStatement"===n.type&&!n.await;switch(n.type){case"ParenthesizedExpression":return !1;case"ClassDeclaration":case"ClassExpression":if("superClass"===r&&("ArrowFunctionExpression"===i.type||"AssignmentExpression"===i.type||"AwaitExpression"===i.type||"BinaryExpression"===i.type||"ConditionalExpression"===i.type||"LogicalExpression"===i.type||"NewExpression"===i.type||"ObjectExpression"===i.type||"ParenthesizedExpression"===i.type||"SequenceExpression"===i.type||"TaggedTemplateExpression"===i.type||"UnaryExpression"===i.type||"UpdateExpression"===i.type||"YieldExpression"===i.type||"TSNonNullExpression"===i.type))return !0;break;case"ExportDefaultDeclaration":return Xy(e,t)||"SequenceExpression"===i.type;case"Decorator":if("expression"===r){let e=!1,t=!1,n=i;for(;n;)switch(n.type){case"MemberExpression":t=!0,n=n.object;break;case"CallExpression":if(t||e)return !0;e=!0,n=n.callee;break;case"Identifier":return !1;default:return !0}return !0}break;case"ExpressionStatement":if(Vy(i,!0))return !0;break;case"ArrowFunctionExpression":if("body"===r&&"SequenceExpression"!==i.type&&Vy(i,!1))return !0}switch(i.type){case"UpdateExpression":if("UnaryExpression"===n.type)return i.prefix&&("++"===i.operator&&"+"===n.operator||"--"===i.operator&&"-"===n.operator);case"UnaryExpression":switch(n.type){case"UnaryExpression":return i.operator===n.operator&&("+"===i.operator||"-"===i.operator);case"BindExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":return "object"===r;case"TaggedTemplateExpression":return !0;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return "callee"===r;case"BinaryExpression":return "left"===r&&"**"===n.operator;case"TSNonNullExpression":return !0;default:return !1}case"BinaryExpression":if("UpdateExpression"===n.type||"PipelineTopicExpression"===n.type&&"|>"===i.operator)return !0;if("in"===i.operator&&function(e){let t=0,n=e.getValue();for(;n;){const r=e.getParentNode(t++);if(r&&"ForStatement"===r.type&&r.init===n)return !0;n=r;}return !1}(e))return !0;if("|>"===i.operator&&i.extra&&i.extra.parenthesized){const t=e.getParentNode(1);if("BinaryExpression"===t.type&&"|>"===t.operator)return !0}case"TSTypeAssertion":case"TSAsExpression":case"LogicalExpression":switch(n.type){case"TSAsExpression":return "TSAsExpression"!==i.type;case"ConditionalExpression":return "TSAsExpression"===i.type;case"CallExpression":case"NewExpression":case"OptionalCallExpression":return "callee"===r;case"ClassExpression":case"ClassDeclaration":return "superClass"===r;case"TSTypeAssertion":case"TaggedTemplateExpression":case"UnaryExpression":case"JSXSpreadAttribute":case"SpreadElement":case"SpreadProperty":case"BindExpression":case"AwaitExpression":case"TSNonNullExpression":case"UpdateExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":return "object"===r;case"AssignmentExpression":case"AssignmentPattern":return "left"===r&&("TSTypeAssertion"===i.type||"TSAsExpression"===i.type);case"LogicalExpression":if("LogicalExpression"===i.type)return n.operator!==i.operator;case"BinaryExpression":{const{operator:e,type:t}=i;if(!e&&"TSTypeAssertion"!==t)return !0;const u=Wy(e),o=n.operator,s=Wy(o);return s>u||("right"===r&&s===u||(s===u&&!qy(o,e)||(s<u&&"%"===e?"+"===o||"-"===o:!!$y(o))))}default:return !1}case"SequenceExpression":switch(n.type){case"ReturnStatement":case"ForStatement":return !1;case"ExpressionStatement":return "expression"!==r;case"ArrowFunctionExpression":return "body"!==r;default:return !0}case"YieldExpression":if("UnaryExpression"===n.type||"AwaitExpression"===n.type||"TSAsExpression"===n.type||"TSNonNullExpression"===n.type)return !0;if("expression"===r&&i.argument&&"PipelinePrimaryTopicReference"===i.argument.type&&"PipelineTopicExpression"===n.type)return !0;case"AwaitExpression":switch(n.type){case"TaggedTemplateExpression":case"UnaryExpression":case"LogicalExpression":case"SpreadElement":case"SpreadProperty":case"TSAsExpression":case"TSNonNullExpression":case"BindExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":return "object"===r;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return "callee"===r;case"ConditionalExpression":return "test"===r;case"BinaryExpression":return !(!i.argument&&"|>"===n.operator);default:return !1}case"TSConditionalType":if("extendsType"===r&&"TSConditionalType"===n.type)return !0;case"TSFunctionType":case"TSConstructorType":if("checkType"===r&&"TSConditionalType"===n.type)return !0;case"TSUnionType":case"TSIntersectionType":if(("TSUnionType"===n.type||"TSIntersectionType"===n.type)&&n.types.length>1&&(!i.types||i.types.length>1))return !0;case"TSInferType":if("TSInferType"===i.type&&"TSRestType"===n.type)return !1;case"TSTypeOperator":return "TSArrayType"===n.type||"TSOptionalType"===n.type||"TSRestType"===n.type||"objectType"===r&&"TSIndexedAccessType"===n.type||"TSTypeOperator"===n.type||"TSTypeAnnotation"===n.type&&/^TSJSDoc/.test(e.getParentNode(1).type);case"ArrayTypeAnnotation":return "NullableTypeAnnotation"===n.type;case"IntersectionTypeAnnotation":case"UnionTypeAnnotation":return "ArrayTypeAnnotation"===n.type||"NullableTypeAnnotation"===n.type||"IntersectionTypeAnnotation"===n.type||"UnionTypeAnnotation"===n.type||"objectType"===r&&("IndexedAccessType"===n.type||"OptionalIndexedAccessType"===n.type);case"NullableTypeAnnotation":return "ArrayTypeAnnotation"===n.type||"objectType"===r&&("IndexedAccessType"===n.type||"OptionalIndexedAccessType"===n.type);case"FunctionTypeAnnotation":{const t="NullableTypeAnnotation"===n.type?e.getParentNode(1):n;return "UnionTypeAnnotation"===t.type||"IntersectionTypeAnnotation"===t.type||"ArrayTypeAnnotation"===t.type||"objectType"===r&&("IndexedAccessType"===t.type||"OptionalIndexedAccessType"===t.type)||"NullableTypeAnnotation"===t.type||"FunctionTypeParam"===n.type&&null===n.name&&jy(i).some((e=>e.typeAnnotation&&"NullableTypeAnnotation"===e.typeAnnotation.type))}case"OptionalIndexedAccessType":return "objectType"===r&&"IndexedAccessType"===n.type;case"TypeofTypeAnnotation":return "objectType"===r&&("IndexedAccessType"===n.type||"OptionalIndexedAccessType"===n.type);case"StringLiteral":case"NumericLiteral":case"Literal":if("string"==typeof i.value&&"ExpressionStatement"===n.type&&!n.directive){const t=e.getParentNode(1);return "Program"===t.type||"BlockStatement"===t.type}return "object"===r&&"MemberExpression"===n.type&&"number"==typeof i.value;case"AssignmentExpression":{const t=e.getParentNode(1);return "body"===r&&"ArrowFunctionExpression"===n.type||("key"!==r||"ClassProperty"!==n.type&&"PropertyDefinition"!==n.type||!n.computed)&&(("init"!==r&&"update"!==r||"ForStatement"!==n.type)&&("ExpressionStatement"===n.type?"ObjectPattern"===i.left.type:("key"!==r||"TSPropertySignature"!==n.type)&&("AssignmentExpression"!==n.type&&(("SequenceExpression"!==n.type||!t||"ForStatement"!==t.type||t.init!==n&&t.update!==n)&&(("value"!==r||"Property"!==n.type||!t||"ObjectPattern"!==t.type||!t.properties.includes(n))&&"NGChainedExpression"!==n.type)))))}case"ConditionalExpression":switch(n.type){case"TaggedTemplateExpression":case"UnaryExpression":case"SpreadElement":case"SpreadProperty":case"BinaryExpression":case"LogicalExpression":case"NGPipeExpression":case"ExportDefaultDeclaration":case"AwaitExpression":case"JSXSpreadAttribute":case"TSTypeAssertion":case"TypeCastExpression":case"TSAsExpression":case"TSNonNullExpression":return !0;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return "callee"===r;case"ConditionalExpression":return "test"===r;case"MemberExpression":case"OptionalMemberExpression":return "object"===r;default:return !1}case"FunctionExpression":switch(n.type){case"NewExpression":case"CallExpression":case"OptionalCallExpression":return "callee"===r;case"TaggedTemplateExpression":return !0;default:return !1}case"ArrowFunctionExpression":switch(n.type){case"PipelineTopicExpression":return Boolean(i.extra&&i.extra.parenthesized);case"BinaryExpression":return "|>"!==n.operator||i.extra&&i.extra.parenthesized;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return "callee"===r;case"MemberExpression":case"OptionalMemberExpression":return "object"===r;case"TSAsExpression":case"TSNonNullExpression":case"BindExpression":case"TaggedTemplateExpression":case"UnaryExpression":case"LogicalExpression":case"AwaitExpression":case"TSTypeAssertion":return !0;case"ConditionalExpression":return "test"===r;default:return !1}case"ClassExpression":switch(n.type){case"NewExpression":return "callee"===r;default:return !1}case"OptionalMemberExpression":case"OptionalCallExpression":{const t=e.getParentNode(1);if("object"===r&&"MemberExpression"===n.type||"callee"===r&&("CallExpression"===n.type||"NewExpression"===n.type)||"TSNonNullExpression"===n.type&&"MemberExpression"===t.type&&t.object===n)return !0}case"CallExpression":case"MemberExpression":case"TaggedTemplateExpression":case"TSNonNullExpression":if("callee"===r&&("BindExpression"===n.type||"NewExpression"===n.type)){let e=i;for(;e;)switch(e.type){case"CallExpression":case"OptionalCallExpression":return !0;case"MemberExpression":case"OptionalMemberExpression":case"BindExpression":e=e.object;break;case"TaggedTemplateExpression":e=e.tag;break;case"TSNonNullExpression":e=e.expression;break;default:return !1}}return !1;case"BindExpression":return "callee"===r&&("BindExpression"===n.type||"NewExpression"===n.type)||"object"===r&&zy(n);case"NGPipeExpression":return !("NGRoot"===n.type||"NGMicrosyntaxExpression"===n.type||"ObjectProperty"===n.type&&(!i.extra||!i.extra.parenthesized)||"ArrayExpression"===n.type||Uy(n)&&n.arguments[r]===i||"right"===r&&"NGPipeExpression"===n.type||"property"===r&&"MemberExpression"===n.type||"AssignmentExpression"===n.type);case"JSXFragment":case"JSXElement":return "callee"===r||"left"===r&&"BinaryExpression"===n.type&&"<"===n.operator||"ArrayExpression"!==n.type&&"ArrowFunctionExpression"!==n.type&&"AssignmentExpression"!==n.type&&"AssignmentPattern"!==n.type&&"BinaryExpression"!==n.type&&"NewExpression"!==n.type&&"ConditionalExpression"!==n.type&&"ExpressionStatement"!==n.type&&"JsExpressionRoot"!==n.type&&"JSXAttribute"!==n.type&&"JSXElement"!==n.type&&"JSXExpressionContainer"!==n.type&&"JSXFragment"!==n.type&&"LogicalExpression"!==n.type&&!Uy(n)&&!Gy(n)&&"ReturnStatement"!==n.type&&"ThrowStatement"!==n.type&&"TypeCastExpression"!==n.type&&"VariableDeclarator"!==n.type&&"YieldExpression"!==n.type;case"TypeAnnotation":return "returnType"===r&&"ArrowFunctionExpression"===n.type&&function(e){return Ry(e,(e=>"ObjectTypeAnnotation"===e.type&&Ry(e,(e=>"FunctionTypeAnnotation"===e.type||void 0))||void 0))}(i)}return !1}function Jy(e){const t=e.getValue(),n=e.getParentNode(),r=e.getName();switch(n.type){case"NGPipeExpression":if("number"==typeof r&&n.arguments[r]===t&&n.arguments.length-1===r)return e.callParent(Jy);break;case"ObjectProperty":if("value"===r){const t=e.getParentNode(1);return Sn$1(t.properties)===n}break;case"BinaryExpression":case"LogicalExpression":if("right"===r)return e.callParent(Jy);break;case"ConditionalExpression":if("alternate"===r)return e.callParent(Jy);break;case"UnaryExpression":if(n.prefix)return e.callParent(Jy)}return !1}function Xy(e,t){const n=e.getValue(),r=e.getParentNode();return "FunctionExpression"===n.type||"ClassExpression"===n.type?"ExportDefaultDeclaration"===r.type||!Hy(e,t):!(!My(n)||"ExportDefaultDeclaration"!==r.type&&Hy(e,t))&&e.call((e=>Xy(e,t)),...Ly(e,n))}var Yy=Hy;var Ky=function(e,t){switch(t.parser){case"json":case"json5":case"json-stringify":case"__js_expression":case"__vue_expression":return Object.assign(Object.assign({},e),{},{type:t.parser.startsWith("__")?"JsExpressionRoot":"JsonRoot",node:e,comments:[],rootMarker:t.rootMarker});default:return e}};const{builders:{join:Qy,line:Zy,group:eD,softline:tD,indent:nD}}=Ji$1;var rD={isVueEventBindingExpression:function e(t){switch(t.type){case"MemberExpression":switch(t.property.type){case"Identifier":case"NumericLiteral":case"StringLiteral":return e(t.object)}return !1;case"Identifier":return !0;default:return !1}},printHtmlBinding:function(e,t,n){const r=e.getValue();if(t.__onHtmlBindingRoot&&null===e.getName()&&t.__onHtmlBindingRoot(r,t),"File"===r.type)return t.__isVueForBindingLeft?e.call((e=>{const t=Qy([",",Zy],e.map(n,"params")),{params:r}=e.getValue();return 1===r.length?t:["(",nD([tD,eD(t)]),tD,")"]}),"program","body",0):t.__isVueBindings?e.call((e=>Qy([",",Zy],e.map(n,"params"))),"program","body",0):void 0}};const{printComments:iD}=Wf,{getLast:uD}=fi$1,{builders:{join:oD,line:sD,softline:aD,group:lD,indent:cD,align:pD,ifBreak:fD,indentIfBreak:dD},utils:{cleanDoc:hD,getDocParts:gD,isConcat:mD}}=Ji$1,{hasLeadingOwnLineComment:yD,isBinaryish:DD,isJsxNode:ED,shouldFlatten:bD,hasComment:CD,CommentCheckFlags:vD,isCallExpression:AD,isMemberExpression:FD,isObjectProperty:xD}=Gh;let SD=0;function wD(e,t,n,r,i){let u=[];const o=e.getValue();if(DD(o)){bD(o.operator,o.left.operator)?u=[...u,...e.call((e=>wD(e,t,n,!0,i)),"left")]:u.push(lD(t("left")));const s=TD(o),a=("|>"===o.operator||"NGPipeExpression"===o.type||"|"===o.operator&&"__vue_expression"===n.parser)&&!yD(n.originalText,o.right),l="NGPipeExpression"===o.type?"|":o.operator,c="NGPipeExpression"===o.type&&o.arguments.length>0?lD(cD([aD,": ",oD([aD,":",fD(" ")],e.map(t,"arguments").map((e=>pD(2,lD(e)))))])):"",p=s?[l," ",t("right"),c]:[a?sD:"",l,a?" ":sD,t("right"),c],f=e.getParentNode(),d=CD(o.left,vD.Trailing|vD.Line),h=d||!(i&&"LogicalExpression"===o.type)&&f.type!==o.type&&o.left.type!==o.type&&o.right.type!==o.type;if(u.push(a?"":" ",h?lD(p,{shouldBreak:d}):p),r&&CD(o)){const t=hD(iD(e,u,n));u=mD(t)||"fill"===t.type?gD(t):[t];}}else u.push(lD(t()));return u}function TD(e){return "LogicalExpression"===e.type&&("ObjectExpression"===e.right.type&&e.right.properties.length>0||("ArrayExpression"===e.right.type&&e.right.elements.length>0||!!ED(e.right)))}var BD={printBinaryishExpression:function(e,t,n){const r=e.getValue(),i=e.getParentNode(),u=e.getParentNode(1),o=r!==i.body&&("IfStatement"===i.type||"WhileStatement"===i.type||"SwitchStatement"===i.type||"DoWhileStatement"===i.type),s=wD(e,n,t,!1,o);if(o)return s;if(AD(i)&&i.callee===r||"UnaryExpression"===i.type||FD(i)&&!i.computed)return lD([cD([aD,...s]),aD]);const a="ReturnStatement"===i.type||"ThrowStatement"===i.type||"JSXExpressionContainer"===i.type&&"JSXAttribute"===u.type||"|"!==r.operator&&"JsExpressionRoot"===i.type||"NGPipeExpression"!==r.type&&("NGRoot"===i.type&&"__ng_binding"===t.parser||"NGMicrosyntaxExpression"===i.type&&"NGMicrosyntax"===u.type&&1===u.body.length)||r===i.body&&"ArrowFunctionExpression"===i.type||r!==i.body&&"ForStatement"===i.type||"ConditionalExpression"===i.type&&"ReturnStatement"!==u.type&&"ThrowStatement"!==u.type&&!AD(u)||"TemplateLiteral"===i.type,l="AssignmentExpression"===i.type||"VariableDeclarator"===i.type||"ClassProperty"===i.type||"PropertyDefinition"===i.type||"TSAbstractClassProperty"===i.type||"ClassPrivateProperty"===i.type||xD(i),c=DD(r.left)&&bD(r.operator,r.left.operator);if(a||TD(r)&&!c||!TD(r)&&l)return lD(s);if(0===s.length)return "";const p=ED(r.right),f=s.findIndex((e=>"string"!=typeof e&&!Array.isArray(e)&&"group"===e.type)),d=s.slice(0,-1===f?1:f+1),h=s.slice(d.length,p?-1:void 0),g=Symbol("logicalChain-"+ ++SD),m=lD([...d,cD(h)],{id:g});if(!p)return m;const y=uD(s);return lD([m,dD(y,{groupId:g})])},shouldInlineLogicalExpression:TD};const{builders:{join:kD,line:ND,group:PD}}=Ji$1,{hasNode:OD,hasComment:ID,getComments:jD}=Gh,{printBinaryishExpression:LD}=BD;function _D(e,t,n){return "NGMicrosyntaxKeyedExpression"===e.type&&"of"===e.key.name&&1===t&&"NGMicrosyntaxLet"===n.body[0].type&&null===n.body[0].value}var MD={printAngular:function(e,t,n){const r=e.getValue();if(r.type.startsWith("NG"))switch(r.type){case"NGRoot":return [n("node"),ID(r.node)?" //"+jD(r.node)[0].value.trimEnd():""];case"NGPipeExpression":return LD(e,t,n);case"NGChainedExpression":return PD(kD([";",ND],e.map((e=>function(e){return OD(e.getValue(),(e=>{switch(e.type){case void 0:return !1;case"CallExpression":case"OptionalCallExpression":case"AssignmentExpression":return !0}}))}(e)?n():["(",n(),")"]),"expressions")));case"NGEmptyExpression":return "";case"NGQuotedExpression":return [r.prefix,": ",r.value.trim()];case"NGMicrosyntax":return e.map(((e,t)=>[0===t?"":_D(e.getValue(),t,r)?" ":[";",ND],n()]),"body");case"NGMicrosyntaxKey":return /^[$_a-z][\w$]*(-[$_a-z][\w$])*$/i.test(r.name)?r.name:JSON.stringify(r.name);case"NGMicrosyntaxExpression":return [n("expression"),null===r.alias?"":[" as ",n("alias")]];case"NGMicrosyntaxKeyedExpression":{const t=e.getName(),i=e.getParentNode(),u=_D(r,t,i)||(1===t&&("then"===r.key.name||"else"===r.key.name)||2===t&&"else"===r.key.name&&"NGMicrosyntaxKeyedExpression"===i.body[t-1].type&&"then"===i.body[t-1].key.name)&&"NGMicrosyntaxExpression"===i.body[0].type;return [n("key"),u?" ":": ",n("expression")]}case"NGMicrosyntaxLet":return ["let ",n("key"),null===r.value?"":[" = ",n("value")]];case"NGMicrosyntaxAs":return [n("key")," as ",n("alias")];default:throw new Error(`Unknown Angular node type: ${JSON.stringify(r.type)}.`)}}};const{printComments:RD,printDanglingComments:$D}=Wf,{builders:{line:VD,hardline:qD,softline:WD,group:UD,indent:zD,conditionalGroup:GD,fill:HD,ifBreak:JD,lineSuffixBoundary:XD,join:YD},utils:{willBreak:KD}}=Ji$1,{getLast:QD,getPreferredQuote:ZD}=fi$1,{isJsxNode:eE,rawText:tE,isLiteral:nE,isCallExpression:rE,isStringLiteral:iE,isBinaryish:uE,hasComment:oE,CommentCheckFlags:sE,hasNodeIgnoreComment:aE}=Gh,{willPrintOwnComments:lE}=Iy,cE=e=>""===e||e===VD||e===qD||e===WD;function pE(e,t,n){const r=e.getValue();if("JSXElement"===r.type&&function(e){if(0===e.children.length)return !0;if(e.children.length>1)return !1;const t=e.children[0];return nE(t)&&!EE(t)}(r))return [n("openingElement"),n("closingElement")];const i="JSXElement"===r.type?n("openingElement"):n("openingFragment"),u="JSXElement"===r.type?n("closingElement"):n("closingFragment");if(1===r.children.length&&"JSXExpressionContainer"===r.children[0].type&&("TemplateLiteral"===r.children[0].expression.type||"TaggedTemplateExpression"===r.children[0].expression.type))return [i,...e.map(n,"children"),u];r.children=r.children.map((e=>function(e){return "JSXExpressionContainer"===e.type&&nE(e.expression)&&" "===e.expression.value&&!oE(e.expression)}(e)?{type:"JSXText",value:" ",raw:" "}:e));const o=r.children.filter(eE).length>0,s=r.children.filter((e=>"JSXExpressionContainer"===e.type)).length>1,a="JSXElement"===r.type&&r.openingElement.attributes.length>1;let l=KD(i)||o||a||s;const c="mdx"===e.getParentNode().rootMarker,p=t.singleQuote?"{' '}":'{" "}',f=c?" ":JD([p,WD]," "),d=function(e,t,n,r,i){const u=[];return e.each(((e,t,o)=>{const s=e.getValue();if(nE(s)){const e=tE(s);if(EE(s)){const n=e.split(mE);if(""===n[0]){if(u.push(""),n.shift(),/\n/.test(n[0])){const e=o[t+1];u.push(dE(i,n[1],s,e));}else u.push(r);n.shift();}let a;if(""===QD(n)&&(n.pop(),a=n.pop()),0===n.length)return;for(const[e,t]of n.entries())e%2==1?u.push(VD):u.push(t);if(void 0!==a)if(/\n/.test(a)){const e=o[t+1];u.push(dE(i,QD(u),s,e));}else u.push(r);else {const e=o[t+1];u.push(fE(i,QD(u),s,e));}}else /\n/.test(e)?e.match(/\n/g).length>1&&u.push("",qD):u.push("",r);}else {const e=n();u.push(e);const r=o[t+1];if(r&&EE(r)){const e=DE(tE(r)).split(mE)[0];u.push(fE(i,e,s,r));}else u.push(qD);}}),"children"),u}(e,0,n,f,r.openingElement&&r.openingElement.name&&"fbt"===r.openingElement.name.name),h=r.children.some((e=>EE(e)));for(let e=d.length-2;e>=0;e--){const t=""===d[e]&&""===d[e+1],n=d[e]===qD&&""===d[e+1]&&d[e+2]===qD,r=(d[e]===WD||d[e]===qD)&&""===d[e+1]&&d[e+2]===f,i=d[e]===f&&""===d[e+1]&&(d[e+2]===WD||d[e+2]===qD),u=d[e]===f&&""===d[e+1]&&d[e+2]===f,o=d[e]===WD&&""===d[e+1]&&d[e+2]===qD||d[e]===qD&&""===d[e+1]&&d[e+2]===WD;n&&h||t||r||u||o?d.splice(e,2):i&&d.splice(e+1,2);}for(;d.length>0&&cE(QD(d));)d.pop();for(;d.length>1&&cE(d[0])&&cE(d[1]);)d.shift(),d.shift();const g=[];for(const[e,t]of d.entries()){if(t===f){if(1===e&&""===d[e-1]){if(2===d.length){g.push(p);continue}g.push([p,qD]);continue}if(e===d.length-1){g.push(p);continue}if(""===d[e-1]&&d[e-2]===qD){g.push(p);continue}}g.push(t),KD(t)&&(l=!0);}const m=h?HD(g):UD(g,{shouldBreak:!0});if(c)return m;const y=UD([i,zD([qD,m]),qD,u]);return l?y:GD([UD([i,...d,u]),y])}function fE(e,t,n,r){return e?"":"JSXElement"===n.type&&!n.closingElement||r&&"JSXElement"===r.type&&!r.closingElement?1===t.length?WD:qD:WD}function dE(e,t,n,r){return e?qD:1===t.length?"JSXElement"===n.type&&!n.closingElement||r&&"JSXElement"===r.type&&!r.closingElement?qD:WD:qD}function hE(e,t,n){return function(e,t,n){const r=e.getParentNode();if(!r)return t;if({ArrayExpression:!0,JSXAttribute:!0,JSXElement:!0,JSXExpressionContainer:!0,JSXFragment:!0,ExpressionStatement:!0,CallExpression:!0,OptionalCallExpression:!0,ConditionalExpression:!0,JsExpressionRoot:!0}[r.type])return t;const i=e.match(void 0,(e=>"ArrowFunctionExpression"===e.type),rE,(e=>"JSXExpressionContainer"===e.type)),u=Yy(e,n);return UD([u?"":JD("("),zD([WD,t]),WD,u?"":JD(")")],{shouldBreak:i})}(e,RD(e,pE(e,t,n),t),t)}function gE(e,t,n){const r=e.getValue();return ["{",e.call((e=>{const r=["...",n()],i=e.getValue();return oE(i)&&lE(e)?[zD([WD,RD(e,r,t)]),WD]:r}),"JSXSpreadAttribute"===r.type?"argument":"expression"),"}"]}const mE=new RegExp("([ \n\r\t]+)"),yE=new RegExp("[^ \n\r\t]"),DE=e=>e.replace(new RegExp("(?:^"+mE.source+"|"+mE.source+"$)"),"");function EE(e){return nE(e)&&(yE.test(tE(e))||!/\n/.test(tE(e)))}var bE={hasJsxIgnoreComment:function(e){const t=e.getValue(),n=e.getParentNode();if(!(n&&t&&eE(t)&&eE(n)))return !1;let r=null;for(let e=n.children.indexOf(t);e>0;e--){const t=n.children[e-1];if("JSXText"!==t.type||EE(t)){r=t;break}}return r&&"JSXExpressionContainer"===r.type&&"JSXEmptyExpression"===r.expression.type&&aE(r.expression)},printJsx:function(e,t,n){const r=e.getValue();if(r.type.startsWith("JSX"))switch(r.type){case"JSXAttribute":return function(e,t,n){const r=e.getValue(),i=[];if(i.push(n("name")),r.value){let e;if(iE(r.value)){let n=tE(r.value).replace(/&apos;/g,"'").replace(/&quot;/g,'"');const i=ZD(n,t.jsxSingleQuote?"'":'"'),u="'"===i?"&apos;":"&quot;";n=n.slice(1,-1).replace(new RegExp(i,"g"),u),e=[i,n,i];}else e=n("value");i.push("=",e);}return i}(e,t,n);case"JSXIdentifier":return String(r.name);case"JSXNamespacedName":return YD(":",[n("namespace"),n("name")]);case"JSXMemberExpression":return YD(".",[n("object"),n("property")]);case"JSXSpreadAttribute":return gE(e,t,n);case"JSXSpreadChild":return gE(e,t,n);case"JSXExpressionContainer":return function(e,t,n){const r=e.getValue(),i=e.getParentNode(0),u="JSXEmptyExpression"===r.expression.type||!oE(r.expression)&&("ArrayExpression"===r.expression.type||"ObjectExpression"===r.expression.type||"ArrowFunctionExpression"===r.expression.type||rE(r.expression)||"FunctionExpression"===r.expression.type||"TemplateLiteral"===r.expression.type||"TaggedTemplateExpression"===r.expression.type||"DoExpression"===r.expression.type||eE(i)&&("ConditionalExpression"===r.expression.type||uE(r.expression)));return UD(u?["{",n("expression"),XD,"}"]:["{",zD([WD,n("expression")]),WD,XD,"}"])}(e,0,n);case"JSXFragment":case"JSXElement":return hE(e,t,n);case"JSXOpeningElement":return function(e,t,n){const r=e.getValue(),i=r.name&&oE(r.name)||r.typeParameters&&oE(r.typeParameters);if(r.selfClosing&&0===r.attributes.length&&!i)return ["<",n("name"),n("typeParameters")," />"];if(r.attributes&&1===r.attributes.length&&r.attributes[0].value&&iE(r.attributes[0].value)&&!r.attributes[0].value.value.includes("\n")&&!i&&!oE(r.attributes[0]))return UD(["<",n("name"),n("typeParameters")," ",...e.map(n,"attributes"),r.selfClosing?" />":">"]);const u=r.attributes.length>0&&oE(QD(r.attributes),sE.Trailing),o=0===r.attributes.length&&!i||t.jsxBracketSameLine&&(!i||r.attributes.length>0)&&!u,s=r.attributes&&r.attributes.some((e=>e.value&&iE(e.value)&&e.value.value.includes("\n")));return UD(["<",n("name"),n("typeParameters"),zD(e.map((()=>[VD,n()]),"attributes")),r.selfClosing?VD:o?">":WD,r.selfClosing?"/>":o?"":">"],{shouldBreak:s})}(e,t,n);case"JSXClosingElement":return function(e,t,n){const r=e.getValue(),i=[];i.push("</");const u=n("name");return oE(r.name,sE.Leading|sE.Line)?i.push(zD([qD,u]),qD):oE(r.name,sE.Leading|sE.Block)?i.push(" ",u):i.push(u),i.push(">"),i}(e,0,n);case"JSXOpeningFragment":case"JSXClosingFragment":return function(e,t){const n=e.getValue(),r=oE(n),i=oE(n,sE.Line),u="JSXOpeningFragment"===n.type;return [u?"<":"</",zD([i?qD:r&&!u?" ":"",$D(e,t,!0)]),i?qD:"",">"]}(e,t);case"JSXEmptyExpression":return function(e,t){const n=e.getValue(),r=oE(n,sE.Line);return [$D(e,t,!r),r?qD:""]}(e,t);case"JSXText":throw new Error("JSXTest should be handled by JSXElement");default:throw new Error(`Unknown JSX node type: ${JSON.stringify(r.type)}.`)}}};Me$1({target:"Array",proto:!0},{flat:function(){var e=arguments.length?arguments[0]:void 0,t=B$1(this),n=be$1(t.length),r=Mn$1(t,0);return r.length=kn$1(r,t,t,n,0,void 0===e?1:De$1(e)),r}});const{isNonEmptyArray:CE}=fi$1,{builders:{indent:vE,join:AE,line:FE}}=Ji$1,{isFlowAnnotationComment:xE}=Gh;function SE(e,t,n){const r=e.getValue();if(!r.typeAnnotation)return "";const i=e.getParentNode(),u=r.definite||i&&"VariableDeclarator"===i.type&&i.definite,o="DeclareFunction"===i.type&&i.id===r;return xE(t.originalText,r.typeAnnotation)?[" /*: ",n("typeAnnotation")," */"]:[o?"":u?"!: ":": ",n("typeAnnotation")]}var wE={printOptionalToken:function(e){const t=e.getValue();return !t.optional||"Identifier"===t.type&&t===e.getParentNode().key?"":"OptionalCallExpression"===t.type||"OptionalMemberExpression"===t.type&&t.computed?"?.":"?"},printFunctionTypeParameters:function(e,t,n){const r=e.getValue();return r.typeArguments?n("typeArguments"):r.typeParameters?n("typeParameters"):""},printBindExpressionCallee:function(e,t,n){return ["::",n("callee")]},printTypeScriptModifiers:function(e,t,n){const r=e.getValue();return CE(r.modifiers)?[AE(" ",e.map(n,"modifiers"))," "]:""},printTypeAnnotation:SE,printRestSpread:function(e,t,n){return ["...",n("argument"),SE(e,t,n)]},adjustClause:function(e,t,n){return "EmptyStatement"===e.type?";":"BlockStatement"===e.type||n?[" ",t]:vE([FE,t])}};const{printDanglingComments:TE}=Wf,{builders:{line:BE,softline:kE,hardline:NE,group:PE,indent:OE,ifBreak:IE,fill:jE}}=Ji$1,{getLast:LE,hasNewline:_E}=fi$1,{shouldPrintComma:ME,hasComment:RE,CommentCheckFlags:$E,isNextLineEmpty:VE,isNumericLiteral:qE,isSignedNumericLiteral:WE}=Gh,{locStart:UE}=Rl,{printOptionalToken:zE,printTypeAnnotation:GE}=wE;function HE(e,t){return e.elements.length>1&&e.elements.every((e=>e&&(qE(e)||WE(e)&&!RE(e.argument))&&!RE(e,$E.Trailing|$E.Line,(e=>!_E(t.originalText,UE(e),{backwards:!0})))))}function JE(e,t,n,r){const i=[];let u=[];return e.each((e=>{i.push(u,PE(r())),u=[",",BE],e.getValue()&&VE(e.getValue(),t)&&u.push(kE);}),n),i}function XE(e,t,n,r){const i=[];return e.each(((e,u,o)=>{const s=u===o.length-1;i.push([n(),s?r:","]),s||i.push(VE(e.getValue(),t)?[NE,NE]:RE(o[u+1],$E.Leading|$E.Line)?NE:BE);}),"elements"),jE(i)}var YE={printArray:function(e,t,n){const r=e.getValue(),i=[],u="TupleExpression"===r.type?"#[":"[";if(0===r.elements.length)RE(r,$E.Dangling)?i.push(PE([u,TE(e,t),kE,"]"])):i.push(u,"]");else {const o=LE(r.elements),s=!(o&&"RestElement"===o.type),a=null===o,l=Symbol("array"),c=!t.__inJestEach&&r.elements.length>1&&r.elements.every(((e,t,n)=>{const r=e&&e.type;if("ArrayExpression"!==r&&"ObjectExpression"!==r)return !1;const i=n[t+1];if(i&&r!==i.type)return !1;const u="ArrayExpression"===r?"elements":"properties";return e[u]&&e[u].length>1})),p=HE(r,t),f=s?a?",":ME(t)?p?IE(",","",{groupId:l}):IE(","):"":"";i.push(PE([u,OE([kE,p?XE(e,t,n,f):[JE(e,t,"elements",n),f],TE(e,t,!0)]),kE,"]"],{shouldBreak:c,id:l}));}return i.push(zE(e),GE(e,t,n)),i},printArrayItems:JE,isConciselyPrintedArray:HE};const{printDanglingComments:KE}=Wf,{getLast:QE,getPenultimate:ZE}=fi$1,{getFunctionParameters:eb,hasComment:tb,CommentCheckFlags:nb,isFunctionCompositionArgs:rb,isJsxNode:ib,isLongCurriedCallExpression:ub,shouldPrintComma:ob,getCallArguments:sb,iterateCallArgumentsPath:ab,isNextLineEmpty:lb,isCallExpression:cb,isStringLiteral:pb,isObjectProperty:fb}=Gh,{builders:{line:db,hardline:hb,softline:gb,group:mb,indent:yb,conditionalGroup:Db,ifBreak:Eb,breakParent:bb},utils:{willBreak:Cb}}=Ji$1,{ArgExpansionBailout:vb}=go,{isConciselyPrintedArray:Ab}=YE;function Fb(e,t=!1){return "ObjectExpression"===e.type&&(e.properties.length>0||tb(e))||"ArrayExpression"===e.type&&(e.elements.length>0||tb(e))||"TSTypeAssertion"===e.type&&Fb(e.expression)||"TSAsExpression"===e.type&&Fb(e.expression)||"FunctionExpression"===e.type||"ArrowFunctionExpression"===e.type&&(!e.returnType||!e.returnType.typeAnnotation||"TSTypeReference"!==e.returnType.typeAnnotation.type||"BlockStatement"===(n=e.body).type&&(n.body.some((e=>"EmptyStatement"!==e.type))||tb(n,nb.Dangling)))&&("BlockStatement"===e.body.type||"ArrowFunctionExpression"===e.body.type&&Fb(e.body,!0)||"ObjectExpression"===e.body.type||"ArrayExpression"===e.body.type||!t&&(cb(e.body)||"ConditionalExpression"===e.body.type)||ib(e.body))||"DoExpression"===e.type||"ModuleExpression"===e.type;var n;}var xb=function(e,t,n){const r=e.getValue(),i="ImportExpression"===r.type,u=sb(r);if(0===u.length)return ["(",KE(e,t,!0),")"];if(function(e){return 2===e.length&&"ArrowFunctionExpression"===e[0].type&&0===eb(e[0]).length&&"BlockStatement"===e[0].body.type&&"ArrayExpression"===e[1].type&&!e.some((e=>tb(e)))}(u))return ["(",n(["arguments",0]),", ",n(["arguments",1]),")"];let o=!1,s=!1;const a=u.length-1,l=[];ab(e,((e,r)=>{const i=e.getNode(),u=[n()];r===a||(lb(i,t)?(0===r&&(s=!0),o=!0,u.push(",",hb,hb)):u.push(",",db)),l.push(u);}));const c=i||r.callee&&"Import"===r.callee.type||!ob(t,"all")?"":",";function p(){return mb(["(",yb([db,...l]),c,db,")"],{shouldBreak:!0})}if(o||"Decorator"!==e.getParentNode().type&&rb(u))return p();const f=function(e){if(2!==e.length)return !1;const[t,n]=e;if("ModuleExpression"===t.type&&function(e){return "ObjectExpression"===e.type&&1===e.properties.length&&fb(e.properties[0])&&"Identifier"===e.properties[0].key.type&&"type"===e.properties[0].key.name&&pb(e.properties[0].value)&&"module"===e.properties[0].value.value}(n))return !0;return !tb(t)&&("FunctionExpression"===t.type||"ArrowFunctionExpression"===t.type&&"BlockStatement"===t.body.type)&&"FunctionExpression"!==n.type&&"ArrowFunctionExpression"!==n.type&&"ConditionalExpression"!==n.type&&!Fb(n)}(u),d=function(e,t){const n=QE(e),r=ZE(e);return !tb(n,nb.Leading)&&!tb(n,nb.Trailing)&&Fb(n)&&(!r||r.type!==n.type)&&(2!==e.length||"ArrowFunctionExpression"!==r.type||"ArrayExpression"!==n.type)&&!(e.length>1&&"ArrayExpression"===n.type&&Ab(n,t))}(u,t);if(f||d){if(f?l.slice(1).some(Cb):l.slice(0,-1).some(Cb))return p();let t=[];try{e.try((()=>{ab(e,((e,r)=>{f&&0===r&&(t=[[n([],{expandFirstArg:!0}),l.length>1?",":"",s?hb:db,s?hb:""],...l.slice(1)]),d&&r===a&&(t=[...l.slice(0,-1),n([],{expandLastArg:!0})]);}));}));}catch(e){if(e instanceof vb)return p();throw e}return [l.some(Cb)?bb:"",Db([["(",...t,")"],f?["(",mb(t[0],{shouldBreak:!0}),...t.slice(1),")"]:["(",...l.slice(0,-1),mb(QE(t),{shouldBreak:!0}),")"],p()])]}const h=["(",yb([gb,...l]),Eb(c),gb,")"];return ub(e)?h:mb(h,{shouldBreak:l.some(Cb)||o})};const{builders:{softline:Sb,group:wb,indent:Tb,label:Bb}}=Ji$1,{isNumericLiteral:kb,isMemberExpression:Nb,isCallExpression:Pb}=Gh,{printOptionalToken:Ob}=wE;function Ib(e,t,n){const r=n("property"),i=e.getValue(),u=Ob(e);return i.computed?!i.property||kb(i.property)?[u,"[",r,"]"]:wb([u,"[",Tb([Sb,r]),Sb,"]"]):[u,".",r]}var jb={printMemberExpression:function(e,t,n){const r=e.getValue(),i=e.getParentNode();let u,o=0;do{u=e.getParentNode(o),o++;}while(u&&(Nb(u)||"TSNonNullExpression"===u.type));const s=n("object"),a=Ib(e,t,n),l=u&&("NewExpression"===u.type||"BindExpression"===u.type||"AssignmentExpression"===u.type&&"Identifier"!==u.left.type)||r.computed||"Identifier"===r.object.type&&"Identifier"===r.property.type&&!Nb(i)||("AssignmentExpression"===i.type||"VariableDeclarator"===i.type)&&(Pb(r.object)&&r.object.arguments.length>0||"TSNonNullExpression"===r.object.type&&Pb(r.object.expression)&&r.object.expression.arguments.length>0||"member-chain"===s.label);return Bb("member-chain"===s.label?"member-chain":"member",[s,l?a:wb(Tb([Sb,a]))])},printMemberLookup:Ib};const{printComments:Lb}=Wf,{getLast:_b,isNextLineEmptyAfterIndex:Mb,getNextNonSpaceNonCommentCharacterIndex:Rb}=fi$1,{isCallExpression:$b,isMemberExpression:Vb,isFunctionOrArrowExpression:qb,isLongCurriedCallExpression:Wb,isMemberish:Ub,isNumericLiteral:zb,isSimpleCallArgument:Gb,hasComment:Hb,CommentCheckFlags:Jb,isNextLineEmpty:Xb}=Gh,{locEnd:Yb}=Rl,{builders:{join:Kb,hardline:Qb,group:Zb,indent:eC,conditionalGroup:tC,breakParent:nC,label:rC},utils:{willBreak:iC}}=Ji$1,{printMemberLookup:uC}=jb,{printOptionalToken:oC,printFunctionTypeParameters:sC,printBindExpressionCallee:aC}=wE;var lC=function(e,t,n){const r=e.getParentNode(),i=!r||"ExpressionStatement"===r.type,u=[];function o(e){const{originalText:n}=t,r=Rb(n,e,Yb);return ")"===n.charAt(r)?!1!==r&&Mb(n,r+1):Xb(e,t)}function s(e){const r=e.getValue();$b(r)&&(Ub(r.callee)||$b(r.callee))?(u.unshift({node:r,printed:[Lb(e,[oC(e),sC(e,t,n),xb(e,t,n)],t),o(r)?Qb:""]}),e.call((e=>s(e)),"callee")):Ub(r)?(u.unshift({node:r,needsParens:Yy(e,t),printed:Lb(e,Vb(r)?uC(e,t,n):aC(e,t,n),t)}),e.call((e=>s(e)),"object")):"TSNonNullExpression"===r.type?(u.unshift({node:r,printed:Lb(e,"!",t)}),e.call((e=>s(e)),"expression")):u.unshift({node:r,printed:n()});}const a=e.getValue();u.unshift({node:a,printed:[oC(e),sC(e,t,n),xb(e,t,n)]}),a.callee&&e.call((e=>s(e)),"callee");const l=[];let c=[u[0]],p=1;for(;p<u.length&&("TSNonNullExpression"===u[p].node.type||$b(u[p].node)||Vb(u[p].node)&&u[p].node.computed&&zb(u[p].node.property));++p)c.push(u[p]);if(!$b(u[0].node))for(;p+1<u.length&&(Ub(u[p].node)&&Ub(u[p+1].node));++p)c.push(u[p]);l.push(c),c=[];let f=!1;for(;p<u.length;++p){if(f&&Ub(u[p].node)){if(u[p].node.computed&&zb(u[p].node.property)){c.push(u[p]);continue}l.push(c),c=[],f=!1;}($b(u[p].node)||"ImportExpression"===u[p].node.type)&&(f=!0),c.push(u[p]),Hb(u[p].node,Jb.Trailing)&&(l.push(c),c=[],f=!1);}function d(e){return /^[A-Z]|^[$_]+$/.test(e)}c.length>0&&l.push(c);const h=l.length>=2&&!Hb(l[1][0].node)&&function(e){const n=e[1].length>0&&e[1][0].node.computed;if(1===e[0].length){const r=e[0][0].node;return "ThisExpression"===r.type||"Identifier"===r.type&&(d(r.name)||i&&function(e){return e.length<=t.tabWidth}(r.name)||n)}const r=_b(e[0]).node;return Vb(r)&&"Identifier"===r.property.type&&(d(r.property.name)||n)}(l);function g(e){const t=e.map((e=>e.printed));return e.length>0&&_b(e).needsParens?["(",...t,")"]:t}const m=l.map(g),y=m,D=h?3:2,E=l.flat(),b=E.slice(1,-1).some((e=>Hb(e.node,Jb.Leading)))||E.slice(0,-1).some((e=>Hb(e.node,Jb.Trailing)))||l[D]&&Hb(l[D][0].node,Jb.Leading);if(l.length<=D&&!b)return Wb(e)?y:Zb(y);const C=_b(l[h?1:0]).node,v=!$b(C)&&o(C),A=[g(l[0]),h?l.slice(1,2).map(g):"",v?Qb:"",function(e){return 0===e.length?"":eC(Zb([Qb,Kb(Qb,e.map(g))]))}(l.slice(h?2:1))],F=u.map((({node:e})=>e)).filter($b);let x;return x=b||F.length>2&&F.some((e=>!e.arguments.every((e=>Gb(e,0)))))||m.slice(0,-1).some(iC)||function(){const e=_b(_b(l)).node,t=_b(m);return $b(e)&&iC(t)&&F.slice(0,-1).some((e=>e.arguments.some(qb)))}()?Zb(A):[iC(y)||v?nC:"",tC([y,A])],rC("member-chain",x)};const{builders:{join:cC,group:pC}}=Ji$1,{getCallArguments:fC,hasFlowAnnotationComment:dC,isCallExpression:hC,isMemberish:gC,isStringLiteral:mC,isTemplateOnItsOwnLine:yC,isTestCall:DC,iterateCallArgumentsPath:EC}=Gh,{printOptionalToken:bC,printFunctionTypeParameters:CC}=wE;var vC={printCallExpression:function(e,t,n){const r=e.getValue(),i=e.getParentNode(),u="NewExpression"===r.type,o="ImportExpression"===r.type,s=bC(e),a=fC(r);if(a.length>0&&(!o&&!u&&function(e,t){if("Identifier"!==e.callee.type)return !1;if("require"===e.callee.name)return !0;if("define"===e.callee.name){const n=fC(e);return "ExpressionStatement"===t.type&&(1===n.length||2===n.length&&"ArrayExpression"===n[0].type||3===n.length&&mC(n[0])&&"ArrayExpression"===n[1].type)}return !1}(r,i)||1===a.length&&yC(a[0],t.originalText)||!u&&DC(r,i))){const r=[];return EC(e,(()=>{r.push(n());})),[u?"new ":"",n("callee"),s,CC(e,t,n),"(",cC(", ",r),")"]}const l=("babel"===t.parser||"babel-flow"===t.parser)&&r.callee&&"Identifier"===r.callee.type&&dC(r.callee.trailingComments);if(l&&(r.callee.trailingComments[0].printed=!0),!o&&!u&&gC(r.callee)&&!e.call((e=>Yy(e,t)),"callee"))return lC(e,t,n);const c=[u?"new ":"",o?"import":n("callee"),s,l?`/*:: ${r.callee.trailingComments[0].value.slice(2).trim()} */`:"",CC(e,t,n),xb(e,t,n)];return o||hC(r.callee)?pC(c):c}};const{isNonEmptyArray:AC,getStringWidth:FC}=fi$1,{builders:{line:xC,group:SC,indent:wC,indentIfBreak:TC},utils:{cleanDoc:BC,willBreak:kC}}=Ji$1,{hasLeadingOwnLineComment:NC,isBinaryish:PC,isStringLiteral:OC,isLiteral:IC,isNumericLiteral:jC,isCallExpression:LC,isMemberExpression:_C,getCallArguments:MC,rawText:RC,hasComment:$C,isSignedNumericLiteral:VC,isObjectProperty:qC}=Gh,{shouldInlineLogicalExpression:WC}=BD,{printCallExpression:UC}=vC;function zC(e,t,n,r,i,u){const o=function(e,t,n,r,i){const u=e.getValue(),o=u[i];if(!o)return "only-left";const s=!GC(o);if(e.match(GC,HC,(e=>!s||"ExpressionStatement"!==e.type&&"VariableDeclaration"!==e.type)))return s?"ArrowFunctionExpression"===o.type&&"ArrowFunctionExpression"===o.body.type?"chain-tail-arrow-chain":"chain-tail":"chain";if(!s&&GC(o.right)||NC(t.originalText,o))return "break-after-operator";if("CallExpression"===o.type&&"require"===o.callee.name||"json5"===t.parser||"json"===t.parser)return "never-break-after-operator";if(function(e){if(HC(e)){const t=e.left||e.id;return "ObjectPattern"===t.type&&t.properties.length>2&&t.properties.some((e=>qC(e)&&(!e.shorthand||e.value&&"AssignmentPattern"===e.value.type)))}return !1}(u)||function(e){const t=function(e){if(function(e){return "TSTypeAliasDeclaration"===e.type||"TypeAlias"===e.type}(e)&&e.typeParameters&&e.typeParameters.params)return e.typeParameters.params;return null}(e);if(AC(t)){const n="TSTypeAliasDeclaration"===e.type?"constraint":"bound";if(t.length>1&&t.some((e=>e[n]||e.default)))return !0}return !1}(u)||function(e){if("VariableDeclarator"!==e.type)return !1;const{typeAnnotation:t}=e.id;if(!t||!t.typeAnnotation)return !1;const n=JC(t.typeAnnotation);return AC(n)&&n.length>1&&n.some((e=>AC(JC(e))||"TSConditionalType"===e.type))}(u))return "break-lhs";const a=function(e,t,n){if(!qC(e))return !1;t=BC(t);const r=3;return "string"==typeof t&&FC(t)<n.tabWidth+r}(u,r,t);if(e.call((()=>function(e,t,n,r){const i=e.getValue();if(PC(i)&&!WC(i))return !0;switch(i.type){case"StringLiteralTypeAnnotation":case"SequenceExpression":return !0;case"ConditionalExpression":{const{test:e}=i;return PC(e)&&!WC(e)}case"ClassExpression":return AC(i.decorators)}if(r)return !1;let u=i;const o=[];for(;;)if("UnaryExpression"===u.type)u=u.argument,o.push("argument");else {if("TSNonNullExpression"!==u.type)break;u=u.expression,o.push("expression");}if(OC(u)||e.call((()=>XC(e,t,n)),...o))return !0;return !1}(e,t,n,a)),i))return "break-after-operator";if(a||"TemplateLiteral"===o.type||"TaggedTemplateExpression"===o.type||"BooleanLiteral"===o.type||jC(o)||"ClassExpression"===o.type)return "never-break-after-operator";return "fluid"}(e,t,n,r,u),s=n(u,{assignmentLayout:o});switch(o){case"break-after-operator":return SC([SC(r),i,SC(wC([xC,s]))]);case"never-break-after-operator":return SC([SC(r),i," ",s]);case"fluid":{const e=Symbol("assignment");return SC([SC(r),i,SC(wC(xC),{id:e}),TC(s,{groupId:e})])}case"break-lhs":return SC([r,i," ",SC(s)]);case"chain":return [SC(r),i,xC,s];case"chain-tail":return [SC(r),i,wC([xC,s])];case"chain-tail-arrow-chain":return [SC(r),i,s];case"only-left":return r}}function GC(e){return "AssignmentExpression"===e.type}function HC(e){return GC(e)||"VariableDeclarator"===e.type}function JC(e){return function(e){return "TSTypeReference"===e.type||"GenericTypeAnnotation"===e.type}(e)&&e.typeParameters&&e.typeParameters.params?e.typeParameters.params:null}function XC(e,t,n,r=!1){const i=e.getValue(),u=()=>XC(e,t,n,!0);if("TSNonNullExpression"===i.type)return e.call(u,"expression");if(LC(i)){if("member-chain"===UC(e,t,n).label)return !1;const r=MC(i);return !!(0===r.length||1===r.length&&function(e,{printWidth:t}){if($C(e))return !1;const n=.25*t;if("ThisExpression"===e.type||"Identifier"===e.type&&e.name.length<=n||VC(e)&&!$C(e.argument))return !0;const r="Literal"===e.type&&"regex"in e&&e.regex.pattern||"RegExpLiteral"===e.type&&e.pattern;if(r)return r.length<=n;if(OC(e))return RC(e).length<=n;if("TemplateLiteral"===e.type)return 0===e.expressions.length&&e.quasis[0].value.raw.length<=n&&!e.quasis[0].value.raw.includes("\n");return IC(e)}(r[0],t))&&(!function(e,t){const n=function(e){return e.typeParameters&&e.typeParameters.params||e.typeArguments&&e.typeArguments.params}(e);if(AC(n)){if(n.length>1)return !0;if(1===n.length){const e=n[0];if("TSUnionType"===e.type||"UnionTypeAnnotation"===e.type||"TSIntersectionType"===e.type||"IntersectionTypeAnnotation"===e.type)return !0}const r=e.typeParameters?"typeParameters":"typeArguments";if(kC(t(r)))return !0}return !1}(i,n)&&e.call(u,"callee"))}return _C(i)?e.call(u,"object"):r&&("Identifier"===i.type||"ThisExpression"===i.type)}var YC={printVariableDeclarator:function(e,t,n){return zC(e,t,n,n("id")," =","init")},printAssignmentExpression:function(e,t,n){const r=e.getValue();return zC(e,t,n,n("left"),[" ",r.operator],"right")},printAssignment:zC};const{getNextNonSpaceNonCommentCharacter:KC}=fi$1,{printDanglingComments:QC}=Wf,{builders:{line:ZC,hardline:ev,softline:tv,group:nv,indent:rv,ifBreak:iv},utils:{removeLines:uv,willBreak:ov}}=Ji$1,{getFunctionParameters:sv,iterateFunctionParametersPath:av,isSimpleType:lv,isTestCall:cv,isTypeAnnotationAFunction:pv,isObjectType:fv,isObjectTypePropertyAFunction:dv,hasRestParameter:hv,shouldPrintComma:gv,hasComment:mv,isNextLineEmpty:yv}=Gh,{locEnd:Dv}=Rl,{ArgExpansionBailout:Ev}=go,{printFunctionTypeParameters:bv}=wE;function Cv(e){if(!e)return !1;const t=sv(e);if(1!==t.length)return !1;const[n]=t;return !mv(n)&&("ObjectPattern"===n.type||"ArrayPattern"===n.type||"Identifier"===n.type&&n.typeAnnotation&&("TypeAnnotation"===n.typeAnnotation.type||"TSTypeAnnotation"===n.typeAnnotation.type)&&fv(n.typeAnnotation.typeAnnotation)||"FunctionTypeParam"===n.type&&fv(n.typeAnnotation)||"AssignmentPattern"===n.type&&("ObjectPattern"===n.left.type||"ArrayPattern"===n.left.type)&&("Identifier"===n.right.type||"ObjectExpression"===n.right.type&&0===n.right.properties.length||"ArrayExpression"===n.right.type&&0===n.right.elements.length))}var vv={printFunctionParameters:function(e,t,n,r,i){const u=e.getValue(),o=sv(u),s=i?bv(e,n,t):"";if(0===o.length)return [s,"(",QC(e,n,!0,(e=>")"===KC(n.originalText,e,Dv))),")"];const a=e.getParentNode(),l=cv(a),c=Cv(u),p=[];if(av(e,((e,r)=>{const i=r===o.length-1;i&&u.rest&&p.push("..."),p.push(t()),i||(p.push(","),l||c?p.push(" "):yv(o[r],n)?p.push(ev,ev):p.push(ZC));})),r){if(ov(s)||ov(p))throw new Ev;return nv([uv(s),"(",uv(p),")"])}const f=o.every((e=>!e.decorators));return c&&f||l?[s,"(",...p,")"]:(dv(a)||pv(a)||"TypeAlias"===a.type||"UnionTypeAnnotation"===a.type||"TSUnionType"===a.type||"IntersectionTypeAnnotation"===a.type||"FunctionTypeAnnotation"===a.type&&a.returnType===u)&&1===o.length&&null===o[0].name&&u.this!==o[0]&&o[0].typeAnnotation&&null===u.typeParameters&&lv(o[0].typeAnnotation)&&!u.rest?"always"===n.arrowParens?["(",...p,")"]:p:[s,"(",rv([tv,...p]),iv(!hv(u)&&gv(n,"all")?",":""),tv,")"]},shouldHugFunctionParameters:Cv,shouldGroupFunctionParameters:function(e,t){const n=function(e){let t;return e.returnType?(t=e.returnType,t.typeAnnotation&&(t=t.typeAnnotation)):e.typeAnnotation&&(t=e.typeAnnotation),t}(e);if(!n)return !1;const r=e.typeParameters&&e.typeParameters.params;if(r){if(r.length>1)return !1;if(1===r.length){const e=r[0];if(e.constraint||e.default)return !1}}return 1===sv(e).length&&(fv(n)||ov(t))}};const{printComments:Av,printDanglingComments:Fv}=Wf,{getLast:xv}=fi$1,{builders:{group:Sv,join:wv,line:Tv,softline:Bv,indent:kv,align:Nv,ifBreak:Pv}}=Ji$1,{locStart:Ov}=Rl,{isSimpleType:Iv,isObjectType:jv,hasLeadingOwnLineComment:Lv,isObjectTypePropertyAFunction:_v,shouldPrintComma:Mv}=Gh,{printAssignment:Rv}=YC,{printFunctionParameters:$v,shouldGroupFunctionParameters:Vv}=vv,{printArrayItems:qv}=YE;function Wv(e){if(Iv(e)||jv(e))return !0;if("UnionTypeAnnotation"===e.type||"TSUnionType"===e.type){const t=e.types.filter((e=>"VoidTypeAnnotation"===e.type||"TSVoidKeyword"===e.type||"NullLiteralTypeAnnotation"===e.type||"TSNullKeyword"===e.type)).length,n=e.types.some((e=>"ObjectTypeAnnotation"===e.type||"TSTypeLiteral"===e.type||"GenericTypeAnnotation"===e.type||"TSTypeReference"===e.type));if(e.types.length-1===t&&n)return !0}return !1}var Uv={printOpaqueType:function(e,t,n){const r=t.semi?";":"",i=e.getValue(),u=[];return u.push("opaque type ",n("id"),n("typeParameters")),i.supertype&&u.push(": ",n("supertype")),i.impltype&&u.push(" = ",n("impltype")),u.push(r),u},printTypeAlias:function(e,t,n){const r=t.semi?";":"",i=e.getValue(),u=[];i.declare&&u.push("declare "),u.push("type ",n("id"),n("typeParameters"));const o="TSTypeAliasDeclaration"===i.type?"typeAnnotation":"right";return [Rv(e,t,n,u," =",o),r]},printIntersectionType:function(e,t,n){const r=e.getValue(),i=e.map(n,"types"),u=[];let o=!1;for(let e=0;e<i.length;++e)0===e?u.push(i[e]):jv(r.types[e-1])&&jv(r.types[e])?u.push([" & ",o?kv(i[e]):i[e]]):jv(r.types[e-1])||jv(r.types[e])?(e>1&&(o=!0),u.push(" & ",e>1?kv(i[e]):i[e])):u.push(kv([" &",Tv,i[e]]));return Sv(u)},printUnionType:function(e,t,n){const r=e.getValue(),i=e.getParentNode(),u=!("TypeParameterInstantiation"===i.type||"TSTypeParameterInstantiation"===i.type||"GenericTypeAnnotation"===i.type||"TSTypeReference"===i.type||"TSTypeAssertion"===i.type||"TupleTypeAnnotation"===i.type||"TSTupleType"===i.type||"FunctionTypeParam"===i.type&&!i.name&&e.getParentNode(1).this!==i||("TypeAlias"===i.type||"VariableDeclarator"===i.type||"TSTypeAliasDeclaration"===i.type)&&Lv(t.originalText,r)),o=Wv(r),s=e.map((e=>{let r=n();return o||(r=Nv(2,r)),Av(e,r,t)}),"types");if(o)return wv(" | ",s);const a=u&&!Lv(t.originalText,r),l=[Pv([a?Tv:"","| "]),wv([Tv,"| "],s)];return Yy(e,t)?Sv([kv(l),Bv]):"TupleTypeAnnotation"===i.type&&i.types.length>1||"TSTupleType"===i.type&&i.elementTypes.length>1?Sv([kv([Pv(["(",Bv]),l]),Bv,Pv(")")]):Sv(u?kv(l):l)},printFunctionType:function(e,t,n){const r=e.getValue(),i=[],u=e.getParentNode(0),o=e.getParentNode(1),s=e.getParentNode(2);let a="TSFunctionType"===r.type||!(("ObjectTypeProperty"===u.type||"ObjectTypeInternalSlot"===u.type)&&!u.variance&&!u.optional&&Ov(u)===Ov(r)||"ObjectTypeCallProperty"===u.type||s&&"DeclareFunction"===s.type),l=a&&("TypeAnnotation"===u.type||"TSTypeAnnotation"===u.type);const c=l&&a&&("TypeAnnotation"===u.type||"TSTypeAnnotation"===u.type)&&"ArrowFunctionExpression"===o.type;_v(u)&&(a=!0,l=!0),c&&i.push("(");const p=$v(e,n,t,!1,!0),f=r.returnType||r.predicate||r.typeAnnotation?[a?" => ":": ",n("returnType"),n("predicate"),n("typeAnnotation")]:"",d=Vv(r,f);return i.push(d?Sv(p):p),f&&i.push(f),c&&i.push(")"),Sv(i)},printTupleType:function(e,t,n){const r=e.getValue(),i="TSTupleType"===r.type?"elementTypes":"types",u=r[i].length>0&&"TSRestType"===xv(r[i]).type;return Sv(["[",kv([Bv,qv(e,t,i,n)]),Pv(Mv(t,"all")&&!u?",":""),Fv(e,t,!0),Bv,"]"])},printIndexedAccessType:function(e,t,n){const r=e.getValue(),i="OptionalIndexedAccessType"===r.type&&r.optional?"?.[":"[";return [n("objectType"),i,n("indexType"),"]"]},shouldHugType:Wv};const{printDanglingComments:zv}=Wf,{builders:{join:Gv,line:Hv,hardline:Jv,softline:Xv,group:Yv,indent:Kv,ifBreak:Qv}}=Ji$1,{isTestCall:Zv,hasComment:eA,CommentCheckFlags:tA,isTSXFile:nA,shouldPrintComma:rA,getFunctionParameters:iA}=Gh,{createGroupIdMapper:uA}=fi$1,{shouldHugType:oA}=Uv,sA=uA("typeParameters");function aA(e,t){const n=e.getValue();if(!eA(n,tA.Dangling))return "";const r=!eA(n,tA.Line),i=zv(e,t,r);return r?i:[i,Jv]}var lA={printTypeParameter:function(e,t,n){const r=e.getValue(),i=[],u=e.getParentNode();return "TSMappedType"===u.type?(i.push("[",n("name")),r.constraint&&i.push(" in ",n("constraint")),u.nameType&&i.push(" as ",e.callParent((()=>n("nameType")))),i.push("]"),i):(r.variance&&i.push(n("variance")),i.push(n("name")),r.bound&&i.push(": ",n("bound")),r.constraint&&i.push(" extends ",n("constraint")),r.default&&i.push(" = ",n("default")),i)},printTypeParameters:function(e,t,n,r){const i=e.getValue();if(!i[r])return "";if(!Array.isArray(i[r]))return n(r);const u=e.getNode(2);if(u&&Zv(u)||0===i[r].length||1===i[r].length&&(oA(i[r][0])||"NullableTypeAnnotation"===i[r][0].type))return ["<",Gv(", ",e.map(n,r)),aA(e,t),">"];const o="TSTypeParameterInstantiation"===i.type?"":1===iA(i).length&&nA(t)&&!i[r][0].constraint&&"ArrowFunctionExpression"===e.getParentNode().type?",":rA(t,"all")?Qv(","):"";return Yv(["<",Kv([Xv,Gv([",",Hv],e.map(n,r))]),o,Xv,">"],{id:sA(i)})},getTypeParametersGroupId:sA};const{printComments:cA}=Wf,{printString:pA,printNumber:fA}=fi$1,{isNumericLiteral:dA,isSimpleNumber:hA,isStringLiteral:gA,isStringPropSafeToUnquote:mA,rawText:yA}=Gh,{printAssignment:DA}=YC,EA=new WeakMap;function bA(e,t,n){const r=e.getNode();if(r.computed)return ["[",n("key"),"]"];const i=e.getParentNode(),{key:u}=r;if("ClassPrivateProperty"===r.type&&"Identifier"===u.type)return ["#",n("key")];if("consistent"===t.quoteProps&&!EA.has(i)){const e=(i.properties||i.body||i.members).some((e=>!e.computed&&e.key&&gA(e.key)&&!mA(e,t)));EA.set(i,e);}if(("Identifier"===u.type||dA(u)&&hA(fA(yA(u)))&&String(u.value)===fA(yA(u))&&"typescript"!==t.parser&&"babel-ts"!==t.parser)&&("json"===t.parser||"consistent"===t.quoteProps&&EA.get(i))){const n=pA(JSON.stringify("Identifier"===u.type?u.name:u.value.toString()),t);return e.call((e=>cA(e,n,t)),"key")}return mA(r,t)&&("as-needed"===t.quoteProps||"consistent"===t.quoteProps&&!EA.get(i))?e.call((e=>cA(e,/^\d/.test(u.value)?fA(u.value):u.value,t)),"key"):n("key")}var CA={printProperty:function(e,t,n){return e.getValue().shorthand?n("value"):DA(e,t,n,bA(e,t,n),":","value")},printPropertyKey:bA};const{printDanglingComments:vA,printCommentsSeparately:AA}=Wf,{getNextNonSpaceNonCommentCharacterIndex:FA}=fi$1,{builders:{line:xA,softline:SA,group:wA,indent:TA,ifBreak:BA,hardline:kA,join:NA,indentIfBreak:PA},utils:{removeLines:OA,willBreak:IA}}=Ji$1,{ArgExpansionBailout:jA}=go,{getFunctionParameters:LA,hasLeadingOwnLineComment:_A,isFlowAnnotationComment:MA,isJsxNode:RA,isTemplateOnItsOwnLine:$A,shouldPrintComma:VA,startsWithNoLookaheadToken:qA,isBinaryish:WA,isLineComment:UA,hasComment:zA,getComments:GA,CommentCheckFlags:HA,isCallLikeExpression:JA,isCallExpression:XA,getCallArguments:YA,hasNakedLeftSide:KA,getLeftSide:QA}=Gh,{locEnd:ZA}=Rl,{printFunctionParameters:eF,shouldGroupFunctionParameters:tF}=vv,{printPropertyKey:nF}=CA,{printFunctionTypeParameters:rF}=wE;function iF(e,t,n){const r=e.getNode(),i=eF(e,n,t),u=oF(e,n,t),o=tF(r,u),s=[rF(e,t,n),wA([o?wA(i):i,u])];return r.body?s.push(" ",n("body")):s.push(t.semi?";":""),s}function uF(e,t){if("always"===t.arrowParens)return !1;if("avoid"===t.arrowParens){return function(e){const t=LA(e);return !(1!==t.length||e.typeParameters||zA(e,HA.Dangling)||"Identifier"!==t[0].type||t[0].typeAnnotation||zA(t[0])||t[0].optional||e.predicate||e.returnType)}(e.getValue())}return !1}function oF(e,t,n){const r=e.getValue(),i=t("returnType");if(r.returnType&&MA(n.originalText,r.returnType))return [" /*: ",i," */"];const u=[i];return r.returnType&&r.returnType.typeAnnotation&&u.unshift(": "),r.predicate&&u.push(r.returnType?" ":": ",t("predicate")),u}function sF(e,t,n){const r=e.getValue(),i=t.semi?";":"",u=[];r.argument&&(!function(e,t){if(_A(e.originalText,t))return !0;if(KA(t)){let n,r=t;for(;n=QA(r);)if(r=n,_A(e.originalText,r))return !0}return !1}(t,r.argument)?WA(r.argument)||"SequenceExpression"===r.argument.type?u.push(wA([BA(" ("," "),TA([SA,n("argument")]),SA,BA(")")])):u.push(" ",n("argument")):u.push([" (",TA([kA,n("argument")]),kA,")"]));const o=GA(r),s=Sn$1(o),a=s&&UA(s);return a&&u.push(i),zA(r,HA.Dangling)&&u.push(" ",vA(e,t,!0)),a||u.push(i),u}var aF={printFunction:function(e,t,n,r){const i=e.getValue();let u=!1;if(("FunctionDeclaration"===i.type||"FunctionExpression"===i.type)&&r&&r.expandLastArg){const t=e.getParentNode();XA(t)&&YA(t).length>1&&(u=!0);}const o=[];"TSDeclareFunction"===i.type&&i.declare&&o.push("declare "),i.async&&o.push("async "),i.generator?o.push("function* "):o.push("function "),i.id&&o.push(t("id"));const s=eF(e,t,n,u),a=oF(e,t,n),l=tF(i,a);return o.push(rF(e,n,t),wA([l?wA(s):s,a]),i.body?" ":"",t("body")),!n.semi||!i.declare&&i.body||o.push(";"),o},printArrowFunction:function(e,t,n,r){let i=e.getValue();const u=[],o=[];let s=!1;if(function a(){const l=function(e,t,n,r){const i=[];if(e.getValue().async&&i.push("async "),uF(e,t))i.push(n(["params",0]));else {const u=r&&(r.expandLastArg||r.expandFirstArg);let o=oF(e,n,t);if(u){if(IA(o))throw new jA;o=wA(OA(o));}i.push(wA([eF(e,n,t,u,!0),o]));}const u=vA(e,t,!0,(e=>{const n=FA(t.originalText,e,ZA);return !1!==n&&"=>"===t.originalText.slice(n,n+2)}));return u&&i.push(" ",u),i}(e,t,n,r);if(0===u.length)u.push(l);else {const{leading:n,trailing:r}=AA(e,t);u.push([n,l]),o.unshift(r);}s=s||i.returnType&&LA(i).length>0||i.typeParameters||LA(i).some((e=>"Identifier"!==e.type)),"ArrowFunctionExpression"!==i.body.type||r&&r.expandLastArg?o.unshift(n("body",r)):(i=i.body,e.call(a,"body"));}(),u.length>1)return function(e,t,n,r,i,u){const o=e.getName(),s=e.getParentNode(),a=JA(s)&&"callee"===o,l=Boolean(t&&t.assignmentLayout),c="BlockStatement"!==u.body.type&&"ObjectExpression"!==u.body.type,p=a&&c||t&&"chain-tail-arrow-chain"===t.assignmentLayout,f=Symbol("arrow-chain");return wA([wA(TA([a||l?SA:"",wA(NA([" =>",xA],n),{shouldBreak:r})]),{id:f,shouldBreak:p})," =>",PA(c?TA([xA,i]):[" ",i],{groupId:f}),a?BA(SA,"",{groupId:f}):""])}(e,r,u,s,o,i);const a=u;if(a.push(" =>"),!_A(t.originalText,i.body)&&("ArrayExpression"===i.body.type||"ObjectExpression"===i.body.type||"BlockStatement"===i.body.type||RA(i.body)||$A(i.body,t.originalText)||"ArrowFunctionExpression"===i.body.type||"DoExpression"===i.body.type))return wA([...a," ",o]);if("SequenceExpression"===i.body.type)return wA([...a,wA([" (",TA([SA,o]),SA,")"])]);const l=(r&&r.expandLastArg||"JSXExpressionContainer"===e.getParentNode().type)&&!zA(i),c=r&&r.expandLastArg&&VA(t,"all"),p="ConditionalExpression"===i.body.type&&!qA(i.body,!1);return wA([...a,wA([TA([xA,p?BA("","("):"",o,p?BA("",")"):""]),l?[BA(c?",":""),SA]:""])])},printMethod:function(e,t,n){const r=e.getNode(),{kind:i}=r,u=r.value||r,o=[];return i&&"init"!==i&&"method"!==i&&"constructor"!==i?(yf.ok("get"===i||"set"===i),o.push(i," ")):u.async&&o.push("async "),u.generator&&o.push("*"),o.push(nF(e,t,n),r.optional||r.key.optional?"?":""),r===u?o.push(iF(e,t,n)):"FunctionExpression"===u.type?o.push(e.call((e=>iF(e,t,n)),"value")):o.push(n("value")),o},printReturnStatement:function(e,t,n){return ["return",sF(e,t,n)]},printThrowStatement:function(e,t,n){return ["throw",sF(e,t,n)]},printMethodInternal:iF,shouldPrintParamsWithoutParens:uF};const{isNonEmptyArray:lF,hasNewline:cF}=fi$1,{builders:{line:pF,hardline:fF,join:dF,breakParent:hF,group:gF}}=Ji$1,{locStart:mF,locEnd:yF}=Rl,{getParentExportDeclaration:DF}=Gh;function EF(e,t){return e.decorators.some((e=>cF(t.originalText,yF(e))))}function bF(e){if("ExportDefaultDeclaration"!==e.type&&"ExportNamedDeclaration"!==e.type&&"DeclareExportDeclaration"!==e.type)return !1;const t=e.declaration&&e.declaration.decorators;return lF(t)&&mF(e,{ignoreDecorators:!0})>mF(t[0])}var CF={printDecorators:function(e,t,n){const r=e.getValue(),{decorators:i}=r;if(!lF(i)||bF(e.getParentNode()))return;const u="ClassExpression"===r.type||"ClassDeclaration"===r.type||EF(r,t);return [DF(e)?fF:u?hF:"",dF(pF,e.map(n,"decorators")),pF]},printClassMemberDecorators:function(e,t,n){const r=e.getValue();return gF([dF(pF,e.map(n,"decorators")),EF(r,t)?fF:pF])},printDecoratorsBeforeExport:function(e,t,n){return [dF(fF,e.map(n,"declaration","decorators")),fF]},hasDecoratorsBeforeExport:bF};const{isNonEmptyArray:vF,createGroupIdMapper:AF}=fi$1,{printComments:FF,printDanglingComments:xF}=Wf,{builders:{join:SF,line:wF,hardline:TF,softline:BF,group:kF,indent:NF,ifBreak:PF}}=Ji$1,{hasComment:OF,CommentCheckFlags:IF}=Gh,{getTypeParametersGroupId:jF}=lA,{printMethod:LF}=aF,{printOptionalToken:_F,printTypeAnnotation:MF}=wE,{printPropertyKey:RF}=CA,{printAssignment:$F}=YC,{printClassMemberDecorators:VF}=CF;const qF=AF("heritageGroup");function WF(e){return e.typeParameters&&!OF(e.typeParameters,IF.Trailing|IF.Line)&&!function(e){return ["superClass","extends","mixins","implements"].filter((t=>Boolean(e[t]))).length>1}(e)}function UF(e,t,n,r){const i=e.getValue();if(!vF(i[r]))return "";const u=xF(e,t,!0,(({marker:e})=>e===r));return [WF(i)?PF(" ",wF,{groupId:jF(i.typeParameters)}):wF,u,u&&TF,r,kF(NF([wF,SF([",",wF],e.map(n,r))]))]}function zF(e,t,n){const r=n("superClass");return "AssignmentExpression"===e.getParentNode().type?kF(PF(["(",NF([BF,r]),BF,")"],r)):r}var GF={printClass:function(e,t,n){const r=e.getValue(),i=[];r.declare&&i.push("declare "),r.abstract&&i.push("abstract "),i.push("class");const u=r.id&&OF(r.id,IF.Trailing)||r.superClass&&OF(r.superClass)||vF(r.extends)||vF(r.mixins)||vF(r.implements),o=[],s=[];if(r.id&&o.push(" ",n("id")),o.push(n("typeParameters")),r.superClass){const r=["extends ",zF(e,t,n),n("superTypeParameters")],i=e.call((e=>FF(e,r,t)),"superClass");u?s.push(wF,kF(i)):s.push(" ",i);}else s.push(UF(e,t,n,"extends"));if(s.push(UF(e,t,n,"mixins"),UF(e,t,n,"implements")),u){let e;e=WF(r)?[...o,NF(s)]:NF([...o,s]),i.push(kF(e,{id:qF(r)}));}else i.push(...o,...s);return i.push(" ",n("body")),i},printClassMethod:function(e,t,n){const r=e.getValue(),i=[];return vF(r.decorators)&&i.push(VF(e,t,n)),r.accessibility&&i.push(r.accessibility+" "),r.readonly&&i.push("readonly "),r.declare&&i.push("declare "),r.static&&i.push("static "),("TSAbstractMethodDefinition"===r.type||r.abstract)&&i.push("abstract "),r.override&&i.push("override "),i.push(LF(e,t,n)),i},printClassProperty:function(e,t,n){const r=e.getValue(),i=[],u=t.semi?";":"";return vF(r.decorators)&&i.push(VF(e,t,n)),r.accessibility&&i.push(r.accessibility+" "),r.declare&&i.push("declare "),r.static&&i.push("static "),("TSAbstractClassProperty"===r.type||r.abstract)&&i.push("abstract "),r.override&&i.push("override "),r.readonly&&i.push("readonly "),r.variance&&i.push(n("variance")),i.push(RF(e,t,n),_F(e),MF(e,t,n)),[$F(e,t,n,i," =","value"),u]},printHardlineAfterHeritage:function(e){return PF(TF,"",{groupId:qF(e)})}};const{isNonEmptyArray:HF}=fi$1,{builders:{join:JF,line:XF,group:YF,indent:KF,ifBreak:QF}}=Ji$1,{hasComment:ZF,identity:ex,CommentCheckFlags:tx}=Gh,{getTypeParametersGroupId:nx}=lA,{printTypeScriptModifiers:rx}=wE;var ix={printInterface:function(e,t,n){const r=e.getValue(),i=[];r.declare&&i.push("declare "),"TSInterfaceDeclaration"===r.type&&i.push(r.abstract?"abstract ":"",rx(e,t,n)),i.push("interface");const u=[],o=[];"InterfaceTypeAnnotation"!==r.type&&u.push(" ",n("id"),n("typeParameters"));const s=r.typeParameters&&!ZF(r.typeParameters,tx.Trailing|tx.Line);return HF(r.extends)&&o.push(s?QF(" ",XF,{groupId:nx(r.typeParameters)}):XF,"extends ",(1===r.extends.length?ex:KF)(JF([",",XF],e.map(n,"extends")))),r.id&&ZF(r.id,tx.Trailing)||HF(r.extends)?s?i.push(YF([...u,KF(o)])):i.push(YF(KF([...u,...o]))):i.push(...u,...o),i.push(" ",n("body")),YF(i)}};const{isNonEmptyArray:ux}=fi$1,{builders:{softline:ox,group:sx,indent:ax,join:lx,line:cx,ifBreak:px,hardline:fx}}=Ji$1,{printDanglingComments:dx}=Wf,{hasComment:hx,CommentCheckFlags:gx,shouldPrintComma:mx,needsHardlineAfterDanglingComment:yx}=Gh,{locStart:Dx,hasSameLoc:Ex}=Rl,{hasDecoratorsBeforeExport:bx,printDecoratorsBeforeExport:Cx}=CF;function vx(e,t,n){const r=e.getValue();if(!r.source)return "";const i=[];return Fx(r,t)||i.push(" from"),i.push(" ",n("source")),i}function Ax(e,t,n){const r=e.getValue();if(Fx(r,t))return "";const i=[" "];if(ux(r.specifiers)){const u=[],o=[];if(e.each((()=>{const t=e.getValue().type;if("ExportNamespaceSpecifier"===t||"ExportDefaultSpecifier"===t||"ImportNamespaceSpecifier"===t||"ImportDefaultSpecifier"===t)u.push(n());else {if("ExportSpecifier"!==t&&"ImportSpecifier"!==t)throw new Error(`Unknown specifier type ${JSON.stringify(t)}`);o.push(n());}}),"specifiers"),i.push(lx(", ",u)),o.length>0){u.length>0&&i.push(", ");o.length>1||u.length>0||r.specifiers.some((e=>hx(e)))?i.push(sx(["{",ax([t.bracketSpacing?cx:ox,lx([",",cx],o)]),px(mx(t)?",":""),t.bracketSpacing?cx:ox,"}"])):i.push(["{",t.bracketSpacing?" ":"",...o,t.bracketSpacing?" ":"","}"]);}}else i.push("{}");return i}function Fx(e,t){const{type:n,importKind:r,source:i,specifiers:u}=e;return "ImportDeclaration"===n&&!ux(u)&&"type"!==r&&!/{\s*}/.test(t.originalText.slice(Dx(e),Dx(i)))}function xx(e,t,n){const r=e.getNode();return ux(r.assertions)?[" assert {",t.bracketSpacing?" ":"",lx(", ",e.map(n,"assertions")),t.bracketSpacing?" ":"","}"]:""}var Sx={printImportDeclaration:function(e,t,n){const r=e.getValue(),i=t.semi?";":"",u=[],{importKind:o}=r;return u.push("import"),o&&"value"!==o&&u.push(" ",o),u.push(Ax(e,t,n),vx(e,t,n),xx(e,t,n),i),u},printExportDeclaration:function(e,t,n){const r=e.getValue(),i=[];bx(r)&&i.push(Cx(e,t,n));const{type:u,exportKind:o,declaration:s}=r;return i.push("export"),(r.default||"ExportDefaultDeclaration"===u)&&i.push(" default"),hx(r,gx.Dangling)&&(i.push(" ",dx(e,t,!0)),yx(r)&&i.push(fx)),s?i.push(" ",n("declaration")):i.push("type"===o?" type":"",Ax(e,t,n),vx(e,t,n),xx(e,t,n)),function(e,t){if(!t.semi)return !1;const{type:n,declaration:r}=e,i=e.default||"ExportDefaultDeclaration"===n;if(!r)return !0;const{type:u}=r;if(i&&"ClassDeclaration"!==u&&"FunctionDeclaration"!==u&&"TSInterfaceDeclaration"!==u&&"DeclareClass"!==u&&"DeclareFunction"!==u&&"TSDeclareFunction"!==u&&"EnumDeclaration"!==u)return !0;return !1}(r,t)&&i.push(";"),i},printExportAllDeclaration:function(e,t,n){const r=e.getValue(),i=t.semi?";":"",u=[],{exportKind:o,exported:s}=r;return u.push("export"),"type"===o&&u.push(" type"),u.push(" *"),s&&u.push(" as ",n("exported")),u.push(vx(e,t,n),xx(e,t,n),i),u},printModuleSpecifier:function(e,t,n){const r=e.getNode(),{type:i,importKind:u}=r,o=[];"ImportSpecifier"===i&&u&&o.push(u," ");const s=i.startsWith("Import"),a=s?"imported":"local",l=s?"local":"exported";let c="",p="";return "ExportNamespaceSpecifier"===i||"ImportNamespaceSpecifier"===i?c="*":r[a]&&(c=n(a)),!r[l]||r[a]&&Ex(r[a],r[l])||(p=n(l)),o.push(c,c&&p?" as ":"",p),o}};const{printDanglingComments:wx}=Wf,{builders:{line:Tx,softline:Bx,group:kx,indent:Nx,ifBreak:Px,hardline:Ox}}=Ji$1,{getLast:Ix,hasNewlineInRange:jx,hasNewline:Lx,isNonEmptyArray:_x}=fi$1,{shouldPrintComma:Mx,hasComment:Rx,getComments:$x,CommentCheckFlags:Vx,isNextLineEmpty:qx}=Gh,{locStart:Wx,locEnd:Ux}=Rl,{printOptionalToken:zx,printTypeAnnotation:Gx}=wE,{shouldHugFunctionParameters:Hx}=vv,{shouldHugType:Jx}=Uv,{printHardlineAfterHeritage:Xx}=GF;var Yx={printObject:function(e,t,n){const r=t.semi?";":"",i=e.getValue();let u;u="TSTypeLiteral"===i.type?"members":"TSInterfaceBody"===i.type?"body":"properties";const o="ObjectTypeAnnotation"===i.type,s=[u];o&&s.push("indexers","callProperties","internalSlots");const a=s.map((e=>i[e][0])).sort(((e,t)=>Wx(e)-Wx(t)))[0],l=e.getParentNode(0),c=o&&l&&("InterfaceDeclaration"===l.type||"DeclareInterface"===l.type||"DeclareClass"===l.type)&&"body"===e.getName(),p="TSInterfaceBody"===i.type||c||"ObjectPattern"===i.type&&"FunctionDeclaration"!==l.type&&"FunctionExpression"!==l.type&&"ArrowFunctionExpression"!==l.type&&"ObjectMethod"!==l.type&&"ClassMethod"!==l.type&&"ClassPrivateMethod"!==l.type&&"AssignmentPattern"!==l.type&&"CatchClause"!==l.type&&i.properties.some((e=>e.value&&("ObjectPattern"===e.value.type||"ArrayPattern"===e.value.type)))||"ObjectPattern"!==i.type&&a&&jx(t.originalText,Wx(i),Wx(a)),f=c?";":"TSInterfaceBody"===i.type||"TSTypeLiteral"===i.type?Px(r,";"):",",d="RecordExpression"===i.type?"#{":i.exact?"{|":"{",h=i.exact?"|}":"}",g=[];for(const t of s)e.each((e=>{const t=e.getValue();g.push({node:t,printed:n(),loc:Wx(t)});}),t);s.length>1&&g.sort(((e,t)=>e.loc-t.loc));let m=[];const y=g.map((e=>{const n=[...m,kx(e.printed)];return m=[f,Tx],"TSPropertySignature"!==e.node.type&&"TSMethodSignature"!==e.node.type&&"TSConstructSignatureDeclaration"!==e.node.type||!Rx(e.node,Vx.PrettierIgnore)||m.shift(),qx(e.node,t)&&m.push(Ox),n}));if(i.inexact){let n;if(Rx(i,Vx.Dangling)){const r=Rx(i,Vx.Line);n=[wx(e,t,!0),r||Lx(t.originalText,Ux(Ix($x(i))))?Ox:Tx,"..."];}else n=["..."];y.push([...m,...n]);}const D=Ix(i[u]),E=!(i.inexact||D&&"RestElement"===D.type||D&&("TSPropertySignature"===D.type||"TSCallSignatureDeclaration"===D.type||"TSMethodSignature"===D.type||"TSConstructSignatureDeclaration"===D.type)&&Rx(D,Vx.PrettierIgnore));let b;if(0===y.length){if(!Rx(i,Vx.Dangling))return [d,h,Gx(e,t,n)];b=kx([d,wx(e,t),Bx,h,zx(e),Gx(e,t,n)]);}else b=[c&&_x(i.properties)?Xx(l):"",d,Nx([t.bracketSpacing?Tx:Bx,...y]),Px(E&&(","!==f||Mx(t))?f:""),t.bracketSpacing?Tx:Bx,h,zx(e),Gx(e,t,n)];return e.match((e=>"ObjectPattern"===e.type&&!e.decorators),((e,t,n)=>Hx(e)&&("params"===t||"parameters"===t||"this"===t||"rest"===t)&&0===n))||e.match(Jx,((e,t)=>"typeAnnotation"===t),((e,t)=>"typeAnnotation"===t),((e,t,n)=>Hx(e)&&("params"===t||"parameters"===t||"this"===t||"rest"===t)&&0===n))||!p&&e.match((e=>"ObjectPattern"===e.type),(e=>"AssignmentExpression"===e.type||"VariableDeclarator"===e.type))?b:kx(b,{shouldBreak:p})}};const{printDanglingComments:Kx}=Wf,{printString:Qx,printNumber:Zx}=fi$1,{builders:{hardline:eS,softline:tS,group:nS,indent:rS}}=Ji$1,{getParentExportDeclaration:iS,isFunctionNotation:uS,isGetterOrSetter:oS,rawText:sS,shouldPrintComma:aS}=Gh,{locStart:lS,locEnd:cS}=Rl,{printClass:pS}=GF,{printOpaqueType:fS,printTypeAlias:dS,printIntersectionType:hS,printUnionType:gS,printFunctionType:mS,printTupleType:yS,printIndexedAccessType:DS}=Uv,{printInterface:ES}=ix,{printTypeParameter:bS,printTypeParameters:CS}=lA,{printExportDeclaration:vS,printExportAllDeclaration:AS}=Sx,{printArrayItems:FS}=YE,{printObject:xS}=Yx,{printPropertyKey:SS}=CA,{printOptionalToken:wS,printTypeAnnotation:TS,printRestSpread:BS}=wE;function kS(e,t){const n=iS(e);return n?(yf.strictEqual(n.type,"DeclareExportDeclaration"),t):["declare ",t]}var NS={printFlow:function(e,t,n){const r=e.getValue(),i=t.semi?";":"",u=[];switch(r.type){case"DeclareClass":return kS(e,pS(e,t,n));case"DeclareFunction":return kS(e,["function ",n("id"),r.predicate?" ":"",n("predicate"),i]);case"DeclareModule":return kS(e,["module ",n("id")," ",n("body")]);case"DeclareModuleExports":return kS(e,["module.exports",": ",n("typeAnnotation"),i]);case"DeclareVariable":return kS(e,["var ",n("id"),i]);case"DeclareOpaqueType":return kS(e,fS(e,t,n));case"DeclareInterface":return kS(e,ES(e,t,n));case"DeclareTypeAlias":return kS(e,dS(e,t,n));case"DeclareExportDeclaration":return kS(e,vS(e,t,n));case"DeclareExportAllDeclaration":return kS(e,AS(e,t,n));case"OpaqueType":return fS(e,t,n);case"TypeAlias":return dS(e,t,n);case"IntersectionTypeAnnotation":return hS(e,t,n);case"UnionTypeAnnotation":return gS(e,t,n);case"FunctionTypeAnnotation":return mS(e,t,n);case"TupleTypeAnnotation":return yS(e,t,n);case"GenericTypeAnnotation":return [n("id"),CS(e,t,n,"typeParameters")];case"IndexedAccessType":case"OptionalIndexedAccessType":return DS(e,t,n);case"TypeAnnotation":return n("typeAnnotation");case"TypeParameter":return bS(e,t,n);case"TypeofTypeAnnotation":return ["typeof ",n("argument")];case"ExistsTypeAnnotation":return "*";case"EmptyTypeAnnotation":return "empty";case"MixedTypeAnnotation":return "mixed";case"ArrayTypeAnnotation":return [n("elementType"),"[]"];case"BooleanLiteralTypeAnnotation":return String(r.value);case"EnumDeclaration":return ["enum ",n("id")," ",n("body")];case"EnumBooleanBody":case"EnumNumberBody":case"EnumStringBody":case"EnumSymbolBody":if("EnumSymbolBody"===r.type||r.explicitType){let e=null;switch(r.type){case"EnumBooleanBody":e="boolean";break;case"EnumNumberBody":e="number";break;case"EnumStringBody":e="string";break;case"EnumSymbolBody":e="symbol";}u.push("of ",e," ");}if(0!==r.members.length||r.hasUnknownMembers){const i=r.members.length>0?[eS,FS(e,t,"members",n),r.hasUnknownMembers||aS(t)?",":""]:[];u.push(nS(["{",rS([...i,...r.hasUnknownMembers?[eS,"..."]:[]]),Kx(e,t,!0),eS,"}"]));}else u.push(nS(["{",Kx(e,t),tS,"}"]));return u;case"EnumBooleanMember":case"EnumNumberMember":case"EnumStringMember":return [n("id")," = ","object"==typeof r.init?n("init"):String(r.init)];case"EnumDefaultedMember":return n("id");case"FunctionTypeParam":{const t=r.name?n("name"):e.getParentNode().this===r?"this":"";return [t,wS(e),t?": ":"",n("typeAnnotation")]}case"InterfaceDeclaration":case"InterfaceTypeAnnotation":return ES(e,t,n);case"ClassImplements":case"InterfaceExtends":return [n("id"),n("typeParameters")];case"NullableTypeAnnotation":return ["?",n("typeAnnotation")];case"Variance":{const{kind:e}=r;return yf.ok("plus"===e||"minus"===e),"plus"===e?"+":"-"}case"ObjectTypeCallProperty":return r.static&&u.push("static "),u.push(n("value")),u;case"ObjectTypeIndexer":return [r.variance?n("variance"):"","[",n("id"),r.id?": ":"",n("key"),"]: ",n("value")];case"ObjectTypeProperty":{let i="";return r.proto?i="proto ":r.static&&(i="static "),[i,oS(r)?r.kind+" ":"",r.variance?n("variance"):"",SS(e,t,n),wS(e),uS(r)?"":": ",n("value")]}case"ObjectTypeAnnotation":return xS(e,t,n);case"ObjectTypeInternalSlot":return [r.static?"static ":"","[[",n("id"),"]]",wS(e),r.method?"":": ",n("value")];case"ObjectTypeSpreadProperty":return BS(e,t,n);case"QualifiedTypeIdentifier":return [n("qualification"),".",n("id")];case"StringLiteralTypeAnnotation":return Qx(sS(r),t);case"NumberLiteralTypeAnnotation":yf.strictEqual(typeof r.value,"number");case"BigIntLiteralTypeAnnotation":return r.extra?Zx(r.extra.raw):Zx(r.raw);case"TypeCastExpression":return ["(",n("expression"),TS(e,t,n),")"];case"TypeParameterDeclaration":case"TypeParameterInstantiation":{const i=CS(e,t,n,"params");if("flow"===t.parser){const e=lS(r),n=cS(r),u=t.originalText.lastIndexOf("/*",e),o=t.originalText.indexOf("*/",n);if(-1!==u&&-1!==o){const e=t.originalText.slice(u+2,o).trim();if(e.startsWith("::")&&!e.includes("/*")&&!e.includes("*/"))return ["/*:: ",i," */"]}}return i}case"InferredPredicate":return "%checks";case"DeclaredPredicate":return ["%checks(",n("value"),")"];case"AnyTypeAnnotation":return "any";case"BooleanTypeAnnotation":return "boolean";case"BigIntTypeAnnotation":return "bigint";case"NullLiteralTypeAnnotation":return "null";case"NumberTypeAnnotation":return "number";case"SymbolTypeAnnotation":return "symbol";case"StringTypeAnnotation":return "string";case"VoidTypeAnnotation":return "void";case"ThisTypeAnnotation":return "this";case"Node":case"Printable":case"SourceLocation":case"Position":case"Statement":case"Function":case"Pattern":case"Expression":case"Declaration":case"Specifier":case"NamedSpecifier":case"Comment":case"MemberTypeAnnotation":case"Type":throw new Error("unprintable type: "+JSON.stringify(r.type))}}};const{hasNewlineInRange:PS}=fi$1,{isJsxNode:OS,isBlockComment:IS,getComments:jS,isCallExpression:LS,isMemberExpression:_S}=Gh,{locStart:MS,locEnd:RS}=Rl,{builders:{line:$S,softline:VS,group:qS,indent:WS,align:US,ifBreak:zS,dedent:GS,breakParent:HS}}=Ji$1;function JS(e,t,n){const r=e.getValue(),i="ConditionalExpression"===r.type,u=i?"alternate":"falseType",o=e.getParentNode(),s=i?n("test"):[n("checkType")," ","extends"," ",n("extendsType")];return o.type===r.type&&o[u]===r?US(2,s):s}const XS=new Map([["AssignmentExpression","right"],["VariableDeclarator","init"],["ReturnStatement","argument"],["ThrowStatement","argument"],["UnaryExpression","argument"],["YieldExpression","argument"]]);var YS={printTernary:function(e,t,n){const r=e.getValue(),i="ConditionalExpression"===r.type,u=i?"consequent":"trueType",o=i?"alternate":"falseType",s=i?["test"]:["checkType","extendsType"],a=r[u],l=r[o],c=[];let p=!1;const f=e.getParentNode(),d=f.type===r.type&&s.some((e=>f[e]===r));let h,g,m=f.type===r.type&&!d,y=0;do{g=h||r,h=e.getParentNode(y),y++;}while(h&&h.type===r.type&&s.every((e=>h[e]!==g)));const D=h||f,E=g;if(i&&(OS(r[s[0]])||OS(a)||OS(l)||function(e){const t=[e];for(let e=0;e<t.length;e++){const n=t[e];for(const e of ["test","consequent","alternate"]){const r=n[e];if(OS(r))return !0;"ConditionalExpression"===r.type&&t.push(r);}}return !1}(E))){p=!0,m=!0;const e=e=>[zS("("),WS([VS,e]),VS,zS(")")],t=e=>"NullLiteral"===e.type||"Literal"===e.type&&null===e.value||"Identifier"===e.type&&"undefined"===e.name;c.push(" ? ",t(a)?n(u):e(n(u))," : ",l.type===r.type||t(l)?n(o):e(n(o)));}else {const e=[$S,"? ",a.type===r.type?zS("","("):"",US(2,n(u)),a.type===r.type?zS("",")"):"",$S,": ",l.type===r.type?n(o):US(2,n(o))];c.push(f.type!==r.type||f[o]===r||d?e:t.useTabs?GS(WS(e)):US(Math.max(0,t.tabWidth-2),e));}const b=[...s.map((e=>jS(r[e]))),jS(a),jS(l)].flat().some((e=>IS(e)&&PS(t.originalText,MS(e),RS(e)))),C=!p&&(_S(f)||"NGPipeExpression"===f.type&&f.left===r)&&!f.computed,v=function(e){const t=e.getValue();if("ConditionalExpression"!==t.type)return !1;let n,r=t;for(let t=0;!n;t++){const i=e.getParentNode(t);LS(i)&&i.callee===r||_S(i)&&i.object===r||"TSNonNullExpression"===i.type&&i.expression===r?r=i:"NewExpression"===i.type&&i.callee===r||"TSAsExpression"===i.type&&i.expression===r?(n=e.getParentNode(t+1),r=i):n=i;}return r!==t&&n[XS.get(n.type)]===r}(e),A=(F=[JS(e,0,n),m?c:WS(c),i&&C&&!v?VS:""],f===D?qS(F,{shouldBreak:b}):b?[F,HS]:F);var F;return d||v?qS([WS([VS,A]),VS]):A}};const{builders:{hardline:KS}}=Ji$1,{getLeftSidePathName:QS,hasNakedLeftSide:ZS,isJsxNode:ew,isTheOnlyJsxElementInMarkdown:tw,hasComment:nw,CommentCheckFlags:rw,isNextLineEmpty:iw}=Gh,{shouldPrintParamsWithoutParens:uw}=aF;function ow(e,t,n,r){const i=e.getValue(),u=[],o="ClassBody"===i.type,s=function(e){for(let t=e.length-1;t>=0;t--){const n=e[t];if("EmptyStatement"!==n.type)return n}}(i[r]);return e.each(((e,r,i)=>{const a=e.getValue();if("EmptyStatement"===a.type)return;const l=n();t.semi||o||tw(t,e)||!function(e,t){if("ExpressionStatement"!==e.getNode().type)return !1;return e.call((e=>sw(e,t)),"expression")}(e,t)?u.push(l):nw(a,rw.Leading)?u.push(n([],{needsSemi:!0})):u.push(";",l),!t.semi&&o&&aw(a)&&function(e,t){const n=e.key&&e.key.name;if(!("static"!==n&&"get"!==n&&"set"!==n||e.value||e.typeAnnotation))return !0;if(!t)return !1;if(t.static||t.accessibility)return !1;if(!t.computed){const e=t.key&&t.key.name;if("in"===e||"instanceof"===e)return !0}switch(t.type){case"ClassProperty":case"PropertyDefinition":case"TSAbstractClassProperty":return t.computed;case"MethodDefinition":case"TSAbstractMethodDefinition":case"ClassMethod":case"ClassPrivateMethod":{if((t.value?t.value.async:t.async)||"get"===t.kind||"set"===t.kind)return !1;const e=t.value?t.value.generator:t.generator;return !(!t.computed&&!e)}case"TSIndexSignature":return !0}return !1}(a,i[r+1])&&u.push(";"),a!==s&&(u.push(KS),iw(a,t)&&u.push(KS));}),r),u}function sw(e,t){const n=e.getValue();switch(n.type){case"ParenthesizedExpression":case"TypeCastExpression":case"ArrayExpression":case"ArrayPattern":case"TemplateLiteral":case"TemplateElement":case"RegExpLiteral":return !0;case"ArrowFunctionExpression":if(!uw(e,t))return !0;break;case"UnaryExpression":{const{prefix:e,operator:t}=n;if(e&&("+"===t||"-"===t))return !0;break}case"BindExpression":if(!n.object)return !0;break;case"Literal":if(n.regex)return !0;break;default:if(ew(n))return !0}return !!Yy(e,t)||!!ZS(n)&&e.call((e=>sw(e,t)),...QS(e,n))}const aw=({type:e})=>"ClassProperty"===e||"PropertyDefinition"===e||"ClassPrivateProperty"===e;var lw={printBody:function(e,t,n){return ow(e,t,n,"body")},printSwitchCaseConsequent:function(e,t,n){return ow(e,t,n,"consequent")}};const{printDanglingComments:cw}=Wf,{isNonEmptyArray:pw}=fi$1,{builders:{hardline:fw,indent:dw}}=Ji$1,{hasComment:hw,CommentCheckFlags:gw,isNextLineEmpty:mw}=Gh,{printHardlineAfterHeritage:yw}=GF,{printBody:Dw}=lw;function Ew(e,t,n){const r=e.getValue(),i=pw(r.directives),u=r.body.some((e=>"EmptyStatement"!==e.type)),o=hw(r,gw.Dangling);if(!i&&!u&&!o)return "";const s=[];if(i&&e.each(((e,r,i)=>{s.push(n()),(r<i.length-1||u||o)&&(s.push(fw),mw(e.getValue(),t)&&s.push(fw));}),"directives"),u&&s.push(Dw(e,t,n)),o&&s.push(cw(e,t,!0)),"Program"===r.type){const t=e.getParentNode();t&&"ModuleExpression"===t.type||s.push(fw);}return s}var bw={printBlock:function(e,t,n){const r=e.getValue(),i=[];if("StaticBlock"===r.type&&i.push("static "),"ClassBody"===r.type&&pw(r.body)){const t=e.getParentNode();i.push(yw(t));}i.push("{");const u=Ew(e,t,n);if(u)i.push(dw([fw,u]),fw);else {const t=e.getParentNode(),n=e.getParentNode(1);"ArrowFunctionExpression"===t.type||"FunctionExpression"===t.type||"FunctionDeclaration"===t.type||"ObjectMethod"===t.type||"ClassMethod"===t.type||"ClassPrivateMethod"===t.type||"ForStatement"===t.type||"WhileStatement"===t.type||"DoWhileStatement"===t.type||"DoExpression"===t.type||"CatchClause"===t.type&&!n.finalizer||"TSModuleDeclaration"===t.type||"TSDeclareFunction"===t.type||"StaticBlock"===r.type||"ClassBody"===r.type||i.push(fw);}return i.push("}"),i},printBlockBody:Ew};const{printDanglingComments:Cw}=Wf,{hasNewlineInRange:vw}=fi$1,{builders:{join:Aw,line:Fw,hardline:xw,softline:Sw,group:ww,indent:Tw,conditionalGroup:Bw,ifBreak:kw}}=Ji$1,{isLiteral:Nw,getTypeScriptMappedTypeModifier:Pw,shouldPrintComma:Ow,isCallExpression:Iw,isMemberExpression:jw}=Gh,{locStart:Lw,locEnd:_w}=Rl,{printOptionalToken:Mw,printTypeScriptModifiers:Rw}=wE,{printTernary:$w}=YS,{printFunctionParameters:Vw,shouldGroupFunctionParameters:qw}=vv,{printTemplateLiteral:Ww}=pg,{printArrayItems:Uw}=YE,{printObject:zw}=Yx,{printClassProperty:Gw,printClassMethod:Hw}=GF,{printTypeParameter:Jw,printTypeParameters:Xw}=lA,{printPropertyKey:Yw}=CA,{printFunction:Kw,printMethodInternal:Qw}=aF,{printInterface:Zw}=ix,{printBlock:eT}=bw,{printTypeAlias:tT,printIntersectionType:nT,printUnionType:rT,printFunctionType:iT,printTupleType:uT,printIndexedAccessType:oT}=Uv;var sT={printTypescript:function(e,t,n){const r=e.getValue();if(!r.type.startsWith("TS"))return;if(r.type.endsWith("Keyword"))return r.type.slice(2,-7).toLowerCase();const i=t.semi?";":"",u=[];switch(r.type){case"TSThisType":return "this";case"TSTypeAssertion":{const e=!("ArrayExpression"===r.expression.type||"ObjectExpression"===r.expression.type),t=ww(["<",Tw([Sw,n("typeAnnotation")]),Sw,">"]),i=[kw("("),Tw([Sw,n("expression")]),Sw,kw(")")];return e?Bw([[t,n("expression")],[t,ww(i,{shouldBreak:!0})],[t,n("expression")]]):ww([t,n("expression")])}case"TSDeclareFunction":return Kw(e,n,t);case"TSExportAssignment":return ["export = ",n("expression"),i];case"TSModuleBlock":return eT(e,t,n);case"TSInterfaceBody":case"TSTypeLiteral":return zw(e,t,n);case"TSTypeAliasDeclaration":return tT(e,t,n);case"TSQualifiedName":return Aw(".",[n("left"),n("right")]);case"TSAbstractMethodDefinition":case"TSDeclareMethod":return Hw(e,t,n);case"TSAbstractClassProperty":return Gw(e,t,n);case"TSInterfaceHeritage":case"TSExpressionWithTypeArguments":return u.push(n("expression")),r.typeParameters&&u.push(n("typeParameters")),u;case"TSTemplateLiteralType":return Ww(e,n,t);case"TSNamedTupleMember":return [n("label"),r.optional?"?":"",": ",n("elementType")];case"TSRestType":return ["...",n("typeAnnotation")];case"TSOptionalType":return [n("typeAnnotation"),"?"];case"TSInterfaceDeclaration":return Zw(e,t,n);case"TSClassImplements":return [n("expression"),n("typeParameters")];case"TSTypeParameterDeclaration":case"TSTypeParameterInstantiation":return Xw(e,t,n,"params");case"TSTypeParameter":return Jw(e,t,n);case"TSAsExpression":{u.push(n("expression")," as ",n("typeAnnotation"));const t=e.getParentNode();return Iw(t)&&t.callee===r||jw(t)&&t.object===r?ww([Tw([Sw,...u]),Sw]):u}case"TSArrayType":return [n("elementType"),"[]"];case"TSPropertySignature":return r.readonly&&u.push("readonly "),u.push(Yw(e,t,n),Mw(e)),r.typeAnnotation&&u.push(": ",n("typeAnnotation")),r.initializer&&u.push(" = ",n("initializer")),u;case"TSParameterProperty":return r.accessibility&&u.push(r.accessibility+" "),r.export&&u.push("export "),r.static&&u.push("static "),r.override&&u.push("override "),r.readonly&&u.push("readonly "),u.push(n("parameter")),u;case"TSTypeQuery":return ["typeof ",n("exprName")];case"TSIndexSignature":{const u=e.getParentNode(),o=r.parameters.length>1?kw(Ow(t)?",":""):"",s=ww([Tw([Sw,Aw([", ",Sw],e.map(n,"parameters"))]),o,Sw]);return [r.export?"export ":"",r.accessibility?[r.accessibility," "]:"",r.static?"static ":"",r.readonly?"readonly ":"",r.declare?"declare ":"","[",r.parameters?s:"",r.typeAnnotation?"]: ":"]",r.typeAnnotation?n("typeAnnotation"):"","ClassBody"===u.type?i:""]}case"TSTypePredicate":return [r.asserts?"asserts ":"",n("parameterName"),r.typeAnnotation?[" is ",n("typeAnnotation")]:""];case"TSNonNullExpression":return [n("expression"),"!"];case"TSImportType":return [r.isTypeOf?"typeof ":"","import(",n(r.parameter?"parameter":"argument"),")",r.qualifier?[".",n("qualifier")]:"",Xw(e,t,n,"typeParameters")];case"TSLiteralType":return n("literal");case"TSIndexedAccessType":return oT(e,t,n);case"TSConstructSignatureDeclaration":case"TSCallSignatureDeclaration":case"TSConstructorType":if("TSConstructorType"===r.type&&r.abstract&&u.push("abstract "),"TSCallSignatureDeclaration"!==r.type&&u.push("new "),u.push(ww(Vw(e,n,t,!1,!0))),r.returnType||r.typeAnnotation){const e="TSConstructorType"===r.type;u.push(e?" => ":": ",n("returnType"),n("typeAnnotation"));}return u;case"TSTypeOperator":return [r.operator," ",n("typeAnnotation")];case"TSMappedType":{const u=vw(t.originalText,Lw(r),_w(r));return ww(["{",Tw([t.bracketSpacing?Fw:Sw,r.readonly?[Pw(r.readonly,"readonly")," "]:"",Rw(e,t,n),n("typeParameter"),r.optional?Pw(r.optional,"?"):"",r.typeAnnotation?": ":"",n("typeAnnotation"),kw(i)]),Cw(e,t,!0),t.bracketSpacing?Fw:Sw,"}"],{shouldBreak:u})}case"TSMethodSignature":{const i=r.kind&&"method"!==r.kind?`${r.kind} `:"";u.push(r.accessibility?[r.accessibility," "]:"",i,r.export?"export ":"",r.static?"static ":"",r.readonly?"readonly ":"",r.abstract?"abstract ":"",r.declare?"declare ":"",r.computed?"[":"",n("key"),r.computed?"]":"",Mw(e));const o=Vw(e,n,t,!1,!0),s=r.returnType?"returnType":"typeAnnotation",a=r[s],l=a?n(s):"",c=qw(r,l);return u.push(c?ww(o):o),a&&u.push(": ",ww(l)),ww(u)}case"TSNamespaceExportDeclaration":return u.push("export as namespace ",n("id")),t.semi&&u.push(";"),ww(u);case"TSEnumDeclaration":return r.declare&&u.push("declare "),r.modifiers&&u.push(Rw(e,t,n)),r.const&&u.push("const "),u.push("enum ",n("id")," "),0===r.members.length?u.push(ww(["{",Cw(e,t),Sw,"}"])):u.push(ww(["{",Tw([xw,Uw(e,t,"members",n),Ow(t,"es5")?",":""]),Cw(e,t,!0),xw,"}"])),u;case"TSEnumMember":return u.push(n("id")),r.initializer&&u.push(" = ",n("initializer")),u;case"TSImportEqualsDeclaration":return r.isExport&&u.push("export "),u.push("import "),r.importKind&&"value"!==r.importKind&&u.push(r.importKind," "),u.push(n("id")," = ",n("moduleReference")),t.semi&&u.push(";"),ww(u);case"TSExternalModuleReference":return ["require(",n("expression"),")"];case"TSModuleDeclaration":{const o=e.getParentNode(),s=Nw(r.id),a="TSModuleDeclaration"===o.type,l=r.body&&"TSModuleDeclaration"===r.body.type;if(a)u.push(".");else {r.declare&&u.push("declare "),u.push(Rw(e,t,n));const i=t.originalText.slice(Lw(r),Lw(r.id));"Identifier"===r.id.type&&"global"===r.id.name&&!/namespace|module/.test(i)||u.push(s||/(^|\s)module(\s|$)/.test(i)?"module ":"namespace ");}return u.push(n("id")),l?u.push(n("body")):r.body?u.push(" ",ww(n("body"))):u.push(i),u}case"TSPrivateIdentifier":return r.escapedText;case"TSConditionalType":return $w(e,t,n);case"TSInferType":return ["infer"," ",n("typeParameter")];case"TSIntersectionType":return nT(e,t,n);case"TSUnionType":return rT(e,t,n);case"TSFunctionType":return iT(e,t,n);case"TSTupleType":return uT(e,t,n);case"TSTypeReference":return [n("typeName"),Xw(e,t,n,"typeParameters")];case"TSTypeAnnotation":return n("typeAnnotation");case"TSEmptyBodyFunctionExpression":return Qw(e,t,n);case"TSJSDocAllType":return "*";case"TSJSDocUnknownType":return "?";case"TSJSDocNullableType":return ["?",n("typeAnnotation")];case"TSJSDocNonNullableType":return ["!",n("typeAnnotation")];default:throw new Error(`Unknown TypeScript node type: ${JSON.stringify(r.type)}.`)}}};const{hasNewline:aT}=fi$1,{builders:{join:lT,hardline:cT},utils:{replaceNewlinesWithLiterallines:pT}}=Ji$1,{isLineComment:fT,isBlockComment:dT}=Gh,{locStart:hT,locEnd:gT}=Rl;var mT={printComment:function(e,t){const n=e.getValue();if(fT(n))return t.originalText.slice(hT(n),gT(n)).trimEnd();if(dT(n)){if(function(e){const t=`*${e.value}*`.split("\n");return t.length>1&&t.every((e=>"*"===e.trim()[0]))}(n)){const e=function(e){const t=e.value.split("\n");return ["/*",lT(cT,t.map(((e,n)=>0===n?e.trimEnd():" "+(n<t.length-1?e.trim():e.trimStart())))),"*/"]}(n);return n.trailing&&!aT(t.originalText,hT(n),{backwards:!0})?[cT,e]:e}const e=gT(n),r="*-/"===t.originalText.slice(e-3,e);return ["/*",pT(n.value),r?"*-/":"*/"]}throw new Error("Not a comment: "+JSON.stringify(n))}};const{printString:yT,printNumber:DT}=fi$1;function ET(e){return e.toLowerCase()}function bT({pattern:e,flags:t}){return `/${e}/${t=t.split("").sort().join("")}`}var CT={printLiteral:function(e,t){const n=e.getNode();switch(n.type){case"RegExpLiteral":return bT(n);case"BigIntLiteral":return ET(n.bigint||n.extra.raw);case"NumericLiteral":return DT(n.extra.raw);case"StringLiteral":return yT(n.extra.raw,t);case"NullLiteral":return "null";case"BooleanLiteral":return String(n.value);case"DecimalLiteral":return DT(n.value)+"m";case"Literal":{if(n.regex)return bT(n.regex);if(n.bigint)return ET(n.raw);if(n.decimal)return DT(n.decimal)+"m";const{value:e}=n;return "number"==typeof e?DT(n.raw):"string"==typeof e?yT(n.raw,t):String(e)}}}};const{printDanglingComments:vT}=Wf,{hasNewline:AT}=fi$1,{builders:{join:FT,line:xT,hardline:ST,softline:wT,group:TT,indent:BT},utils:{replaceNewlinesWithLiterallines:kT}}=Ji$1,{insertPragma:NT}=Nm,{hasFlowShorthandAnnotationComment:PT,hasComment:OT,CommentCheckFlags:IT,isTheOnlyJsxElementInMarkdown:jT,isBlockComment:LT,isLineComment:_T,isNextLineEmpty:MT,needsHardlineAfterDanglingComment:RT,rawText:$T,hasIgnoreComment:VT,isCallExpression:qT,isMemberExpression:WT}=Gh,{locStart:UT,locEnd:zT}=Rl,{printHtmlBinding:GT,isVueEventBindingExpression:HT}=rD,{printAngular:JT}=MD,{printJsx:XT,hasJsxIgnoreComment:YT}=bE,{printFlow:KT}=NS,{printTypescript:QT}=sT,{printOptionalToken:ZT,printBindExpressionCallee:eB,printTypeAnnotation:tB,adjustClause:nB,printRestSpread:rB}=wE,{printImportDeclaration:iB,printExportDeclaration:uB,printExportAllDeclaration:oB,printModuleSpecifier:sB}=Sx,{printTernary:aB}=YS,{printTemplateLiteral:lB}=pg,{printArray:cB}=YE,{printObject:pB}=Yx,{printClass:fB,printClassMethod:dB,printClassProperty:hB}=GF,{printProperty:gB}=CA,{printFunction:mB,printArrowFunction:yB,printMethod:DB,printReturnStatement:EB,printThrowStatement:bB}=aF,{printCallExpression:CB}=vC,{printVariableDeclarator:vB,printAssignmentExpression:AB}=YC,{printBinaryishExpression:FB}=BD,{printSwitchCaseConsequent:xB}=lw,{printMemberExpression:SB}=jb,{printBlock:wB,printBlockBody:TB}=bw,{printComment:BB}=mT,{printLiteral:kB}=CT,{printDecorators:NB}=CF;function PB(e,t){const n=$T(e),r=n.slice(1,-1);if(r.includes('"')||r.includes("'"))return n;const i=t.singleQuote?"'":'"';return i+r+i}var OB={preprocess:Ky,print:function(e,t,n,r){const i=function(e,t,n,r){const i=e.getValue(),u=t.semi?";":"";if(!i)return "";if("string"==typeof i)return i;for(const r of [kB,GT,JT,XT,KT,QT]){const i=r(e,t,n);if(void 0!==i)return i}let o=[];switch(i.type){case"JsExpressionRoot":return n("node");case"JsonRoot":return [n("node"),ST];case"File":return i.program&&i.program.interpreter&&o.push(n(["program","interpreter"])),o.push(n("program")),o;case"Program":return TB(e,t,n);case"EmptyStatement":return "";case"ExpressionStatement":if(i.directive)return [PB(i.expression,t),u];if("__vue_event_binding"===t.parser){const t=e.getParentNode();if("Program"===t.type&&1===t.body.length&&t.body[0]===i)return [n("expression"),HT(i.expression)?";":""]}return [n("expression"),jT(t,e)?"":u];case"ParenthesizedExpression":return !OT(i.expression)&&("ObjectExpression"===i.expression.type||"ArrayExpression"===i.expression.type)?["(",n("expression"),")"]:TT(["(",BT([wT,n("expression")]),wT,")"]);case"AssignmentExpression":return AB(e,t,n);case"VariableDeclarator":return vB(e,t,n);case"BinaryExpression":case"LogicalExpression":return FB(e,t,n);case"AssignmentPattern":return [n("left")," = ",n("right")];case"OptionalMemberExpression":case"MemberExpression":return SB(e,t,n);case"MetaProperty":return [n("meta"),".",n("property")];case"BindExpression":return i.object&&o.push(n("object")),o.push(TT(BT([wT,eB(e,t,n)]))),o;case"Identifier":return [i.name,ZT(e),tB(e,t,n)];case"V8IntrinsicIdentifier":return ["%",i.name];case"SpreadElement":case"SpreadElementPattern":case"SpreadProperty":case"SpreadPropertyPattern":case"RestElement":return rB(e,t,n);case"FunctionDeclaration":case"FunctionExpression":return mB(e,n,t,r);case"ArrowFunctionExpression":return yB(e,t,n,r);case"YieldExpression":return o.push("yield"),i.delegate&&o.push("*"),i.argument&&o.push(" ",n("argument")),o;case"AwaitExpression":if(o.push("await"),i.argument){o.push(" ",n("argument"));const t=e.getParentNode();if(qT(t)&&t.callee===i||WT(t)&&t.object===i){o=[BT([wT,...o]),wT];const t=e.findAncestor((e=>"AwaitExpression"===e.type||"BlockStatement"===e.type));if(!t||"AwaitExpression"!==t.type)return TT(o)}}return o;case"ExportDefaultDeclaration":case"ExportNamedDeclaration":return uB(e,t,n);case"ExportAllDeclaration":return oB(e,t,n);case"ImportDeclaration":return iB(e,t,n);case"ImportSpecifier":case"ExportSpecifier":case"ImportNamespaceSpecifier":case"ExportNamespaceSpecifier":case"ImportDefaultSpecifier":case"ExportDefaultSpecifier":return sB(e,t,n);case"ImportAttribute":return [n("key"),": ",n("value")];case"Import":return "import";case"BlockStatement":case"StaticBlock":case"ClassBody":return wB(e,t,n);case"ThrowStatement":return bB(e,t,n);case"ReturnStatement":return EB(e,t,n);case"NewExpression":case"ImportExpression":case"OptionalCallExpression":case"CallExpression":return CB(e,t,n);case"ObjectExpression":case"ObjectPattern":case"RecordExpression":return pB(e,t,n);case"ObjectProperty":case"Property":return i.method||"get"===i.kind||"set"===i.kind?DB(e,t,n):gB(e,t,n);case"ObjectMethod":return DB(e,t,n);case"Decorator":return ["@",n("expression")];case"ArrayExpression":case"ArrayPattern":case"TupleExpression":return cB(e,t,n);case"SequenceExpression":{const t=e.getParentNode(0);if("ExpressionStatement"===t.type||"ForStatement"===t.type){const t=[];return e.each(((e,r)=>{0===r?t.push(n()):t.push(",",BT([xT,n()]));}),"expressions"),TT(t)}return TT(FT([",",xT],e.map(n,"expressions")))}case"ThisExpression":return "this";case"Super":return "super";case"Directive":return [n("value"),u];case"DirectiveLiteral":return PB(i,t);case"UnaryExpression":return o.push(i.operator),/[a-z]$/.test(i.operator)&&o.push(" "),OT(i.argument)?o.push(TT(["(",BT([wT,n("argument")]),wT,")"])):o.push(n("argument")),o;case"UpdateExpression":return o.push(n("argument"),i.operator),i.prefix&&o.reverse(),o;case"ConditionalExpression":return aB(e,t,n);case"VariableDeclaration":{const t=e.map(n,"declarations"),r=e.getParentNode(),s="ForStatement"===r.type||"ForInStatement"===r.type||"ForOfStatement"===r.type,a=i.declarations.some((e=>e.init));let l;return 1!==t.length||OT(i.declarations[0])?t.length>0&&(l=BT(t[0])):l=t[0],o=[i.declare?"declare ":"",i.kind,l?[" ",l]:"",BT(t.slice(1).map((e=>[",",a&&!s?ST:xT,e])))],s&&r.body!==i||o.push(u),TT(o)}case"WithStatement":return TT(["with (",n("object"),")",nB(i.body,n("body"))]);case"IfStatement":{const r=nB(i.consequent,n("consequent")),u=TT(["if (",TT([BT([wT,n("test")]),wT]),")",r]);if(o.push(u),i.alternate){const r=OT(i.consequent,IT.Trailing|IT.Line)||RT(i),u="BlockStatement"===i.consequent.type&&!r;o.push(u?" ":ST),OT(i,IT.Dangling)&&o.push(vT(e,t,!0),r?ST:" "),o.push("else",TT(nB(i.alternate,n("alternate"),"IfStatement"===i.alternate.type)));}return o}case"ForStatement":{const r=nB(i.body,n("body")),u=vT(e,t,!0),o=u?[u,wT]:"";return i.init||i.test||i.update?[o,TT(["for (",TT([BT([wT,n("init"),";",xT,n("test"),";",xT,n("update")]),wT]),")",r])]:[o,TT(["for (;;)",r])]}case"WhileStatement":return TT(["while (",TT([BT([wT,n("test")]),wT]),")",nB(i.body,n("body"))]);case"ForInStatement":return TT(["for (",n("left")," in ",n("right"),")",nB(i.body,n("body"))]);case"ForOfStatement":return TT(["for",i.await?" await":""," (",n("left")," of ",n("right"),")",nB(i.body,n("body"))]);case"DoWhileStatement":{const e=nB(i.body,n("body"));return o=[TT(["do",e])],"BlockStatement"===i.body.type?o.push(" "):o.push(ST),o.push("while (",TT([BT([wT,n("test")]),wT]),")",u),o}case"DoExpression":return [i.async?"async ":"","do ",n("body")];case"BreakStatement":return o.push("break"),i.label&&o.push(" ",n("label")),o.push(u),o;case"ContinueStatement":return o.push("continue"),i.label&&o.push(" ",n("label")),o.push(u),o;case"LabeledStatement":return "EmptyStatement"===i.body.type?[n("label"),":;"]:[n("label"),": ",n("body")];case"TryStatement":return ["try ",n("block"),i.handler?[" ",n("handler")]:"",i.finalizer?[" finally ",n("finalizer")]:""];case"CatchClause":if(i.param){const e=OT(i.param,(e=>!LT(e)||e.leading&&AT(t.originalText,zT(e))||e.trailing&&AT(t.originalText,UT(e),{backwards:!0}))),r=n("param");return ["catch ",e?["(",BT([wT,r]),wT,") "]:["(",r,") "],n("body")]}return ["catch ",n("body")];case"SwitchStatement":return [TT(["switch (",BT([wT,n("discriminant")]),wT,")"])," {",i.cases.length>0?BT([ST,FT(ST,e.map(((e,r,i)=>{const u=e.getValue();return [n(),r!==i.length-1&&MT(u,t)?ST:""]}),"cases"))]):"",ST,"}"];case"SwitchCase":{i.test?o.push("case ",n("test"),":"):o.push("default:");const r=i.consequent.filter((e=>"EmptyStatement"!==e.type));if(r.length>0){const i=xB(e,t,n);o.push(1===r.length&&"BlockStatement"===r[0].type?[" ",i]:BT([ST,i]));}return o}case"DebuggerStatement":return ["debugger",u];case"ClassDeclaration":case"ClassExpression":return fB(e,t,n);case"ClassMethod":case"ClassPrivateMethod":case"MethodDefinition":return dB(e,t,n);case"ClassProperty":case"PropertyDefinition":case"ClassPrivateProperty":return hB(e,t,n);case"TemplateElement":return kT(i.value.raw);case"TemplateLiteral":return lB(e,n,t);case"TaggedTemplateExpression":return [n("tag"),n("typeParameters"),n("quasi")];case"PrivateIdentifier":return ["#",n("name")];case"PrivateName":return ["#",n("id")];case"InterpreterDirective":return o.push("#!",i.value,ST),MT(i,t)&&o.push(ST),o;case"PipelineBareFunction":return n("callee");case"PipelineTopicExpression":return n("expression");case"PipelinePrimaryTopicReference":return "#";case"ArgumentPlaceholder":return "?";case"ModuleExpression":{o.push("module {");const e=n("body");return e&&o.push(BT([ST,e]),ST),o.push("}"),o}default:throw new Error("unknown type: "+JSON.stringify(i.type))}}(e,t,n,r);if(!i)return "";const u=e.getValue(),{type:o}=u;if("ClassMethod"===o||"ClassPrivateMethod"===o||"ClassProperty"===o||"PropertyDefinition"===o||"TSAbstractClassProperty"===o||"ClassPrivateProperty"===o||"MethodDefinition"===o||"TSAbstractMethodDefinition"===o||"TSDeclareMethod"===o)return i;const s=NB(e,t,n);if(s)return TT([...s,i]);if(!Yy(e,t))return r&&r.needsSemi?[";",i]:i;const a=[r&&r.needsSemi?";(":"(",i];if(PT(u)){const[e]=u.trailingComments;a.push(" /*",e.value.trimStart(),"*/"),e.printed=!0;}return a.push(")"),a},embed:Kg,insertPragma:NT,massageAstNode:nm,hasPrettierIgnore:e=>VT(e)||YT(e),willPrintOwnComments:Iy.willPrintOwnComments,canAttachComment:function(e){return e.type&&!LT(e)&&!_T(e)&&"EmptyStatement"!==e.type&&"TemplateElement"!==e.type&&"Import"!==e.type&&"TSEmptyBodyFunctionExpression"!==e.type},printComment:BB,isBlockComment:LT,handleComments:{avoidAstMutation:!0,ownLine:Iy.handleOwnLineComment,endOfLine:Iy.handleEndOfLineComment,remaining:Iy.handleRemainingComment},getCommentChildNodes:Iy.getCommentChildNodes};const{builders:{hardline:IB,indent:jB,join:LB}}=Ji$1;const _B=new Set(["start","end","extra","loc","comments","leadingComments","trailingComments","innerComments","errors","range","tokens"]);function MB(e,t){const{type:n}=e;if("ObjectProperty"!==n||"Identifier"!==e.key.type){if("UnaryExpression"===n&&"+"===e.operator)return t.argument;if("ArrayExpression"!==n)return "TemplateLiteral"===n?{type:"StringLiteral",value:e.quasis[0].value.cooked}:void 0;for(const[n,r]of e.elements.entries())null===r&&t.elements.splice(n,0,{type:"NullLiteral"});}else t.key={type:"StringLiteral",value:e.key.name};}MB.ignoredProperties=_B;var RB={preprocess:Ky,print:function(e,t,n){const r=e.getValue();switch(r.type){case"JsonRoot":return [n("node"),IB];case"ArrayExpression":{if(0===r.elements.length)return "[]";const t=e.map((()=>null===e.getValue()?"null":n()),"elements");return ["[",jB([IB,LB([",",IB],t)]),IB,"]"]}case"ObjectExpression":return 0===r.properties.length?"{}":["{",jB([IB,LB([",",IB],e.map(n,"properties"))]),IB,"}"];case"ObjectProperty":return [n("key"),": ",n("value")];case"UnaryExpression":return ["+"===r.operator?"":r.operator,n("argument")];case"NullLiteral":return "null";case"BooleanLiteral":return r.value?"true":"false";case"StringLiteral":case"NumericLiteral":return JSON.stringify(r.value);case"Identifier":{const t=e.getParentNode();return t&&"ObjectProperty"===t.type&&t.key===r?JSON.stringify(r.name):r.name}case"TemplateLiteral":return n(["quasis",0]);case"TemplateElement":return JSON.stringify(r.value.cooked);default:throw new Error("unknown type: "+JSON.stringify(r.type))}},massageAstNode:MB};var $B={bracketSpacing:{since:"0.0.0",category:"Common",type:"boolean",default:!0,description:"Print spaces between brackets.",oppositeDescription:"Do not print spaces between brackets."},singleQuote:{since:"0.0.0",category:"Common",type:"boolean",default:!1,description:"Use single quotes instead of double quotes."},proseWrap:{since:"1.8.2",category:"Common",type:"choice",default:[{since:"1.8.2",value:!0},{since:"1.9.0",value:"preserve"}],description:"How to wrap prose.",choices:[{since:"1.9.0",value:"always",description:"Wrap prose if it exceeds the print width."},{since:"1.9.0",value:"never",description:"Do not wrap prose."},{since:"1.9.0",value:"preserve",description:"Wrap prose as-is."}]}};var VB={arrowParens:{since:"1.9.0",category:"JavaScript",type:"choice",default:[{since:"1.9.0",value:"avoid"},{since:"2.0.0",value:"always"}],description:"Include parentheses around a sole arrow function parameter.",choices:[{value:"always",description:"Always include parens. Example: `(x) => x`"},{value:"avoid",description:"Omit parens when possible. Example: `x => x`"}]},bracketSpacing:$B.bracketSpacing,jsxBracketSameLine:{since:"0.17.0",category:"JavaScript",type:"boolean",default:!1,description:"Put > on the last line instead of at a new line."},semi:{since:"1.0.0",category:"JavaScript",type:"boolean",default:!0,description:"Print semicolons.",oppositeDescription:"Do not print semicolons, except at the beginning of lines which may need them."},singleQuote:$B.singleQuote,jsxSingleQuote:{since:"1.15.0",category:"JavaScript",type:"boolean",default:!1,description:"Use single quotes in JSX."},quoteProps:{since:"1.17.0",category:"JavaScript",type:"choice",default:"as-needed",description:"Change when properties in objects are quoted.",choices:[{value:"as-needed",description:"Only add quotes around object properties where required."},{value:"consistent",description:"If at least one property in an object requires quotes, quote all properties."},{value:"preserve",description:"Respect the input use of quotes in object properties."}]},trailingComma:{since:"0.0.0",category:"JavaScript",type:"choice",default:[{since:"0.0.0",value:!1},{since:"0.19.0",value:"none"},{since:"2.0.0",value:"es5"}],description:"Print trailing commas wherever possible when multi-line.",choices:[{value:"es5",description:"Trailing commas where valid in ES5 (objects, arrays, etc.)"},{value:"none",description:"No trailing commas."},{value:"all",description:"Trailing commas wherever possible (including function arguments)."}]}},qB={name:"JavaScript",type:"programming",tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"text/javascript",color:"#f1e05a",aliases:["js","node"],extensions:[".js","._js",".bones",".cjs",".es",".es6",".frag",".gs",".jake",".jsb",".jscad",".jsfl",".jsm",".jss",".jsx",".mjs",".njs",".pac",".sjs",".ssjs",".xsjs",".xsjslib"],filenames:["Jakefile"],interpreters:["chakra","d8","gjs","js","node","nodejs","qjs","rhino","v8","v8-shell"],languageId:183},WB={name:"TypeScript",type:"programming",color:"#2b7489",aliases:["ts"],interpreters:["deno","ts-node"],extensions:[".ts"],tmScope:"source.ts",aceMode:"typescript",codemirrorMode:"javascript",codemirrorMimeType:"application/typescript",languageId:378},UB={name:"TSX",type:"programming",group:"TypeScript",extensions:[".tsx"],tmScope:"source.tsx",aceMode:"javascript",codemirrorMode:"jsx",codemirrorMimeType:"text/jsx",languageId:94901924},zB={name:"JSON",type:"data",tmScope:"source.json",aceMode:"json",codemirrorMode:"javascript",codemirrorMimeType:"application/json",extensions:[".json",".avsc",".geojson",".gltf",".har",".ice",".JSON-tmLanguage",".jsonl",".mcmeta",".tfstate",".tfstate.backup",".topojson",".webapp",".webmanifest",".yy",".yyp"],filenames:[".arcconfig",".htmlhintrc",".imgbotconfig",".tern-config",".tern-project",".watchmanconfig","Pipfile.lock","composer.lock","mcmod.info"],languageId:174},GB={name:"JSON with Comments",type:"data",group:"JSON",tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"text/javascript",aliases:["jsonc"],extensions:[".jsonc",".sublime-build",".sublime-commands",".sublime-completions",".sublime-keymap",".sublime-macro",".sublime-menu",".sublime-mousemap",".sublime-project",".sublime-settings",".sublime-theme",".sublime-workspace",".sublime_metrics",".sublime_session"],filenames:[".babelrc",".eslintrc.json",".jscsrc",".jshintrc",".jslintrc","api-extractor.json","devcontainer.json","jsconfig.json","language-configuration.json","tsconfig.json","tslint.json"],languageId:423},HB={name:"JSON5",type:"data",extensions:[".json5"],tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"application/json",languageId:175};var JB={languages:[Yd(qB,(e=>({since:"0.0.0",parsers:["babel","espree","meriyah","babel-flow","babel-ts","flow","typescript"],vscodeLanguageIds:["javascript","mongo"],extensions:[...e.extensions.filter((e=>".jsx"!==e)),".wxs"]}))),Yd(qB,(()=>({name:"Flow",since:"0.0.0",parsers:["flow","babel-flow"],vscodeLanguageIds:["javascript"],aliases:[],filenames:[],extensions:[".js.flow"]}))),Yd(qB,(()=>({name:"JSX",since:"0.0.0",parsers:["babel","babel-flow","babel-ts","flow","typescript","espree","meriyah"],vscodeLanguageIds:["javascriptreact"],aliases:void 0,filenames:void 0,extensions:[".jsx"],group:"JavaScript",interpreters:void 0,tmScope:"source.js.jsx",aceMode:"javascript",codemirrorMode:"jsx",codemirrorMimeType:"text/jsx",color:void 0}))),Yd(WB,(()=>({since:"1.4.0",parsers:["typescript","babel-ts"],vscodeLanguageIds:["typescript"]}))),Yd(UB,(()=>({since:"1.4.0",parsers:["typescript","babel-ts"],vscodeLanguageIds:["typescriptreact"]}))),Yd(zB,(()=>({name:"JSON.stringify",since:"1.13.0",parsers:["json-stringify"],vscodeLanguageIds:["json"],extensions:[],filenames:["package.json","package-lock.json","composer.json"]}))),Yd(zB,(e=>({since:"1.5.0",parsers:["json"],vscodeLanguageIds:["json"],extensions:e.extensions.filter((e=>".jsonl"!==e))}))),Yd(GB,(e=>({since:"1.5.0",parsers:["json"],vscodeLanguageIds:["jsonc"],filenames:[...e.filenames,".eslintrc"]}))),Yd(HB,(()=>({since:"1.13.0",parsers:["json5"],vscodeLanguageIds:["json5"]})))],options:VB,printers:{estree:OB,"estree-json":RB},parsers:{get babel(){return require("./parser-babel").parsers.babel},get"babel-flow"(){return require("./parser-babel").parsers["babel-flow"]},get"babel-ts"(){return require("./parser-babel").parsers["babel-ts"]},get json(){return require("./parser-babel").parsers.json},get json5(){return require("./parser-babel").parsers.json5},get"json-stringify"(){return require("./parser-babel").parsers["json-stringify"]},get __js_expression(){return require("./parser-babel").parsers.__js_expression},get __vue_expression(){return require("./parser-babel").parsers.__vue_expression},get __vue_event_binding(){return require("./parser-babel").parsers.__vue_event_binding},get flow(){return require("./parser-flow").parsers.flow},get typescript(){return require("./parser-typescript").parsers.typescript},get __ng_action(){return require("./parser-angular").parsers.__ng_action},get __ng_binding(){return require("./parser-angular").parsers.__ng_binding},get __ng_interpolation(){return require("./parser-angular").parsers.__ng_interpolation},get __ng_directive(){return require("./parser-angular").parsers.__ng_directive},get espree(){return require("./parser-espree").parsers.espree},get meriyah(){return require("./parser-meriyah").parsers.meriyah},get __babel_estree(){return require("./parser-babel").parsers.__babel_estree}}};const{isFrontMatterNode:XB}=fi$1,YB=new Set(["raw","raws","sourceIndex","source","before","after","trailingComma"]);function KB(e,t,n){if(XB(e)&&"yaml"===e.lang&&delete t.value,"css-comment"===e.type&&"css-root"===n.type&&n.nodes.length>0){if((n.nodes[0]===e||XB(n.nodes[0])&&n.nodes[1]===e)&&(delete t.text,/^\*\s*@(format|prettier)\s*$/.test(e.text)))return null;if("css-root"===n.type&&Sn$1(n.nodes)===e)return null}if("value-root"===e.type&&delete t.text,"media-query"!==e.type&&"media-query-list"!==e.type&&"media-feature-expression"!==e.type||delete t.value,"css-rule"===e.type&&delete t.params,"selector-combinator"===e.type&&(t.value=t.value.replace(/\s+/g," ")),"media-feature"===e.type&&(t.value=t.value.replace(/ /g,"")),("value-word"===e.type&&(e.isColor&&e.isHex||["initial","inherit","unset","revert"].includes(t.value.replace().toLowerCase()))||"media-feature"===e.type||"selector-root-invalid"===e.type||"selector-pseudo"===e.type)&&(t.value=t.value.toLowerCase()),"css-decl"===e.type&&(t.prop=t.prop.toLowerCase()),"css-atrule"!==e.type&&"css-import"!==e.type||(t.name=t.name.toLowerCase()),"value-number"===e.type&&(t.unit=t.unit.toLowerCase()),"media-feature"!==e.type&&"media-keyword"!==e.type&&"media-type"!==e.type&&"media-unknown"!==e.type&&"media-url"!==e.type&&"media-value"!==e.type&&"selector-attribute"!==e.type&&"selector-string"!==e.type&&"selector-class"!==e.type&&"selector-combinator"!==e.type&&"value-string"!==e.type||!t.value||(t.value=t.value.replace(/'/g,'"').replace(/\\([^\dA-Fa-f])/g,"$1")),"selector-attribute"===e.type&&(t.attribute=t.attribute.trim(),t.namespace&&"string"==typeof t.namespace&&(t.namespace=t.namespace.trim(),0===t.namespace.length&&(t.namespace=!0)),t.value&&(t.value=t.value.trim().replace(/^["']|["']$/g,""),delete t.quoted)),"media-value"!==e.type&&"media-type"!==e.type&&"value-number"!==e.type&&"selector-root-invalid"!==e.type&&"selector-class"!==e.type&&"selector-combinator"!==e.type&&"selector-tag"!==e.type||!t.value||(t.value=t.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g,((e,t,n)=>{const r=Number(t);return Number.isNaN(r)?e:r+n.toLowerCase()}))),"selector-tag"===e.type){const n=e.value.toLowerCase();["from","to"].includes(n)&&(t.value=n);}"css-atrule"===e.type&&"supports"===e.name.toLowerCase()&&delete t.value,"selector-unknown"===e.type&&delete t.value;}KB.ignoredProperties=YB;var QB=KB;const{builders:{hardline:ZB,markAsRoot:ek}}=Ji$1;var tk=function(e,t){if("yaml"===e.lang){const n=e.value.trim(),r=n?t(n,{parser:"yaml"},{stripTrailingHardline:!0}):"";return ek([e.startDelimiter,ZB,r,r?ZB:"",e.endDelimiter])}};const{builders:{hardline:nk}}=Ji$1;var rk=function(e,t,n){const r=e.getValue();if("front-matter"===r.type){const e=tk(r,n);return e?[e,nk]:""}};const ik=new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)","s");var uk=function(e){const t=e.match(ik);if(!t)return {content:e};const{startDelimiter:n,language:r,value:i="",endDelimiter:u}=t.groups;let o=r.trim()||"yaml";if("+++"===n&&(o="toml"),"yaml"!==o&&n!==u)return {content:e};const[s]=t;return {frontMatter:{type:"front-matter",lang:o,value:i,startDelimiter:n,endDelimiter:u,raw:s.replace(/\n$/,"")},content:s.replace(/[^\n]/g," ")+e.slice(s.length)}};var ok={hasPragma:function(e){return Nm.hasPragma(uk(e).content)},insertPragma:function(e){const{frontMatter:t,content:n}=uk(e);return (t?t.raw+"\n\n":"")+Nm.insertPragma(n)}};const{isNonEmptyArray:sk}=fi$1,ak=new Set(["red","green","blue","alpha","a","rgb","hue","h","saturation","s","lightness","l","whiteness","w","blackness","b","tint","shade","blend","blenda","contrast","hsl","hsla","hwb","hwba"]);function lk(e,t){const n=Array.isArray(t)?t:[t];let r,i=-1;for(;r=e.getParentNode(++i);)if(n.includes(r.type))return i;return -1}function ck(e,t){const n=lk(e,t);return -1===n?null:e.getParentNode(n)}function pk(e){return "value-operator"===e.type&&"*"===e.value}function fk(e){return "value-operator"===e.type&&"/"===e.value}function dk(e){return "value-operator"===e.type&&"+"===e.value}function hk(e){return "value-operator"===e.type&&"-"===e.value}function gk(e){return "value-operator"===e.type&&"%"===e.value}function mk(e){return "value-comma_group"===e.type&&e.groups&&e.groups[1]&&"value-colon"===e.groups[1].type}function yk(e){return "value-paren_group"===e.type&&e.groups&&e.groups[0]&&mk(e.groups[0])}function Dk(e){return e&&"value-colon"===e.type}var Ek={getAncestorCounter:lk,getAncestorNode:ck,getPropOfDeclNode:function(e){const t=ck(e,"css-decl");return t&&t.prop&&t.prop.toLowerCase()},hasSCSSInterpolation:function(e){if(sk(e))for(let t=e.length-1;t>0;t--)if("word"===e[t].type&&"{"===e[t].value&&"word"===e[t-1].type&&e[t-1].value.endsWith("#"))return !0;return !1},hasStringOrFunction:function(e){if(sk(e))for(let t=0;t<e.length;t++)if("string"===e[t].type||"func"===e[t].type)return !0;return !1},maybeToLowerCase:function(e){return e.includes("$")||e.includes("@")||e.includes("#")||e.startsWith("%")||e.startsWith("--")||e.startsWith(":--")||e.includes("(")&&e.includes(")")?e:e.toLowerCase()},insideValueFunctionNode:function(e,t){const n=ck(e,"value-func");return n&&n.value&&n.value.toLowerCase()===t},insideICSSRuleNode:function(e){const t=ck(e,"css-rule");return t&&t.raws&&t.raws.selector&&(t.raws.selector.startsWith(":import")||t.raws.selector.startsWith(":export"))},insideAtRuleNode:function(e,t){const n=Array.isArray(t)?t:[t],r=ck(e,"css-atrule");return r&&n.includes(r.name.toLowerCase())},insideURLFunctionInImportAtRuleNode:function(e){const t=e.getValue(),n=ck(e,"css-atrule");return n&&"import"===n.name&&"url"===t.groups[0].value&&2===t.groups.length},isKeyframeAtRuleKeywords:function(e,t){const n=ck(e,"css-atrule");return n&&n.name&&n.name.toLowerCase().endsWith("keyframes")&&["from","to"].includes(t.toLowerCase())},isWideKeywords:function(e){return ["initial","inherit","unset","revert"].includes(e.toLowerCase())},isSCSS:function(e,t){return "less"===e||"scss"===e?"scss"===e:/(\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t)},isSCSSVariable:function(e){return Boolean(e&&"word"===e.type&&e.value.startsWith("$"))},isLastNode:function(e,t){const n=e.getParentNode();if(!n)return !1;const{nodes:r}=n;return r&&r.indexOf(t)===r.length-1},isLessParser:function(e){return "css"===e.parser||"less"===e.parser},isSCSSControlDirectiveNode:function(e){return "css-atrule"===e.type&&["if","else","for","each","while"].includes(e.name)},isDetachedRulesetDeclarationNode:function(e){return !!e.selector&&("string"==typeof e.selector&&/^@.+:.*$/.test(e.selector)||e.selector.value&&/^@.+:.*$/.test(e.selector.value))},isRelationalOperatorNode:function(e){return "value-word"===e.type&&["<",">","<=",">="].includes(e.value)},isEqualityOperatorNode:function(e){return "value-word"===e.type&&["==","!="].includes(e.value)},isMultiplicationNode:pk,isDivisionNode:fk,isAdditionNode:dk,isSubtractionNode:hk,isModuloNode:gk,isMathOperatorNode:function(e){return pk(e)||fk(e)||dk(e)||hk(e)||gk(e)},isEachKeywordNode:function(e){return "value-word"===e.type&&"in"===e.value},isForKeywordNode:function(e){return "value-word"===e.type&&["from","through","end"].includes(e.value)},isURLFunctionNode:function(e){return "value-func"===e.type&&"url"===e.value.toLowerCase()},isIfElseKeywordNode:function(e){return "value-word"===e.type&&["and","or","not"].includes(e.value)},hasComposesNode:function(e){return e.value&&"value-root"===e.value.type&&e.value.group&&"value-value"===e.value.group.type&&"composes"===e.prop.toLowerCase()},hasParensAroundNode:function(e){return e.value&&e.value.group&&e.value.group.group&&"value-paren_group"===e.value.group.group.type&&null!==e.value.group.group.open&&null!==e.value.group.group.close},hasEmptyRawBefore:function(e){return e.raws&&""===e.raws.before},isSCSSNestedPropertyNode:function(e){return !!e.selector&&e.selector.replace(/\/\*.*?\*\//,"").replace(/\/\/.*?\n/,"").trim().endsWith(":")},isDetachedRulesetCallNode:function(e){return e.raws&&e.raws.params&&/^\(\s*\)$/.test(e.raws.params)},isTemplatePlaceholderNode:function(e){return e.name.startsWith("prettier-placeholder")},isTemplatePropNode:function(e){return e.prop.startsWith("@prettier-placeholder")},isPostcssSimpleVarNode:function(e,t){return "$$"===e.value&&"value-func"===e.type&&t&&"value-word"===t.type&&!t.raws.before},isKeyValuePairNode:mk,isKeyValuePairInParenGroupNode:yk,isKeyInValuePairNode:function(e,t){if(!mk(t))return !1;const{groups:n}=t,r=n.indexOf(e);return -1!==r&&Dk(n[r+1])},isSCSSMapItemNode:function(e){const t=e.getValue();if(0===t.groups.length)return !1;const n=e.getParentNode(1);if(!(yk(t)||n&&yk(n)))return !1;const r=ck(e,"css-decl");return !!(r&&r.prop&&r.prop.startsWith("$"))||(!!yk(n)||"value-func"===n.type)},isInlineValueCommentNode:function(e){return "value-comment"===e.type&&e.inline},isHashNode:function(e){return "value-word"===e.type&&"#"===e.value},isLeftCurlyBraceNode:function(e){return "value-word"===e.type&&"{"===e.value},isRightCurlyBraceNode:function(e){return "value-word"===e.type&&"}"===e.value},isWordNode:function(e){return ["value-word","value-atword"].includes(e.type)},isColonNode:Dk,isMediaAndSupportsKeywords:function(e){return e.value&&["not","and","or"].includes(e.value.toLowerCase())},isColorAdjusterFuncNode:function(e){return "value-func"===e.type&&ak.has(e.value.toLowerCase())},lastLineHasInlineComment:function(e){return /\/\//.test(e.split(/[\n\r]/).pop())},stringifyNode:function e(t){if(t.groups){return (t.open&&t.open.value?t.open.value:"")+t.groups.reduce(((n,r,i)=>n+e(r)+("comma_group"===t.groups[0].type&&i!==t.groups.length-1?",":"")),"")+(t.close&&t.close.value?t.close.value:"")}const n=t.raws&&t.raws.before?t.raws.before:"",r=t.raws&&t.raws.quote?t.raws.quote:"";return n+r+("atword"===t.type?"@":"")+(t.value?t.value:"")+r+(t.unit?t.unit:"")+(t.group?e(t.group):"")+(t.raws&&t.raws.after?t.raws.after:"")},isAtWordPlaceholderNode:function(e){return e&&"value-atword"===e.type&&e.value.startsWith("prettier-placeholder-")}},bk=function(e,t){let n=0;for(let r=0;r<e.line-1;++r)n=t.indexOf("\n",n)+1;return n+e.column};const{getLast:Ck,skipEverythingButNewLine:vk}=fi$1;function Ak(e,t){return "number"==typeof e.sourceIndex?e.sourceIndex:e.source?bk(e.source.start,t)-1:null}function Fk(e,t){if("css-comment"===e.type&&e.inline)return vk(t,e.source.startOffset);const n=e.nodes&&Ck(e.nodes);return n&&e.source&&!e.source.end&&(e=n),e.source&&e.source.end?bk(e.source.end,t):null}function xk(e,t,n){e.source&&(e.source.startOffset=Ak(e,n)+t,e.source.endOffset=Fk(e,n)+t);for(const r in e){const i=e[r];"source"!==r&&i&&"object"==typeof i&&xk(i,t,n);}}function Sk(e){let t=e.source.startOffset;return "string"==typeof e.prop&&(t+=e.prop.length),"css-atrule"===e.type&&"string"==typeof e.name&&(t+=1+e.name.length+e.raws.afterName.match(/^\s*:?\s*/)[0].length),"css-atrule"!==e.type&&e.raws&&"string"==typeof e.raws.between&&(t+=e.raws.between.length),t}var wk={locStart:function(e){return e.source.startOffset},locEnd:function(e){return e.source.endOffset},calculateLoc:function e(t,n){t.source&&(t.source.startOffset=Ak(t,n),t.source.endOffset=Fk(t,n));for(const r in t){const i=t[r];"source"!==r&&i&&"object"==typeof i&&("value-root"===i.type||"value-unknown"===i.type?xk(i,Sk(t),i.text||i.value):e(i,n));}},replaceQuotesInInlineComments:function(e){let t,n="initial",r="initial",i=!1;const u=[];for(let o=0;o<e.length;o++){const s=e[o];switch(n){case"initial":if("'"===s){n="single-quotes";continue}if('"'===s){n="double-quotes";continue}if(("u"===s||"U"===s)&&"url("===e.slice(o,o+4).toLowerCase()){n="url",o+=3;continue}if("*"===s&&"/"===e[o-1]){n="comment-block";continue}if("/"===s&&"/"===e[o-1]){n="comment-inline",t=o-1;continue}continue;case"single-quotes":if("'"===s&&"\\"!==e[o-1]&&(n=r,r="initial"),"\n"===s||"\r"===s)return e;continue;case"double-quotes":if('"'===s&&"\\"!==e[o-1]&&(n=r,r="initial"),"\n"===s||"\r"===s)return e;continue;case"url":if(")"===s&&(n="initial"),"\n"===s||"\r"===s)return e;if("'"===s){n="single-quotes",r="url";continue}if('"'===s){n="double-quotes",r="url";continue}continue;case"comment-block":"/"===s&&"*"===e[o-1]&&(n="initial");continue;case"comment-inline":'"'!==s&&"'"!==s&&"*"!==s||(i=!0),"\n"!==s&&"\r"!==s||(i&&u.push([t,o]),n="initial",i=!1);continue}}for(const[t,n]of u)e=e.slice(0,t)+e.slice(t,n).replace(/["'*]/g," ")+e.slice(n);return e}};const{printNumber:Tk,printString:Bk,hasNewline:kk,isFrontMatterNode:Nk,isNextLineEmpty:Pk,isNonEmptyArray:Ok}=fi$1,{builders:{join:Ik,line:jk,hardline:Lk,softline:_k,group:Mk,fill:Rk,indent:$k,dedent:Vk,ifBreak:qk,breakParent:Wk},utils:{removeLines:Uk,getDocParts:zk}}=Ji$1,{insertPragma:Gk}=ok,{getAncestorNode:Hk,getPropOfDeclNode:Jk,maybeToLowerCase:Xk,insideValueFunctionNode:Yk,insideICSSRuleNode:Kk,insideAtRuleNode:Qk,insideURLFunctionInImportAtRuleNode:Zk,isKeyframeAtRuleKeywords:eN,isWideKeywords:tN,isSCSS:nN,isLastNode:rN,isLessParser:iN,isSCSSControlDirectiveNode:uN,isDetachedRulesetDeclarationNode:oN,isRelationalOperatorNode:sN,isEqualityOperatorNode:aN,isMultiplicationNode:lN,isDivisionNode:cN,isAdditionNode:pN,isSubtractionNode:fN,isMathOperatorNode:dN,isEachKeywordNode:hN,isForKeywordNode:gN,isURLFunctionNode:mN,isIfElseKeywordNode:yN,hasComposesNode:DN,hasParensAroundNode:EN,hasEmptyRawBefore:bN,isKeyValuePairNode:CN,isKeyInValuePairNode:vN,isDetachedRulesetCallNode:AN,isTemplatePlaceholderNode:FN,isTemplatePropNode:xN,isPostcssSimpleVarNode:SN,isSCSSMapItemNode:wN,isInlineValueCommentNode:TN,isHashNode:BN,isLeftCurlyBraceNode:kN,isRightCurlyBraceNode:NN,isWordNode:PN,isColonNode:ON,isMediaAndSupportsKeywords:IN,isColorAdjusterFuncNode:jN,lastLineHasInlineComment:LN,isAtWordPlaceholderNode:_N}=Ek,{locStart:MN,locEnd:RN}=wk;function $N(e){return "es5"===e.trailingComma||"all"===e.trailingComma}function VN(e,t,n){const r=[];return e.each(((e,i,u)=>{const o=u[i-1];if(o&&"css-comment"===o.type&&"prettier-ignore"===o.text.trim()){const n=e.getValue();r.push(t.originalText.slice(MN(n),RN(n)));}else r.push(n());i!==u.length-1&&("css-comment"===u[i+1].type&&!kk(t.originalText,MN(u[i+1]),{backwards:!0})&&!Nk(u[i])||"css-atrule"===u[i+1].type&&"else"===u[i+1].name&&"css-comment"!==u[i].type?r.push(" "):(r.push(t.__isHTMLStyleAttribute?jk:Lk),Pk(t.originalText,e.getValue(),RN)&&!Nk(u[i])&&r.push(Lk)));}),"nodes"),r}const qN=/(["'])(?:(?!\1)[^\\]|\\.)*\1/gs,WN=new RegExp(qN.source+"|"+`(${/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source})?`+`(${/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source})`+`(${/[A-Za-z]+/g.source})?`,"g");function UN(e,t){return e.replace(qN,(e=>Bk(e,t)))}function zN(e,t){const n=t.singleQuote?"'":'"';return e.includes('"')||e.includes("'")?e:n+e+n}function GN(e){return e.replace(WN,((e,t,n,r,i)=>!n&&r?HN(r)+Xk(i||""):e))}function HN(e){return Tk(e).replace(/\.0(?=$|e)/,"")}var JN={print:function(e,t,n){const r=e.getValue();if(!r)return "";if("string"==typeof r)return r;switch(r.type){case"front-matter":return [r.raw,Lk];case"css-root":{const i=VN(e,t,n),u=r.raws.after.trim();return [i,u?` ${u}`:"",zk(i).length>0?Lk:""]}case"css-comment":{const e=r.inline||r.raws.inline,n=t.originalText.slice(MN(r),RN(r));return e?n.trimEnd():n}case"css-rule":return [n("selector"),r.important?" !important":"",r.nodes?[r.selector&&"selector-unknown"===r.selector.type&&LN(r.selector.value)?jk:" ","{",r.nodes.length>0?$k([Lk,VN(e,t,n)]):"",Lk,"}",oN(r)?";":""]:";"];case"css-decl":{const i=e.getParentNode(),{between:u}=r.raws,o=u.trim(),s=":"===o;let a=DN(r)?Uk(n("value")):n("value");return !s&&LN(o)&&(a=$k([Lk,Vk(a)])),[r.raws.before.replace(/[\s;]/g,""),Kk(e)?r.prop:Xk(r.prop),o.startsWith("//")?" ":"",o,r.extend?"":" ",iN(t)&&r.extend&&r.selector?["extend(",n("selector"),")"]:"",a,r.raws.important?r.raws.important.replace(/\s*!\s*important/i," !important"):r.important?" !important":"",r.raws.scssDefault?r.raws.scssDefault.replace(/\s*!default/i," !default"):r.scssDefault?" !default":"",r.raws.scssGlobal?r.raws.scssGlobal.replace(/\s*!global/i," !global"):r.scssGlobal?" !global":"",r.nodes?[" {",$k([_k,VN(e,t,n)]),_k,"}"]:xN(r)&&!i.raws.semicolon&&";"!==t.originalText[RN(r)-1]?"":t.__isHTMLStyleAttribute&&rN(e,r)?qk(";"):";"]}case"css-atrule":{const i=e.getParentNode(),u=FN(r)&&!i.raws.semicolon&&";"!==t.originalText[RN(r)-1];if(iN(t)){if(r.mixin)return [n("selector"),r.important?" !important":"",u?"":";"];if(r.function)return [r.name,n("params"),u?"":";"];if(r.variable)return ["@",r.name,": ",r.value?n("value"):"",r.raws.between.trim()?r.raws.between.trim()+" ":"",r.nodes?["{",$k([r.nodes.length>0?_k:"",VN(e,t,n)]),_k,"}"]:"",u?"":";"]}return ["@",AN(r)||r.name.endsWith(":")?r.name:Xk(r.name),r.params?[AN(r)?"":FN(r)?""===r.raws.afterName?"":r.name.endsWith(":")?" ":/^\s*\n\s*\n/.test(r.raws.afterName)?[Lk,Lk]:/^\s*\n/.test(r.raws.afterName)?Lk:" ":" ",n("params")]:"",r.selector?$k([" ",n("selector")]):"",r.value?Mk([" ",n("value"),uN(r)?EN(r)?" ":jk:""]):"else"===r.name?" ":"",r.nodes?[uN(r)?"":r.selector&&!r.selector.nodes&&"string"==typeof r.selector.value&&LN(r.selector.value)||!r.selector&&"string"==typeof r.params&&LN(r.params)?jk:" ","{",$k([r.nodes.length>0?_k:"",VN(e,t,n)]),_k,"}"]:u?"":";"]}case"media-query-list":{const t=[];return e.each((e=>{const r=e.getValue();"media-query"===r.type&&""===r.value||t.push(n());}),"nodes"),Mk($k(Ik(jk,t)))}case"media-query":return [Ik(" ",e.map(n,"nodes")),rN(e,r)?"":","];case"media-type":return GN(UN(r.value,t));case"media-feature-expression":return r.nodes?["(",...e.map(n,"nodes"),")"]:r.value;case"media-feature":return Xk(UN(r.value.replace(/ +/g," "),t));case"media-colon":return [r.value," "];case"media-value":return GN(UN(r.value,t));case"media-keyword":return UN(r.value,t);case"media-url":return UN(r.value.replace(/^url\(\s+/gi,"url(").replace(/\s+\)$/g,")"),t);case"media-unknown":return r.value;case"selector-root":return Mk([Qk(e,"custom-selector")?[Hk(e,"css-atrule").customSelector,jk]:"",Ik([",",Qk(e,["extend","custom-selector","nest"])?jk:Lk],e.map(n,"nodes"))]);case"selector-selector":return Mk($k(e.map(n,"nodes")));case"selector-comment":return r.value;case"selector-string":return UN(r.value,t);case"selector-tag":{const t=e.getParentNode(),n=t&&t.nodes.indexOf(r),i=n&&t.nodes[n-1];return [r.namespace?[!0===r.namespace?"":r.namespace.trim(),"|"]:"","selector-nesting"===i.type?r.value:GN(eN(e,r.value)?r.value.toLowerCase():r.value)]}case"selector-id":return ["#",r.value];case"selector-class":return [".",GN(UN(r.value,t))];case"selector-attribute":return ["[",r.namespace?[!0===r.namespace?"":r.namespace.trim(),"|"]:"",r.attribute.trim(),r.operator?r.operator:"",r.value?zN(UN(r.value.trim(),t),t):"",r.insensitive?" i":"","]"];case"selector-combinator":if("+"===r.value||">"===r.value||"~"===r.value||">>>"===r.value){const t=e.getParentNode();return ["selector-selector"===t.type&&t.nodes[0]===r?"":jk,r.value,rN(e,r)?"":" "]}return [r.value.trim().startsWith("(")?jk:"",GN(UN(r.value.trim(),t))||jk];case"selector-universal":return [r.namespace?[!0===r.namespace?"":r.namespace.trim(),"|"]:"",r.value];case"selector-pseudo":return [Xk(r.value),Ok(r.nodes)?["(",Ik(", ",e.map(n,"nodes")),")"]:""];case"selector-nesting":return r.value;case"selector-unknown":{const n=Hk(e,"css-rule");if(n&&n.isSCSSNesterProperty)return GN(UN(Xk(r.value),t));const i=e.getParentNode();if(i.raws&&i.raws.selector){const e=MN(i),n=e+i.raws.selector.length;return t.originalText.slice(e,n).trim()}const u=e.getParentNode(1);if("value-paren_group"===i.type&&u&&"value-func"===u.type&&"selector"===u.value){const e=MN(i.open)+1,n=RN(i.close)-1,r=t.originalText.slice(e,n).trim();return LN(r)?[Wk,r]:r}return r.value}case"value-value":case"value-root":return n("group");case"value-comment":return t.originalText.slice(MN(r),RN(r));case"value-comma_group":{const t=e.getParentNode(),i=e.getParentNode(1),u=Jk(e),o=u&&"value-value"===t.type&&("grid"===u||u.startsWith("grid-template")),s=Hk(e,"css-atrule"),a=s&&uN(s),l=r.groups.some((e=>TN(e))),c=e.map(n,"groups"),p=[],f=Yk(e,"url");let d=!1,h=!1;for(let n=0;n<r.groups.length;++n){p.push(c[n]);const u=r.groups[n-1],l=r.groups[n],g=r.groups[n+1],m=r.groups[n+2];if(f){(g&&pN(g)||pN(l))&&p.push(" ");continue}if(!g)continue;if("value-word"===l.type&&l.value.endsWith("-")&&_N(g))continue;const y="value-string"===l.type&&l.value.startsWith("#{"),D=d&&"value-string"===g.type&&g.value.endsWith("}");if(y||D){d=!d;continue}if(d)continue;if(ON(l)||ON(g))continue;if("value-atword"===l.type&&""===l.value)continue;if("~"===l.value)continue;if(l.value&&l.value.includes("\\")&&g&&"value-comment"!==g.type)continue;if(u&&u.value&&u.value.indexOf("\\")===u.value.length-1&&"value-operator"===l.type&&"/"===l.value)continue;if("\\"===l.value)continue;if(SN(l,g))continue;if(BN(l)||kN(l)||NN(g)||kN(g)&&bN(g)||NN(l)&&bN(g))continue;if("--"===l.value&&BN(g))continue;const E=dN(l),b=dN(g);if((E&&BN(g)||b&&NN(l))&&bN(g))continue;if(!u&&cN(l))continue;if(Yk(e,"calc")&&(pN(l)||pN(g)||fN(l)||fN(g))&&bN(g))continue;const C=(pN(l)||fN(l))&&0===n&&("value-number"===g.type||g.isHex)&&i&&jN(i)&&!bN(g),v=m&&"value-func"===m.type||m&&PN(m)||"value-func"===l.type||PN(l),A="value-func"===g.type||PN(g)||u&&"value-func"===u.type||u&&PN(u);if(lN(g)||lN(l)||Yk(e,"calc")||C||!(cN(g)&&!v||cN(l)&&!A||pN(g)&&!v||pN(l)&&!A||fN(g)||fN(l))||!(bN(g)||E&&(!u||u&&dN(u))))if(TN(l)){if("value-paren_group"===t.type){p.push(Vk(Lk));continue}p.push(Lk);}else a&&(aN(g)||sN(g)||yN(g)||hN(l)||gN(l))||s&&"namespace"===s.name.toLowerCase()?p.push(" "):o?l.source&&g.source&&l.source.start.line!==g.source.start.line?(p.push(Lk),h=!0):p.push(" "):b?p.push(" "):g&&"..."===g.value||_N(l)&&_N(g)&&RN(l)===MN(g)||p.push(jk);}return l&&p.push(Wk),h&&p.unshift(Lk),a?Mk($k(p)):Zk(e)?Mk(Rk(p)):Mk($k(Rk(p)))}case"value-paren_group":{const i=e.getParentNode();if(i&&mN(i)&&(1===r.groups.length||r.groups.length>0&&"value-comma_group"===r.groups[0].type&&r.groups[0].groups.length>0&&"value-word"===r.groups[0].groups[0].type&&r.groups[0].groups[0].value.startsWith("data:")))return [r.open?n("open"):"",Ik(",",e.map(n,"groups")),r.close?n("close"):""];if(!r.open){const t=e.map(n,"groups"),r=[];for(let e=0;e<t.length;e++)0!==e&&r.push([",",jk]),r.push(t[e]);return Mk($k(Rk(r)))}const u=wN(e),o=Sn$1(r.groups),s=o&&"value-comment"===o.type,a=vN(r,i),l=Mk([r.open?n("open"):"",$k([_k,Ik([",",jk],e.map((e=>{const t=e.getValue(),r=n();if(CN(t)&&"value-comma_group"===t.type&&t.groups&&"value-paren_group"!==t.groups[0].type&&t.groups[2]&&"value-paren_group"===t.groups[2].type){const e=zk(r.contents.contents);return e[1]=Mk(e[1]),Mk(Vk(r))}return r}),"groups"))]),qk(!s&&nN(t.parser,t.originalText)&&u&&$N(t)?",":""),_k,r.close?n("close"):""],{shouldBreak:u&&!a});return a?Vk(l):l}case"value-func":return [r.value,Qk(e,"supports")&&IN(r)?" ":"",n("group")];case"value-paren":return r.value;case"value-number":return [HN(r.value),Xk(r.unit)];case"value-operator":return r.value;case"value-word":return r.isColor&&r.isHex||tN(r.value)?r.value.toLowerCase():r.value;case"value-colon":{const t=e.getParentNode(),n=t&&t.groups.indexOf(r),i=n&&t.groups[n-1];return [r.value,i&&"string"==typeof i.value&&"\\"===Sn$1(i.value)||Yk(e,"url")?"":jk]}case"value-comma":return [r.value," "];case"value-string":return Bk(r.raws.quote+r.value+r.raws.quote,t);case"value-atword":return ["@",r.value];case"value-unicode-range":case"value-unknown":return r.value;default:throw new Error(`Unknown postcss type ${JSON.stringify(r.type)}`)}},embed:rk,insertPragma:Gk,massageAstNode:QB},XN={singleQuote:$B.singleQuote},YN={name:"PostCSS",type:"markup",tmScope:"source.postcss",group:"CSS",extensions:[".pcss",".postcss"],aceMode:"text",languageId:262764437},KN={name:"Less",type:"markup",color:"#1d365d",extensions:[".less"],tmScope:"source.css.less",aceMode:"less",codemirrorMode:"css",codemirrorMimeType:"text/css",languageId:198},QN={name:"SCSS",type:"markup",color:"#c6538c",tmScope:"source.css.scss",aceMode:"scss",codemirrorMode:"css",codemirrorMimeType:"text/x-scss",extensions:[".scss"],languageId:329};var ZN={languages:[Yd({name:"CSS",type:"markup",tmScope:"source.css",aceMode:"css",codemirrorMode:"css",codemirrorMimeType:"text/css",color:"#563d7c",extensions:[".css"],languageId:50},(e=>({since:"1.4.0",parsers:["css"],vscodeLanguageIds:["css"],extensions:[...e.extensions,".wxss"]}))),Yd(YN,(()=>({since:"1.4.0",parsers:["css"],vscodeLanguageIds:["postcss"]}))),Yd(KN,(()=>({since:"1.4.0",parsers:["less"],vscodeLanguageIds:["less"]}))),Yd(QN,(()=>({since:"1.4.0",parsers:["scss"],vscodeLanguageIds:["scss"]})))],options:XN,printers:{postcss:JN},parsers:{get css(){return require("./parser-postcss").parsers.css},get less(){return require("./parser-postcss").parsers.less},get scss(){return require("./parser-postcss").parsers.scss}}};var eP={locStart:function(e){return e.loc.start.offset},locEnd:function(e){return e.loc.end.offset}};function tP(e,t){if("TextNode"===e.type){const n=e.chars.trim();if(!n)return null;t.chars=n.replace(/[\t\n\f\r ]+/g," ");}"AttrNode"===e.type&&"class"===e.name.toLowerCase()&&delete t.value;}tP.ignoredProperties=new Set(["loc","selfClosing"]);var nP=tP;const rP=new Set(["area","base","basefont","bgsound","br","col","command","embed","frame","hr","image","img","input","isindex","keygen","link","menuitem","meta","nextid","param","source","track","wbr"]);function iP(e){return uP(e,["TextNode"])&&!/\S/.test(e.chars)}function uP(e,t){return e&&t.includes(e.type)}function oP(e,t){return uP(e.getParentNode(0),t)}function sP(e,t){const n=e.getValue(),r=e.getParentNode(0)||{},i=r.children||r.body||r.parts||[],u=i.indexOf(n);return -1!==u&&i[u+t]}function aP(e,t=1){return sP(e,-t)}function lP(e){return sP(e,1)}function cP(e){return uP(e,["MustacheCommentStatement"])&&"string"==typeof e.value&&"prettier-ignore"===e.value.trim()}var pP={getNextNode:lP,getPreviousNode:aP,hasPrettierIgnore:function(e){const t=e.getValue(),n=aP(e,2);return cP(t)||cP(n)},isLastNodeOfSiblings:function(e){const t=e.getValue(),n=e.getParentNode(0);return !(!oP(e,["ElementNode"])||Sn$1(n.children)!==t)||!(!oP(e,["Block"])||Sn$1(n.body)!==t)},isNextNodeOfSomeType:function(e,t){return uP(lP(e),t)},isNodeOfSomeType:uP,isParentOfSomeType:oP,isPreviousNodeOfSomeType:function(e,t){return uP(aP(e),t)},isVoid:function(e){return function(e){return uP(e,["ElementNode"])&&"string"==typeof e.tag&&(function(e){return e.toUpperCase()===e}(e.tag[0])||e.tag.includes("."))}(e)&&e.children.every((e=>iP(e)))||rP.has(e.tag)},isWhitespaceNode:iP};const{builders:{dedent:fP,fill:dP,group:hP,hardline:gP,ifBreak:mP,indent:yP,join:DP,line:EP,softline:bP,literalline:CP},utils:{getDocParts:vP,replaceEndOfLineWith:AP}}=Ji$1,{isNonEmptyArray:FP}=fi$1,{locStart:xP,locEnd:SP}=eP,{getNextNode:wP,getPreviousNode:TP,hasPrettierIgnore:BP,isLastNodeOfSiblings:kP,isNextNodeOfSomeType:NP,isNodeOfSomeType:PP,isParentOfSomeType:OP,isPreviousNodeOfSomeType:IP,isVoid:jP,isWhitespaceNode:LP}=pP;function _P(e,t){return xP(e)-xP(t)}function MP(e,t,n){const r=e.getValue().children.every((e=>LP(e)));return "ignore"===t.htmlWhitespaceSensitivity&&r?"":e.map(((e,r)=>{const i=n();return 0===r&&"ignore"===t.htmlWhitespaceSensitivity?[bP,i]:i}),"children")}function RP(e){return jP(e)?mP([bP,"/>"],[" />",bP]):mP([bP,">"],">")}function $P(e){return [!1===e.escaped?"{{{":"{{",e.strip&&e.strip.open?"~":""]}function VP(e){const t=!1===e.escaped?"}}}":"}}";return [e.strip&&e.strip.close?"~":"",t]}function qP(e){return [$P(e),e.closeStrip.open?"~":"","/"]}function WP(e){const t=VP(e);return [e.closeStrip.close?"~":"",t]}function UP(e){return [$P(e),e.inverseStrip.open?"~":""]}function zP(e){const t=VP(e);return [e.inverseStrip.close?"~":"",t]}function GP(e,t){const n=e.getValue(),r=function(e){return [$P(e),e.openStrip.open?"~":"","#"]}(n),i=function(e){const t=VP(e);return [e.openStrip.close?"~":"",t]}(n),u=[oO(e,t)],o=sO(e,t);if(o&&u.push(EP,o),FP(n.program.blockParams)){const e=aO(n.program);u.push(EP,e);}return hP([r,yP(u),bP,i])}function HP(e,t){return ["ignore"===t.htmlWhitespaceSensitivity?gP:"",UP(e),"else",zP(e)]}function JP(e,t){const n=e.getParentNode(1);return [UP(n),"else if ",sO(e,t),zP(n)]}function XP(e,t,n){const r=e.getValue();if("ignore"===n.htmlWhitespaceSensitivity){return [YP(r)?bP:gP,qP(r),t("path"),WP(r)]}return [qP(r),t("path"),WP(r)]}function YP(e){return PP(e,["BlockStatement"])&&e.program.body.every((e=>LP(e)))}function KP(e){return PP(e,["BlockStatement"])&&e.inverse}function QP(e,t,n){if(YP(e.getValue()))return "";const r=t("program");return "ignore"===n.htmlWhitespaceSensitivity?yP([gP,r]):yP(r)}function ZP(e,t,n){const r=e.getValue(),i=t("inverse"),u="ignore"===n.htmlWhitespaceSensitivity?[gP,i]:i;return function(e){return KP(e)&&1===e.inverse.body.length&&PP(e.inverse.body[0],["BlockStatement"])&&"if"===e.inverse.body[0].path.parts[0]}(r)?u:KP(r)?[HP(r,n),yP(u)]:""}function eO(e){return vP(DP(EP,function(e){return e.split(/[\t\n\f\r ]+/)}(e)))}function tO(e){return (e="string"==typeof e?e:"").split("\n").length-1}function nO(e=0){return new Array(Math.min(e,2)).fill(gP)}function rO(e,t){const n={quote:'"',regex:/"/g},r={quote:"'",regex:/'/g},i=e.singleQuote?r:n,u=i===r?n:r;let o=!1;if(t.includes(i.quote)||t.includes(u.quote)){o=(t.match(i.regex)||[]).length>(t.match(u.regex)||[]).length;}return o?u:i}function iO(e,t){const n=oO(e,t),r=sO(e,t);return r?yP([n,EP,hP(r)]):n}function uO(e,t){const n=oO(e,t),r=sO(e,t);return r?[yP([n,EP,r]),bP]:n}function oO(e,t){return t("path")}function sO(e,t){const n=e.getValue(),r=[];if(n.params.length>0){const n=e.map(t,"params");r.push(...n);}if(n.hash&&n.hash.pairs.length>0){const e=t("hash");r.push(e);}return 0===r.length?"":DP(EP,r)}function aO(e){return ["as |",e.blockParams.join(" "),"|"]}var lO={print:function(e,t,n){const r=e.getValue();if(!r)return "";if(BP(e))return t.originalText.slice(xP(r),SP(r));switch(r.type){case"Block":case"Program":case"Template":return hP(e.map(n,"body"));case"ElementNode":{const i=hP(function(e,t){const n=e.getValue(),r=["attributes","modifiers","comments"].filter((e=>FP(n[e]))),i=r.flatMap((e=>n[e])).sort(_P);for(const n of r)e.each((e=>{const n=i.indexOf(e.getValue());i.splice(n,1,[EP,t()]);}),n);FP(n.blockParams)&&i.push(EP,aO(n));return ["<",n.tag,yP(i),RP(n)]}(e,n)),u="ignore"===t.htmlWhitespaceSensitivity&&NP(e,["ElementNode"])?bP:"";if(jP(r))return [i,u];const o=["</",r.tag,">"];return 0===r.children.length?[i,yP(o),u]:"ignore"===t.htmlWhitespaceSensitivity?[i,yP(MP(e,t,n)),gP,yP(o),u]:[i,yP(hP(MP(e,t,n))),yP(o),u]}case"BlockStatement":{const i=e.getParentNode(1);return i&&i.inverse&&1===i.inverse.body.length&&i.inverse.body[0]===r&&"if"===i.inverse.body[0].path.parts[0]?[JP(e,n),QP(e,n,t),ZP(e,n,t)]:[GP(e,n),hP([QP(e,n,t),ZP(e,n,t),XP(e,n,t)])]}case"ElementModifierStatement":return hP(["{{",uO(e,n),"}}"]);case"MustacheStatement":return hP([$P(r),uO(e,n),VP(r)]);case"SubExpression":return hP(["(",iO(e,n),bP,")"]);case"AttrNode":{const e="TextNode"===r.value.type;if(e&&""===r.value.chars&&xP(r.value)===SP(r.value))return r.name;const i=e?rO(t,r.value.chars).quote:"ConcatStatement"===r.value.type?rO(t,r.value.parts.filter((e=>"TextNode"===e.type)).map((e=>e.chars)).join("")).quote:"",u=n("value");return [r.name,"=",i,"class"===r.name&&i?hP(yP(u)):u,i]}case"ConcatStatement":return e.map(n,"parts");case"Hash":return DP(EP,e.map(n,"pairs"));case"HashPair":return [r.key,"=",n("value")];case"TextNode":{let n=r.chars.replace(/{{/g,"\\{{");const i=function(e){for(let t=0;t<2;t++){const n=e.getParentNode(t);if(n&&"AttrNode"===n.type)return n.name.toLowerCase()}}(e);if(i){if("class"===i){const t=n.trim().split(/\s+/).join(" ");let r=!1,i=!1;return OP(e,["ConcatStatement"])&&(IP(e,["MustacheStatement"])&&/^\s/.test(n)&&(r=!0),NP(e,["MustacheStatement"])&&/\s$/.test(n)&&""!==t&&(i=!0)),[r?EP:"",t,i?EP:""]}return AP(n,CP)}const u=/^[\t\n\f\r ]*$/.test(n),o=!TP(e),s=!wP(e);if("ignore"!==t.htmlWhitespaceSensitivity){const t=/^[\t\n\f\r ]*/,r=/[\t\n\f\r ]*$/,i=s&&OP(e,["Template"]),a=o&&OP(e,["Template"]);if(u){if(a||i)return "";let t=[EP];const r=tO(n);return r&&(t=nO(r)),kP(e)&&(t=t.map((e=>fP(e)))),t}const[l]=n.match(t),[c]=n.match(r);let p=[];if(l){p=[EP];const e=tO(l);e&&(p=nO(e)),n=n.replace(t,"");}let f=[];if(c){if(!i){f=[EP];const t=tO(c);t&&(f=nO(t)),kP(e)&&(f=f.map((e=>fP(e))));}n=n.replace(r,"");}return [...p,dP(eO(n)),...f]}const a=tO(n);let l=function(e){return tO(((e="string"==typeof e?e:"").match(/^([^\S\n\r]*[\n\r])+/g)||[])[0]||"")}(n),c=function(e){return tO(((e="string"==typeof e?e:"").match(/([\n\r][^\S\n\r]*)+$/g)||[])[0]||"")}(n);if((o||s)&&u&&OP(e,["Block","ElementNode","Template"]))return "";u&&a?(l=Math.min(a,2),c=0):(NP(e,["BlockStatement","ElementNode"])&&(c=Math.max(c,1)),IP(e,["BlockStatement","ElementNode"])&&(l=Math.max(l,1)));let p="",f="";return 0===c&&NP(e,["MustacheStatement"])&&(f=" "),0===l&&IP(e,["MustacheStatement"])&&(p=" "),o&&(l=0,p=""),s&&(c=0,f=""),n=n.replace(/^[\t\n\f\r ]+/g,p).replace(/[\t\n\f\r ]+$/,f),[...nO(l),dP(eO(n)),...nO(c)]}case"MustacheCommentStatement":{const e=xP(r),n=SP(r),i="~"===t.originalText.charAt(e+2),u="~"===t.originalText.charAt(n-3),o=r.value.includes("}}")?"--":"";return ["{{",i?"~":"","!",o,r.value,o,u?"~":"","}}"]}case"PathExpression":return r.original;case"BooleanLiteral":return String(r.value);case"CommentStatement":return ["\x3c!--",r.value,"--\x3e"];case"StringLiteral":return function(e,t){const{quote:n,regex:r}=rO(t,e);return [n,e.replace(r,`\\${n}`),n]}(r.value,t);case"NumberLiteral":return String(r.value);case"UndefinedLiteral":return "undefined";case"NullLiteral":return "null";default:throw new Error("unknown glimmer type: "+JSON.stringify(r.type))}},massageAstNode:nP};var cO={languages:[Yd({name:"Handlebars",type:"markup",color:"#f7931e",aliases:["hbs","htmlbars"],extensions:[".handlebars",".hbs"],tmScope:"text.html.handlebars",aceMode:"handlebars",languageId:155},(()=>({since:"2.3.0",parsers:["glimmer"],vscodeLanguageIds:["handlebars"]})))],printers:{glimmer:lO},parsers:{get glimmer(){return require("./parser-glimmer").parsers.glimmer}}};var pO={hasPragma:function(e){return /^\s*#[^\S\n]*@(format|prettier)\s*(\n|$)/.test(e)},insertPragma:function(e){return "# @format\n\n"+e}};var fO={locStart:function(e){return "number"==typeof e.start?e.start:e.loc&&e.loc.start},locEnd:function(e){return "number"==typeof e.end?e.end:e.loc&&e.loc.end}};const{builders:{join:dO,hardline:hO,line:gO,softline:mO,group:yO,indent:DO,ifBreak:EO}}=Ji$1,{isNextLineEmpty:bO,isNonEmptyArray:CO}=fi$1,{insertPragma:vO}=pO,{locStart:AO,locEnd:FO}=fO;function xO(e,t,n){if(0===n.directives.length)return "";const r=dO(gO,e.map(t,"directives"));return "FragmentDefinition"===n.kind||"OperationDefinition"===n.kind?yO([gO,r]):[" ",yO(DO([mO,r]))]}function SO(e,t,n){const r=e.getValue().length;return e.map(((e,i)=>{const u=n();return bO(t.originalText,e.getValue(),FO)&&i<r-1?[u,hO]:u}))}function wO(e,t,n){const r=e.getNode(),i=[],{interfaces:u}=r,o=e.map((e=>n(e)),"interfaces");for(let e=0;e<u.length;e++){const n=u[e];i.push(o[e]);const r=u[e+1];if(r){const e=t.originalText.slice(n.loc.end,r.loc.start),u=e.includes("#"),o=e.replace(/#.*/g,"").trim();i.push(","===o?",":" &",u?gO:" ");}}return i}function TO(){}TO.ignoredProperties=new Set(["loc","comments"]);var BO={print:function(e,t,n){const r=e.getValue();if(!r)return "";if("string"==typeof r)return r;switch(r.kind){case"Document":{const r=[];return e.each(((e,i,u)=>{r.push(n()),i!==u.length-1&&(r.push(hO),bO(t.originalText,e.getValue(),FO)&&r.push(hO));}),"definitions"),[...r,hO]}case"OperationDefinition":{const i="{"!==t.originalText[AO(r)],u=Boolean(r.name);return [i?r.operation:"",i&&u?[" ",n("name")]:"",i&&!u&&CO(r.variableDefinitions)?" ":"",CO(r.variableDefinitions)?yO(["(",DO([mO,dO([EO("",", "),mO],e.map(n,"variableDefinitions"))]),mO,")"]):"",xO(e,n,r),r.selectionSet&&(i||u)?" ":"",n("selectionSet")]}case"FragmentDefinition":return ["fragment ",n("name"),CO(r.variableDefinitions)?yO(["(",DO([mO,dO([EO("",", "),mO],e.map(n,"variableDefinitions"))]),mO,")"]):""," on ",n("typeCondition"),xO(e,n,r)," ",n("selectionSet")];case"SelectionSet":return ["{",DO([hO,dO(hO,e.call((e=>SO(e,t,n)),"selections"))]),hO,"}"];case"Field":return yO([r.alias?[n("alias"),": "]:"",n("name"),r.arguments.length>0?yO(["(",DO([mO,dO([EO("",", "),mO],e.call((e=>SO(e,t,n)),"arguments"))]),mO,")"]):"",xO(e,n,r),r.selectionSet?" ":"",n("selectionSet")]);case"Name":return r.value;case"StringValue":return r.block?['"""',hO,dO(hO,r.value.replace(/"""/g,"\\$&").split("\n")),hO,'"""']:['"',r.value.replace(/["\\]/g,"\\$&").replace(/\n/g,"\\n"),'"'];case"IntValue":case"FloatValue":case"EnumValue":return r.value;case"BooleanValue":return r.value?"true":"false";case"NullValue":return "null";case"Variable":return ["$",n("name")];case"ListValue":return yO(["[",DO([mO,dO([EO("",", "),mO],e.map(n,"values"))]),mO,"]"]);case"ObjectValue":return yO(["{",t.bracketSpacing&&r.fields.length>0?" ":"",DO([mO,dO([EO("",", "),mO],e.map(n,"fields"))]),mO,EO("",t.bracketSpacing&&r.fields.length>0?" ":""),"}"]);case"ObjectField":case"Argument":return [n("name"),": ",n("value")];case"Directive":return ["@",n("name"),r.arguments.length>0?yO(["(",DO([mO,dO([EO("",", "),mO],e.call((e=>SO(e,t,n)),"arguments"))]),mO,")"]):""];case"NamedType":return n("name");case"VariableDefinition":return [n("variable"),": ",n("type"),r.defaultValue?[" = ",n("defaultValue")]:"",xO(e,n,r)];case"ObjectTypeExtension":case"ObjectTypeDefinition":return [n("description"),r.description?hO:"","ObjectTypeExtension"===r.kind?"extend ":"","type ",n("name"),r.interfaces.length>0?[" implements ",...wO(e,t,n)]:"",xO(e,n,r),r.fields.length>0?[" {",DO([hO,dO(hO,e.call((e=>SO(e,t,n)),"fields"))]),hO,"}"]:""];case"FieldDefinition":return [n("description"),r.description?hO:"",n("name"),r.arguments.length>0?yO(["(",DO([mO,dO([EO("",", "),mO],e.call((e=>SO(e,t,n)),"arguments"))]),mO,")"]):"",": ",n("type"),xO(e,n,r)];case"DirectiveDefinition":return [n("description"),r.description?hO:"","directive ","@",n("name"),r.arguments.length>0?yO(["(",DO([mO,dO([EO("",", "),mO],e.call((e=>SO(e,t,n)),"arguments"))]),mO,")"]):"",r.repeatable?" repeatable":""," on ",dO(" | ",e.map(n,"locations"))];case"EnumTypeExtension":case"EnumTypeDefinition":return [n("description"),r.description?hO:"","EnumTypeExtension"===r.kind?"extend ":"","enum ",n("name"),xO(e,n,r),r.values.length>0?[" {",DO([hO,dO(hO,e.call((e=>SO(e,t,n)),"values"))]),hO,"}"]:""];case"EnumValueDefinition":return [n("description"),r.description?hO:"",n("name"),xO(e,n,r)];case"InputValueDefinition":return [n("description"),r.description?r.description.block?hO:gO:"",n("name"),": ",n("type"),r.defaultValue?[" = ",n("defaultValue")]:"",xO(e,n,r)];case"InputObjectTypeExtension":case"InputObjectTypeDefinition":return [n("description"),r.description?hO:"","InputObjectTypeExtension"===r.kind?"extend ":"","input ",n("name"),xO(e,n,r),r.fields.length>0?[" {",DO([hO,dO(hO,e.call((e=>SO(e,t,n)),"fields"))]),hO,"}"]:""];case"SchemaDefinition":return ["schema",xO(e,n,r)," {",r.operationTypes.length>0?DO([hO,dO(hO,e.call((e=>SO(e,t,n)),"operationTypes"))]):"",hO,"}"];case"OperationTypeDefinition":return [n("operation"),": ",n("type")];case"InterfaceTypeExtension":case"InterfaceTypeDefinition":return [n("description"),r.description?hO:"","InterfaceTypeExtension"===r.kind?"extend ":"","interface ",n("name"),r.interfaces.length>0?[" implements ",...wO(e,t,n)]:"",xO(e,n,r),r.fields.length>0?[" {",DO([hO,dO(hO,e.call((e=>SO(e,t,n)),"fields"))]),hO,"}"]:""];case"FragmentSpread":return ["...",n("name"),xO(e,n,r)];case"InlineFragment":return ["...",r.typeCondition?[" on ",n("typeCondition")]:"",xO(e,n,r)," ",n("selectionSet")];case"UnionTypeExtension":case"UnionTypeDefinition":return yO([n("description"),r.description?hO:"",yO(["UnionTypeExtension"===r.kind?"extend ":"","union ",n("name"),xO(e,n,r),r.types.length>0?[" =",EO(""," "),DO([EO([gO,"  "]),dO([gO,"| "],e.map(n,"types"))])]:""])]);case"ScalarTypeExtension":case"ScalarTypeDefinition":return [n("description"),r.description?hO:"","ScalarTypeExtension"===r.kind?"extend ":"","scalar ",n("name"),xO(e,n,r)];case"NonNullType":return [n("type"),"!"];case"ListType":return ["[",n("type"),"]"];default:throw new Error("unknown graphql type: "+JSON.stringify(r.kind))}},massageAstNode:TO,hasPrettierIgnore:function(e){const t=e.getValue();return t&&Array.isArray(t.comments)&&t.comments.some((e=>"prettier-ignore"===e.value.trim()))},insertPragma:vO,printComment:function(e){const t=e.getValue();if("Comment"===t.kind)return "#"+t.value.trimEnd();throw new Error("Not a comment: "+JSON.stringify(t))},canAttachComment:function(e){return e.kind&&"Comment"!==e.kind}},kO={bracketSpacing:$B.bracketSpacing};var NO={languages:[Yd({name:"GraphQL",type:"data",color:"#e10098",extensions:[".graphql",".gql",".graphqls"],tmScope:"source.graphql",aceMode:"text",languageId:139},(()=>({since:"1.5.0",parsers:["graphql"],vscodeLanguageIds:["graphql"]})))],options:kO,printers:{graphql:BO},parsers:{get graphql(){return require("./parser-graphql").parsers.graphql}}};var PO={locStart:function(e){return e.position.start.offset},locEnd:function(e){return e.position.end.offset}};const{getLast:OO}=fi$1,{locStart:IO,locEnd:jO}=PO,{cjkPattern:LO,kPattern:_O,punctuationPattern:MO}={cjkPattern:"(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",kPattern:"[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",punctuationPattern:"[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"},RO=["liquidNode","inlineCode","emphasis","strong","delete","wikiLink","link","linkReference","image","imageReference","footnote","footnoteReference","sentence","whitespace","word","break","inlineMath"],$O=[...RO,"tableCell","paragraph","heading"],VO=new RegExp(_O),qO=new RegExp(MO);function WO(e,t){const[,n,r,i]=t.slice(e.position.start.offset,e.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);return {numberText:n,marker:r,leadingSpaces:i}}var UO={mapAst:function(e,t){return function e(n,r,i){const u=Object.assign({},t(n,r,i));return u.children&&(u.children=u.children.map(((t,n)=>e(t,n,[u,...i])))),u}(e,null,[])},splitText:function(e,t){const n="non-cjk",r="cj-letter",i="cjk-punctuation",u=[],o=("preserve"===t.proseWrap?e:e.replace(new RegExp(`(${LO})\n(${LO})`,"g"),"$1$2")).split(/([\t\n ]+)/);for(const[e,t]of o.entries()){if(e%2==1){u.push({type:"whitespace",value:/\n/.test(t)?"\n":" "});continue}if((0===e||e===o.length-1)&&""===t)continue;const a=t.split(new RegExp(`(${LO})`));for(const[e,t]of a.entries())(0!==e&&e!==a.length-1||""!==t)&&(e%2!=0?s(qO.test(t)?{type:"word",value:t,kind:i,hasLeadingPunctuation:!0,hasTrailingPunctuation:!0}:{type:"word",value:t,kind:VO.test(t)?"k-letter":r,hasLeadingPunctuation:!1,hasTrailingPunctuation:!1}):""!==t&&s({type:"word",value:t,kind:n,hasLeadingPunctuation:qO.test(t[0]),hasTrailingPunctuation:qO.test(OO(t))}));}return u;function s(e){const t=OO(u);var o,s;t&&"word"===t.type&&(t.kind===n&&e.kind===r&&!t.hasTrailingPunctuation||t.kind===r&&e.kind===n&&!e.hasLeadingPunctuation?u.push({type:"whitespace",value:" "}):(o=n,s=i,t.kind===o&&e.kind===s||t.kind===s&&e.kind===o||[t.value,e.value].some((e=>/\u3000/.test(e)))||u.push({type:"whitespace",value:""}))),u.push(e);}},punctuationPattern:MO,getFencedCodeBlockValue:function(e,t){const{value:n}=e;return e.position.end.offset===t.length&&n.endsWith("\n")&&t.endsWith("\n")?n.slice(0,-1):n},getOrderedListItemInfo:WO,hasGitDiffFriendlyOrderedList:function(e,t){if(!e.ordered)return !1;if(e.children.length<2)return !1;const n=Number(WO(e.children[0],t.originalText).numberText),r=Number(WO(e.children[1],t.originalText).numberText);if(0===n&&e.children.length>2){const n=Number(WO(e.children[2],t.originalText).numberText);return 1===r&&1===n}return 1===r},INLINE_NODE_TYPES:RO,INLINE_NODE_WRAPPER_TYPES:$O,isAutolink:function(e){if(!e||"link"!==e.type||1!==e.children.length)return !1;const t=e.children[0];return t&&IO(e)===IO(t)&&jO(e)===jO(t)}};const{inferParserByLanguage:zO,getMaxContinuousCount:GO}=fi$1,{builders:{hardline:HO,markAsRoot:JO},utils:{replaceNewlinesWithLiterallines:XO}}=Ji$1,{getFencedCodeBlockValue:YO}=UO;var KO=function(e,t,n,r){const i=e.getValue();if("code"===i.type&&null!==i.lang){const e=zO(i.lang,r);if(e){const t=r.__inJsTemplate?"~":"`",u=t.repeat(Math.max(3,GO(i.value,t)+1)),o=n(YO(i,r.originalText),{parser:e},{stripTrailingHardline:!0});return JO([u,i.lang,i.meta?" "+i.meta:"",HO,XO(o),HO,u])}}switch(i.type){case"front-matter":return tk(i,n);case"importExport":return [n(i.value,{parser:"babel"},{stripTrailingHardline:!0}),HO];case"jsx":return n(`<$>${i.value}</$>`,{parser:"__js_expression",rootMarker:"mdx"},{stripTrailingHardline:!0})}return null};const QO=["format","prettier"];function ZO(e){const t=`@(${QO.join("|")})`,n=new RegExp([`\x3c!--\\s*${t}\\s*--\x3e`,`\x3c!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*${t}[^\\S\n]*($|\n)[\\s\\S]*\n.*--\x3e`].join("|"),"m"),r=e.match(n);return r&&0===r.index}var eI={startWithPragma:ZO,hasPragma:e=>ZO(uk(e).content.trimStart()),insertPragma:e=>{const t=uk(e),n=`\x3c!-- @${QO[0]} --\x3e`;return t.frontMatter?`${t.frontMatter.raw}\n\n${n}\n\n${t.content}`:`${n}\n\n${t.content}`}};const{getOrderedListItemInfo:tI,mapAst:nI,splitText:rI}=UO,iI=/^.$/us;function uI(e,t,n){return nI(e,(e=>{if(!e.children)return e;const r=e.children.reduce(((e,r)=>{const i=Sn$1(e);return i&&t(i,r)?e.splice(-1,1,n(i,r)):e.push(r),e}),[]);return Object.assign(Object.assign({},e),{},{children:r})}))}var oI=function(e,t){return e=function(e){return uI(e,((e,t)=>"importExport"===e.type&&"importExport"===t.type),((e,t)=>({type:"importExport",value:e.value+"\n\n"+t.value,position:{start:e.position.start,end:t.position.end}})))}(e=function(e){return nI(e,(e=>"import"!==e.type&&"export"!==e.type?e:Object.assign(Object.assign({},e),{},{type:"importExport"})))}(e=function(e,t){return nI(e,((e,n,[r])=>{if("text"!==e.type)return e;let{value:i}=e;return "paragraph"===r.type&&(0===n&&(i=i.trimStart()),n===r.children.length-1&&(i=i.trimEnd())),{type:"sentence",position:e.position,children:rI(i,t)}}))}(e=function(e,t){return nI(e,((e,t,n)=>{if("list"===e.type&&e.children.length>0){for(let t=0;t<n.length;t++){const r=n[t];if("list"===r.type&&!r.isAligned)return e.isAligned=!1,e}e.isAligned=r(e);}return e}));function n(e){return 0===e.children.length?-1:e.children[0].position.start.column-1}function r(e){if(!e.ordered)return !0;const[r,i]=e.children;if(tI(r,t.originalText).leadingSpaces.length>1)return !0;const u=n(r);if(-1===u)return !1;if(1===e.children.length)return u%t.tabWidth==0;if(u!==n(i))return !1;if(u%t.tabWidth==0)return !0;return tI(i,t.originalText).leadingSpaces.length>1}}(e=function(e,t){return nI(e,((e,n,r)=>{if("code"===e.type){const n=/^\n?( {4,}|\t)/.test(t.originalText.slice(e.position.start.offset,e.position.end.offset));if(e.isIndented=n,n)for(let e=0;e<r.length;e++){const t=r[e];if(t.hasIndentedCodeblock)break;"list"===t.type&&(t.hasIndentedCodeblock=!0);}}return e}))}(e=function(e){return nI(e,(e=>"inlineCode"!==e.type?e:Object.assign(Object.assign({},e),{},{value:e.value.replace(/\s+/g," ")})))}(e=function(e){return uI(e,((e,t)=>"text"===e.type&&"text"===t.type),((e,t)=>({type:"text",value:e.value+t.value,position:{start:e.position.start,end:t.position.end}})))}(e=function(e,t){return nI(e,(e=>"text"===e.type&&"*"!==e.value&&"_"!==e.value&&iI.test(e.value)&&e.position.end.offset-e.position.start.offset!==e.value.length?Object.assign(Object.assign({},e),{},{value:t.originalText.slice(e.position.start.offset,e.position.end.offset)}):e))}(e,t))),t),t),t)))};const{isFrontMatterNode:sI}=fi$1,{startWithPragma:aI}=eI,lI=new Set(["position","raw"]);function cI(e,t,n){return "front-matter"!==e.type&&"code"!==e.type&&"yaml"!==e.type&&"import"!==e.type&&"export"!==e.type&&"jsx"!==e.type||delete t.value,"list"===e.type&&delete t.isAligned,"list"!==e.type&&"listItem"!==e.type||(delete t.spread,delete t.loose),"text"===e.type?null:("inlineCode"===e.type&&(t.value=e.value.replace(/[\t\n ]+/g," ")),"wikiLink"===e.type&&(t.value=e.value.trim().replace(/[\t\n]+/g," ")),"definition"!==e.type&&"linkReference"!==e.type||(t.label=e.label.trim().replace(/[\t\n ]+/g," ").toLowerCase()),"definition"!==e.type&&"link"!==e.type&&"image"!==e.type||!e.title||(t.title=e.title.replace(/\\(["')])/g,"$1")),n&&"root"===n.type&&n.children.length>0&&(n.children[0]===e||sI(n.children[0])&&n.children[1]===e)&&"html"===e.type&&aI(e.value)?null:void 0)}cI.ignoredProperties=lI;var pI=cI;const{getLast:fI,getMinNotPresentContinuousCount:dI,getMaxContinuousCount:hI,getStringWidth:gI,isNonEmptyArray:mI}=fi$1,{builders:{breakParent:yI,join:DI,line:EI,literalline:bI,markAsRoot:CI,hardline:vI,softline:AI,ifBreak:FI,fill:xI,align:SI,indent:wI,group:TI,hardlineWithoutBreakParent:BI},utils:{normalizeDoc:kI,replaceEndOfLineWith:NI},printer:{printDocToString:PI}}=Ji$1,{insertPragma:OI}=eI,{locStart:II,locEnd:jI}=PO,{getFencedCodeBlockValue:LI,hasGitDiffFriendlyOrderedList:_I,splitText:MI,punctuationPattern:RI,INLINE_NODE_TYPES:$I,INLINE_NODE_WRAPPER_TYPES:VI,isAutolink:qI}=UO,WI=new Set(["importExport"]),UI=["heading","tableCell","link","wikiLink"],zI=new Set(["listItem","definition","footnoteDefinition"]);function GI(e,t,n,r){const i=e.getValue(),u=null===i.checked?"":i.checked?"[x] ":"[ ] ";return [u,QI(e,t,n,{processor:(e,i)=>{if(0===i&&"list"!==e.getValue().type)return SI(" ".repeat(u.length),n());const o=" ".repeat(function(e,t,n){return e<t?t:e>n?n:e}(t.tabWidth-r.length,0,3));return [o,SI(o,n())]}})]}function HI(e,t){return function(e,t,n){let r=-1;for(const i of t.children)if(i.type===e.type&&n(i)?r++:r=-1,i===e)return r}(e,t,(t=>t.ordered===e.ordered))}function JI(e,t){const n=Array.isArray(t)?t:[t];let r,i=-1;for(;r=e.getParentNode(++i);)if(n.includes(r.type))return i;return -1}function XI(e,t){const n=JI(e,t);return -1===n?null:e.getParentNode(n)}function YI(e,t,n){if("preserve"===n.proseWrap&&"\n"===t)return vI;const r="always"===n.proseWrap&&!XI(e,UI);return ""!==t?r?EI:" ":r?AI:""}function KI(e,t,n){const r=[];let i=null;const{children:u}=e.getValue();for(const[e,t]of u.entries())switch(ej(t)){case"start":null===i&&(i={index:e,offset:t.position.end.offset});break;case"end":null!==i&&(r.push({start:i,end:{index:e,offset:t.position.start.offset}}),i=null);}return QI(e,t,n,{processor:(e,i)=>{if(r.length>0){const e=r[0];if(i===e.start.index)return [u[e.start.index].value,t.originalText.slice(e.start.offset,e.end.offset),u[e.end.index].value];if(e.start.index<i&&i<e.end.index)return !1;if(i===e.end.index)return r.shift(),!1}return n()}})}function QI(e,t,n,r={}){const{postprocessor:i}=r,u=r.processor||(()=>n()),o=e.getValue(),s=[];let a;return e.each(((e,n)=>{const r=e.getValue(),i=u(e,n);if(!1!==i){const e={parts:s,prevNode:a,parentNode:o,options:t};(function(e,t){const n=0===t.parts.length,r=$I.includes(e.type),i="html"===e.type&&VI.includes(t.parentNode.type);return !n&&!r&&!i})(r,e)&&(s.push(vI),a&&WI.has(a.type)||(function(e,t){const n=(t.prevNode&&t.prevNode.type)===e.type&&zI.has(e.type),r="listItem"===t.parentNode.type&&!t.parentNode.loose,i=t.prevNode&&"listItem"===t.prevNode.type&&t.prevNode.loose,u="next"===ej(t.prevNode),o="html"===e.type&&t.prevNode&&"html"===t.prevNode.type&&t.prevNode.position.end.line+1===e.position.start.line,s="html"===e.type&&"listItem"===t.parentNode.type&&t.prevNode&&"paragraph"===t.prevNode.type&&t.prevNode.position.end.line+1===e.position.start.line;return i||!(n||r||u||o||s)}(r,e)||tj(r,e))&&s.push(vI),tj(r,e)&&s.push(vI)),s.push(i),a=r;}}),"children"),i?i(s):s}function ZI(e){let t=e;for(;mI(t.children);)t=fI(t.children);return t}function ej(e){if("html"!==e.type)return !1;const t=e.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);return null!==t&&(t[1]?t[1]:"next")}function tj(e,t){const n=t.prevNode&&"list"===t.prevNode.type,r="code"===e.type&&e.isIndented;return n&&r}function nj(e,t=[]){const n=[" ",...Array.isArray(t)?t:[t]];return new RegExp(n.map((e=>`\\${e}`)).join("|")).test(e)?`<${e}>`:e}function rj(e,t,n=!0){if(!e)return "";if(n)return " "+rj(e,t,!1);if((e=e.replace(/\\(["')])/g,"$1")).includes('"')&&e.includes("'")&&!e.includes(")"))return `(${e})`;const r=e.split("'").length-1,i=e.split('"').length-1,u=r>i?'"':i>r||t.singleQuote?"'":'"';return `${u}${e=(e=e.replace(/\\/,"\\\\")).replace(new RegExp(`(${u})`,"g"),"\\$1")}${u}`}var ij={preprocess:oI,print:function(e,t,n){const r=e.getValue();if(function(e){const t=XI(e,["linkReference","imageReference"]);return t&&("linkReference"!==t.type||"full"!==t.referenceType)}(e))return MI(t.originalText.slice(r.position.start.offset,r.position.end.offset),t).map((n=>"word"===n.type?n.value:""===n.value?"":YI(e,n.value,t)));switch(r.type){case"front-matter":return t.originalText.slice(r.position.start.offset,r.position.end.offset);case"root":return 0===r.children.length?"":[kI(KI(e,t,n)),WI.has(ZI(r).type)?"":vI];case"paragraph":return QI(e,t,n,{postprocessor:xI});case"sentence":return QI(e,t,n);case"word":{let t=r.value.replace(/\*/g,"\\$&").replace(new RegExp([`(^|${RI})(_+)`,`(_+)(${RI}|$)`].join("|"),"g"),((e,t,n,r,i)=>(n?`${t}${n}`:`${r}${i}`).replace(/_/g,"\\_")));const n=(e,t,n)=>"sentence"===e.type&&0===n,i=(e,t,n)=>qI(e.children[n-1]);return t!==r.value&&(e.match(void 0,n,i)||e.match(void 0,n,((e,t,n)=>"emphasis"===e.type&&0===n),i))&&(t=t.replace(/^(\\?[*_])+/,(e=>e.replace(/\\/g,"")))),t}case"whitespace":{const n=e.getParentNode(),i=n.children.indexOf(r),u=n.children[i+1],o=u&&/^>|^([*+-]|#{1,6}|\d+[).])$/.test(u.value)?"never":t.proseWrap;return YI(e,r.value,{proseWrap:o})}case"emphasis":{let i;if(qI(r.children[0]))i=t.originalText[r.position.start.offset];else {const t=e.getParentNode(),n=t.children.indexOf(r),u=t.children[n-1],o=t.children[n+1];i=u&&"sentence"===u.type&&u.children.length>0&&"word"===fI(u.children).type&&!fI(u.children).hasTrailingPunctuation||o&&"sentence"===o.type&&o.children.length>0&&"word"===o.children[0].type&&!o.children[0].hasLeadingPunctuation||XI(e,"emphasis")?"*":"_";}return [i,QI(e,t,n),i]}case"strong":return ["**",QI(e,t,n),"**"];case"delete":return ["~~",QI(e,t,n),"~~"];case"inlineCode":{const e=dI(r.value,"`"),t="`".repeat(e||1),n=e&&!/^\s/.test(r.value)?" ":"";return [t,n,r.value,n,t]}case"wikiLink":{let e="";return e="preserve"===t.proseWrap?r.value:r.value.replace(/[\t\n]+/g," "),["[[",e,"]]"]}case"link":switch(t.originalText[r.position.start.offset]){case"<":{const e="mailto:";return ["<",r.url.startsWith(e)&&t.originalText.slice(r.position.start.offset+1,r.position.start.offset+1+e.length)!==e?r.url.slice(e.length):r.url,">"]}case"[":return ["[",QI(e,t,n),"](",nj(r.url,")"),rj(r.title,t),")"];default:return t.originalText.slice(r.position.start.offset,r.position.end.offset)}case"image":return ["![",r.alt||"","](",nj(r.url,")"),rj(r.title,t),")"];case"blockquote":return ["> ",SI("> ",QI(e,t,n))];case"heading":return ["#".repeat(r.depth)+" ",QI(e,t,n)];case"code":{if(r.isIndented){const e=" ".repeat(4);return SI(e,[e,...NI(r.value,vI)])}const e=t.__inJsTemplate?"~":"`",n=e.repeat(Math.max(3,hI(r.value,e)+1));return [n,r.lang||"",r.meta?" "+r.meta:"",vI,...NI(LI(r,t.originalText),vI),vI,n]}case"html":{const t=e.getParentNode(),n="root"===t.type&&fI(t.children)===r?r.value.trimEnd():r.value,i=/^<!--.*-->$/s.test(n);return NI(n,i?vI:CI(bI))}case"list":{const i=HI(r,e.getParentNode()),u=_I(r,t);return QI(e,t,n,{processor:(e,o)=>{const s=function(){const e=r.ordered?(0===o?r.start:u?1:r.start+o)+(i%2==0?". ":") "):i%2==0?"- ":"* ";return r.isAligned||r.hasIndentedCodeblock?function(e,t){const n=r();return e+" ".repeat(n>=4?0:n);function r(){const n=e.length%t.tabWidth;return 0===n?0:t.tabWidth-n}}(e,t):e}(),a=e.getValue();return 2===a.children.length&&"html"===a.children[1].type&&a.children[0].position.start.column!==a.children[1].position.start.column?[s,GI(e,t,n,s)]:[s,SI(" ".repeat(s.length),GI(e,t,n,s))]}})}case"thematicBreak":{const t=JI(e,"list");if(-1===t)return "---";return HI(e.getParentNode(t),e.getParentNode(t+1))%2==0?"***":"---"}case"linkReference":return ["[",QI(e,t,n),"]","full"===r.referenceType?["[",r.identifier,"]"]:"collapsed"===r.referenceType?"[]":""];case"imageReference":switch(r.referenceType){case"full":return ["![",r.alt||"","][",r.identifier,"]"];default:return ["![",r.alt,"]","collapsed"===r.referenceType?"[]":""]}case"definition":{const e="always"===t.proseWrap?EI:" ";return TI(["[",r.identifier,"]:",wI([e,nj(r.url),null===r.title?"":[e,rj(r.title,t,!1)]])])}case"footnote":return ["[^",QI(e,t,n),"]"];case"footnoteReference":return ["[^",r.identifier,"]"];case"footnoteDefinition":{const i=e.getParentNode().children[e.getName()+1],u=1===r.children.length&&"paragraph"===r.children[0].type&&("never"===t.proseWrap||"preserve"===t.proseWrap&&r.children[0].position.start.line===r.children[0].position.end.line);return ["[^",r.identifier,"]: ",u?QI(e,t,n):TI([SI(" ".repeat(4),QI(e,t,n,{processor:(e,t)=>0===t?TI([AI,n()]):n()})),i&&"footnoteDefinition"===i.type?AI:""])]}case"table":return function(e,t,n){const r=e.getValue(),i=[],u=e.map((e=>e.map(((e,r)=>{const u=PI(n(),t).formatted,o=gI(u);return i[r]=Math.max(i[r]||3,o),{text:u,width:o}}),"children")),"children"),o=a(!1);if("never"!==t.proseWrap)return [yI,o];const s=a(!0);return [yI,TI(FI(s,o))];function a(e){const t=[c(u[0],e),l(e)];return u.length>1&&t.push(DI(BI,u.slice(1).map((t=>c(t,e))))),DI(BI,t)}function l(e){return `| ${i.map(((t,n)=>{const i=r.align[n],u="center"===i||"right"===i?":":"-";return `${"center"===i||"left"===i?":":"-"}${e?"-":"-".repeat(t-2)}${u}`})).join(" | ")} |`}function c(e,t){return `| ${e.map((({text:e,width:n},u)=>{if(t)return e;const o=i[u]-n,s=r.align[u];let a=0;"right"===s?a=o:"center"===s&&(a=Math.floor(o/2));const l=o-a;return `${" ".repeat(a)}${e}${" ".repeat(l)}`})).join(" | ")} |`}}(e,t,n);case"tableCell":return QI(e,t,n);case"break":return /\s/.test(t.originalText[r.position.start.offset])?["  ",CI(bI)]:["\\",vI];case"liquidNode":return NI(r.value,vI);case"importExport":return [r.value,vI];case"jsx":return r.value;case"math":return ["$$",vI,r.value?[...NI(r.value,vI),vI]:"","$$"];case"inlineMath":return t.originalText.slice(II(r),jI(r));case"tableRow":case"listItem":default:throw new Error(`Unknown markdown type ${JSON.stringify(r.type)}`)}},embed:KO,massageAstNode:pI,hasPrettierIgnore:function(e){const t=Number(e.getName());return 0!==t&&"next"===ej(e.getParentNode().children[t-1])},insertPragma:OI},uj={proseWrap:$B.proseWrap,singleQuote:$B.singleQuote},oj={name:"Markdown",type:"prose",color:"#083fa1",aliases:["pandoc"],aceMode:"markdown",codemirrorMode:"gfm",codemirrorMimeType:"text/x-gfm",wrap:!0,extensions:[".md",".markdown",".mdown",".mdwn",".mdx",".mkd",".mkdn",".mkdown",".ronn",".scd",".workbook"],filenames:["contents.lr"],tmScope:"source.gfm",languageId:222};var sj={languages:[Yd(oj,(e=>({since:"1.8.0",parsers:["markdown"],vscodeLanguageIds:["markdown"],filenames:[...e.filenames,"README"],extensions:e.extensions.filter((e=>".mdx"!==e))}))),Yd(oj,(()=>({name:"MDX",since:"1.15.0",parsers:["mdx"],vscodeLanguageIds:["mdx"],filenames:[],extensions:[".mdx"]})))],options:uj,printers:{mdast:ij},parsers:{get remark(){return require("./parser-markdown").parsers.remark},get markdown(){return require("./parser-markdown").parsers.remark},get mdx(){return require("./parser-markdown").parsers.mdx}}};const{isFrontMatterNode:aj}=fi$1,lj=new Set(["sourceSpan","startSourceSpan","endSourceSpan","nameSpan","valueSpan"]);function cj(e,t){return "text"===e.type||"comment"===e.type||aj(e)||"yaml"===e.type||"toml"===e.type?null:("attribute"===e.type&&delete t.value,void("docType"===e.type&&delete t.value))}cj.ignoredProperties=lj;var pj=cj,fj={"*":["accesskey","autocapitalize","autofocus","class","contenteditable","dir","draggable","enterkeyhint","hidden","id","inputmode","is","itemid","itemprop","itemref","itemscope","itemtype","lang","nonce","slot","spellcheck","style","tabindex","title","translate"],a:["accesskey","charset","coords","download","href","hreflang","name","ping","referrerpolicy","rel","rev","shape","tabindex","target","type"],abbr:["title"],applet:["align","alt","archive","code","codebase","height","hspace","name","object","vspace","width"],area:["accesskey","alt","coords","download","href","hreflang","nohref","ping","referrerpolicy","rel","shape","tabindex","target","type"],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],base:["href","target"],basefont:["color","face","size"],bdo:["dir"],blockquote:["cite"],body:["alink","background","bgcolor","link","text","vlink"],br:["clear"],button:["accesskey","autofocus","disabled","form","formaction","formenctype","formmethod","formnovalidate","formtarget","name","tabindex","type","value"],canvas:["height","width"],caption:["align"],col:["align","char","charoff","span","valign","width"],colgroup:["align","char","charoff","span","valign","width"],data:["value"],del:["cite","datetime"],details:["open"],dfn:["title"],dialog:["open"],dir:["compact"],div:["align"],dl:["compact"],embed:["height","src","type","width"],fieldset:["disabled","form","name"],font:["color","face","size"],form:["accept","accept-charset","action","autocomplete","enctype","method","name","novalidate","target"],frame:["frameborder","longdesc","marginheight","marginwidth","name","noresize","scrolling","src"],frameset:["cols","rows"],h1:["align"],h2:["align"],h3:["align"],h4:["align"],h5:["align"],h6:["align"],head:["profile"],hr:["align","noshade","size","width"],html:["manifest","version"],iframe:["align","allow","allowfullscreen","allowpaymentrequest","allowusermedia","frameborder","height","loading","longdesc","marginheight","marginwidth","name","referrerpolicy","sandbox","scrolling","src","srcdoc","width"],img:["align","alt","border","crossorigin","decoding","height","hspace","ismap","loading","longdesc","name","referrerpolicy","sizes","src","srcset","usemap","vspace","width"],input:["accept","accesskey","align","alt","autocomplete","autofocus","checked","dirname","disabled","form","formaction","formenctype","formmethod","formnovalidate","formtarget","height","ismap","list","max","maxlength","min","minlength","multiple","name","pattern","placeholder","readonly","required","size","src","step","tabindex","title","type","usemap","value","width"],ins:["cite","datetime"],isindex:["prompt"],label:["accesskey","for","form"],legend:["accesskey","align"],li:["type","value"],link:["as","charset","color","crossorigin","disabled","href","hreflang","imagesizes","imagesrcset","integrity","media","nonce","referrerpolicy","rel","rev","sizes","target","title","type"],map:["name"],menu:["compact"],meta:["charset","content","http-equiv","name","scheme"],meter:["high","low","max","min","optimum","value"],object:["align","archive","border","classid","codebase","codetype","data","declare","form","height","hspace","name","standby","tabindex","type","typemustmatch","usemap","vspace","width"],ol:["compact","reversed","start","type"],optgroup:["disabled","label"],option:["disabled","label","selected","value"],output:["for","form","name"],p:["align"],param:["name","type","value","valuetype"],pre:["width"],progress:["max","value"],q:["cite"],script:["async","charset","crossorigin","defer","integrity","language","nomodule","nonce","referrerpolicy","src","type"],select:["autocomplete","autofocus","disabled","form","multiple","name","required","size","tabindex"],slot:["name"],source:["media","sizes","src","srcset","type"],style:["media","nonce","title","type"],table:["align","bgcolor","border","cellpadding","cellspacing","frame","rules","summary","width"],tbody:["align","char","charoff","valign"],td:["abbr","align","axis","bgcolor","char","charoff","colspan","headers","height","nowrap","rowspan","scope","valign","width"],textarea:["accesskey","autocomplete","autofocus","cols","dirname","disabled","form","maxlength","minlength","name","placeholder","readonly","required","rows","tabindex","wrap"],tfoot:["align","char","charoff","valign"],th:["abbr","align","axis","bgcolor","char","charoff","colspan","headers","height","nowrap","rowspan","scope","valign","width"],thead:["align","char","charoff","valign"],time:["datetime"],tr:["align","bgcolor","char","charoff","valign"],track:["default","kind","label","src","srclang"],ul:["compact","type"],video:["autoplay","controls","crossorigin","height","loop","muted","playsinline","poster","preload","src","width"]};const{inferParserByLanguage:dj,isFrontMatterNode:hj}=fi$1,{CSS_DISPLAY_TAGS:gj,CSS_DISPLAY_DEFAULT:mj,CSS_WHITE_SPACE_TAGS:yj,CSS_WHITE_SPACE_DEFAULT:Dj}={CSS_DISPLAY_TAGS:{area:"none",base:"none",basefont:"none",datalist:"none",head:"none",link:"none",meta:"none",noembed:"none",noframes:"none",param:"block",rp:"none",script:"block",source:"block",style:"none",template:"inline",track:"block",title:"none",html:"block",body:"block",address:"block",blockquote:"block",center:"block",div:"block",figure:"block",figcaption:"block",footer:"block",form:"block",header:"block",hr:"block",legend:"block",listing:"block",main:"block",p:"block",plaintext:"block",pre:"block",xmp:"block",slot:"contents",ruby:"ruby",rt:"ruby-text",article:"block",aside:"block",h1:"block",h2:"block",h3:"block",h4:"block",h5:"block",h6:"block",hgroup:"block",nav:"block",section:"block",dir:"block",dd:"block",dl:"block",dt:"block",ol:"block",ul:"block",li:"list-item",table:"table",caption:"table-caption",colgroup:"table-column-group",col:"table-column",thead:"table-header-group",tbody:"table-row-group",tfoot:"table-footer-group",tr:"table-row",td:"table-cell",th:"table-cell",fieldset:"block",button:"inline-block",details:"block",summary:"block",dialog:"block",meter:"inline-block",progress:"inline-block",object:"inline-block",video:"inline-block",audio:"inline-block",select:"inline-block",option:"block",optgroup:"block"},CSS_DISPLAY_DEFAULT:"inline",CSS_WHITE_SPACE_TAGS:{listing:"pre",plaintext:"pre",pre:"pre",xmp:"pre",nobr:"nowrap",table:"initial",textarea:"pre-wrap"},CSS_WHITE_SPACE_DEFAULT:"normal"},Ej=Fj(["a","abbr","acronym","address","applet","area","article","aside","audio","b","base","basefont","bdi","bdo","bgsound","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","command","content","data","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","element","em","embed","fieldset","figcaption","figure","font","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","image","img","input","ins","isindex","kbd","keygen","label","legend","li","link","listing","main","map","mark","marquee","math","menu","menuitem","meta","meter","multicol","nav","nextid","nobr","noembed","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","plaintext","pre","progress","q","rb","rbc","rp","rt","rtc","ruby","s","samp","script","section","select","shadow","slot","small","source","spacer","span","strike","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","tt","u","ul","var","video","wbr","xmp"]),bj=function(e,t){const n=Object.create(null);for(const[r,i]of Object.entries(e))n[r]=t(i,r);return n}(fj,Fj),Cj=new Set(["\t","\n","\f","\r"," "]),vj=e=>e.replace(/[\t\n\f\r ]+$/,""),Aj=e=>e.match(/^[\t\n\f\r ]*/)[0];function Fj(e){const t=Object.create(null);for(const n of e)t[n]=!0;return t}function xj(e,t){return !("ieConditionalComment"!==e.type||!e.lastChild||e.lastChild.isSelfClosing||e.lastChild.endSourceSpan)||("ieConditionalComment"===e.type&&!e.complete||(!(!_j(e)||!e.children.some((e=>"text"!==e.type&&"interpolation"!==e.type)))||!(!Wj(e,t)||wj(e)||"interpolation"===e.type)))}function Sj(e){if("attribute"===e.type)return !1;if(!e.parent)return !1;if("number"!=typeof e.index||0===e.index)return !1;return function(e){return "comment"===e.type&&"prettier-ignore"===e.value.trim()}(e.parent.children[e.index-1])}function wj(e){return "element"===e.type&&("script"===e.fullName||"style"===e.fullName||"svg:style"===e.fullName||Mj(e)&&("script"===e.name||"style"===e.name))}function Tj(e){return Rj(e).startsWith("pre")}function Bj(e){return "element"===e.type&&e.children.length>0&&(["html","head","ul","ol","select"].includes(e.name)||e.cssDisplay.startsWith("table")&&"table-cell"!==e.cssDisplay)}function kj(e){return Ij(e)||"element"===e.type&&"br"===e.fullName||Nj(e)}function Nj(e){return Pj(e)&&Oj(e)}function Pj(e){return e.hasLeadingSpaces&&(e.prev?e.prev.sourceSpan.end.line<e.sourceSpan.start.line:"root"===e.parent.type||e.parent.startSourceSpan.end.line<e.sourceSpan.start.line)}function Oj(e){return e.hasTrailingSpaces&&(e.next?e.next.sourceSpan.start.line>e.sourceSpan.end.line:"root"===e.parent.type||e.parent.endSourceSpan&&e.parent.endSourceSpan.start.line>e.sourceSpan.end.line)}function Ij(e){switch(e.type){case"ieConditionalComment":case"comment":case"directive":return !0;case"element":return ["script","select"].includes(e.name)}return !1}function jj(e){const{type:t,lang:n}=e.attrMap;return "module"===t||"text/javascript"===t||"text/babel"===t||"application/javascript"===t||"jsx"===n?"babel":"application/x-typescript"===t||"ts"===n||"tsx"===n?"typescript":"text/markdown"===t?"markdown":"text/html"===t?"html":t&&(t.endsWith("json")||t.endsWith("importmap"))?"json":"text/x-handlebars-template"===t?"glimmer":void 0}function Lj(e){return "block"===e||"list-item"===e||e.startsWith("table")}function _j(e){return Rj(e).startsWith("pre")}function Mj(e){return "element"===e.type&&!e.hasExplicitNamespace&&!["html","svg"].includes(e.namespace)}function Rj(e){return "element"===e.type&&(!e.namespace||Mj(e))&&yj[e.name]||Dj}const $j=new Set(["template","style","script"]);function Vj(e,t){return qj(e,t)&&!$j.has(e.fullName)}function qj(e,t){return "vue"===t.parser&&"element"===e.type&&"root"===e.parent.type&&"html"!==e.fullName.toLowerCase()}function Wj(e,t){return qj(e,t)&&(Vj(e,t)||e.attrMap.lang&&"html"!==e.attrMap.lang)}var Uj={HTML_ELEMENT_ATTRIBUTES:bj,HTML_TAGS:Ej,htmlTrim:e=>(e=>e.replace(/^[\t\n\f\r ]+/,""))(vj(e)),htmlTrimPreserveIndentation:e=>(e=>e.replace(/^[\t\f\r ]*?\n/g,""))(vj(e)),splitByHtmlWhitespace:e=>e.split(/[\t\n\f\r ]+/),hasHtmlWhitespace:e=>/[\t\n\f\r ]/.test(e),getLeadingAndTrailingHtmlWhitespace:e=>{const[,t,n,r]=e.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);return {leadingWhitespace:t,trailingWhitespace:r,text:n}},canHaveInterpolation:function(e){return e.children&&!wj(e)},countChars:function(e,t){let n=0;for(let r=0;r<e.length;r++)e[r]===t&&n++;return n},countParents:function(e,t){let n=0;for(let r=e.stack.length-1;r>=0;r--){const i=e.stack[r];i&&"object"==typeof i&&!Array.isArray(i)&&t(i)&&n++;}return n},dedentString:function(e,t=function(e){let t=Number.POSITIVE_INFINITY;for(const n of e.split("\n")){if(0===n.length)continue;if(!Cj.has(n[0]))return 0;const e=Aj(n).length;n.length!==e&&e<t&&(t=e);}return t===Number.POSITIVE_INFINITY?0:t}(e)){return 0===t?e:e.split("\n").map((e=>e.slice(t))).join("\n")},forceBreakChildren:Bj,forceBreakContent:function(e){return Bj(e)||"element"===e.type&&e.children.length>0&&(["body","script","style"].includes(e.name)||e.children.some((e=>function(e){return e.children&&e.children.some((e=>"text"!==e.type))}(e))))||e.firstChild&&e.firstChild===e.lastChild&&"text"!==e.firstChild.type&&Pj(e.firstChild)&&(!e.lastChild.isTrailingSpaceSensitive||Oj(e.lastChild))},forceNextEmptyLine:function(e){return hj(e)||e.next&&e.sourceSpan.end&&e.sourceSpan.end.line+1<e.next.sourceSpan.start.line},getLastDescendant:function e(t){return t.lastChild?e(t.lastChild):t},getNodeCssStyleDisplay:function(e,t){if(e.prev&&"comment"===e.prev.type){const t=e.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);if(t)return t[1]}let n=!1;if("element"===e.type&&"svg"===e.namespace){if(!function(e,t){let n=e;for(;n;){if(t(n))return !0;n=n.parent;}return !1}(e,(e=>"svg:foreignObject"===e.fullName)))return "svg"===e.name?"inline-block":"block";n=!0;}switch(t.htmlWhitespaceSensitivity){case"strict":return "inline";case"ignore":return "block";default:return "vue"===t.parser&&e.parent&&"root"===e.parent.type?"block":"element"===e.type&&(!e.namespace||n||Mj(e))&&gj[e.name]||mj}},getNodeCssStyleWhiteSpace:Rj,getPrettierIgnoreAttributeCommentData:function(e){const t=e.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);return !!t&&(!t[1]||t[1].split(/\s+/))},hasPrettierIgnore:Sj,inferScriptParser:function(e,t){return "script"!==e.name||e.attrMap.src?"style"===e.name?function(e){const{lang:t}=e.attrMap;return t&&"postcss"!==t&&"css"!==t?"scss"===t?"scss":"less"===t?"less":void 0:"css"}(e):t&&Wj(e,t)?jj(e)||!("src"in e.attrMap)&&dj(e.attrMap.lang,t):void 0:e.attrMap.lang||e.attrMap.type?jj(e):"babel"},isVueCustomBlock:Vj,isVueNonHtmlBlock:Wj,isVueSlotAttribute:function(e){const t=e.fullName;return "#"===t.charAt(0)||"slot-scope"===t||"v-slot"===t||t.startsWith("v-slot:")},isVueSfcBindingsAttribute:function(e,t){const n=e.parent;if(!qj(n,t))return !1;const r=n.fullName,i=e.fullName;return "script"===r&&"setup"===i||"style"===r&&"vars"===i},isDanglingSpaceSensitiveNode:function(e){return !(t=e.cssDisplay,Lj(t)||"inline-block"===t||wj(e));var t;},isIndentationSensitiveNode:Tj,isLeadingSpaceSensitiveNode:function(e,t){const n=function(){if(hj(e))return !1;if(("text"===e.type||"interpolation"===e.type)&&e.prev&&("text"===e.prev.type||"interpolation"===e.prev.type))return !0;if(!e.parent||"none"===e.parent.cssDisplay)return !1;if(_j(e.parent))return !0;if(!e.prev&&("root"===e.parent.type||_j(e)&&e.parent||wj(e.parent)||Vj(e.parent,t)||(n=e.parent.cssDisplay,Lj(n)||"inline-block"===n)))return !1;var n;if(e.prev&&!function(e){return !Lj(e)}(e.prev.cssDisplay))return !1;return !0}();return n&&!e.prev&&e.parent&&e.parent.tagDefinition&&e.parent.tagDefinition.ignoreFirstLf?"interpolation"===e.type:n},isPreLikeNode:_j,isScriptLikeTag:wj,isTextLikeNode:function(e){return "text"===e.type||"comment"===e.type},isTrailingSpaceSensitiveNode:function(e,t){return !hj(e)&&(!("text"!==e.type&&"interpolation"!==e.type||!e.next||"text"!==e.next.type&&"interpolation"!==e.next.type)||!(!e.parent||"none"===e.parent.cssDisplay)&&(!!_j(e.parent)||!(!e.next&&("root"===e.parent.type||_j(e)&&e.parent||wj(e.parent)||Vj(e.parent,t)||(n=e.parent.cssDisplay,Lj(n)||"inline-block"===n)))&&!(e.next&&!function(e){return !Lj(e)}(e.next.cssDisplay))));var n;},isWhitespaceSensitiveNode:function(e){return wj(e)||"interpolation"===e.type||Tj(e)},isUnknownNamespace:Mj,preferHardlineAsLeadingSpaces:function(e){return Ij(e)||e.prev&&kj(e.prev)||Nj(e)},preferHardlineAsTrailingSpaces:kj,shouldNotPrintClosingTag:function(e,t){return !e.isSelfClosing&&!e.endSourceSpan&&(Sj(e)||xj(e.parent,t))},shouldPreserveContent:xj,unescapeQuoteEntities:function(e){return e.replace(/&apos;/g,"'").replace(/&quot;/g,'"')}},zj=i$2((function(e,t){function n(e){return t.$0<=e&&e<=t.$9}
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
Object.defineProperty(t,"__esModule",{value:!0}),t.$EOF=0,t.$BSPACE=8,t.$TAB=9,t.$LF=10,t.$VTAB=11,t.$FF=12,t.$CR=13,t.$SPACE=32,t.$BANG=33,t.$DQ=34,t.$HASH=35,t.$$=36,t.$PERCENT=37,t.$AMPERSAND=38,t.$SQ=39,t.$LPAREN=40,t.$RPAREN=41,t.$STAR=42,t.$PLUS=43,t.$COMMA=44,t.$MINUS=45,t.$PERIOD=46,t.$SLASH=47,t.$COLON=58,t.$SEMICOLON=59,t.$LT=60,t.$EQ=61,t.$GT=62,t.$QUESTION=63,t.$0=48,t.$7=55,t.$9=57,t.$A=65,t.$E=69,t.$F=70,t.$X=88,t.$Z=90,t.$LBRACKET=91,t.$BACKSLASH=92,t.$RBRACKET=93,t.$CARET=94,t.$_=95,t.$a=97,t.$b=98,t.$e=101,t.$f=102,t.$n=110,t.$r=114,t.$t=116,t.$u=117,t.$v=118,t.$x=120,t.$z=122,t.$LBRACE=123,t.$BAR=124,t.$RBRACE=125,t.$NBSP=160,t.$PIPE=124,t.$TILDA=126,t.$AT=64,t.$BT=96,t.isWhitespace=function(e){return e>=t.$TAB&&e<=t.$SPACE||e==t.$NBSP},t.isDigit=n,t.isAsciiLetter=function(e){return e>=t.$a&&e<=t.$z||e>=t.$A&&e<=t.$Z},t.isAsciiHexDigit=function(e){return e>=t.$a&&e<=t.$f||e>=t.$A&&e<=t.$F||n(e)},t.isNewLine=function(e){return e===t.$LF||e===t.$CR},t.isOctalDigit=function(e){return t.$0<=e&&e<=t.$7};}));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class Gj{constructor(e,t,n){this.filePath=e,this.name=t,this.members=n;}assertNoMembers(){if(this.members.length)throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`)}}var Hj=Gj;var Jj=class{constructor(){this.cache=new Map;}get(e,t,n){const r=`"${e}".${t}${(n=n||[]).length?`.${n.join(".")}`:""}`;let i=this.cache.get(r);return i||(i=new Gj(e,t,n),this.cache.set(r,i)),i}},Xj=Object.defineProperty({StaticSymbol:Hj,StaticSymbolCache:Jj},"__esModule",{value:!0});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const Yj=/-+([a-z0-9])/g;var Kj=function(e){return e.replace(Yj,((...e)=>e[1].toUpperCase()))};var Qj=function(e,t){return eL(e,":",t)};var Zj=function(e,t){return eL(e,".",t)};function eL(e,t,n){const r=e.indexOf(t);return -1==r?n:[e.slice(0,r).trim(),e.slice(r+1).trim()]}function tL(e,t,n){return Array.isArray(e)?t.visitArray(e,n):function(e){return "object"==typeof e&&null!==e&&Object.getPrototypeOf(e)===hL}(e)?t.visitStringMap(e,n):null==e||"string"==typeof e||"number"==typeof e||"boolean"==typeof e?t.visitPrimitive(e,n):t.visitOther(e,n)}var nL=tL;var rL=function(e){return null!=e};var iL=function(e){return void 0===e?null:e};var uL=class{visitArray(e,t){return e.map((e=>tL(e,this,t)))}visitStringMap(e,t){const n={};return Object.keys(e).forEach((r=>{n[r]=tL(e[r],this,t);})),n}visitPrimitive(e,t){return e}visitOther(e,t){return e}},oL={assertSync:e=>{if(DL(e))throw new Error("Illegal state: value cannot be a promise");return e},then:(e,t)=>DL(e)?e.then(t):t(e),all:e=>e.some(DL)?Promise.all(e):e};var sL=function(e){throw new Error(`Internal Error: ${e}`)};var aL=function(e,t){const n=Error(e);return n[lL]=!0,t&&(n[cL]=t),n};const lL="ngSyntaxError",cL="ngParseErrors";var pL=function(e){return e[lL]};var fL=function(e){return e[cL]||[]};var dL=function(e){return e.replace(/([.*+?^=!:${}()|[\]\/\\])/g,"\\$1")};const hL=Object.getPrototypeOf({});var gL=function(e){let t="";for(let n=0;n<e.length;n++){let r=e.charCodeAt(n);if(r>=55296&&r<=56319&&e.length>n+1){const t=e.charCodeAt(n+1);t>=56320&&t<=57343&&(n++,r=(r-55296<<10)+t-56320+65536);}r<=127?t+=String.fromCharCode(r):r<=2047?t+=String.fromCharCode(r>>6&31|192,63&r|128):r<=65535?t+=String.fromCharCode(r>>12|224,r>>6&63|128,63&r|128):r<=2097151&&(t+=String.fromCharCode(r>>18&7|240,r>>12&63|128,r>>6&63|128,63&r|128));}return t};var mL=function e(t){if("string"==typeof t)return t;if(t instanceof Array)return "["+t.map(e).join(", ")+"]";if(null==t)return ""+t;if(t.overriddenName)return `${t.overriddenName}`;if(t.name)return `${t.name}`;if(!t.toString)return "object";const n=t.toString();if(null==n)return ""+n;const r=n.indexOf("\n");return -1===r?n:n.substring(0,r)};var yL=function(e){return "function"==typeof e&&e.hasOwnProperty("__forward_ref__")?e():e};function DL(e){return !!e&&"function"==typeof e.then}var EL=DL;var bL=class{constructor(e){this.full=e;const t=e.split(".");this.major=t[0],this.minor=t[1],this.patch=t.slice(2).join(".");}};const CL="undefined"!=typeof window&&window,vL="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self;var AL=void 0!==n$2&&n$2||CL||vL,FL=Object.defineProperty({dashCaseToCamelCase:Kj,splitAtColon:Qj,splitAtPeriod:Zj,visitValue:nL,isDefined:rL,noUndefined:iL,ValueTransformer:uL,SyncAsync:oL,error:sL,syntaxError:aL,isSyntaxError:pL,getParseErrors:fL,escapeRegExp:dL,utf8Encode:gL,stringify:mL,resolveForwardRef:yL,isPromise:EL,Version:bL,global:AL},"__esModule",{value:!0}),xL=i$2((function(e,t){
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
Object.defineProperty(t,"__esModule",{value:!0});const n=/^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;function r(e){return e.replace(/\W/g,"_")}t.sanitizeIdentifier=r;let i=0;function u(e){if(!e||!e.reference)return null;const t=e.reference;if(t instanceof Xj.StaticSymbol)return t.name;if(t.__anonymousType)return t.__anonymousType;let n=FL.stringify(t);return n.indexOf("(")>=0?(n="anonymous_"+i++,t.__anonymousType=n):n=r(n),n}var o;t.identifierName=u,t.identifierModuleUrl=function(e){const t=e.reference;return t instanceof Xj.StaticSymbol?t.filePath:`./${FL.stringify(t)}`},t.viewClassName=function(e,t){return `View_${u({reference:e})}_${t}`},t.rendererTypeName=function(e){return `RenderType_${u({reference:e})}`},t.hostViewClassName=function(e){return `HostView_${u({reference:e})}`},t.componentFactoryName=function(e){return `${u({reference:e})}NgFactory`},function(e){e[e.Pipe=0]="Pipe",e[e.Directive=1]="Directive",e[e.NgModule=2]="NgModule",e[e.Injectable=3]="Injectable";}(o=t.CompileSummaryKind||(t.CompileSummaryKind={})),t.tokenName=function(e){return null!=e.value?r(e.value):u(e.identifier)},t.tokenReference=function(e){return null!=e.identifier?e.identifier.reference:e.value};t.CompileStylesheetMetadata=class{constructor({moduleUrl:e,styles:t,styleUrls:n}={}){this.moduleUrl=e||null,this.styles=a(t),this.styleUrls=a(n);}};t.CompileTemplateMetadata=class{constructor({encapsulation:e,template:t,templateUrl:n,htmlAst:r,styles:i,styleUrls:u,externalStylesheets:o,animations:s,ngContentSelectors:c,interpolation:p,isInline:f,preserveWhitespaces:d}){if(this.encapsulation=e,this.template=t,this.templateUrl=n,this.htmlAst=r,this.styles=a(i),this.styleUrls=a(u),this.externalStylesheets=a(o),this.animations=s?l(s):[],this.ngContentSelectors=c||[],p&&2!=p.length)throw new Error("'interpolation' should have a start and an end symbol.");this.interpolation=p,this.isInline=f,this.preserveWhitespaces=d;}toSummary(){return {ngContentSelectors:this.ngContentSelectors,encapsulation:this.encapsulation,styles:this.styles,animations:this.animations}}};class s{static create({isHost:e,type:t,isComponent:r,selector:i,exportAs:u,changeDetection:o,inputs:a,outputs:l,host:c,providers:p,viewProviders:f,queries:d,guards:h,viewQueries:g,entryComponents:m,template:y,componentViewType:D,rendererType:E,componentFactory:b}){const C={},v={},A={};null!=c&&Object.keys(c).forEach((e=>{const t=c[e],r=e.match(n);null===r?A[e]=t:null!=r[1]?v[r[1]]=t:null!=r[2]&&(C[r[2]]=t);}));const F={};null!=a&&a.forEach((e=>{const t=FL.splitAtColon(e,[e,e]);F[t[0]]=t[1];}));const x={};return null!=l&&l.forEach((e=>{const t=FL.splitAtColon(e,[e,e]);x[t[0]]=t[1];})),new s({isHost:e,type:t,isComponent:!!r,selector:i,exportAs:u,changeDetection:o,inputs:F,outputs:x,hostListeners:C,hostProperties:v,hostAttributes:A,providers:p,viewProviders:f,queries:d,guards:h,viewQueries:g,entryComponents:m,template:y,componentViewType:D,rendererType:E,componentFactory:b})}constructor({isHost:e,type:t,isComponent:n,selector:r,exportAs:i,changeDetection:u,inputs:o,outputs:s,hostListeners:l,hostProperties:c,hostAttributes:p,providers:f,viewProviders:d,queries:h,guards:g,viewQueries:m,entryComponents:y,template:D,componentViewType:E,rendererType:b,componentFactory:C}){this.isHost=!!e,this.type=t,this.isComponent=n,this.selector=r,this.exportAs=i,this.changeDetection=u,this.inputs=o,this.outputs=s,this.hostListeners=l,this.hostProperties=c,this.hostAttributes=p,this.providers=a(f),this.viewProviders=a(d),this.queries=a(h),this.guards=g,this.viewQueries=a(m),this.entryComponents=a(y),this.template=D,this.componentViewType=E,this.rendererType=b,this.componentFactory=C;}toSummary(){return {summaryKind:o.Directive,type:this.type,isComponent:this.isComponent,selector:this.selector,exportAs:this.exportAs,inputs:this.inputs,outputs:this.outputs,hostListeners:this.hostListeners,hostProperties:this.hostProperties,hostAttributes:this.hostAttributes,providers:this.providers,viewProviders:this.viewProviders,queries:this.queries,guards:this.guards,viewQueries:this.viewQueries,entryComponents:this.entryComponents,changeDetection:this.changeDetection,template:this.template&&this.template.toSummary(),componentViewType:this.componentViewType,rendererType:this.rendererType,componentFactory:this.componentFactory}}}t.CompileDirectiveMetadata=s;t.CompilePipeMetadata=class{constructor({type:e,name:t,pure:n}){this.type=e,this.name=t,this.pure=!!n;}toSummary(){return {summaryKind:o.Pipe,type:this.type,name:this.name,pure:this.pure}}};t.CompileShallowModuleMetadata=class{};t.CompileNgModuleMetadata=class{constructor({type:e,providers:t,declaredDirectives:n,exportedDirectives:r,declaredPipes:i,exportedPipes:u,entryComponents:o,bootstrapComponents:s,importedModules:l,exportedModules:c,schemas:p,transitiveModule:f,id:d}){this.type=e||null,this.declaredDirectives=a(n),this.exportedDirectives=a(r),this.declaredPipes=a(i),this.exportedPipes=a(u),this.providers=a(t),this.entryComponents=a(o),this.bootstrapComponents=a(s),this.importedModules=a(l),this.exportedModules=a(c),this.schemas=a(p),this.id=d||null,this.transitiveModule=f||null;}toSummary(){const e=this.transitiveModule;return {summaryKind:o.NgModule,type:this.type,entryComponents:e.entryComponents,providers:e.providers,modules:e.modules,exportedDirectives:e.exportedDirectives,exportedPipes:e.exportedPipes}}};function a(e){return e||[]}t.TransitiveCompileNgModuleMetadata=class{constructor(){this.directivesSet=new Set,this.directives=[],this.exportedDirectivesSet=new Set,this.exportedDirectives=[],this.pipesSet=new Set,this.pipes=[],this.exportedPipesSet=new Set,this.exportedPipes=[],this.modulesSet=new Set,this.modules=[],this.entryComponentsSet=new Set,this.entryComponents=[],this.providers=[];}addProvider(e,t){this.providers.push({provider:e,module:t});}addDirective(e){this.directivesSet.has(e.reference)||(this.directivesSet.add(e.reference),this.directives.push(e));}addExportedDirective(e){this.exportedDirectivesSet.has(e.reference)||(this.exportedDirectivesSet.add(e.reference),this.exportedDirectives.push(e));}addPipe(e){this.pipesSet.has(e.reference)||(this.pipesSet.add(e.reference),this.pipes.push(e));}addExportedPipe(e){this.exportedPipesSet.has(e.reference)||(this.exportedPipesSet.add(e.reference),this.exportedPipes.push(e));}addModule(e){this.modulesSet.has(e.reference)||(this.modulesSet.add(e.reference),this.modules.push(e));}addEntryComponent(e){this.entryComponentsSet.has(e.componentType)||(this.entryComponentsSet.add(e.componentType),this.entryComponents.push(e));}};function l(e){return e.reduce(((e,t)=>{const n=Array.isArray(t)?l(t):t;return e.concat(n)}),[])}function c(e){return e.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/,"ng:///")}t.ProviderMeta=class{constructor(e,{useClass:t,useValue:n,useExisting:r,useFactory:i,deps:u,multi:o}){this.token=e,this.useClass=t||null,this.useValue=n,this.useExisting=r,this.useFactory=i||null,this.dependencies=u||null,this.multi=!!o;}},t.flatten=l,t.templateSourceUrl=function(e,t,n){let r;return r=n.isInline?t.type.reference instanceof Xj.StaticSymbol?`${t.type.reference.filePath}.${t.type.reference.name}.html`:`${u(e)}/${u(t.type)}.html`:n.templateUrl,t.type.reference instanceof Xj.StaticSymbol?r:c(r)},t.sharedStylesheetJitUrl=function(e,t){const n=e.moduleUrl.split(/\/\\/g);return c(`css/${t}${n[n.length-1]}.ngstyle.js`)},t.ngModuleJitUrl=function(e){return c(`${u(e.type)}/module.ngfactory.js`)},t.templateJitUrl=function(e,t){return c(`${u(e)}/${u(t.type)}.ngfactory.js`)};})),SL=i$2((function(e,t){Object.defineProperty(t,"__esModule",{value:!0});
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
class n{constructor(e,t,n,r){this.file=e,this.offset=t,this.line=n,this.col=r;}toString(){return null!=this.offset?`${this.file.url}@${this.line}:${this.col}`:this.file.url}moveBy(e){const t=this.file.content,r=t.length;let i=this.offset,u=this.line,o=this.col;for(;i>0&&e<0;){i--,e++;if(t.charCodeAt(i)==zj.$LF){u--;const e=t.substr(0,i-1).lastIndexOf(String.fromCharCode(zj.$LF));o=e>0?i-e:i;}else o--;}for(;i<r&&e>0;){const n=t.charCodeAt(i);i++,e--,n==zj.$LF?(u++,o=0):o++;}return new n(this.file,i,u,o)}getContext(e,t){const n=this.file.content;let r=this.offset;if(null!=r){r>n.length-1&&(r=n.length-1);let i=r,u=0,o=0;for(;u<e&&r>0&&(r--,u++,"\n"!=n[r]||++o!=t););for(u=0,o=0;u<e&&i<n.length-1&&(i++,u++,"\n"!=n[i]||++o!=t););return {before:n.substring(r,this.offset),after:n.substring(this.offset,i+1)}}return null}}t.ParseLocation=n;class r{constructor(e,t){this.content=e,this.url=t;}}t.ParseSourceFile=r;class i{constructor(e,t,n=null){this.start=e,this.end=t,this.details=n;}toString(){return this.start.file.content.substring(this.start.offset,this.end.offset)}}var u;t.ParseSourceSpan=i,t.EMPTY_PARSE_LOCATION=new n(new r("",""),0,0,0),t.EMPTY_SOURCE_SPAN=new i(t.EMPTY_PARSE_LOCATION,t.EMPTY_PARSE_LOCATION),function(e){e[e.WARNING=0]="WARNING",e[e.ERROR=1]="ERROR";}(u=t.ParseErrorLevel||(t.ParseErrorLevel={}));t.ParseError=class{constructor(e,t,n=u.ERROR){this.span=e,this.msg=t,this.level=n;}contextualMessage(){const e=this.span.start.getContext(100,3);return e?`${this.msg} ("${e.before}[${u[this.level]} ->]${e.after}")`:this.msg}toString(){const e=this.span.details?`, ${this.span.details}`:"";return `${this.contextualMessage()}: ${this.span.start}${e}`}},t.typeSourceSpan=function(e,t){const u=xL.identifierModuleUrl(t),o=null!=u?`in ${e} ${xL.identifierName(t)} in ${u}`:`in ${e} ${xL.identifierName(t)}`,s=new r("",o);return new i(new n(s,-1,-1,-1),new n(s,-1,-1,-1))},t.r3JitTypeSourceSpan=function(e,t,u){const o=new r("",`in ${e} ${t} in ${u}`);return new i(new n(o,-1,-1,-1),new n(o,-1,-1,-1))};}));const{ParseSourceSpan:wL}=SL,{htmlTrim:TL,getLeadingAndTrailingHtmlWhitespace:BL,hasHtmlWhitespace:kL,canHaveInterpolation:NL,getNodeCssStyleDisplay:PL,isDanglingSpaceSensitiveNode:OL,isIndentationSensitiveNode:IL,isLeadingSpaceSensitiveNode:jL,isTrailingSpaceSensitiveNode:LL,isWhitespaceSensitiveNode:_L}=Uj,ML=[function(e){return e.map((e=>{if("element"===e.type&&e.tagDefinition.ignoreFirstLf&&e.children.length>0&&"text"===e.children[0].type&&"\n"===e.children[0].value[0]){const[t,...n]=e.children;return e.clone({children:1===t.value.length?n:[t.clone({value:t.value.slice(1)}),...n]})}return e}))},function(e){const t=e=>"element"===e.type&&e.prev&&"ieConditionalStartComment"===e.prev.type&&e.prev.sourceSpan.end.offset===e.startSourceSpan.start.offset&&e.firstChild&&"ieConditionalEndComment"===e.firstChild.type&&e.firstChild.sourceSpan.start.offset===e.startSourceSpan.end.offset;return e.map((e=>{if(e.children){const n=e.children.map(t);if(n.some(Boolean)){const t=[];for(let r=0;r<e.children.length;r++){const i=e.children[r];if(!n[r+1])if(n[r]){const e=i.prev,n=i.firstChild,r=new wL(e.sourceSpan.start,n.sourceSpan.end),u=new wL(r.start,i.sourceSpan.end);t.push(i.clone({condition:e.condition,sourceSpan:u,startSourceSpan:r,children:i.children.slice(1)}));}else t.push(i);}return e.clone({children:t})}}return e}))},function(e){return function(e,t,n){return e.map((e=>{if(e.children){const r=e.children.map(t);if(r.some(Boolean)){const t=[];for(let i=0;i<e.children.length;i++){const u=e.children[i];if("text"!==u.type&&!r[i]){t.push(u);continue}const o="text"===u.type?u:u.clone({type:"text",value:n(u)});if(0===t.length||"text"!==Sn$1(t).type){t.push(o);continue}const s=t.pop();t.push(s.clone({value:s.value+o.value,sourceSpan:new wL(s.sourceSpan.start,o.sourceSpan.end)}));}return e.clone({children:t})}}return e}))}(e,(e=>"cdata"===e.type),(e=>`<![CDATA[${e.value}]]>`))},function(e,t){if("html"===t.parser)return e;const n=/{{(.+?)}}/gs;return e.map((e=>{if(!NL(e))return e;const t=[];for(const r of e.children){if("text"!==r.type){t.push(r);continue}let e=r.sourceSpan.start,i=null;const u=r.value.split(n);for(let n=0;n<u.length;n++,e=i){const r=u[n];n%2!=0?(i=e.moveBy(r.length+4),t.push({type:"interpolation",sourceSpan:new wL(e,i),children:0===r.length?[]:[{type:"text",value:r,sourceSpan:new wL(e.moveBy(2),i.moveBy(-2))}]})):(i=e.moveBy(r.length),r.length>0&&t.push({type:"text",value:r,sourceSpan:new wL(e,i)}));}}return e.clone({children:t})}))},function(e){return e.map((e=>{if(!e.children)return e;if(0===e.children.length||1===e.children.length&&"text"===e.children[0].type&&0===TL(e.children[0].value).length)return e.clone({children:[],hasDanglingSpaces:e.children.length>0});const t=_L(e),n=IL(e);return e.clone({isWhitespaceSensitive:t,isIndentationSensitive:n,children:e.children.flatMap((e=>{if("text"!==e.type||t)return e;const n=[],{leadingWhitespace:r,text:i,trailingWhitespace:u}=BL(e.value);return r&&n.push(RL),i&&n.push({type:"text",value:i,sourceSpan:new wL(e.sourceSpan.start.moveBy(r.length),e.sourceSpan.end.moveBy(-u.length))}),u&&n.push(RL),n})).map(((e,t,n)=>{if(e!==RL)return Object.assign(Object.assign({},e),{},{hasLeadingSpaces:n[t-1]===RL,hasTrailingSpaces:n[t+1]===RL})})).filter(Boolean)})}))},function(e,t){return e.map((e=>Object.assign(e,{cssDisplay:PL(e,t)})))},function(e){return e.map((e=>Object.assign(e,{isSelfClosing:!e.children||"element"===e.type&&(e.tagDefinition.isVoid||e.startSourceSpan===e.endSourceSpan)})))},function(e,t){return e.map((e=>"element"!==e.type?e:Object.assign(e,{hasHtmComponentClosingTag:e.endSourceSpan&&/^<\s*\/\s*\/\s*>$/.test(t.originalText.slice(e.endSourceSpan.start.offset,e.endSourceSpan.end.offset))})))},function(e,t){return e.map((e=>e.children?0===e.children.length?e.clone({isDanglingSpaceSensitive:OL(e)}):e.clone({children:e.children.map((e=>Object.assign(Object.assign({},e),{},{isLeadingSpaceSensitive:jL(e,t),isTrailingSpaceSensitive:LL(e,t)}))).map(((e,t,n)=>Object.assign(Object.assign({},e),{},{isLeadingSpaceSensitive:(0===t||n[t-1].isTrailingSpaceSensitive)&&e.isLeadingSpaceSensitive,isTrailingSpaceSensitive:(t===n.length-1||n[t+1].isLeadingSpaceSensitive)&&e.isTrailingSpaceSensitive})))}):e))},function(e){const t=e=>"element"===e.type&&0===e.attrs.length&&1===e.children.length&&"text"===e.firstChild.type&&!kL(e.children[0].value)&&!e.firstChild.hasLeadingSpaces&&!e.firstChild.hasTrailingSpaces&&e.isLeadingSpaceSensitive&&!e.hasLeadingSpaces&&e.isTrailingSpaceSensitive&&!e.hasTrailingSpaces&&e.prev&&"text"===e.prev.type&&e.next&&"text"===e.next.type;return e.map((e=>{if(e.children){const n=e.children.map(t);if(n.some(Boolean)){const t=[];for(let r=0;r<e.children.length;r++){const i=e.children[r];if(n[r]){const n=t.pop(),u=e.children[++r],{isTrailingSpaceSensitive:o,hasTrailingSpaces:s}=u;t.push(n.clone({value:n.value+`<${i.rawName}>`+i.firstChild.value+`</${i.rawName}>`+u.value,sourceSpan:new wL(n.sourceSpan.start,u.sourceSpan.end),isTrailingSpaceSensitive:o,hasTrailingSpaces:s}));}else t.push(i);}return e.clone({children:t})}}return e}))}];const RL={type:"whitespace"};var $L=function(e,t){for(const n of ML)e=n(e,t);return e};var VL={hasPragma:function(e){return /^\s*<!--\s*@(format|prettier)\s*-->/.test(e)},insertPragma:function(e){return "\x3c!-- @format --\x3e\n\n"+e.replace(/^\s*\n/,"")}};var qL={locStart:function(e){return e.sourceSpan.start.offset},locEnd:function(e){return e.sourceSpan.end.offset}};const{builders:{group:WL}}=Ji$1;var UL={isVueEventBindingExpression:function(e){const t=e.trim();return /^([\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t)||/^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t)},printVueFor:function(e,t){const{left:n,operator:r,right:i}=function(e){const t=/(.*?)\s+(in|of)\s+(.*)/s,n=/,([^,\]}]*)(?:,([^,\]}]*))?$/,r=/^\(|\)$/g,i=e.match(t);if(!i)return;const u={};u.for=i[3].trim();const o=i[1].trim().replace(r,""),s=o.match(n);s?(u.alias=o.replace(n,""),u.iterator1=s[1].trim(),s[2]&&(u.iterator2=s[2].trim())):u.alias=o;return {left:`${[u.alias,u.iterator1,u.iterator2].filter(Boolean).join(",")}`,operator:i[2],right:u.for}}(e);return [WL(t(`function _(${n}) {}`,{parser:"babel",__isVueForBindingLeft:!0}))," ",r," ",t(i,{parser:"__js_expression"},{stripTrailingHardline:!0})]},printVueBindings:function(e,t){return t(`function _(${e}) {}`,{parser:"babel",__isVueBindings:!0})}},zL=i$2((function(e){var t,r;t=n$2,r=function(){return function(e,t){var n=t&&t.logger||console;function r(e){return " "===e||"\t"===e||"\n"===e||"\f"===e||"\r"===e}function i(t){var n,r=t.exec(e.substring(y));if(r)return n=r[0],y+=n.length,n}for(var u,o,s,a,l,c=e.length,p=/^[ \t\n\r\u000c]+/,f=/^[, \t\n\r\u000c]+/,d=/^[^ \t\n\r\u000c]+/,h=/[,]+$/,g=/^\d+$/,m=/^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,y=0,D=[];;){if(i(f),y>=c)return D;u=i(d),o=[],","===u.slice(-1)?(u=u.replace(h,""),b()):E();}function E(){for(i(p),s="",a="in descriptor";;){if(l=e.charAt(y),"in descriptor"===a)if(r(l))s&&(o.push(s),s="",a="after descriptor");else {if(","===l)return y+=1,s&&o.push(s),void b();if("("===l)s+=l,a="in parens";else {if(""===l)return s&&o.push(s),void b();s+=l;}}else if("in parens"===a)if(")"===l)s+=l,a="in descriptor";else {if(""===l)return o.push(s),void b();s+=l;}else if("after descriptor"===a)if(r(l));else {if(""===l)return void b();a="in descriptor",y-=1;}y+=1;}}function b(){var t,r,i,s,a,l,c,p,f,d=!1,h={};for(s=0;s<o.length;s++)l=(a=o[s])[a.length-1],c=a.substring(0,a.length-1),p=parseInt(c,10),f=parseFloat(c),g.test(c)&&"w"===l?((t||r)&&(d=!0),0===p?d=!0:t=p):m.test(c)&&"x"===l?((t||r||i)&&(d=!0),f<0?d=!0:r=f):g.test(c)&&"h"===l?((i||r)&&(d=!0),0===p?d=!0:i=p):d=!0;d?n&&n.error&&n.error("Invalid srcset descriptor found in '"+e+"' at '"+a+"'."):(h.url=u,t&&(h.w=t),r&&(h.d=r),i&&(h.h=i),D.push(h));}}},e.exports?e.exports=r():t.parseSrcset=r();}));const{builders:{group:GL,ifBreak:HL,indent:JL,join:XL,line:YL,softline:KL}}=Ji$1;const QL=[":","__","--","_","-"];function ZL(e){const t=e.search(/[^_-]/);if(-1!==t)for(const n of QL){const r=e.indexOf(n,t);if(-1!==r)return e.slice(0,r)}return e}var e_={printImgSrcset:function(e){const t=zL(e,{logger:{error(e){throw new Error(e)}}}),n=t.some((({w:e})=>e)),r=t.some((({h:e})=>e));if(n+r+t.some((({d:e})=>e))>1)throw new Error("Mixed descriptor in srcset is not supported");const i=n?"w":r?"h":"d",u=n?"w":r?"h":"x",o=e=>Math.max(...e),s=t.map((e=>e.url)),a=o(s.map((e=>e.length))),l=t.map((e=>e[i])).map((e=>e?e.toString():"")),c=l.map((e=>{const t=e.indexOf(".");return -1===t?e.length:t})),p=o(c);return XL([",",YL],s.map(((e,t)=>{const n=[e],r=l[t];if(r){const i=a-e.length+1,o=p-c[t],s=" ".repeat(i+o);n.push(HL(s," "),r+u);}return n})))},printClassNames:function(e){const t=e.trim().split(/\s+/),n=[];let r;for(let e=0;e<t.length;e++){const i=ZL(t[e]);i!==r&&i!==t[e-1]&&n.push([]),Sn$1(n).push(t[e]),r=i;}return [JL([KL,XL(YL,n.map((e=>GL(XL(YL,e)))))]),KL]}};const{builders:{breakParent:t_,dedentToRoot:n_,fill:r_,group:i_,hardline:u_,ifBreak:o_,indentIfBreak:s_,indent:a_,join:l_,line:c_,literalline:p_,softline:f_},utils:{mapDoc:d_,cleanDoc:h_,getDocParts:g_,isConcat:m_,replaceEndOfLineWith:y_}}=Ji$1,{isNonEmptyArray:D_}=fi$1,{htmlTrimPreserveIndentation:E_,splitByHtmlWhitespace:b_,countChars:C_,countParents:v_,dedentString:A_,forceBreakChildren:F_,forceBreakContent:x_,forceNextEmptyLine:S_,getLastDescendant:w_,getPrettierIgnoreAttributeCommentData:T_,hasPrettierIgnore:B_,inferScriptParser:k_,isVueCustomBlock:N_,isVueNonHtmlBlock:P_,isVueSlotAttribute:O_,isVueSfcBindingsAttribute:I_,isScriptLikeTag:j_,isTextLikeNode:L_,preferHardlineAsLeadingSpaces:__,shouldNotPrintClosingTag:M_,shouldPreserveContent:R_,unescapeQuoteEntities:$_,isPreLikeNode:V_}=Uj,{insertPragma:q_}=VL,{locStart:W_,locEnd:U_}=qL,{printVueFor:z_,printVueBindings:G_,isVueEventBindingExpression:H_}=UL,{printImgSrcset:J_,printClassNames:X_}=e_;function Y_(e,t,n){const r=e.getValue();if(F_(r))return [t_,...e.map((e=>{const t=e.getValue(),n=t.prev?o(t.prev,t):"";return [n?[n,S_(t.prev)?u_:""]:"",u(e)]}),"children")];const i=r.children.map((()=>Symbol("")));return e.map(((e,t)=>{const n=e.getValue();if(L_(n)){if(n.prev&&L_(n.prev)){const t=o(n.prev,n);if(t)return S_(n.prev)?[u_,u_,u(e)]:[t,u(e)]}return u(e)}const r=[],s=[],a=[],l=[],c=n.prev?o(n.prev,n):"",p=n.next?o(n,n.next):"";return c&&(S_(n.prev)?r.push(u_,u_):c===u_?r.push(u_):L_(n.prev)?s.push(c):s.push(o_("",f_,{groupId:i[t-1]}))),p&&(S_(n)?L_(n.next)&&l.push(u_,u_):p===u_?L_(n.next)&&l.push(u_):a.push(p)),[...r,i_([...s,i_([u(e),...a],{id:i[t]})]),...l]}),"children");function u(e){const r=e.getValue();return B_(r)?[cM(r,t),...y_(t.originalText.slice(W_(r)+(r.prev&&uM(r.prev)?dM(r).length:0),U_(r)-(r.next&&sM(r.next)?mM(r,t).length:0)),p_),fM(r,t)]:n()}function o(e,t){return L_(e)&&L_(t)?e.isTrailingSpaceSensitive?e.hasTrailingSpaces?__(t)?u_:c_:"":__(t)?u_:f_:uM(e)&&(B_(t)||t.firstChild||t.isSelfClosing||"element"===t.type&&t.attrs.length>0)||"element"===e.type&&e.isSelfClosing&&sM(t)?"":!t.isLeadingSpaceSensitive||__(t)||sM(t)&&e.lastChild&&lM(e.lastChild)&&e.lastChild.lastChild&&lM(e.lastChild.lastChild)?u_:t.hasLeadingSpaces?c_:f_}}function K_(e,t){let n=e.startSourceSpan.end.offset;e.firstChild&&oM(e.firstChild)&&(n-=hM(e).length);let r=e.endSourceSpan.start.offset;return e.lastChild&&lM(e.lastChild)?r+=gM(e,t).length:aM(e)&&(r-=mM(e.lastChild,t).length),t.originalText.slice(n,r)}function Q_(e,t,n){const r=e.getValue();if(!D_(r.attrs))return r.isSelfClosing?" ":"";const i=r.prev&&"comment"===r.prev.type&&T_(r.prev.value),u="boolean"==typeof i?()=>i:Array.isArray(i)?e=>i.includes(e.rawName):()=>!1,o=e.map((e=>{const r=e.getValue();return u(r)?y_(t.originalText.slice(W_(r),U_(r)),p_):n()}),"attrs"),s="element"===r.type&&"script"===r.fullName&&1===r.attrs.length&&"src"===r.attrs[0].fullName&&0===r.children.length,a=[a_([s?" ":c_,l_(c_,o)])];return r.firstChild&&oM(r.firstChild)||r.isSelfClosing&&aM(r.parent)||s?a.push(r.isSelfClosing?" ":""):a.push(r.isSelfClosing?c_:f_),a}function Z_(e,t,n){const r=e.getValue();return [eM(r,t),Q_(e,t,n),r.isSelfClosing?"":tM(r)]}function eM(e,t){return e.prev&&uM(e.prev)?"":[cM(e,t),dM(e)]}function tM(e){return e.firstChild&&oM(e.firstChild)?"":hM(e)}function nM(e,t){return [e.isSelfClosing?"":rM(e,t),iM(e,t)]}function rM(e,t){return e.lastChild&&lM(e.lastChild)?"":[pM(e,t),gM(e,t)]}function iM(e,t){return (e.next?sM(e.next):aM(e.parent))?"":[mM(e,t),fM(e,t)]}function uM(e){return e.next&&!L_(e.next)&&L_(e)&&e.isTrailingSpaceSensitive&&!e.hasTrailingSpaces}function oM(e){return !e.prev&&e.isLeadingSpaceSensitive&&!e.hasLeadingSpaces}function sM(e){return e.prev&&"docType"!==e.prev.type&&!L_(e.prev)&&e.isLeadingSpaceSensitive&&!e.hasLeadingSpaces}function aM(e){return e.lastChild&&e.lastChild.isTrailingSpaceSensitive&&!e.lastChild.hasTrailingSpaces&&!L_(w_(e.lastChild))&&!V_(e)}function lM(e){return !e.next&&!e.hasTrailingSpaces&&e.isTrailingSpaceSensitive&&L_(w_(e))}function cM(e,t){return oM(e)?hM(e.parent):sM(e)?mM(e.prev,t):""}function pM(e,t){return aM(e)?mM(e.lastChild,t):""}function fM(e,t){return lM(e)?gM(e.parent,t):uM(e)?dM(e.next):""}function dM(e){switch(e.type){case"ieConditionalComment":case"ieConditionalStartComment":return `\x3c!--[if ${e.condition}`;case"ieConditionalEndComment":return "\x3c!--<!";case"interpolation":return "{{";case"docType":return "<!DOCTYPE";case"element":if(e.condition)return `\x3c!--[if ${e.condition}]>\x3c!--\x3e<${e.rawName}`;default:return `<${e.rawName}`}}function hM(e){switch(yf(!e.isSelfClosing),e.type){case"ieConditionalComment":return "]>";case"element":if(e.condition)return ">\x3c!--<![endif]--\x3e";default:return ">"}}function gM(e,t){if(yf(!e.isSelfClosing),M_(e,t))return "";switch(e.type){case"ieConditionalComment":return "<!";case"element":if(e.hasHtmComponentClosingTag)return "<//";default:return `</${e.rawName}`}}function mM(e,t){if(M_(e,t))return "";switch(e.type){case"ieConditionalComment":case"ieConditionalEndComment":return "[endif]--\x3e";case"ieConditionalStartComment":return "]>\x3c!--\x3e";case"interpolation":return "}}";case"element":if(e.isSelfClosing)return "/>";default:return ">"}}function yM(e,t=e.value){return e.parent.isWhitespaceSensitive?e.parent.isIndentationSensitive?y_(t,p_):y_(A_(E_(t)),u_):g_(l_(c_,b_(t)))}var DM={preprocess:$L,print:function(e,t,n){const r=e.getValue();switch(r.type){case"front-matter":return y_(r.raw,p_);case"root":return t.__onHtmlRoot&&t.__onHtmlRoot(r),[i_(Y_(e,t,n)),u_];case"element":case"ieConditionalComment":{if(R_(r,t))return [cM(r,t),i_(Z_(e,t,n)),...y_(K_(r,t),p_),...nM(r,t),fM(r,t)];const u=1===r.children.length&&"interpolation"===r.firstChild.type&&r.firstChild.isLeadingSpaceSensitive&&!r.firstChild.hasLeadingSpaces&&r.lastChild.isTrailingSpaceSensitive&&!r.lastChild.hasTrailingSpaces,o=Symbol("element-attr-group-id");return [i_([i_(Z_(e,t,n),{id:o}),0===r.children.length?r.hasDanglingSpaces&&r.isDanglingSpaceSensitive?c_:"":[x_(r)?t_:"",(i=[u?o_(f_,"",{groupId:o}):r.firstChild.hasLeadingSpaces&&r.firstChild.isLeadingSpaceSensitive?c_:"text"===r.firstChild.type&&r.isWhitespaceSensitive&&r.isIndentationSensitive?n_(f_):f_,Y_(e,t,n)],u?s_(i,{groupId:o}):!j_(r)&&!N_(r,t)||"root"!==r.parent.type||"vue"!==t.parser||t.vueIndentScriptAndStyle?a_(i):i),(r.next?sM(r.next):aM(r.parent))?r.lastChild.hasTrailingSpaces&&r.lastChild.isTrailingSpaceSensitive?" ":"":u?o_(f_,"",{groupId:o}):r.lastChild.hasTrailingSpaces&&r.lastChild.isTrailingSpaceSensitive?c_:("comment"===r.lastChild.type||"text"===r.lastChild.type&&r.isWhitespaceSensitive&&r.isIndentationSensitive)&&new RegExp(`\\n[\\t ]{${t.tabWidth*v_(e,(e=>e.parent&&"root"!==e.parent.type))}}$`).test(r.lastChild.value)?"":f_]]),nM(r,t)]}case"ieConditionalStartComment":case"ieConditionalEndComment":return [eM(r),iM(r)];case"interpolation":return [eM(r,t),...e.map(n,"children"),iM(r,t)];case"text":{if("interpolation"===r.parent.type){const e=/\n[^\S\n]*?$/,t=e.test(r.value),n=t?r.value.replace(e,""):r.value;return [...y_(n,p_),t?u_:""]}const e=h_([cM(r,t),...yM(r),fM(r,t)]);return m_(e)||"fill"===e.type?r_(g_(e)):e}case"docType":return [i_([eM(r,t)," ",r.value.replace(/^html\b/i,"html").replace(/\s+/g," ")]),iM(r,t)];case"comment":return [cM(r,t),...y_(t.originalText.slice(W_(r),U_(r)),p_),fM(r,t)];case"attribute":{if(null===r.value)return r.rawName;const e=$_(r.value),t=C_(e,"'")<C_(e,'"')?"'":'"';return [r.rawName,"=",t,...y_('"'===t?e.replace(/"/g,"&quot;"):e.replace(/'/g,"&apos;"),p_),t]}default:throw new Error(`Unexpected node type ${r.type}`)}var i;},insertPragma:q_,massageAstNode:pj,embed:function(e,t,n,r){const i=e.getValue();switch(i.type){case"element":if(j_(i)||"interpolation"===i.type)return;if(!i.isSelfClosing&&P_(i,r)){const u=k_(i,r);if(!u)return;const o=K_(i,r);let s=/^\s*$/.test(o),a="";return s||(a=n(E_(o),{parser:u,__embeddedInHtml:!0},{stripTrailingHardline:!0}),s=""===a),[cM(i,r),i_(Z_(e,r,t)),s?"":u_,a,s?"":u_,nM(i,r),fM(i,r)]}break;case"text":if(j_(i.parent)){const e=k_(i.parent);if(e){const t="markdown"===e?A_(i.value.replace(/^[^\S\n]*?\n/,"")):i.value,u={parser:e,__embeddedInHtml:!0};if("html"===r.parser&&"babel"===e){let e="script";const{attrMap:t}=i.parent;t&&("module"===t.type||"text/babel"===t.type&&"module"===t["data-type"])&&(e="module"),u.__babelSourceType=e;}return [t_,cM(i,r),n(t,u,{stripTrailingHardline:!0}),fM(i,r)]}}else if("interpolation"===i.parent.type){const e={__isInHtmlInterpolation:!0,__embeddedInHtml:!0};return "angular"===r.parser?(e.parser="__ng_interpolation",e.trailingComma="none"):"vue"===r.parser?e.parser="__vue_expression":e.parser="__js_expression",[a_([c_,n(i.value,e,{stripTrailingHardline:!0})]),i.parent.next&&sM(i.parent.next)?" ":c_]}break;case"attribute":{if(!i.value)break;if(/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r.originalText.slice(i.valueSpan.start.offset,i.valueSpan.end.offset)))return [i.rawName,"=",i.value];if("lwc"===r.parser){if(/^{.*}$/s.test(r.originalText.slice(i.valueSpan.start.offset,i.valueSpan.end.offset)))return [i.rawName,"=",i.value]}const e=function(e,t,n){const r=t=>new RegExp(t.join("|")).test(e.fullName),i=()=>$_(e.value);let u=!1;const o=(e,t)=>{const n="NGRoot"===e.type?"NGMicrosyntax"===e.node.type&&1===e.node.body.length&&"NGMicrosyntaxExpression"===e.node.body[0].type?e.node.body[0].expression:e.node:"JsExpressionRoot"===e.type?e.node:e;!n||"ObjectExpression"!==n.type&&"ArrayExpression"!==n.type&&("__vue_expression"!==t.parser||"TemplateLiteral"!==n.type&&"StringLiteral"!==n.type)||(u=!0);},s=e=>i_(e),a=(e,t=!0)=>i_([a_([f_,e]),t?f_:""]),l=e=>u?s(e):a(e),c=(e,n)=>t(e,Object.assign({__onHtmlBindingRoot:o,__embeddedInHtml:!0},n),{stripTrailingHardline:!0});if("srcset"===e.fullName&&("img"===e.parent.fullName||"source"===e.parent.fullName))return a(J_(i()));if("class"===e.fullName&&!n.parentParser){const e=i();if(!e.includes("{{"))return X_(e)}if("style"===e.fullName&&!n.parentParser){const e=i();if(!e.includes("{{"))return a(c(e,{parser:"css",__isHTMLStyleAttribute:!0}))}if("vue"===n.parser){if("v-for"===e.fullName)return z_(i(),c);if(O_(e)||I_(e,n))return G_(i(),c);const t=["^:","^v-bind:"],u=["^v-"];if(r(["^@","^v-on:"])){const e=i();return l(c(e,{parser:H_(e)?"__js_expression":"__vue_event_binding"}))}if(r(t))return l(c(i(),{parser:"__vue_expression"}));if(r(u))return l(c(i(),{parser:"__js_expression"}))}if("angular"===n.parser){const t=(e,t)=>c(e,Object.assign(Object.assign({},t),{},{trailingComma:"none"})),n=["^\\*"],u=["^\\[.+\\]$","^bind(on)?-","^ng-(if|show|hide|class|style)$"],o=["^i18n(-.+)?$"];if(r(["^\\(.+\\)$","^on-"]))return l(t(i(),{parser:"__ng_action"}));if(r(u))return l(t(i(),{parser:"__ng_binding"}));if(r(o)){const t=i().trim();return a(r_(yM(e,t)),!t.includes("@@"))}if(r(n))return l(t(i(),{parser:"__ng_directive"}));const s=/{{(.+?)}}/gs,p=i();if(s.test(p)){const e=[];for(const[n,r]of p.split(s).entries())if(n%2==0)e.push(y_(r,p_));else try{e.push(i_(["{{",a_([c_,t(r,{parser:"__ng_interpolation",__isInHtmlInterpolation:!0})]),c_,"}}"]));}catch{e.push("{{",y_(r,p_),"}}");}return i_(e)}}return null}(i,((e,t)=>n(e,Object.assign({__isInHtmlAttribute:!0,__embeddedInHtml:!0},t),{stripTrailingHardline:!0})),r);if(e)return [i.rawName,'="',i_(d_(e,(e=>"string"==typeof e?e.replace(/"/g,"&quot;"):e))),'"'];break}case"front-matter":return tk(i,n)}}};var EM={htmlWhitespaceSensitivity:{since:"1.15.0",category:"HTML",type:"choice",default:"css",description:"How to handle whitespaces in HTML.",choices:[{value:"css",description:"Respect the default value of CSS display property."},{value:"strict",description:"Whitespaces are considered sensitive."},{value:"ignore",description:"Whitespaces are considered insensitive."}]},vueIndentScriptAndStyle:{since:"1.19.0",category:"HTML",type:"boolean",default:!1,description:"Indent script and style tags in Vue files."}},bM={name:"HTML",type:"markup",tmScope:"text.html.basic",aceMode:"html",codemirrorMode:"htmlmixed",codemirrorMimeType:"text/html",color:"#e34c26",aliases:["xhtml"],extensions:[".html",".htm",".html.hl",".inc",".xht",".xhtml"],languageId:146},CM={name:"Vue",type:"markup",color:"#41b883",extensions:[".vue"],tmScope:"text.html.vue",aceMode:"html",languageId:391};var vM={languages:[Yd(bM,(()=>({name:"Angular",since:"1.15.0",parsers:["angular"],vscodeLanguageIds:["html"],extensions:[".component.html"],filenames:[]}))),Yd(bM,(e=>({since:"1.15.0",parsers:["html"],vscodeLanguageIds:["html"],extensions:[...e.extensions,".mjml"]}))),Yd(bM,(()=>({name:"Lightning Web Components",since:"1.17.0",parsers:["lwc"],vscodeLanguageIds:["html"],extensions:[],filenames:[]}))),Yd(CM,(()=>({since:"1.10.0",parsers:["vue"],vscodeLanguageIds:["vue"]})))],printers:{html:DM},options:EM,parsers:{get html(){return require("./parser-html").parsers.html},get vue(){return require("./parser-html").parsers.vue},get angular(){return require("./parser-html").parsers.angular},get lwc(){return require("./parser-html").parsers.lwc}}};var AM={isPragma:function(e){return /^\s*@(prettier|format)\s*$/.test(e)},hasPragma:function(e){return /^\s*#[^\S\n]*@(prettier|format)\s*?(\n|$)/.test(e)},insertPragma:function(e){return `# @format\n\n${e}`}};var FM={locStart:function(e){return e.position.start.offset},locEnd:function(e){return e.position.end.offset}};var xM=function(e,t,n,r){if("root"===e.getValue().type&&r.filepath&&/(?:[/\\]|^)\.prettierrc$/.test(r.filepath))return n(r.originalText,Object.assign(Object.assign({},r),{},{parser:"json"}))};const{getLast:SM,isNonEmptyArray:wM}=fi$1;function TM(e,t){return e&&"string"==typeof e.type&&(!t||t.includes(e.type))}function BM(e){return "prettier-ignore"===e.value.trim()}function kM(e){return e&&wM(e.leadingComments)}function NM(e){return e&&wM(e.middleComments)}function PM(e){return e&&e.indicatorComment}function OM(e){return e&&e.trailingComment}function IM(e){return e&&wM(e.endComments)}function jM(e){const t=[];let n;for(const r of e.split(/( +)/))" "!==r?" "===n?t.push(r):t.push((t.pop()||"")+r):void 0===n&&t.unshift(""),n=r;return " "===n&&t.push((t.pop()||"")+" "),""===t[0]&&(t.shift(),t.unshift(" "+(t.shift()||""))),t}var LM={getLast:SM,getAncestorCount:function(e,t){let n=0;const r=e.stack.length-1;for(let i=0;i<r;i++){const r=e.stack[i];TM(r)&&t(r)&&n++;}return n},isNode:TM,isEmptyNode:function(e){return !wM(e.children)&&!function(e){return kM(e)||NM(e)||PM(e)||OM(e)||IM(e)}(e)},isInlineNode:function(e){if(!e)return !0;switch(e.type){case"plain":case"quoteDouble":case"quoteSingle":case"alias":case"flowMapping":case"flowSequence":return !0;default:return !1}},mapNode:function e(t,n,r){return n("children"in t?Object.assign(Object.assign({},t),{},{children:t.children.map((r=>e(r,n,t)))}):t,r)},defineShortcut:function(e,t,n){Object.defineProperty(e,t,{get:n,enumerable:!1});},isNextLineEmpty:function(e,t){let n=0;const r=t.length;for(let i=e.position.end.offset-1;i<r;i++){const e=t[i];if("\n"===e&&n++,1===n&&/\S/.test(e))return !1;if(2===n)return !0}return !1},isLastDescendantNode:function(e){switch(e.getValue().type){case"tag":case"anchor":case"comment":return !1}const t=e.stack.length;for(let n=1;n<t;n++){const t=e.stack[n],r=e.stack[n-1];if(Array.isArray(r)&&"number"==typeof t&&t!==r.length-1)return !1}return !0},getBlockValueLineContents:function(e,{parentIndent:t,isLastDescendant:n,options:r}){const i=e.position.start.line===e.position.end.line?"":r.originalText.slice(e.position.start.offset,e.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1],u=null===e.indent?(e=>e?e[1].length:Number.POSITIVE_INFINITY)(i.match(/^( *)\S/m)):e.indent-1+t,o=i.split("\n").map((e=>e.slice(u)));return "preserve"===r.proseWrap||"blockLiteral"===e.type?s(o.map((e=>0===e.length?[]:[e]))):s(o.map((e=>0===e.length?[]:jM(e))).reduce(((e,t,n)=>0!==n&&o[n-1].length>0&&t.length>0&&!/^\s/.test(t[0])&&!/^\s|\s$/.test(SM(e))?[...e.slice(0,-1),[...SM(e),...t]]:[...e,t]),[]).map((e=>e.reduce(((e,t)=>e.length>0&&/\s$/.test(SM(e))?[...e.slice(0,-1),SM(e)+" "+t]:[...e,t]),[]))).map((e=>"never"===r.proseWrap?[e.join(" ")]:e)));function s(t){if("keep"===e.chomping)return 0===SM(t).length?t.slice(0,-1):t;let r=0;for(let e=t.length-1;e>=0&&0===t[e].length;e--)r++;return 0===r?t:r>=2&&!n?t.slice(0,-(r-1)):t.slice(0,-r)}},getFlowScalarLineContents:function(e,t,n){const r=t.split("\n").map(((e,t,n)=>0===t&&t===n.length-1?e:0!==t&&t!==n.length-1?e.trim():0===t?e.trimEnd():e.trimStart()));return "preserve"===n.proseWrap?r.map((e=>0===e.length?[]:[e])):r.map((e=>0===e.length?[]:jM(e))).reduce(((t,n,i)=>0!==i&&r[i-1].length>0&&n.length>0&&("quoteDouble"!==e||!SM(SM(t)).endsWith("\\"))?[...t.slice(0,-1),[...SM(t),...n]]:[...t,n]),[]).map((e=>"never"===n.proseWrap?[e.join(" ")]:e))},getLastDescendantNode:function e(t){return wM(t.children)?e(SM(t.children)):t},hasPrettierIgnore:function(e){const t=e.getValue();if("documentBody"===t.type){const t=e.getParentNode();return IM(t.head)&&BM(SM(t.head.endComments))}return kM(t)&&BM(SM(t.leadingComments))},hasLeadingComments:kM,hasMiddleComments:NM,hasIndicatorComment:PM,hasTrailingComment:OM,hasEndComments:IM};const{defineShortcut:_M,mapNode:MM}=LM;function RM(e){switch(e.type){case"document":_M(e,"head",(()=>e.children[0])),_M(e,"body",(()=>e.children[1]));break;case"documentBody":case"sequenceItem":case"flowSequenceItem":case"mappingKey":case"mappingValue":_M(e,"content",(()=>e.children[0]));break;case"mappingItem":case"flowMappingItem":_M(e,"key",(()=>e.children[0])),_M(e,"value",(()=>e.children[1]));}return e}var $M=function(e){return MM(e,RM)};const{builders:{softline:VM,align:qM}}=Ji$1,{hasEndComments:WM,isNextLineEmpty:UM,isNode:zM}=LM,GM=new WeakMap;function HM(e){return WM(e)&&!zM(e,["documentHead","documentBody","flowMapping","flowSequence"])}var JM={alignWithSpaces:function(e,t){return qM(" ".repeat(e),t)},shouldPrintEndComments:HM,printNextEmptyLine:function(e,t){const n=e.getValue(),r=e.stack[0];let i;return GM.has(r)?i=GM.get(r):(i=new Set,GM.set(r,i)),i.has(n.position.end.line)||(i.add(n.position.end.line),!UM(n,t)||HM(e.getParentNode()))?"":VM}};const{builders:{ifBreak:XM,line:YM,softline:KM,hardline:QM,join:ZM}}=Ji$1,{isEmptyNode:eR,getLast:tR,hasEndComments:nR}=LM,{printNextEmptyLine:rR,alignWithSpaces:iR}=JM;function uR(e,t,n){const r=e.getValue(),i="flowMapping"===r.type,u=i?"{":"[",o=i?"}":"]";let s=KM;i&&r.children.length>0&&n.bracketSpacing&&(s=YM);const a=tR(r.children),l=a&&"flowMappingItem"===a.type&&eR(a.key)&&eR(a.value);return [u,iR(n.tabWidth,[s,oR(e,t,n),"none"===n.trailingComma?"":XM(","),nR(r)?[QM,ZM(QM,e.map(t,"endComments"))]:""]),l?"":s,o]}function oR(e,t,n){const r=e.getValue();return e.map(((e,i)=>[t(),i===r.children.length-1?"":[",",YM,r.children[i].position.start.line!==r.children[i+1].position.start.line?rR(e,n.originalText):""]]),"children")}var sR={printFlowMapping:uR,printFlowSequence:uR};const{builders:{conditionalGroup:aR,group:lR,hardline:cR,ifBreak:pR,join:fR,line:dR}}=Ji$1,{hasLeadingComments:hR,hasMiddleComments:gR,hasTrailingComment:mR,hasEndComments:yR,isNode:DR,isEmptyNode:ER,isInlineNode:bR}=LM,{alignWithSpaces:CR}=JM;function vR(e,t){if(!e)return !0;switch(e.type){case"plain":case"quoteSingle":case"quoteDouble":break;case"alias":return !0;default:return !1}if("preserve"===t.proseWrap)return e.position.start.line===e.position.end.line;if(/\\$/m.test(t.originalText.slice(e.position.start.offset,e.position.end.offset)))return !1;switch(t.proseWrap){case"never":return !e.value.includes("\n");case"always":return !/[\n ]/.test(e.value);default:return !1}}var AR=function(e,t,n,r,i){const{key:u,value:o}=e,s=ER(u),a=ER(o);if(s&&a)return ": ";const l=r("key"),c=function(e){return e.key.content&&"alias"===e.key.content.type}(e)?" ":"";if(a)return "flowMappingItem"===e.type&&"flowMapping"===t.type?l:"mappingItem"!==e.type||!vR(u.content,i)||mR(u.content)||t.tag&&"tag:yaml.org,2002:set"===t.tag.value?["? ",CR(2,l)]:[l,c,":"];const p=r("value");if(s)return [": ",CR(2,p)];if(hR(o)||!bR(u.content))return ["? ",CR(2,l),cR,fR("",n.map(r,"value","leadingComments").map((e=>[e,cR]))),": ",CR(2,p)];if(function(e){if(!e)return !0;switch(e.type){case"plain":case"quoteDouble":case"quoteSingle":return e.position.start.line===e.position.end.line;case"alias":return !0;default:return !1}}(u.content)&&!hR(u.content)&&!gR(u.content)&&!mR(u.content)&&!yR(u)&&!hR(o.content)&&!gR(o.content)&&!yR(o)&&vR(o.content,i))return [l,c,": ",p];const f=Symbol("mappingKey"),d=lR([pR("? "),lR(CR(2,l),{id:f})]),h=[cR,": ",CR(2,p)],g=[c,":"];hR(o.content)||yR(o)&&o.content&&!DR(o.content,["mapping","sequence"])||"mapping"===t.type&&mR(u.content)&&bR(o.content)||DR(o.content,["mapping","sequence"])&&null===o.content.tag&&null===o.content.anchor?g.push(cR):o.content&&g.push(dR),g.push(p);const m=CR(i.tabWidth,g);return !vR(u.content,i)||hR(u.content)||gR(u.content)||yR(u)?aR([[d,pR(h,m,{groupId:f})]]):aR([[l,m]])};const{builders:{dedent:FR,dedentToRoot:xR,fill:SR,hardline:wR,join:TR,line:BR,literalline:kR,markAsRoot:NR},utils:{getDocParts:PR}}=Ji$1,{getAncestorCount:OR,getBlockValueLineContents:IR,hasIndicatorComment:jR,isLastDescendantNode:LR,isNode:_R}=LM,{alignWithSpaces:MR}=JM;var RR=function(e,t,n){const r=e.getValue(),i=OR(e,(e=>_R(e,["sequence","mapping"]))),u=LR(e),o=["blockFolded"===r.type?">":"|"];null!==r.indent&&o.push(r.indent.toString()),"clip"!==r.chomping&&o.push("keep"===r.chomping?"+":"-"),jR(r)&&o.push(" ",t("indicatorComment"));const s=IR(r,{parentIndent:i,isLastDescendant:u,options:n}),a=[];for(const[e,t]of s.entries())0===e&&a.push(wR),a.push(SR(PR(TR(BR,t)))),e!==s.length-1?a.push(0===t.length?wR:NR(kR)):"keep"===r.chomping&&u&&a.push(xR(0===t.length?wR:kR));return null===r.indent?o.push(FR(MR(n.tabWidth,a))):o.push(xR(MR(r.indent-1+i,a))),o};const{builders:{breakParent:$R,fill:VR,group:qR,hardline:WR,join:UR,line:zR,lineSuffix:GR,literalline:HR},utils:{getDocParts:JR,replaceEndOfLineWith:XR}}=Ji$1,{isPreviousLineEmpty:YR}=fi$1,{insertPragma:KR,isPragma:QR}=AM,{locStart:ZR}=FM,{getFlowScalarLineContents:e$,getLastDescendantNode:t$,hasLeadingComments:n$,hasMiddleComments:r$,hasTrailingComment:i$,hasEndComments:u$,hasPrettierIgnore:o$,isLastDescendantNode:s$,isNode:a$,isInlineNode:l$}=LM,{alignWithSpaces:c$,printNextEmptyLine:p$,shouldPrintEndComments:f$}=JM,{printFlowMapping:d$,printFlowSequence:h$}=sR;function g$(e,t){return i$(e)||t&&(t.head.children.length>0||u$(t.head))}function m$(e,t,n){const r=e$(e,t,n);return UR(WR,r.map((e=>VR(JR(UR(zR,e))))))}var y$={preprocess:$M,embed:xM,print:function(e,t,n){const r=e.getValue(),i=[];"mappingValue"!==r.type&&n$(r)&&i.push([UR(WR,e.map(n,"leadingComments")),WR]);const{tag:u,anchor:o}=r;u&&i.push(n("tag")),u&&o&&i.push(" "),o&&i.push(n("anchor"));let s="";a$(r,["mapping","sequence","comment","directive","mappingItem","sequenceItem"])&&!s$(e)&&(s=p$(e,t.originalText)),(u||o)&&(a$(r,["sequence","mapping"])&&!r$(r)?i.push(WR):i.push(" ")),r$(r)&&i.push([1===r.middleComments.length?"":WR,UR(WR,e.map(n,"middleComments")),WR]);const a=e.getParentNode();return o$(e)?i.push(XR(t.originalText.slice(r.position.start.offset,r.position.end.offset).trimEnd(),HR)):i.push(qR(function(e,t,n,r,i){switch(e.type){case"root":{const{children:t}=e,r=[];n.each(((e,n)=>{const u=t[n],o=t[n+1];0!==n&&r.push(WR),r.push(i()),g$(u,o)?(r.push(WR,"..."),i$(u)&&r.push(" ",i("trailingComment"))):o&&!i$(o.head)&&r.push(WR,"---");}),"children");const u=t$(e);return a$(u,["blockLiteral","blockFolded"])&&"keep"===u.chomping||r.push(WR),r}case"document":{const u=[];return "head"===function(e,t,n,r){if(n.children[0]===e&&/---(\s|$)/.test(r.originalText.slice(ZR(e),ZR(e)+4))||e.head.children.length>0||u$(e.head)||i$(e.head))return "head";if(g$(e,t))return !1;return !!t&&"root"}(e,t.children[n.getName()+1],t,r)&&((e.head.children.length>0||e.head.endComments.length>0)&&u.push(i("head")),i$(e.head)?u.push(["---"," ",i(["head","trailingComment"])]):u.push("---")),function(e){return e.body.children.length>0||u$(e.body)}(e)&&u.push(i("body")),UR(WR,u)}case"documentHead":return UR(WR,[...n.map(i,"children"),...n.map(i,"endComments")]);case"documentBody":{const{children:t,endComments:r}=e;let u="";if(t.length>0&&r.length>0){const t=t$(e);a$(t,["blockFolded","blockLiteral"])?"keep"!==t.chomping&&(u=[WR,WR]):u=WR;}return [UR(WR,n.map(i,"children")),u,UR(WR,n.map(i,"endComments"))]}case"directive":return ["%",UR(" ",[e.name,...e.parameters])];case"comment":return ["#",e.value];case"alias":return ["*",e.value];case"tag":return r.originalText.slice(e.position.start.offset,e.position.end.offset);case"anchor":return ["&",e.value];case"plain":return m$(e.type,r.originalText.slice(e.position.start.offset,e.position.end.offset),r);case"quoteDouble":case"quoteSingle":{const t="'",n='"',i=r.originalText.slice(e.position.start.offset+1,e.position.end.offset-1);if("quoteSingle"===e.type&&i.includes("\\")||"quoteDouble"===e.type&&/\\[^"]/.test(i)){const u="quoteDouble"===e.type?n:t;return [u,m$(e.type,i,r),u]}if(i.includes(n))return [t,m$(e.type,"quoteDouble"===e.type?i.replace(/\\"/g,n).replace(/'/g,t.repeat(2)):i,r),t];if(i.includes(t))return [n,m$(e.type,"quoteSingle"===e.type?i.replace(/''/g,t):i,r),n];const u=r.singleQuote?t:n;return [u,m$(e.type,i,r),u]}case"blockFolded":case"blockLiteral":return RR(n,i,r);case"mapping":case"sequence":return UR(WR,n.map(i,"children"));case"sequenceItem":return ["- ",c$(2,e.content?i("content"):"")];case"mappingKey":case"mappingValue":return e.content?i("content"):"";case"mappingItem":case"flowMappingItem":return AR(e,t,n,i,r);case"flowMapping":return d$(n,i,r);case"flowSequence":return h$(n,i,r);case"flowSequenceItem":return i("content");default:throw new Error(`Unexpected node type ${e.type}`)}}(r,a,e,t,n))),i$(r)&&!a$(r,["document","documentHead"])&&i.push(GR(["mappingValue"!==r.type||r.content?" ":"","mappingKey"===a.type&&"mapping"===e.getParentNode(2).type&&l$(r)?"":$R,n("trailingComment")])),f$(r)&&i.push(c$("sequenceItem"===r.type?2:0,[WR,UR(WR,e.map((e=>[YR(t.originalText,e.getValue(),ZR)?WR:"",n()]),"endComments"))])),i.push(s),i},massageAstNode:function(e,t){if(a$(t))switch(delete t.position,t.type){case"comment":if(QR(t.value))return null;break;case"quoteDouble":case"quoteSingle":t.type="quote";}},insertPragma:KR},D$={bracketSpacing:$B.bracketSpacing,singleQuote:$B.singleQuote,proseWrap:$B.proseWrap};var E$=[JB,ZN,cO,NO,sj,vM,{languages:[Yd({name:"YAML",type:"data",color:"#cb171e",tmScope:"source.yaml",aliases:["yml"],extensions:[".yml",".mir",".reek",".rviz",".sublime-syntax",".syntax",".yaml",".yaml-tmlanguage",".yaml.sed",".yml.mysql"],filenames:[".clang-format",".clang-tidy",".gemrc","glide.lock","yarn.lock"],aceMode:"yaml",codemirrorMode:"yaml",codemirrorMimeType:"text/x-yaml",languageId:407},(e=>({since:"1.14.0",parsers:["yaml"],vscodeLanguageIds:["yaml","ansible","home-assistant"],filenames:[...e.filenames.filter((e=>"yarn.lock"!==e)),".prettierrc"]})))],printers:{yaml:y$},options:D$,parsers:{get yaml(){return require("./parser-yaml").parsers.yaml}}}];const b$=["parsers"],{version:C$}=t$2,{getSupportInfo:v$}=Hr$1,A$=E$.map((t=>e$2(t,b$)));function F$(e,t=1){return (...n)=>{const r=n[t]||{},i=r.plugins||[];return n[t]=Object.assign(Object.assign({},r),{},{plugins:[...A$,...Array.isArray(i)?i:Object.values(i)]}),e(...n)}}const x$=F$(Fd.formatWithCursor);var S$={formatWithCursor:x$,format:(e,t)=>x$(e,t).formatted,check(e,t){const{formatted:n}=x$(e,t);return n===e},doc:Ji$1,getSupportInfo:F$(v$,0),version:C$,util:Jd,__debug:{parse:F$(Fd.parse),formatAST:F$(Fd.formatAST),formatDoc:F$(Fd.formatDoc),printToDoc:F$(Fd.printToDoc),printDocToString:F$(Fd.printDocToString)}};

var e$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function t$1(e){var t={exports:{}};return e(t,t.exports),t.exports}var r$1=t$1((function(e,t){function r(e){return t.$0<=e&&e<=t.$9}
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
Object.defineProperty(t,"__esModule",{value:!0}),t.$EOF=0,t.$BSPACE=8,t.$TAB=9,t.$LF=10,t.$VTAB=11,t.$FF=12,t.$CR=13,t.$SPACE=32,t.$BANG=33,t.$DQ=34,t.$HASH=35,t.$$=36,t.$PERCENT=37,t.$AMPERSAND=38,t.$SQ=39,t.$LPAREN=40,t.$RPAREN=41,t.$STAR=42,t.$PLUS=43,t.$COMMA=44,t.$MINUS=45,t.$PERIOD=46,t.$SLASH=47,t.$COLON=58,t.$SEMICOLON=59,t.$LT=60,t.$EQ=61,t.$GT=62,t.$QUESTION=63,t.$0=48,t.$7=55,t.$9=57,t.$A=65,t.$E=69,t.$F=70,t.$X=88,t.$Z=90,t.$LBRACKET=91,t.$BACKSLASH=92,t.$RBRACKET=93,t.$CARET=94,t.$_=95,t.$a=97,t.$b=98,t.$e=101,t.$f=102,t.$n=110,t.$r=114,t.$t=116,t.$u=117,t.$v=118,t.$x=120,t.$z=122,t.$LBRACE=123,t.$BAR=124,t.$RBRACE=125,t.$NBSP=160,t.$PIPE=124,t.$TILDA=126,t.$AT=64,t.$BT=96,t.isWhitespace=function(e){return e>=t.$TAB&&e<=t.$SPACE||e==t.$NBSP},t.isDigit=r,t.isAsciiLetter=function(e){return e>=t.$a&&e<=t.$z||e>=t.$A&&e<=t.$Z},t.isAsciiHexDigit=function(e){return e>=t.$a&&e<=t.$f||e>=t.$A&&e<=t.$F||r(e)},t.isNewLine=function(e){return e===t.$LF||e===t.$CR},t.isOctalDigit=function(e){return t.$0<=e&&e<=t.$7};}));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */class n$1{constructor(e,t,r){this.filePath=e,this.name=t,this.members=r;}assertNoMembers(){if(this.members.length)throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`)}}var i$1=n$1;var s$1=class{constructor(){this.cache=new Map;}get(e,t,r){const i=`"${e}".${t}${(r=r||[]).length?`.${r.join(".")}`:""}`;let s=this.cache.get(i);return s||(s=new n$1(e,t,r),this.cache.set(i,s)),s}},o$1=Object.defineProperty({StaticSymbol:i$1,StaticSymbolCache:s$1},"__esModule",{value:!0});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const a$1=/-+([a-z0-9])/g;var u$1=function(e){return e.replace(a$1,((...e)=>e[1].toUpperCase()))};var c$1=function(e,t){return p$1(e,":",t)};var l$1=function(e,t){return p$1(e,".",t)};function p$1(e,t,r){const n=e.indexOf(t);return -1==n?r:[e.slice(0,n).trim(),e.slice(n+1).trim()]}function D(e,t,r){return Array.isArray(e)?t.visitArray(e,r):"object"==typeof(n=e)&&null!==n&&Object.getPrototypeOf(n)===b?t.visitStringMap(e,r):null==e||"string"==typeof e||"number"==typeof e||"boolean"==typeof e?t.visitPrimitive(e,r):t.visitOther(e,r);var n;}var h$1=D;var d$1=function(e){return null!=e};var f$1=function(e){return void 0===e?null:e};var m$1=class{visitArray(e,t){return e.map((e=>D(e,this,t)))}visitStringMap(e,t){const r={};return Object.keys(e).forEach((n=>{r[n]=D(e[n],this,t);})),r}visitPrimitive(e,t){return e}visitOther(e,t){return e}},g$1={assertSync:e=>{if(N(e))throw new Error("Illegal state: value cannot be a promise");return e},then:(e,t)=>N(e)?e.then(t):t(e),all:e=>e.some(N)?Promise.all(e):e};var E=function(e){throw new Error(`Internal Error: ${e}`)};var C=function(e,t){const r=Error(e);return r[T]=!0,t&&(r[y]=t),r};const T="ngSyntaxError",y="ngParseErrors";var S=function(e){return e[T]};var _$1=function(e){return e[y]||[]};var v=function(e){return e.replace(/([.*+?^=!:${}()|[\]\/\\])/g,"\\$1")};const b=Object.getPrototypeOf({});var F=function(e){let t="";for(let r=0;r<e.length;r++){let n=e.charCodeAt(r);if(n>=55296&&n<=56319&&e.length>r+1){const t=e.charCodeAt(r+1);t>=56320&&t<=57343&&(r++,n=(n-55296<<10)+t-56320+65536);}n<=127?t+=String.fromCharCode(n):n<=2047?t+=String.fromCharCode(n>>6&31|192,63&n|128):n<=65535?t+=String.fromCharCode(n>>12|224,n>>6&63|128,63&n|128):n<=2097151&&(t+=String.fromCharCode(n>>18&7|240,n>>12&63|128,n>>6&63|128,63&n|128));}return t};var A=function e(t){if("string"==typeof t)return t;if(t instanceof Array)return "["+t.map(e).join(", ")+"]";if(null==t)return ""+t;if(t.overriddenName)return `${t.overriddenName}`;if(t.name)return `${t.name}`;if(!t.toString)return "object";const r=t.toString();if(null==r)return ""+r;const n=r.indexOf("\n");return -1===n?r:r.substring(0,n)};var w=function(e){return "function"==typeof e&&e.hasOwnProperty("__forward_ref__")?e():e};function N(e){return !!e&&"function"==typeof e.then}var k=N;var O=class{constructor(e){this.full=e;const t=e.split(".");this.major=t[0],this.minor=t[1],this.patch=t.slice(2).join(".");}};const x="undefined"!=typeof window&&window,I="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self;var P=void 0!==e$1&&e$1||x||I,R=Object.defineProperty({dashCaseToCamelCase:u$1,splitAtColon:c$1,splitAtPeriod:l$1,visitValue:h$1,isDefined:d$1,noUndefined:f$1,ValueTransformer:m$1,SyncAsync:g$1,error:E,syntaxError:C,isSyntaxError:S,getParseErrors:_$1,escapeRegExp:v,utf8Encode:F,stringify:A,resolveForwardRef:w,isPromise:k,Version:O,global:P},"__esModule",{value:!0}),L=t$1((function(e,t){
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
Object.defineProperty(t,"__esModule",{value:!0});const r=/^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;function n(e){return e.replace(/\W/g,"_")}t.sanitizeIdentifier=n;let i=0;function s(e){if(!e||!e.reference)return null;const t=e.reference;if(t instanceof o$1.StaticSymbol)return t.name;if(t.__anonymousType)return t.__anonymousType;let r=R.stringify(t);return r.indexOf("(")>=0?(r="anonymous_"+i++,t.__anonymousType=r):r=n(r),r}var a;t.identifierName=s,t.identifierModuleUrl=function(e){const t=e.reference;return t instanceof o$1.StaticSymbol?t.filePath:`./${R.stringify(t)}`},t.viewClassName=function(e,t){return `View_${s({reference:e})}_${t}`},t.rendererTypeName=function(e){return `RenderType_${s({reference:e})}`},t.hostViewClassName=function(e){return `HostView_${s({reference:e})}`},t.componentFactoryName=function(e){return `${s({reference:e})}NgFactory`},function(e){e[e.Pipe=0]="Pipe",e[e.Directive=1]="Directive",e[e.NgModule=2]="NgModule",e[e.Injectable=3]="Injectable";}(a=t.CompileSummaryKind||(t.CompileSummaryKind={})),t.tokenName=function(e){return null!=e.value?n(e.value):s(e.identifier)},t.tokenReference=function(e){return null!=e.identifier?e.identifier.reference:e.value};t.CompileStylesheetMetadata=class{constructor({moduleUrl:e,styles:t,styleUrls:r}={}){this.moduleUrl=e||null,this.styles=c(t),this.styleUrls=c(r);}};t.CompileTemplateMetadata=class{constructor({encapsulation:e,template:t,templateUrl:r,htmlAst:n,styles:i,styleUrls:s,externalStylesheets:o,animations:a,ngContentSelectors:u,interpolation:p,isInline:D,preserveWhitespaces:h}){if(this.encapsulation=e,this.template=t,this.templateUrl=r,this.htmlAst=n,this.styles=c(i),this.styleUrls=c(s),this.externalStylesheets=c(o),this.animations=a?l(a):[],this.ngContentSelectors=u||[],p&&2!=p.length)throw new Error("'interpolation' should have a start and an end symbol.");this.interpolation=p,this.isInline=D,this.preserveWhitespaces=h;}toSummary(){return {ngContentSelectors:this.ngContentSelectors,encapsulation:this.encapsulation,styles:this.styles,animations:this.animations}}};class u{static create({isHost:e,type:t,isComponent:n,selector:i,exportAs:s,changeDetection:o,inputs:a,outputs:c,host:l,providers:p,viewProviders:D,queries:h,guards:d,viewQueries:f,entryComponents:m,template:g,componentViewType:E,rendererType:C,componentFactory:T}){const y={},S={},_={};null!=l&&Object.keys(l).forEach((e=>{const t=l[e],n=e.match(r);null===n?_[e]=t:null!=n[1]?S[n[1]]=t:null!=n[2]&&(y[n[2]]=t);}));const v={};null!=a&&a.forEach((e=>{const t=R.splitAtColon(e,[e,e]);v[t[0]]=t[1];}));const b={};return null!=c&&c.forEach((e=>{const t=R.splitAtColon(e,[e,e]);b[t[0]]=t[1];})),new u({isHost:e,type:t,isComponent:!!n,selector:i,exportAs:s,changeDetection:o,inputs:v,outputs:b,hostListeners:y,hostProperties:S,hostAttributes:_,providers:p,viewProviders:D,queries:h,guards:d,viewQueries:f,entryComponents:m,template:g,componentViewType:E,rendererType:C,componentFactory:T})}constructor({isHost:e,type:t,isComponent:r,selector:n,exportAs:i,changeDetection:s,inputs:o,outputs:a,hostListeners:u,hostProperties:l,hostAttributes:p,providers:D,viewProviders:h,queries:d,guards:f,viewQueries:m,entryComponents:g,template:E,componentViewType:C,rendererType:T,componentFactory:y}){this.isHost=!!e,this.type=t,this.isComponent=r,this.selector=n,this.exportAs=i,this.changeDetection=s,this.inputs=o,this.outputs=a,this.hostListeners=u,this.hostProperties=l,this.hostAttributes=p,this.providers=c(D),this.viewProviders=c(h),this.queries=c(d),this.guards=f,this.viewQueries=c(m),this.entryComponents=c(g),this.template=E,this.componentViewType=C,this.rendererType=T,this.componentFactory=y;}toSummary(){return {summaryKind:a.Directive,type:this.type,isComponent:this.isComponent,selector:this.selector,exportAs:this.exportAs,inputs:this.inputs,outputs:this.outputs,hostListeners:this.hostListeners,hostProperties:this.hostProperties,hostAttributes:this.hostAttributes,providers:this.providers,viewProviders:this.viewProviders,queries:this.queries,guards:this.guards,viewQueries:this.viewQueries,entryComponents:this.entryComponents,changeDetection:this.changeDetection,template:this.template&&this.template.toSummary(),componentViewType:this.componentViewType,rendererType:this.rendererType,componentFactory:this.componentFactory}}}t.CompileDirectiveMetadata=u;t.CompilePipeMetadata=class{constructor({type:e,name:t,pure:r}){this.type=e,this.name=t,this.pure=!!r;}toSummary(){return {summaryKind:a.Pipe,type:this.type,name:this.name,pure:this.pure}}};t.CompileShallowModuleMetadata=class{};t.CompileNgModuleMetadata=class{constructor({type:e,providers:t,declaredDirectives:r,exportedDirectives:n,declaredPipes:i,exportedPipes:s,entryComponents:o,bootstrapComponents:a,importedModules:u,exportedModules:l,schemas:p,transitiveModule:D,id:h}){this.type=e||null,this.declaredDirectives=c(r),this.exportedDirectives=c(n),this.declaredPipes=c(i),this.exportedPipes=c(s),this.providers=c(t),this.entryComponents=c(o),this.bootstrapComponents=c(a),this.importedModules=c(u),this.exportedModules=c(l),this.schemas=c(p),this.id=h||null,this.transitiveModule=D||null;}toSummary(){const e=this.transitiveModule;return {summaryKind:a.NgModule,type:this.type,entryComponents:e.entryComponents,providers:e.providers,modules:e.modules,exportedDirectives:e.exportedDirectives,exportedPipes:e.exportedPipes}}};function c(e){return e||[]}t.TransitiveCompileNgModuleMetadata=class{constructor(){this.directivesSet=new Set,this.directives=[],this.exportedDirectivesSet=new Set,this.exportedDirectives=[],this.pipesSet=new Set,this.pipes=[],this.exportedPipesSet=new Set,this.exportedPipes=[],this.modulesSet=new Set,this.modules=[],this.entryComponentsSet=new Set,this.entryComponents=[],this.providers=[];}addProvider(e,t){this.providers.push({provider:e,module:t});}addDirective(e){this.directivesSet.has(e.reference)||(this.directivesSet.add(e.reference),this.directives.push(e));}addExportedDirective(e){this.exportedDirectivesSet.has(e.reference)||(this.exportedDirectivesSet.add(e.reference),this.exportedDirectives.push(e));}addPipe(e){this.pipesSet.has(e.reference)||(this.pipesSet.add(e.reference),this.pipes.push(e));}addExportedPipe(e){this.exportedPipesSet.has(e.reference)||(this.exportedPipesSet.add(e.reference),this.exportedPipes.push(e));}addModule(e){this.modulesSet.has(e.reference)||(this.modulesSet.add(e.reference),this.modules.push(e));}addEntryComponent(e){this.entryComponentsSet.has(e.componentType)||(this.entryComponentsSet.add(e.componentType),this.entryComponents.push(e));}};function l(e){return e.reduce(((e,t)=>{const r=Array.isArray(t)?l(t):t;return e.concat(r)}),[])}function p(e){return e.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/,"ng:///")}t.ProviderMeta=class{constructor(e,{useClass:t,useValue:r,useExisting:n,useFactory:i,deps:s,multi:o}){this.token=e,this.useClass=t||null,this.useValue=r,this.useExisting=n,this.useFactory=i||null,this.dependencies=s||null,this.multi=!!o;}},t.flatten=l,t.templateSourceUrl=function(e,t,r){let n;return n=r.isInline?t.type.reference instanceof o$1.StaticSymbol?`${t.type.reference.filePath}.${t.type.reference.name}.html`:`${s(e)}/${s(t.type)}.html`:r.templateUrl,t.type.reference instanceof o$1.StaticSymbol?n:p(n)},t.sharedStylesheetJitUrl=function(e,t){const r=e.moduleUrl.split(/\/\\/g);return p(`css/${t}${r[r.length-1]}.ngstyle.js`)},t.ngModuleJitUrl=function(e){return p(`${s(e.type)}/module.ngfactory.js`)},t.templateJitUrl=function(e,t){return p(`${s(e)}/${s(t.type)}.ngfactory.js`)};})),B=t$1((function(e,t){Object.defineProperty(t,"__esModule",{value:!0});
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
class n{constructor(e,t,r,n){this.file=e,this.offset=t,this.line=r,this.col=n;}toString(){return null!=this.offset?`${this.file.url}@${this.line}:${this.col}`:this.file.url}moveBy(e){const t=this.file.content,i=t.length;let s=this.offset,o=this.line,a=this.col;for(;s>0&&e<0;){s--,e++;if(t.charCodeAt(s)==r$1.$LF){o--;const e=t.substr(0,s-1).lastIndexOf(String.fromCharCode(r$1.$LF));a=e>0?s-e:s;}else a--;}for(;s<i&&e>0;){const n=t.charCodeAt(s);s++,e--,n==r$1.$LF?(o++,a=0):a++;}return new n(this.file,s,o,a)}getContext(e,t){const r=this.file.content;let n=this.offset;if(null!=n){n>r.length-1&&(n=r.length-1);let i=n,s=0,o=0;for(;s<e&&n>0&&(n--,s++,"\n"!=r[n]||++o!=t););for(s=0,o=0;s<e&&i<r.length-1&&(i++,s++,"\n"!=r[i]||++o!=t););return {before:r.substring(n,this.offset),after:r.substring(this.offset,i+1)}}return null}}t.ParseLocation=n;class i{constructor(e,t){this.content=e,this.url=t;}}t.ParseSourceFile=i;class s{constructor(e,t,r=null){this.start=e,this.end=t,this.details=r;}toString(){return this.start.file.content.substring(this.start.offset,this.end.offset)}}var o;t.ParseSourceSpan=s,t.EMPTY_PARSE_LOCATION=new n(new i("",""),0,0,0),t.EMPTY_SOURCE_SPAN=new s(t.EMPTY_PARSE_LOCATION,t.EMPTY_PARSE_LOCATION),function(e){e[e.WARNING=0]="WARNING",e[e.ERROR=1]="ERROR";}(o=t.ParseErrorLevel||(t.ParseErrorLevel={}));t.ParseError=class{constructor(e,t,r=o.ERROR){this.span=e,this.msg=t,this.level=r;}contextualMessage(){const e=this.span.start.getContext(100,3);return e?`${this.msg} ("${e.before}[${o[this.level]} ->]${e.after}")`:this.msg}toString(){const e=this.span.details?`, ${this.span.details}`:"";return `${this.contextualMessage()}: ${this.span.start}${e}`}},t.typeSourceSpan=function(e,t){const r=L.identifierModuleUrl(t),o=null!=r?`in ${e} ${L.identifierName(t)} in ${r}`:`in ${e} ${L.identifierName(t)}`,a=new i("",o);return new s(new n(a,-1,-1,-1),new n(a,-1,-1,-1))},t.r3JitTypeSourceSpan=function(e,t,r){const o=new i("",`in ${e} ${t} in ${r}`);return new s(new n(o,-1,-1,-1),new n(o,-1,-1,-1))};}));const $$1=new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)","s");var q=function(e){const t=e.match($$1);if(!t)return {content:e};const{startDelimiter:r,language:n,value:i="",endDelimiter:s}=t.groups;let o=n.trim()||"yaml";if("+++"===r&&(o="toml"),"yaml"!==o&&r!==s)return {content:e};const[a]=t;return {frontMatter:{type:"front-matter",lang:o,value:i,startDelimiter:r,endDelimiter:s,raw:a.replace(/\n$/,"")},content:a.replace(/[^\n]/g," ")+e.slice(a.length)}};var M=e=>e[e.length-1];var U=function(e,t){const r=new SyntaxError(e+" ("+t.start.line+":"+t.start.column+")");return r.loc=t,r},G=e=>"string"==typeof e?e.replace((({onlyFirst:e=!1}={})=>{const t=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(t,e?void 0:"g")})(),""):e;const j=e=>!Number.isNaN(e)&&(e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141));var V=j,H=j;V.default=H;const X=e=>{if("string"!=typeof e||0===e.length)return 0;if(0===(e=G(e)).length)return 0;e=e.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g,"  ");let t=0;for(let r=0;r<e.length;r++){const n=e.codePointAt(r);n<=31||n>=127&&n<=159||(n>=768&&n<=879||(n>65535&&r++,t+=V(n)?2:1));}return t};var z=X,W=X;z.default=W;var Y=e=>{if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")};function Q(e,t){if(null==e)return {};var r,n,i=function(e,t){if(null==e)return {};var r,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r]);}return i}var J=function(e){return e&&e.Math==Math&&e},K=J("object"==typeof globalThis&&globalThis)||J("object"==typeof window&&window)||J("object"==typeof self&&self)||J("object"==typeof e$1&&e$1)||function(){return this}()||Function("return this")(),Z=function(e){try{return !!e()}catch(e){return !0}},ee=!Z((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),te={}.propertyIsEnumerable,re=Object.getOwnPropertyDescriptor,ne={f:re&&!te.call({1:2},1)?function(e){var t=re(this,e);return !!t&&t.enumerable}:te},ie=function(e,t){return {enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},se={}.toString,oe=function(e){return se.call(e).slice(8,-1)},ae="".split,ue=Z((function(){return !Object("z").propertyIsEnumerable(0)}))?function(e){return "String"==oe(e)?ae.call(e,""):Object(e)}:Object,ce=function(e){if(null==e)throw TypeError("Can't call method on "+e);return e},le=function(e){return ue(ce(e))},pe=function(e){return "object"==typeof e?null!==e:"function"==typeof e},De=function(e,t){if(!pe(e))return e;var r,n;if(t&&"function"==typeof(r=e.toString)&&!pe(n=r.call(e)))return n;if("function"==typeof(r=e.valueOf)&&!pe(n=r.call(e)))return n;if(!t&&"function"==typeof(r=e.toString)&&!pe(n=r.call(e)))return n;throw TypeError("Can't convert object to primitive value")},he=function(e){return Object(ce(e))},de={}.hasOwnProperty,fe=Object.hasOwn||function(e,t){return de.call(he(e),t)},me=K.document,ge=pe(me)&&pe(me.createElement),Ee=!ee&&!Z((function(){return 7!=Object.defineProperty((e="div",ge?me.createElement(e):{}),"a",{get:function(){return 7}}).a;var e;})),Ce=Object.getOwnPropertyDescriptor,Te={f:ee?Ce:function(e,t){if(e=le(e),t=De(t,!0),Ee)try{return Ce(e,t)}catch(e){}if(fe(e,t))return ie(!ne.f.call(e,t),e[t])}},ye=function(e){if(!pe(e))throw TypeError(String(e)+" is not an object");return e},Se=Object.defineProperty,_e={f:ee?Se:function(e,t,r){if(ye(e),t=De(t,!0),ye(r),Ee)try{return Se(e,t,r)}catch(e){}if("get"in r||"set"in r)throw TypeError("Accessors not supported");return "value"in r&&(e[t]=r.value),e}},ve=ee?function(e,t,r){return _e.f(e,t,ie(1,r))}:function(e,t,r){return e[t]=r,e},be=function(e,t){try{ve(K,e,t);}catch(r){K[e]=t;}return t},Fe=K["__core-js_shared__"]||be("__core-js_shared__",{}),Ae=Function.toString;"function"!=typeof Fe.inspectSource&&(Fe.inspectSource=function(e){return Ae.call(e)});var we,Ne,ke,Oe,xe=Fe.inspectSource,Ie=K.WeakMap,Pe="function"==typeof Ie&&/native code/.test(xe(Ie)),Re=t$1((function(e){(e.exports=function(e,t){return Fe[e]||(Fe[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.14.0",mode:"global",copyright:"\xa9 2021 Denis Pushkarev (zloirock.ru)"});})),Le=0,Be=Math.random(),$e=function(e){return "Symbol("+String(void 0===e?"":e)+")_"+(++Le+Be).toString(36)},qe=Re("keys"),Me={},Ue=K.WeakMap;if(Pe||Fe.state){var Ge=Fe.state||(Fe.state=new Ue),je=Ge.get,Ve=Ge.has,He=Ge.set;we=function(e,t){if(Ve.call(Ge,e))throw new TypeError("Object already initialized");return t.facade=e,He.call(Ge,e,t),t},Ne=function(e){return je.call(Ge,e)||{}},ke=function(e){return Ve.call(Ge,e)};}else {var Xe=qe[Oe="state"]||(qe[Oe]=$e(Oe));Me[Xe]=!0,we=function(e,t){if(fe(e,Xe))throw new TypeError("Object already initialized");return t.facade=e,ve(e,Xe,t),t},Ne=function(e){return fe(e,Xe)?e[Xe]:{}},ke=function(e){return fe(e,Xe)};}var ze,We,Ye={set:we,get:Ne,has:ke,enforce:function(e){return ke(e)?Ne(e):we(e,{})},getterFor:function(e){return function(t){var r;if(!pe(t)||(r=Ne(t)).type!==e)throw TypeError("Incompatible receiver, "+e+" required");return r}}},Qe=t$1((function(e){var t=Ye.get,r=Ye.enforce,n=String(String).split("String");(e.exports=function(e,t,i,s){var o,a=!!s&&!!s.unsafe,u=!!s&&!!s.enumerable,c=!!s&&!!s.noTargetGet;"function"==typeof i&&("string"!=typeof t||fe(i,"name")||ve(i,"name",t),(o=r(i)).source||(o.source=n.join("string"==typeof t?t:""))),e!==K?(a?!c&&e[t]&&(u=!0):delete e[t],u?e[t]=i:ve(e,t,i)):u?e[t]=i:be(t,i);})(Function.prototype,"toString",(function(){return "function"==typeof this&&t(this).source||xe(this)}));})),Je=K,Ke=function(e){return "function"==typeof e?e:void 0},Ze=function(e,t){return arguments.length<2?Ke(Je[e])||Ke(K[e]):Je[e]&&Je[e][t]||K[e]&&K[e][t]},et=Math.ceil,tt=Math.floor,rt=function(e){return isNaN(e=+e)?0:(e>0?tt:et)(e)},nt=Math.min,it=function(e){return e>0?nt(rt(e),9007199254740991):0},st=Math.max,ot=Math.min,at=function(e){return function(t,r,n){var i,s=le(t),o=it(s.length),a=function(e,t){var r=rt(e);return r<0?st(r+t,0):ot(r,t)}(n,o);if(e&&r!=r){for(;o>a;)if((i=s[a++])!=i)return !0}else for(;o>a;a++)if((e||a in s)&&s[a]===r)return e||a||0;return !e&&-1}},ut={includes:at(!0),indexOf:at(!1)}.indexOf,ct=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"].concat("length","prototype"),lt={f:Object.getOwnPropertyNames||function(e){return function(e,t){var r,n=le(e),i=0,s=[];for(r in n)!fe(Me,r)&&fe(n,r)&&s.push(r);for(;t.length>i;)fe(n,r=t[i++])&&(~ut(s,r)||s.push(r));return s}(e,ct)}},pt={f:Object.getOwnPropertySymbols},Dt=Ze("Reflect","ownKeys")||function(e){var t=lt.f(ye(e)),r=pt.f;return r?t.concat(r(e)):t},ht=function(e,t){for(var r=Dt(t),n=_e.f,i=Te.f,s=0;s<r.length;s++){var o=r[s];fe(e,o)||n(e,o,i(t,o));}},dt=/#|\.prototype\./,ft=function(e,t){var r=gt[mt(e)];return r==Ct||r!=Et&&("function"==typeof t?Z(t):!!t)},mt=ft.normalize=function(e){return String(e).replace(dt,".").toLowerCase()},gt=ft.data={},Et=ft.NATIVE="N",Ct=ft.POLYFILL="P",Tt=ft,yt=Te.f,St=function(e,t){var r,n,i,s,o,a=e.target,u=e.global,c=e.stat;if(r=u?K:c?K[a]||be(a,{}):(K[a]||{}).prototype)for(n in t){if(s=t[n],i=e.noTargetGet?(o=yt(r,n))&&o.value:r[n],!Tt(u?n:a+(c?".":"#")+n,e.forced)&&void 0!==i){if(typeof s==typeof i)continue;ht(s,i);}(e.sham||i&&i.sham)&&ve(s,"sham",!0),Qe(r,n,s,e);}},_t=Array.isArray||function(e){return "Array"==oe(e)},vt=function(e){if("function"!=typeof e)throw TypeError(String(e)+" is not a function");return e},bt=function(e,t,r){if(vt(e),void 0===t)return e;switch(r){case 0:return function(){return e.call(t)};case 1:return function(r){return e.call(t,r)};case 2:return function(r,n){return e.call(t,r,n)};case 3:return function(r,n,i){return e.call(t,r,n,i)}}return function(){return e.apply(t,arguments)}},Ft=function(e,t,r,n,i,s,o,a){for(var u,c=i,l=0,p=!!o&&bt(o,a,3);l<n;){if(l in r){if(u=p?p(r[l],l,t):r[l],s>0&&_t(u))c=Ft(e,t,u,it(u.length),c,s-1)-1;else {if(c>=9007199254740991)throw TypeError("Exceed the acceptable array length");e[c]=u;}c++;}l++;}return c},At=Ft,wt=Ze("navigator","userAgent")||"",Nt=K.process,kt=Nt&&Nt.versions,Ot=kt&&kt.v8;Ot?We=(ze=Ot.split("."))[0]<4?1:ze[0]+ze[1]:wt&&(!(ze=wt.match(/Edge\/(\d+)/))||ze[1]>=74)&&(ze=wt.match(/Chrome\/(\d+)/))&&(We=ze[1]);var xt=We&&+We,It=!!Object.getOwnPropertySymbols&&!Z((function(){var e=Symbol();return !String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&xt&&xt<41})),Pt=It&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,Rt=Re("wks"),Lt=K.Symbol,Bt=Pt?Lt:Lt&&Lt.withoutSetter||$e,$t=function(e){return fe(Rt,e)&&(It||"string"==typeof Rt[e])||(It&&fe(Lt,e)?Rt[e]=Lt[e]:Rt[e]=Bt("Symbol."+e)),Rt[e]},qt=$t("species"),Mt=function(e,t){var r;return _t(e)&&("function"!=typeof(r=e.constructor)||r!==Array&&!_t(r.prototype)?pe(r)&&null===(r=r[qt])&&(r=void 0):r=void 0),new(void 0===r?Array:r)(0===t?0:t)};St({target:"Array",proto:!0},{flatMap:function(e){var t,r=he(this),n=it(r.length);return vt(e),(t=Mt(r,0)).length=At(t,r,r,n,0,1,e,arguments.length>1?arguments[1]:void 0),t}});var Gt,jt=Math.floor,Vt=function(e,t){var r=e.length,n=jt(r/2);return r<8?Ht(e,t):Xt(Vt(e.slice(0,n),t),Vt(e.slice(n),t),t)},Ht=function(e,t){for(var r,n,i=e.length,s=1;s<i;){for(n=s,r=e[s];n&&t(e[n-1],r)>0;)e[n]=e[--n];n!==s++&&(e[n]=r);}return e},Xt=function(e,t,r){for(var n=e.length,i=t.length,s=0,o=0,a=[];s<n||o<i;)s<n&&o<i?a.push(r(e[s],t[o])<=0?e[s++]:t[o++]):a.push(s<n?e[s++]:t[o++]);return a},zt=Vt,Wt=wt.match(/firefox\/(\d+)/i),Yt=!!Wt&&+Wt[1],Qt=/MSIE|Trident/.test(wt),Jt=wt.match(/AppleWebKit\/(\d+)\./),Kt=!!Jt&&+Jt[1],Zt=[],er=Zt.sort,tr=Z((function(){Zt.sort(void 0);})),rr=Z((function(){Zt.sort(null);})),nr=!!(Gt=[]["sort"])&&Z((function(){Gt.call(null,function(){throw 1},1);})),ir=!Z((function(){if(xt)return xt<70;if(!(Yt&&Yt>3)){if(Qt)return !0;if(Kt)return Kt<603;var e,t,r,n,i="";for(e=65;e<76;e++){switch(t=String.fromCharCode(e),e){case 66:case 69:case 70:case 72:r=3;break;case 68:case 71:r=4;break;default:r=2;}for(n=0;n<47;n++)Zt.push({k:t+n,v:r});}for(Zt.sort((function(e,t){return t.v-e.v})),n=0;n<Zt.length;n++)t=Zt[n].k.charAt(0),i.charAt(i.length-1)!==t&&(i+=t);return "DGBEFHACIJK"!==i}}));St({target:"Array",proto:!0,forced:tr||!rr||!nr||!ir},{sort:function(e){void 0!==e&&vt(e);var t=he(this);if(ir)return void 0===e?er.call(t):er.call(t,e);var r,n,i=[],s=it(t.length);for(n=0;n<s;n++)n in t&&i.push(t[n]);for(r=(i=zt(i,function(e){return function(t,r){return void 0===r?-1:void 0===t?1:void 0!==e?+e(t,r)||0:String(t)>String(r)?1:-1}}(e))).length,n=0;n<r;)t[n]=i[n++];for(;n<s;)delete t[n++];return t}});var sr={},or=$t("iterator"),ar=Array.prototype,ur={};ur[$t("toStringTag")]="z";var cr="[object z]"===String(ur),lr=$t("toStringTag"),pr="Arguments"==oe(function(){return arguments}()),Dr=cr?oe:function(e){var t,r,n;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(r=function(e,t){try{return e[t]}catch(e){}}(t=Object(e),lr))?r:pr?oe(t):"Object"==(n=oe(t))&&"function"==typeof t.callee?"Arguments":n},hr=$t("iterator"),dr=function(e){var t=e.return;if(void 0!==t)return ye(t.call(e)).value},fr=function(e,t){this.stopped=e,this.result=t;},mr=function(e,t,r){var n,i,s,o,a,u,c,l,p=r&&r.that,D=!(!r||!r.AS_ENTRIES),h=!(!r||!r.IS_ITERATOR),d=!(!r||!r.INTERRUPTED),f=bt(t,p,1+D+d),m=function(e){return n&&dr(n),new fr(!0,e)},g=function(e){return D?(ye(e),d?f(e[0],e[1],m):f(e[0],e[1])):d?f(e,m):f(e)};if(h)n=e;else {if("function"!=typeof(i=function(e){if(null!=e)return e[hr]||e["@@iterator"]||sr[Dr(e)]}(e)))throw TypeError("Target is not iterable");if(void 0!==(l=i)&&(sr.Array===l||ar[or]===l)){for(s=0,o=it(e.length);o>s;s++)if((a=g(e[s]))&&a instanceof fr)return a;return new fr(!1)}n=i.call(e);}for(u=n.next;!(c=u.call(n)).done;){try{a=g(c.value);}catch(e){throw dr(n),e}if("object"==typeof a&&a&&a instanceof fr)return a}return new fr(!1)};St({target:"Object",stat:!0},{fromEntries:function(e){var t={};return mr(e,(function(e,r){!function(e,t,r){var n=De(t);n in e?_e.f(e,n,ie(0,r)):e[n]=r;}(t,e,r);}),{AS_ENTRIES:!0}),t}});var gr=void 0!==gr?gr:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{};function Er(){throw new Error("setTimeout has not been defined")}function Cr(){throw new Error("clearTimeout has not been defined")}var Tr=Er,yr=Cr;function Sr(e){if(Tr===setTimeout)return setTimeout(e,0);if((Tr===Er||!Tr)&&setTimeout)return Tr=setTimeout,setTimeout(e,0);try{return Tr(e,0)}catch(t){try{return Tr.call(null,e,0)}catch(t){return Tr.call(this,e,0)}}}"function"==typeof gr.setTimeout&&(Tr=setTimeout),"function"==typeof gr.clearTimeout&&(yr=clearTimeout);var _r,vr=[],br=!1,Fr=-1;function Ar(){br&&_r&&(br=!1,_r.length?vr=_r.concat(vr):Fr=-1,vr.length&&wr());}function wr(){if(!br){var e=Sr(Ar);br=!0;for(var t=vr.length;t;){for(_r=vr,vr=[];++Fr<t;)_r&&_r[Fr].run();Fr=-1,t=vr.length;}_r=null,br=!1,function(e){if(yr===clearTimeout)return clearTimeout(e);if((yr===Cr||!yr)&&clearTimeout)return yr=clearTimeout,clearTimeout(e);try{yr(e);}catch(t){try{return yr.call(null,e)}catch(t){return yr.call(this,e)}}}(e);}}function Nr(e,t){this.fun=e,this.array=t;}Nr.prototype.run=function(){this.fun.apply(null,this.array);};function kr(){}var Or=kr,xr=kr,Ir=kr,Pr=kr,Rr=kr,Lr=kr,Br=kr;var $r=gr.performance||{},qr=$r.now||$r.mozNow||$r.msNow||$r.oNow||$r.webkitNow||function(){return (new Date).getTime()};var Mr=new Date;var Ur={nextTick:function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];vr.push(new Nr(e,t)),1!==vr.length||br||Sr(wr);},title:"browser",browser:!0,env:{},argv:[],version:"",versions:{},on:Or,addListener:xr,once:Ir,off:Pr,removeListener:Rr,removeAllListeners:Lr,emit:Br,binding:function(e){throw new Error("process.binding is not supported")},cwd:function(){return "/"},chdir:function(e){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(e){var t=.001*qr.call($r),r=Math.floor(t),n=Math.floor(t%1*1e9);return e&&(r-=e[0],(n-=e[1])<0&&(r--,n+=1e9)),[r,n]},platform:"browser",release:{},config:{},uptime:function(){return (new Date-Mr)/1e3}};var Gr="object"==typeof Ur&&Ur.env&&Ur.env.NODE_DEBUG&&/\bsemver\b/i.test(Ur.env.NODE_DEBUG)?(...e)=>console.error("SEMVER",...e):()=>{};var jr={SEMVER_SPEC_VERSION:"2.0.0",MAX_LENGTH:256,MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER||9007199254740991,MAX_SAFE_COMPONENT_LENGTH:16},Vr=t$1((function(e,t){const{MAX_SAFE_COMPONENT_LENGTH:r}=jr,n=(t=e.exports={}).re=[],i=t.src=[],s=t.t={};let o=0;const a=(e,t,r)=>{const a=o++;Gr(a,t),s[e]=a,i[a]=t,n[a]=new RegExp(t,r?"g":void 0);};a("NUMERICIDENTIFIER","0|[1-9]\\d*"),a("NUMERICIDENTIFIERLOOSE","[0-9]+"),a("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),a("MAINVERSION",`(${i[s.NUMERICIDENTIFIER]})\\.(${i[s.NUMERICIDENTIFIER]})\\.(${i[s.NUMERICIDENTIFIER]})`),a("MAINVERSIONLOOSE",`(${i[s.NUMERICIDENTIFIERLOOSE]})\\.(${i[s.NUMERICIDENTIFIERLOOSE]})\\.(${i[s.NUMERICIDENTIFIERLOOSE]})`),a("PRERELEASEIDENTIFIER",`(?:${i[s.NUMERICIDENTIFIER]}|${i[s.NONNUMERICIDENTIFIER]})`),a("PRERELEASEIDENTIFIERLOOSE",`(?:${i[s.NUMERICIDENTIFIERLOOSE]}|${i[s.NONNUMERICIDENTIFIER]})`),a("PRERELEASE",`(?:-(${i[s.PRERELEASEIDENTIFIER]}(?:\\.${i[s.PRERELEASEIDENTIFIER]})*))`),a("PRERELEASELOOSE",`(?:-?(${i[s.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i[s.PRERELEASEIDENTIFIERLOOSE]})*))`),a("BUILDIDENTIFIER","[0-9A-Za-z-]+"),a("BUILD",`(?:\\+(${i[s.BUILDIDENTIFIER]}(?:\\.${i[s.BUILDIDENTIFIER]})*))`),a("FULLPLAIN",`v?${i[s.MAINVERSION]}${i[s.PRERELEASE]}?${i[s.BUILD]}?`),a("FULL",`^${i[s.FULLPLAIN]}$`),a("LOOSEPLAIN",`[v=\\s]*${i[s.MAINVERSIONLOOSE]}${i[s.PRERELEASELOOSE]}?${i[s.BUILD]}?`),a("LOOSE",`^${i[s.LOOSEPLAIN]}$`),a("GTLT","((?:<|>)?=?)"),a("XRANGEIDENTIFIERLOOSE",`${i[s.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),a("XRANGEIDENTIFIER",`${i[s.NUMERICIDENTIFIER]}|x|X|\\*`),a("XRANGEPLAIN",`[v=\\s]*(${i[s.XRANGEIDENTIFIER]})(?:\\.(${i[s.XRANGEIDENTIFIER]})(?:\\.(${i[s.XRANGEIDENTIFIER]})(?:${i[s.PRERELEASE]})?${i[s.BUILD]}?)?)?`),a("XRANGEPLAINLOOSE",`[v=\\s]*(${i[s.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[s.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[s.XRANGEIDENTIFIERLOOSE]})(?:${i[s.PRERELEASELOOSE]})?${i[s.BUILD]}?)?)?`),a("XRANGE",`^${i[s.GTLT]}\\s*${i[s.XRANGEPLAIN]}$`),a("XRANGELOOSE",`^${i[s.GTLT]}\\s*${i[s.XRANGEPLAINLOOSE]}$`),a("COERCE",`(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`),a("COERCERTL",i[s.COERCE],!0),a("LONETILDE","(?:~>?)"),a("TILDETRIM",`(\\s*)${i[s.LONETILDE]}\\s+`,!0),t.tildeTrimReplace="$1~",a("TILDE",`^${i[s.LONETILDE]}${i[s.XRANGEPLAIN]}$`),a("TILDELOOSE",`^${i[s.LONETILDE]}${i[s.XRANGEPLAINLOOSE]}$`),a("LONECARET","(?:\\^)"),a("CARETTRIM",`(\\s*)${i[s.LONECARET]}\\s+`,!0),t.caretTrimReplace="$1^",a("CARET",`^${i[s.LONECARET]}${i[s.XRANGEPLAIN]}$`),a("CARETLOOSE",`^${i[s.LONECARET]}${i[s.XRANGEPLAINLOOSE]}$`),a("COMPARATORLOOSE",`^${i[s.GTLT]}\\s*(${i[s.LOOSEPLAIN]})$|^$`),a("COMPARATOR",`^${i[s.GTLT]}\\s*(${i[s.FULLPLAIN]})$|^$`),a("COMPARATORTRIM",`(\\s*)${i[s.GTLT]}\\s*(${i[s.LOOSEPLAIN]}|${i[s.XRANGEPLAIN]})`,!0),t.comparatorTrimReplace="$1$2$3",a("HYPHENRANGE",`^\\s*(${i[s.XRANGEPLAIN]})\\s+-\\s+(${i[s.XRANGEPLAIN]})\\s*$`),a("HYPHENRANGELOOSE",`^\\s*(${i[s.XRANGEPLAINLOOSE]})\\s+-\\s+(${i[s.XRANGEPLAINLOOSE]})\\s*$`),a("STAR","(<|>)?=?\\s*\\*"),a("GTE0","^\\s*>=\\s*0.0.0\\s*$"),a("GTE0PRE","^\\s*>=\\s*0.0.0-0\\s*$");}));const Hr=["includePrerelease","loose","rtl"];var Xr=e=>e?"object"!=typeof e?{loose:!0}:Hr.filter((t=>e[t])).reduce(((e,t)=>(e[t]=!0,e)),{}):{};const zr=/^[0-9]+$/,Wr=(e,t)=>{const r=zr.test(e),n=zr.test(t);return r&&n&&(e=+e,t=+t),e===t?0:r&&!n?-1:n&&!r?1:e<t?-1:1};var Yr={compareIdentifiers:Wr,rcompareIdentifiers:(e,t)=>Wr(t,e)};const{MAX_LENGTH:Qr,MAX_SAFE_INTEGER:Jr}=jr,{re:Kr,t:Zr}=Vr,{compareIdentifiers:en}=Yr;class tn{constructor(e,t){if(t=Xr(t),e instanceof tn){if(e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease)return e;e=e.version;}else if("string"!=typeof e)throw new TypeError(`Invalid Version: ${e}`);if(e.length>Qr)throw new TypeError(`version is longer than ${Qr} characters`);Gr("SemVer",e,t),this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease;const r=e.trim().match(t.loose?Kr[Zr.LOOSE]:Kr[Zr.FULL]);if(!r)throw new TypeError(`Invalid Version: ${e}`);if(this.raw=e,this.major=+r[1],this.minor=+r[2],this.patch=+r[3],this.major>Jr||this.major<0)throw new TypeError("Invalid major version");if(this.minor>Jr||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>Jr||this.patch<0)throw new TypeError("Invalid patch version");r[4]?this.prerelease=r[4].split(".").map((e=>{if(/^[0-9]+$/.test(e)){const t=+e;if(t>=0&&t<Jr)return t}return e})):this.prerelease=[],this.build=r[5]?r[5].split("."):[],this.format();}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(e){if(Gr("SemVer.compare",this.version,this.options,e),!(e instanceof tn)){if("string"==typeof e&&e===this.version)return 0;e=new tn(e,this.options);}return e.version===this.version?0:this.compareMain(e)||this.comparePre(e)}compareMain(e){return e instanceof tn||(e=new tn(e,this.options)),en(this.major,e.major)||en(this.minor,e.minor)||en(this.patch,e.patch)}comparePre(e){if(e instanceof tn||(e=new tn(e,this.options)),this.prerelease.length&&!e.prerelease.length)return -1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;let t=0;do{const r=this.prerelease[t],n=e.prerelease[t];if(Gr("prerelease compare",t,r,n),void 0===r&&void 0===n)return 0;if(void 0===n)return 1;if(void 0===r)return -1;if(r!==n)return en(r,n)}while(++t)}compareBuild(e){e instanceof tn||(e=new tn(e,this.options));let t=0;do{const r=this.build[t],n=e.build[t];if(Gr("prerelease compare",t,r,n),void 0===r&&void 0===n)return 0;if(void 0===n)return 1;if(void 0===r)return -1;if(r!==n)return en(r,n)}while(++t)}inc(e,t){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t),this.inc("pre",t);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",t),this.inc("pre",t);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {let e=this.prerelease.length;for(;--e>=0;)"number"==typeof this.prerelease[e]&&(this.prerelease[e]++,e=-2);-1===e&&this.prerelease.push(0);}t&&(this.prerelease[0]===t?isNaN(this.prerelease[1])&&(this.prerelease=[t,0]):this.prerelease=[t,0]);break;default:throw new Error(`invalid increment argument: ${e}`)}return this.format(),this.raw=this.version,this}}var rn=tn;var nn=(e,t,r)=>new rn(e,r).compare(new rn(t,r));var sn=(e,t,r)=>nn(e,t,r)<0;var on$1=(e,t,r)=>nn(e,t,r)>=0,an="2.3.2",un=t$1((function(e,t){function r(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];}function n(){return "undefined"!=typeof WeakMap?new WeakMap:{add:r,delete:r,get:r,set:r,has:function(e){return !1}}}Object.defineProperty(t,"__esModule",{value:!0}),t.outdent=void 0;var i=Object.prototype.hasOwnProperty,s=function(e,t){return i.call(e,t)};function o(e,t){for(var r in t)s(t,r)&&(e[r]=t[r]);return e}var a=/^[ \t]*(?:\r\n|\r|\n)/,u=/(?:\r\n|\r|\n)[ \t]*$/,c=/^(?:[\r\n]|$)/,l=/(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/,p=/^[ \t]*[\r\n][ \t\r\n]*$/;function D(e,t,r){var n=0,i=e[0].match(l);i&&(n=i[1].length);var s=new RegExp("(\\r\\n|\\r|\\n).{0,"+n+"}","g");t&&(e=e.slice(1));var o=r.newline,c=r.trimLeadingNewline,p=r.trimTrailingNewline,D="string"==typeof o,h=e.length;return e.map((function(e,t){return e=e.replace(s,"$1"),0===t&&c&&(e=e.replace(a,"")),t===h-1&&p&&(e=e.replace(u,"")),D&&(e=e.replace(/\r\n|\n|\r/g,(function(e){return o}))),e}))}function h(e,t){for(var r="",n=0,i=e.length;n<i;n++)r+=e[n],n<i-1&&(r+=t[n]);return r}function d(e){return s(e,"raw")&&s(e,"length")}var f=function e(t){var r=n(),i=n();return o((function n(s){for(var a=[],u=1;u<arguments.length;u++)a[u-1]=arguments[u];if(d(s)){var l=s,m=(a[0]===n||a[0]===f)&&p.test(l[0])&&c.test(l[1]),g=m?i:r,E=g.get(l);if(E||(E=D(l,m,t),g.set(l,E)),0===a.length)return E[0];var C=h(E,m?a.slice(1):a);return C}return e(o(o({},t),s||{}))}),{string:function(e){return D([e],!1,t)[0]}})}({trimLeadingNewline:!0,trimTrailingNewline:!0});t.outdent=f,t.default=f;try{e.exports=f,Object.defineProperty(f,"__esModule",{value:!0}),f.default=f,f.outdent=f;}catch(e){}}));const{outdent:cn}=un,ln={cursorOffset:{since:"1.4.0",category:"Special",type:"int",default:-1,range:{start:-1,end:Number.POSITIVE_INFINITY,step:1},description:cn`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,cliCategory:"Editor"},endOfLine:{since:"1.15.0",category:"Global",type:"choice",default:[{since:"1.15.0",value:"auto"},{since:"2.0.0",value:"lf"}],description:"Which end of line characters to apply.",choices:[{value:"lf",description:"Line Feed only (\\n), common on Linux and macOS as well as inside git repos"},{value:"crlf",description:"Carriage Return + Line Feed characters (\\r\\n), common on Windows"},{value:"cr",description:"Carriage Return character only (\\r), used very rarely"},{value:"auto",description:cn`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]},filepath:{since:"1.4.0",category:"Special",type:"path",description:"Specify the input filepath. This will be used to do parser inference.",cliName:"stdin-filepath",cliCategory:"Other",cliDescription:"Path to the file to pretend that stdin comes from."},insertPragma:{since:"1.8.0",category:"Special",type:"boolean",default:!1,description:"Insert @format pragma into file's first docblock comment.",cliCategory:"Other"},parser:{since:"0.0.10",category:"Global",type:"choice",default:[{since:"0.0.10",value:"babylon"},{since:"1.13.0",value:void 0}],description:"Which parser to use.",exception:e=>"string"==typeof e||"function"==typeof e,choices:[{value:"flow",description:"Flow"},{value:"babel",since:"1.16.0",description:"JavaScript"},{value:"babel-flow",since:"1.16.0",description:"Flow"},{value:"babel-ts",since:"2.0.0",description:"TypeScript"},{value:"typescript",since:"1.4.0",description:"TypeScript"},{value:"espree",since:"2.2.0",description:"JavaScript"},{value:"meriyah",since:"2.2.0",description:"JavaScript"},{value:"css",since:"1.7.1",description:"CSS"},{value:"less",since:"1.7.1",description:"Less"},{value:"scss",since:"1.7.1",description:"SCSS"},{value:"json",since:"1.5.0",description:"JSON"},{value:"json5",since:"1.13.0",description:"JSON5"},{value:"json-stringify",since:"1.13.0",description:"JSON.stringify"},{value:"graphql",since:"1.5.0",description:"GraphQL"},{value:"markdown",since:"1.8.0",description:"Markdown"},{value:"mdx",since:"1.15.0",description:"MDX"},{value:"vue",since:"1.10.0",description:"Vue"},{value:"yaml",since:"1.14.0",description:"YAML"},{value:"glimmer",since:"2.3.0",description:"Ember / Handlebars"},{value:"html",since:"1.15.0",description:"HTML"},{value:"angular",since:"1.15.0",description:"Angular"},{value:"lwc",since:"1.17.0",description:"Lightning Web Components"}]},plugins:{since:"1.10.0",type:"path",array:!0,default:[{value:[]}],category:"Global",description:"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",exception:e=>"string"==typeof e||"object"==typeof e,cliName:"plugin",cliCategory:"Config"},pluginSearchDirs:{since:"1.13.0",type:"path",array:!0,default:[{value:[]}],category:"Global",description:cn`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,exception:e=>"string"==typeof e||"object"==typeof e,cliName:"plugin-search-dir",cliCategory:"Config"},printWidth:{since:"0.0.0",category:"Global",type:"int",default:80,description:"The line length where Prettier will try wrap.",range:{start:0,end:Number.POSITIVE_INFINITY,step:1}},rangeEnd:{since:"1.4.0",category:"Special",type:"int",default:Number.POSITIVE_INFINITY,range:{start:0,end:Number.POSITIVE_INFINITY,step:1},description:cn`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,cliCategory:"Editor"},rangeStart:{since:"1.4.0",category:"Special",type:"int",default:0,range:{start:0,end:Number.POSITIVE_INFINITY,step:1},description:cn`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,cliCategory:"Editor"},requirePragma:{since:"1.7.0",category:"Special",type:"boolean",default:!1,description:cn`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,cliCategory:"Other"},tabWidth:{type:"int",category:"Global",default:2,description:"Number of spaces per indentation level.",range:{start:0,end:Number.POSITIVE_INFINITY,step:1}},useTabs:{since:"1.0.0",category:"Global",type:"boolean",default:!1,description:"Indent with tabs instead of spaces."},embeddedLanguageFormatting:{since:"2.1.0",category:"Global",type:"choice",default:[{since:"2.1.0",value:"auto"}],description:"Control how Prettier formats quoted code embedded in the file.",choices:[{value:"auto",description:"Format embedded code if Prettier can automatically identify it."},{value:"off",description:"Never automatically format embedded code."}]}};const pn=["cliName","cliCategory","cliDescription"],Dn={compare:nn,lt:sn,gte:on$1},hn=an,dn={CATEGORY_CONFIG:"Config",CATEGORY_EDITOR:"Editor",CATEGORY_FORMAT:"Format",CATEGORY_OTHER:"Other",CATEGORY_OUTPUT:"Output",CATEGORY_GLOBAL:"Global",CATEGORY_SPECIAL:"Special",options:ln}.options;var fn={getSupportInfo:function({plugins:e=[],showUnreleased:t=!1,showDeprecated:r=!1,showInternal:n=!1}={}){const i=hn.split("-",1)[0],s=e.flatMap((e=>e.languages||[])).filter(a),o=((e,t)=>Object.entries(e).map((([e,r])=>Object.assign({[t]:e},r))))(Object.assign({},...e.map((({options:e})=>e)),dn),"name").filter((e=>a(e)&&u(e))).sort(((e,t)=>e.name===t.name?0:e.name<t.name?-1:1)).map((function(e){if(n)return e;return Q(e,pn)})).map((t=>{t=Object.assign({},t),Array.isArray(t.default)&&(t.default=1===t.default.length?t.default[0].value:t.default.filter(a).sort(((e,t)=>Dn.compare(t.since,e.since)))[0].value),Array.isArray(t.choices)&&(t.choices=t.choices.filter((e=>a(e)&&u(e))),"parser"===t.name&&function(e,t,r){const n=new Set(e.choices.map((e=>e.value)));for(const i of t)if(i.parsers)for(const t of i.parsers)if(!n.has(t)){n.add(t);const s=r.find((e=>e.parsers&&e.parsers[t]));let o=i.name;s&&s.name&&(o+=` (plugin: ${s.name})`),e.choices.push({value:t,description:o});}}(t,s,e));const r=Object.fromEntries(e.filter((e=>e.defaultOptions&&void 0!==e.defaultOptions[t.name])).map((e=>[e.name,e.defaultOptions[t.name]])));return Object.assign(Object.assign({},t),{},{pluginDefaults:r})}));return {languages:s,options:o};function a(e){return t||!("since"in e)||e.since&&Dn.gte(i,e.since)}function u(e){return r||!("deprecated"in e)||e.deprecated&&Dn.lt(i,e.deprecated)}}};const{getSupportInfo:mn}=fn,gn=/[^\x20-\x7F]/;function En(e){return (t,r,n)=>{const i=n&&n.backwards;if(!1===r)return !1;const{length:s}=t;let o=r;for(;o>=0&&o<s;){const r=t.charAt(o);if(e instanceof RegExp){if(!e.test(r))return o}else if(!e.includes(r))return o;i?o--:o++;}return (-1===o||o===s)&&o}}const Cn=En(/\s/),Tn=En(" \t"),yn=En(",; \t"),Sn=En(/[^\n\r]/);function _n(e,t){if(!1===t)return !1;if("/"===e.charAt(t)&&"*"===e.charAt(t+1))for(let r=t+2;r<e.length;++r)if("*"===e.charAt(r)&&"/"===e.charAt(r+1))return r+2;return t}function vn(e,t){return !1!==t&&("/"===e.charAt(t)&&"/"===e.charAt(t+1)?Sn(e,t):t)}function bn(e,t,r){const n=r&&r.backwards;if(!1===t)return !1;const i=e.charAt(t);if(n){if("\r"===e.charAt(t-1)&&"\n"===i)return t-2;if("\n"===i||"\r"===i||"\u2028"===i||"\u2029"===i)return t-1}else {if("\r"===i&&"\n"===e.charAt(t+1))return t+2;if("\n"===i||"\r"===i||"\u2028"===i||"\u2029"===i)return t+1}return t}function Fn(e,t,r={}){const n=Tn(e,r.backwards?t-1:t,r);return n!==bn(e,n,r)}function An(e,t){let r=null,n=t;for(;n!==r;)r=n,n=yn(e,n),n=_n(e,n),n=Tn(e,n);return n=vn(e,n),n=bn(e,n),!1!==n&&Fn(e,n)}function wn(e,t){let r=null,n=t;for(;n!==r;)r=n,n=Tn(e,n),n=_n(e,n),n=vn(e,n),n=bn(e,n);return n}function Nn(e,t,r){return wn(e,r(t))}function kn(e,t,r=0){let n=0;for(let i=r;i<e.length;++i)"\t"===e[i]?n=n+t-n%t:n++;return n}function On(e,t){const r=e.slice(1,-1),n={quote:'"',regex:/"/g},i={quote:"'",regex:/'/g},s="'"===t?i:n,o=s===i?n:i;let a=s.quote;if(r.includes(s.quote)||r.includes(o.quote)){a=(r.match(s.regex)||[]).length>(r.match(o.regex)||[]).length?o.quote:s.quote;}return a}function xn(e,t,r){const n='"'===t?"'":'"',i=e.replace(/\\(.)|(["'])/gs,((e,i,s)=>i===n?i:s===t?"\\"+s:s||(r&&/^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i)?i:"\\"+i)));return t+i+t}function In(e,t){(e.comments||(e.comments=[])).push(t),t.printed=!1,t.nodeDescription=function(e){const t=e.type||e.kind||"(unknown type)";let r=String(e.name||e.id&&("object"==typeof e.id?e.id.name:e.id)||e.key&&("object"==typeof e.key?e.key.name:e.key)||e.value&&("object"==typeof e.value?"":String(e.value))||e.operator||"");r.length>20&&(r=r.slice(0,19)+"\u2026");return t+(r?" "+r:"")}(e);}var Pn={inferParserByLanguage:function(e,t){const{languages:r}=mn({plugins:t.plugins}),n=r.find((({name:t})=>t.toLowerCase()===e))||r.find((({aliases:t})=>Array.isArray(t)&&t.includes(e)))||r.find((({extensions:t})=>Array.isArray(t)&&t.includes(`.${e}`)));return n&&n.parsers[0]},getStringWidth:function(e){return e?gn.test(e)?z(e):e.length:0},getMaxContinuousCount:function(e,t){const r=e.match(new RegExp(`(${Y(t)})+`,"g"));return null===r?0:r.reduce(((e,r)=>Math.max(e,r.length/t.length)),0)},getMinNotPresentContinuousCount:function(e,t){const r=e.match(new RegExp(`(${Y(t)})+`,"g"));if(null===r)return 0;const n=new Map;let i=0;for(const e of r){const r=e.length/t.length;n.set(r,!0),r>i&&(i=r);}for(let e=1;e<i;e++)if(!n.get(e))return e;return i+1},getPenultimate:e=>e[e.length-2],getLast:M,getNextNonSpaceNonCommentCharacterIndexWithStartIndex:wn,getNextNonSpaceNonCommentCharacterIndex:Nn,getNextNonSpaceNonCommentCharacter:function(e,t,r){return e.charAt(Nn(e,t,r))},skip:En,skipWhitespace:Cn,skipSpaces:Tn,skipToLineEnd:yn,skipEverythingButNewLine:Sn,skipInlineComment:_n,skipTrailingComment:vn,skipNewline:bn,isNextLineEmptyAfterIndex:An,isNextLineEmpty:function(e,t,r){return An(e,r(t))},isPreviousLineEmpty:function(e,t,r){let n=r(t)-1;return n=Tn(e,n,{backwards:!0}),n=bn(e,n,{backwards:!0}),n=Tn(e,n,{backwards:!0}),n!==bn(e,n,{backwards:!0})},hasNewline:Fn,hasNewlineInRange:function(e,t,r){for(let n=t;n<r;++n)if("\n"===e.charAt(n))return !0;return !1},hasSpaces:function(e,t,r={}){return Tn(e,r.backwards?t-1:t,r)!==t},getAlignmentSize:kn,getIndentSize:function(e,t){const r=e.lastIndexOf("\n");return -1===r?0:kn(e.slice(r+1).match(/^[\t ]*/)[0],t)},getPreferredQuote:On,printString:function(e,t){return xn(e.slice(1,-1),"json"===t.parser||"json5"===t.parser&&"preserve"===t.quoteProps&&!t.singleQuote?'"':t.__isInHtmlAttribute?"'":On(e,t.singleQuote?"'":'"'),!("css"===t.parser||"less"===t.parser||"scss"===t.parser||t.__embeddedInHtml))},printNumber:function(e){return e.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/,"$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/,"$1").replace(/^([+-])?\./,"$10.").replace(/(\.\d+?)0+(?=e|$)/,"$1").replace(/\.(?=e|$)/,"")},makeString:xn,addLeadingComment:function(e,t){t.leading=!0,t.trailing=!1,In(e,t);},addDanglingComment:function(e,t,r){t.leading=!1,t.trailing=!1,r&&(t.marker=r),In(e,t);},addTrailingComment:function(e,t){t.leading=!1,t.trailing=!0,In(e,t);},isFrontMatterNode:function(e){return e&&"front-matter"===e.type},getShebang:function(e){if(!e.startsWith("#!"))return "";const t=e.indexOf("\n");return -1===t?e:e.slice(0,t)},isNonEmptyArray:function(e){return Array.isArray(e)&&e.length>0},createGroupIdMapper:function(e){const t=new WeakMap;return function(r){return t.has(r)||t.set(r,Symbol(e)),t.get(r)}}},Rn={"*":["accesskey","autocapitalize","autofocus","class","contenteditable","dir","draggable","enterkeyhint","hidden","id","inputmode","is","itemid","itemprop","itemref","itemscope","itemtype","lang","nonce","slot","spellcheck","style","tabindex","title","translate"],a:["accesskey","charset","coords","download","href","hreflang","name","ping","referrerpolicy","rel","rev","shape","tabindex","target","type"],abbr:["title"],applet:["align","alt","archive","code","codebase","height","hspace","name","object","vspace","width"],area:["accesskey","alt","coords","download","href","hreflang","nohref","ping","referrerpolicy","rel","shape","tabindex","target","type"],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],base:["href","target"],basefont:["color","face","size"],bdo:["dir"],blockquote:["cite"],body:["alink","background","bgcolor","link","text","vlink"],br:["clear"],button:["accesskey","autofocus","disabled","form","formaction","formenctype","formmethod","formnovalidate","formtarget","name","tabindex","type","value"],canvas:["height","width"],caption:["align"],col:["align","char","charoff","span","valign","width"],colgroup:["align","char","charoff","span","valign","width"],data:["value"],del:["cite","datetime"],details:["open"],dfn:["title"],dialog:["open"],dir:["compact"],div:["align"],dl:["compact"],embed:["height","src","type","width"],fieldset:["disabled","form","name"],font:["color","face","size"],form:["accept","accept-charset","action","autocomplete","enctype","method","name","novalidate","target"],frame:["frameborder","longdesc","marginheight","marginwidth","name","noresize","scrolling","src"],frameset:["cols","rows"],h1:["align"],h2:["align"],h3:["align"],h4:["align"],h5:["align"],h6:["align"],head:["profile"],hr:["align","noshade","size","width"],html:["manifest","version"],iframe:["align","allow","allowfullscreen","allowpaymentrequest","allowusermedia","frameborder","height","loading","longdesc","marginheight","marginwidth","name","referrerpolicy","sandbox","scrolling","src","srcdoc","width"],img:["align","alt","border","crossorigin","decoding","height","hspace","ismap","loading","longdesc","name","referrerpolicy","sizes","src","srcset","usemap","vspace","width"],input:["accept","accesskey","align","alt","autocomplete","autofocus","checked","dirname","disabled","form","formaction","formenctype","formmethod","formnovalidate","formtarget","height","ismap","list","max","maxlength","min","minlength","multiple","name","pattern","placeholder","readonly","required","size","src","step","tabindex","title","type","usemap","value","width"],ins:["cite","datetime"],isindex:["prompt"],label:["accesskey","for","form"],legend:["accesskey","align"],li:["type","value"],link:["as","charset","color","crossorigin","disabled","href","hreflang","imagesizes","imagesrcset","integrity","media","nonce","referrerpolicy","rel","rev","sizes","target","title","type"],map:["name"],menu:["compact"],meta:["charset","content","http-equiv","name","scheme"],meter:["high","low","max","min","optimum","value"],object:["align","archive","border","classid","codebase","codetype","data","declare","form","height","hspace","name","standby","tabindex","type","typemustmatch","usemap","vspace","width"],ol:["compact","reversed","start","type"],optgroup:["disabled","label"],option:["disabled","label","selected","value"],output:["for","form","name"],p:["align"],param:["name","type","value","valuetype"],pre:["width"],progress:["max","value"],q:["cite"],script:["async","charset","crossorigin","defer","integrity","language","nomodule","nonce","referrerpolicy","src","type"],select:["autocomplete","autofocus","disabled","form","multiple","name","required","size","tabindex"],slot:["name"],source:["media","sizes","src","srcset","type"],style:["media","nonce","title","type"],table:["align","bgcolor","border","cellpadding","cellspacing","frame","rules","summary","width"],tbody:["align","char","charoff","valign"],td:["abbr","align","axis","bgcolor","char","charoff","colspan","headers","height","nowrap","rowspan","scope","valign","width"],textarea:["accesskey","autocomplete","autofocus","cols","dirname","disabled","form","maxlength","minlength","name","placeholder","readonly","required","rows","tabindex","wrap"],tfoot:["align","char","charoff","valign"],th:["abbr","align","axis","bgcolor","char","charoff","colspan","headers","height","nowrap","rowspan","scope","valign","width"],thead:["align","char","charoff","valign"],time:["datetime"],tr:["align","bgcolor","char","charoff","valign"],track:["default","kind","label","src","srclang"],ul:["compact","type"],video:["autoplay","controls","crossorigin","height","loop","muted","playsinline","poster","preload","src","width"]};const{inferParserByLanguage:Ln,isFrontMatterNode:Bn}=Pn,{CSS_DISPLAY_TAGS:$n,CSS_DISPLAY_DEFAULT:qn,CSS_WHITE_SPACE_TAGS:Mn,CSS_WHITE_SPACE_DEFAULT:Un}={CSS_DISPLAY_TAGS:{area:"none",base:"none",basefont:"none",datalist:"none",head:"none",link:"none",meta:"none",noembed:"none",noframes:"none",param:"block",rp:"none",script:"block",source:"block",style:"none",template:"inline",track:"block",title:"none",html:"block",body:"block",address:"block",blockquote:"block",center:"block",div:"block",figure:"block",figcaption:"block",footer:"block",form:"block",header:"block",hr:"block",legend:"block",listing:"block",main:"block",p:"block",plaintext:"block",pre:"block",xmp:"block",slot:"contents",ruby:"ruby",rt:"ruby-text",article:"block",aside:"block",h1:"block",h2:"block",h3:"block",h4:"block",h5:"block",h6:"block",hgroup:"block",nav:"block",section:"block",dir:"block",dd:"block",dl:"block",dt:"block",ol:"block",ul:"block",li:"list-item",table:"table",caption:"table-caption",colgroup:"table-column-group",col:"table-column",thead:"table-header-group",tbody:"table-row-group",tfoot:"table-footer-group",tr:"table-row",td:"table-cell",th:"table-cell",fieldset:"block",button:"inline-block",details:"block",summary:"block",dialog:"block",meter:"inline-block",progress:"inline-block",object:"inline-block",video:"inline-block",audio:"inline-block",select:"inline-block",option:"block",optgroup:"block"},CSS_DISPLAY_DEFAULT:"inline",CSS_WHITE_SPACE_TAGS:{listing:"pre",plaintext:"pre",pre:"pre",xmp:"pre",nobr:"nowrap",table:"initial",textarea:"pre-wrap"},CSS_WHITE_SPACE_DEFAULT:"normal"},Gn=Xn(["a","abbr","acronym","address","applet","area","article","aside","audio","b","base","basefont","bdi","bdo","bgsound","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","command","content","data","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","element","em","embed","fieldset","figcaption","figure","font","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","image","img","input","ins","isindex","kbd","keygen","label","legend","li","link","listing","main","map","mark","marquee","math","menu","menuitem","meta","meter","multicol","nav","nextid","nobr","noembed","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","plaintext","pre","progress","q","rb","rbc","rp","rt","rtc","ruby","s","samp","script","section","select","shadow","slot","small","source","spacer","span","strike","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","tt","u","ul","var","video","wbr","xmp"]),jn=function(e,t){const r=Object.create(null);for(const[n,i]of Object.entries(e))r[n]=t(i,n);return r}(Rn,Xn),Vn=new Set(["\t","\n","\f","\r"," "]),Hn=e=>e.replace(/[\t\n\f\r ]+$/,"");function Xn(e){const t=Object.create(null);for(const r of e)t[r]=!0;return t}function zn(e,t){return !("ieConditionalComment"!==e.type||!e.lastChild||e.lastChild.isSelfClosing||e.lastChild.endSourceSpan)||("ieConditionalComment"===e.type&&!e.complete||(!(!si(e)||!e.children.some((e=>"text"!==e.type&&"interpolation"!==e.type)))||!(!pi(e,t)||Yn(e)||"interpolation"===e.type)))}function Wn(e){if("attribute"===e.type)return !1;if(!e.parent)return !1;if("number"!=typeof e.index||0===e.index)return !1;return function(e){return "comment"===e.type&&"prettier-ignore"===e.value.trim()}(e.parent.children[e.index-1])}function Yn(e){return "element"===e.type&&("script"===e.fullName||"style"===e.fullName||"svg:style"===e.fullName||oi(e)&&("script"===e.name||"style"===e.name))}function Qn(e){return ai(e).startsWith("pre")}function Jn(e){return "element"===e.type&&e.children.length>0&&(["html","head","ul","ol","select"].includes(e.name)||e.cssDisplay.startsWith("table")&&"table-cell"!==e.cssDisplay)}function Kn(e){return ri(e)||"element"===e.type&&"br"===e.fullName||Zn(e)}function Zn(e){return ei(e)&&ti(e)}function ei(e){return e.hasLeadingSpaces&&(e.prev?e.prev.sourceSpan.end.line<e.sourceSpan.start.line:"root"===e.parent.type||e.parent.startSourceSpan.end.line<e.sourceSpan.start.line)}function ti(e){return e.hasTrailingSpaces&&(e.next?e.next.sourceSpan.start.line>e.sourceSpan.end.line:"root"===e.parent.type||e.parent.endSourceSpan&&e.parent.endSourceSpan.start.line>e.sourceSpan.end.line)}function ri(e){switch(e.type){case"ieConditionalComment":case"comment":case"directive":return !0;case"element":return ["script","select"].includes(e.name)}return !1}function ni(e){const{type:t,lang:r}=e.attrMap;return "module"===t||"text/javascript"===t||"text/babel"===t||"application/javascript"===t||"jsx"===r?"babel":"application/x-typescript"===t||"ts"===r||"tsx"===r?"typescript":"text/markdown"===t?"markdown":"text/html"===t?"html":t&&(t.endsWith("json")||t.endsWith("importmap"))?"json":"text/x-handlebars-template"===t?"glimmer":void 0}function ii(e){return "block"===e||"list-item"===e||e.startsWith("table")}function si(e){return ai(e).startsWith("pre")}function oi(e){return "element"===e.type&&!e.hasExplicitNamespace&&!["html","svg"].includes(e.namespace)}function ai(e){return "element"===e.type&&(!e.namespace||oi(e))&&Mn[e.name]||Un}const ui=new Set(["template","style","script"]);function ci(e,t){return li(e,t)&&!ui.has(e.fullName)}function li(e,t){return "vue"===t.parser&&"element"===e.type&&"root"===e.parent.type&&"html"!==e.fullName.toLowerCase()}function pi(e,t){return li(e,t)&&(ci(e,t)||e.attrMap.lang&&"html"!==e.attrMap.lang)}var Di={HTML_ELEMENT_ATTRIBUTES:jn,HTML_TAGS:Gn,htmlTrim:e=>(e=>e.replace(/^[\t\n\f\r ]+/,""))(Hn(e)),htmlTrimPreserveIndentation:e=>(e=>e.replace(/^[\t\f\r ]*?\n/g,""))(Hn(e)),splitByHtmlWhitespace:e=>e.split(/[\t\n\f\r ]+/),hasHtmlWhitespace:e=>/[\t\n\f\r ]/.test(e),getLeadingAndTrailingHtmlWhitespace:e=>{const[,t,r,n]=e.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);return {leadingWhitespace:t,trailingWhitespace:n,text:r}},canHaveInterpolation:function(e){return e.children&&!Yn(e)},countChars:function(e,t){let r=0;for(let n=0;n<e.length;n++)e[n]===t&&r++;return r},countParents:function(e,t){let r=0;for(let n=e.stack.length-1;n>=0;n--){const i=e.stack[n];i&&"object"==typeof i&&!Array.isArray(i)&&t(i)&&r++;}return r},dedentString:function(e,t=function(e){let t=Number.POSITIVE_INFINITY;for(const n of e.split("\n")){if(0===n.length)continue;if(!Vn.has(n[0]))return 0;const e=(r=n,r.match(/^[\t\n\f\r ]*/)[0]).length;n.length!==e&&e<t&&(t=e);}var r;return t===Number.POSITIVE_INFINITY?0:t}(e)){return 0===t?e:e.split("\n").map((e=>e.slice(t))).join("\n")},forceBreakChildren:Jn,forceBreakContent:function(e){return Jn(e)||"element"===e.type&&e.children.length>0&&(["body","script","style"].includes(e.name)||e.children.some((e=>function(e){return e.children&&e.children.some((e=>"text"!==e.type))}(e))))||e.firstChild&&e.firstChild===e.lastChild&&"text"!==e.firstChild.type&&ei(e.firstChild)&&(!e.lastChild.isTrailingSpaceSensitive||ti(e.lastChild))},forceNextEmptyLine:function(e){return Bn(e)||e.next&&e.sourceSpan.end&&e.sourceSpan.end.line+1<e.next.sourceSpan.start.line},getLastDescendant:function e(t){return t.lastChild?e(t.lastChild):t},getNodeCssStyleDisplay:function(e,t){if(e.prev&&"comment"===e.prev.type){const t=e.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);if(t)return t[1]}let r=!1;if("element"===e.type&&"svg"===e.namespace){if(!function(e,t){let r=e;for(;r;){if(t(r))return !0;r=r.parent;}return !1}(e,(e=>"svg:foreignObject"===e.fullName)))return "svg"===e.name?"inline-block":"block";r=!0;}switch(t.htmlWhitespaceSensitivity){case"strict":return "inline";case"ignore":return "block";default:return "vue"===t.parser&&e.parent&&"root"===e.parent.type?"block":"element"===e.type&&(!e.namespace||r||oi(e))&&$n[e.name]||qn}},getNodeCssStyleWhiteSpace:ai,getPrettierIgnoreAttributeCommentData:function(e){const t=e.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);return !!t&&(!t[1]||t[1].split(/\s+/))},hasPrettierIgnore:Wn,inferScriptParser:function(e,t){return "script"!==e.name||e.attrMap.src?"style"===e.name?function(e){const{lang:t}=e.attrMap;return t&&"postcss"!==t&&"css"!==t?"scss"===t?"scss":"less"===t?"less":void 0:"css"}(e):t&&pi(e,t)?ni(e)||!("src"in e.attrMap)&&Ln(e.attrMap.lang,t):void 0:e.attrMap.lang||e.attrMap.type?ni(e):"babel"},isVueCustomBlock:ci,isVueNonHtmlBlock:pi,isVueSlotAttribute:function(e){const t=e.fullName;return "#"===t.charAt(0)||"slot-scope"===t||"v-slot"===t||t.startsWith("v-slot:")},isVueSfcBindingsAttribute:function(e,t){const r=e.parent;if(!li(r,t))return !1;const n=r.fullName,i=e.fullName;return "script"===n&&"setup"===i||"style"===n&&"vars"===i},isDanglingSpaceSensitiveNode:function(e){return !(t=e.cssDisplay,ii(t)||"inline-block"===t||Yn(e));var t;},isIndentationSensitiveNode:Qn,isLeadingSpaceSensitiveNode:function(e,t){const r=function(){if(Bn(e))return !1;if(("text"===e.type||"interpolation"===e.type)&&e.prev&&("text"===e.prev.type||"interpolation"===e.prev.type))return !0;if(!e.parent||"none"===e.parent.cssDisplay)return !1;if(si(e.parent))return !0;if(!e.prev&&("root"===e.parent.type||si(e)&&e.parent||Yn(e.parent)||ci(e.parent,t)||(r=e.parent.cssDisplay,ii(r)||"inline-block"===r)))return !1;var r;if(e.prev&&!function(e){return !ii(e)}(e.prev.cssDisplay))return !1;return !0}();return r&&!e.prev&&e.parent&&e.parent.tagDefinition&&e.parent.tagDefinition.ignoreFirstLf?"interpolation"===e.type:r},isPreLikeNode:si,isScriptLikeTag:Yn,isTextLikeNode:function(e){return "text"===e.type||"comment"===e.type},isTrailingSpaceSensitiveNode:function(e,t){return !Bn(e)&&(!("text"!==e.type&&"interpolation"!==e.type||!e.next||"text"!==e.next.type&&"interpolation"!==e.next.type)||!(!e.parent||"none"===e.parent.cssDisplay)&&(!!si(e.parent)||!(!e.next&&("root"===e.parent.type||si(e)&&e.parent||Yn(e.parent)||ci(e.parent,t)||(r=e.parent.cssDisplay,ii(r)||"inline-block"===r)))&&!(e.next&&!function(e){return !ii(e)}(e.next.cssDisplay))));var r;},isWhitespaceSensitiveNode:function(e){return Yn(e)||"interpolation"===e.type||Qn(e)},isUnknownNamespace:oi,preferHardlineAsLeadingSpaces:function(e){return ri(e)||e.prev&&Kn(e.prev)||Zn(e)},preferHardlineAsTrailingSpaces:Kn,shouldNotPrintClosingTag:function(e,t){return !e.isSelfClosing&&!e.endSourceSpan&&(Wn(e)||zn(e.parent,t))},shouldPreserveContent:zn,unescapeQuoteEntities:function(e){return e.replace(/&apos;/g,"'").replace(/&quot;/g,'"')}};var hi={hasPragma:function(e){return /^\s*<!--\s*@(format|prettier)\s*-->/.test(e)},insertPragma:function(e){return "\x3c!-- @format --\x3e\n\n"+e.replace(/^\s*\n/,"")}};const{isNonEmptyArray:di}=Pn,fi={attrs:!0,children:!0};class mi{constructor(e={}){for(const[t,r]of Object.entries(e))t in fi?this._setNodes(t,r):this[t]=r;}_setNodes(e,t){t!==this[e]&&(this[e]=function(e,t){const r=e.map((e=>e instanceof mi?e.clone():new mi(e)));let n=null,i=r[0],s=r[1]||null;for(let e=0;e<r.length;e++)Ei(i,{index:e,siblings:r,prev:n,next:s,parent:t}),n=i,i=s,s=r[e+2]||null;return r}(t,this),"attrs"===e&&Ei(this,{attrMap:Object.fromEntries(this[e].map((e=>[e.fullName,e.value])))}));}map(e){let t=null;for(const r in fi){const n=this[r];if(n){const i=gi(n,(t=>t.map(e)));t!==n&&(t||(t=new mi),t._setNodes(r,i));}}if(t){for(const e in this)e in fi||(t[e]=this[e]);const{index:e,siblings:r,prev:n,next:i,parent:s}=this;Ei(t,{index:e,siblings:r,prev:n,next:i,parent:s});}return e(t||this)}clone(e){return new mi(e?Object.assign(Object.assign({},this),e):this)}get firstChild(){return di(this.children)?this.children[0]:null}get lastChild(){return di(this.children)?M(this.children):null}get rawName(){return this.hasExplicitNamespace?this.fullName:this.name}get fullName(){return this.namespace?this.namespace+":"+this.name:this.name}}function gi(e,t){const r=e.map(t);return r.some(((t,r)=>t!==e[r]))?r:e}function Ei(e,t){const r=Object.fromEntries(Object.entries(t).map((([e,t])=>[e,{value:t,enumerable:!1}])));Object.defineProperties(e,r);}var Ci={Node:mi};const{ParseSourceSpan:Ti}=B,yi=[{regex:/^(\[if([^\]]*?)]>)(.*?)<!\s*\[endif]$/s,parse:function(e,t,r){const[,n,i,s]=r,o="\x3c!--".length+n.length,a=e.sourceSpan.start.moveBy(o),u=a.moveBy(s.length),[c,l]=(()=>{try{return [!0,t(s,a).children]}catch{return [!1,[{type:"text",value:s,sourceSpan:new Ti(a,u)}]]}})();return {type:"ieConditionalComment",complete:c,children:l,condition:i.trim().replace(/\s+/g," "),sourceSpan:e.sourceSpan,startSourceSpan:new Ti(e.sourceSpan.start,a),endSourceSpan:new Ti(u,e.sourceSpan.end)}}},{regex:/^\[if([^\]]*?)]><!$/,parse:function(e,t,r){const[,n]=r;return {type:"ieConditionalStartComment",condition:n.trim().replace(/\s+/g," "),sourceSpan:e.sourceSpan}}},{regex:/^<!\s*\[endif]$/,parse:function(e){return {type:"ieConditionalEndComment",sourceSpan:e.sourceSpan}}}];var Si={parseIeConditionalComment:function(e,t){if(e.value)for(const{regex:r,parse:n}of yi){const i=e.value.match(r);if(i)return n(e,t,i)}return null}};var _i={locStart:function(e){return e.sourceSpan.start.offset},locEnd:function(e){return e.sourceSpan.end.offset}},vi=t$1((function(e,t){function r(e){if(":"!=e[0])return [null,e];const t=e.indexOf(":",1);if(-1==t)throw new Error(`Unsupported format "${e}" expecting ":namespace:name"`);return [e.slice(1,t),e.slice(t+1)]}
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.RAW_TEXT=0]="RAW_TEXT",e[e.ESCAPABLE_RAW_TEXT=1]="ESCAPABLE_RAW_TEXT",e[e.PARSABLE_DATA=2]="PARSABLE_DATA";}(t.TagContentType||(t.TagContentType={})),t.splitNsName=r,t.isNgContainer=function(e){return "ng-container"===r(e)[1]},t.isNgContent=function(e){return "ng-content"===r(e)[1]},t.isNgTemplate=function(e){return "ng-template"===r(e)[1]},t.getNsPrefix=function(e){return null===e?null:r(e)[0]},t.mergeNsAndName=function(e,t){return e?`:${e}:${t}`:t},t.NAMED_ENTITIES={Aacute:"\xc1",aacute:"\xe1",Abreve:"\u0102",abreve:"\u0103",ac:"\u223e",acd:"\u223f",acE:"\u223e\u0333",Acirc:"\xc2",acirc:"\xe2",acute:"\xb4",Acy:"\u0410",acy:"\u0430",AElig:"\xc6",aelig:"\xe6",af:"\u2061",Afr:"\ud835\udd04",afr:"\ud835\udd1e",Agrave:"\xc0",agrave:"\xe0",alefsym:"\u2135",aleph:"\u2135",Alpha:"\u0391",alpha:"\u03b1",Amacr:"\u0100",amacr:"\u0101",amalg:"\u2a3f",AMP:"&",amp:"&",And:"\u2a53",and:"\u2227",andand:"\u2a55",andd:"\u2a5c",andslope:"\u2a58",andv:"\u2a5a",ang:"\u2220",ange:"\u29a4",angle:"\u2220",angmsd:"\u2221",angmsdaa:"\u29a8",angmsdab:"\u29a9",angmsdac:"\u29aa",angmsdad:"\u29ab",angmsdae:"\u29ac",angmsdaf:"\u29ad",angmsdag:"\u29ae",angmsdah:"\u29af",angrt:"\u221f",angrtvb:"\u22be",angrtvbd:"\u299d",angsph:"\u2222",angst:"\xc5",angzarr:"\u237c",Aogon:"\u0104",aogon:"\u0105",Aopf:"\ud835\udd38",aopf:"\ud835\udd52",ap:"\u2248",apacir:"\u2a6f",apE:"\u2a70",ape:"\u224a",apid:"\u224b",apos:"'",ApplyFunction:"\u2061",approx:"\u2248",approxeq:"\u224a",Aring:"\xc5",aring:"\xe5",Ascr:"\ud835\udc9c",ascr:"\ud835\udcb6",Assign:"\u2254",ast:"*",asymp:"\u2248",asympeq:"\u224d",Atilde:"\xc3",atilde:"\xe3",Auml:"\xc4",auml:"\xe4",awconint:"\u2233",awint:"\u2a11",backcong:"\u224c",backepsilon:"\u03f6",backprime:"\u2035",backsim:"\u223d",backsimeq:"\u22cd",Backslash:"\u2216",Barv:"\u2ae7",barvee:"\u22bd",Barwed:"\u2306",barwed:"\u2305",barwedge:"\u2305",bbrk:"\u23b5",bbrktbrk:"\u23b6",bcong:"\u224c",Bcy:"\u0411",bcy:"\u0431",bdquo:"\u201e",becaus:"\u2235",Because:"\u2235",because:"\u2235",bemptyv:"\u29b0",bepsi:"\u03f6",bernou:"\u212c",Bernoullis:"\u212c",Beta:"\u0392",beta:"\u03b2",beth:"\u2136",between:"\u226c",Bfr:"\ud835\udd05",bfr:"\ud835\udd1f",bigcap:"\u22c2",bigcirc:"\u25ef",bigcup:"\u22c3",bigodot:"\u2a00",bigoplus:"\u2a01",bigotimes:"\u2a02",bigsqcup:"\u2a06",bigstar:"\u2605",bigtriangledown:"\u25bd",bigtriangleup:"\u25b3",biguplus:"\u2a04",bigvee:"\u22c1",bigwedge:"\u22c0",bkarow:"\u290d",blacklozenge:"\u29eb",blacksquare:"\u25aa",blacktriangle:"\u25b4",blacktriangledown:"\u25be",blacktriangleleft:"\u25c2",blacktriangleright:"\u25b8",blank:"\u2423",blk12:"\u2592",blk14:"\u2591",blk34:"\u2593",block:"\u2588",bne:"=\u20e5",bnequiv:"\u2261\u20e5",bNot:"\u2aed",bnot:"\u2310",Bopf:"\ud835\udd39",bopf:"\ud835\udd53",bot:"\u22a5",bottom:"\u22a5",bowtie:"\u22c8",boxbox:"\u29c9",boxDL:"\u2557",boxDl:"\u2556",boxdL:"\u2555",boxdl:"\u2510",boxDR:"\u2554",boxDr:"\u2553",boxdR:"\u2552",boxdr:"\u250c",boxH:"\u2550",boxh:"\u2500",boxHD:"\u2566",boxHd:"\u2564",boxhD:"\u2565",boxhd:"\u252c",boxHU:"\u2569",boxHu:"\u2567",boxhU:"\u2568",boxhu:"\u2534",boxminus:"\u229f",boxplus:"\u229e",boxtimes:"\u22a0",boxUL:"\u255d",boxUl:"\u255c",boxuL:"\u255b",boxul:"\u2518",boxUR:"\u255a",boxUr:"\u2559",boxuR:"\u2558",boxur:"\u2514",boxV:"\u2551",boxv:"\u2502",boxVH:"\u256c",boxVh:"\u256b",boxvH:"\u256a",boxvh:"\u253c",boxVL:"\u2563",boxVl:"\u2562",boxvL:"\u2561",boxvl:"\u2524",boxVR:"\u2560",boxVr:"\u255f",boxvR:"\u255e",boxvr:"\u251c",bprime:"\u2035",Breve:"\u02d8",breve:"\u02d8",brvbar:"\xa6",Bscr:"\u212c",bscr:"\ud835\udcb7",bsemi:"\u204f",bsim:"\u223d",bsime:"\u22cd",bsol:"\\",bsolb:"\u29c5",bsolhsub:"\u27c8",bull:"\u2022",bullet:"\u2022",bump:"\u224e",bumpE:"\u2aae",bumpe:"\u224f",Bumpeq:"\u224e",bumpeq:"\u224f",Cacute:"\u0106",cacute:"\u0107",Cap:"\u22d2",cap:"\u2229",capand:"\u2a44",capbrcup:"\u2a49",capcap:"\u2a4b",capcup:"\u2a47",capdot:"\u2a40",CapitalDifferentialD:"\u2145",caps:"\u2229\ufe00",caret:"\u2041",caron:"\u02c7",Cayleys:"\u212d",ccaps:"\u2a4d",Ccaron:"\u010c",ccaron:"\u010d",Ccedil:"\xc7",ccedil:"\xe7",Ccirc:"\u0108",ccirc:"\u0109",Cconint:"\u2230",ccups:"\u2a4c",ccupssm:"\u2a50",Cdot:"\u010a",cdot:"\u010b",cedil:"\xb8",Cedilla:"\xb8",cemptyv:"\u29b2",cent:"\xa2",CenterDot:"\xb7",centerdot:"\xb7",Cfr:"\u212d",cfr:"\ud835\udd20",CHcy:"\u0427",chcy:"\u0447",check:"\u2713",checkmark:"\u2713",Chi:"\u03a7",chi:"\u03c7",cir:"\u25cb",circ:"\u02c6",circeq:"\u2257",circlearrowleft:"\u21ba",circlearrowright:"\u21bb",circledast:"\u229b",circledcirc:"\u229a",circleddash:"\u229d",CircleDot:"\u2299",circledR:"\xae",circledS:"\u24c8",CircleMinus:"\u2296",CirclePlus:"\u2295",CircleTimes:"\u2297",cirE:"\u29c3",cire:"\u2257",cirfnint:"\u2a10",cirmid:"\u2aef",cirscir:"\u29c2",ClockwiseContourIntegral:"\u2232",CloseCurlyDoubleQuote:"\u201d",CloseCurlyQuote:"\u2019",clubs:"\u2663",clubsuit:"\u2663",Colon:"\u2237",colon:":",Colone:"\u2a74",colone:"\u2254",coloneq:"\u2254",comma:",",commat:"@",comp:"\u2201",compfn:"\u2218",complement:"\u2201",complexes:"\u2102",cong:"\u2245",congdot:"\u2a6d",Congruent:"\u2261",Conint:"\u222f",conint:"\u222e",ContourIntegral:"\u222e",Copf:"\u2102",copf:"\ud835\udd54",coprod:"\u2210",Coproduct:"\u2210",COPY:"\xa9",copy:"\xa9",copysr:"\u2117",CounterClockwiseContourIntegral:"\u2233",crarr:"\u21b5",Cross:"\u2a2f",cross:"\u2717",Cscr:"\ud835\udc9e",cscr:"\ud835\udcb8",csub:"\u2acf",csube:"\u2ad1",csup:"\u2ad0",csupe:"\u2ad2",ctdot:"\u22ef",cudarrl:"\u2938",cudarrr:"\u2935",cuepr:"\u22de",cuesc:"\u22df",cularr:"\u21b6",cularrp:"\u293d",Cup:"\u22d3",cup:"\u222a",cupbrcap:"\u2a48",CupCap:"\u224d",cupcap:"\u2a46",cupcup:"\u2a4a",cupdot:"\u228d",cupor:"\u2a45",cups:"\u222a\ufe00",curarr:"\u21b7",curarrm:"\u293c",curlyeqprec:"\u22de",curlyeqsucc:"\u22df",curlyvee:"\u22ce",curlywedge:"\u22cf",curren:"\xa4",curvearrowleft:"\u21b6",curvearrowright:"\u21b7",cuvee:"\u22ce",cuwed:"\u22cf",cwconint:"\u2232",cwint:"\u2231",cylcty:"\u232d",Dagger:"\u2021",dagger:"\u2020",daleth:"\u2138",Darr:"\u21a1",dArr:"\u21d3",darr:"\u2193",dash:"\u2010",Dashv:"\u2ae4",dashv:"\u22a3",dbkarow:"\u290f",dblac:"\u02dd",Dcaron:"\u010e",dcaron:"\u010f",Dcy:"\u0414",dcy:"\u0434",DD:"\u2145",dd:"\u2146",ddagger:"\u2021",ddarr:"\u21ca",DDotrahd:"\u2911",ddotseq:"\u2a77",deg:"\xb0",Del:"\u2207",Delta:"\u0394",delta:"\u03b4",demptyv:"\u29b1",dfisht:"\u297f",Dfr:"\ud835\udd07",dfr:"\ud835\udd21",dHar:"\u2965",dharl:"\u21c3",dharr:"\u21c2",DiacriticalAcute:"\xb4",DiacriticalDot:"\u02d9",DiacriticalDoubleAcute:"\u02dd",DiacriticalGrave:"`",DiacriticalTilde:"\u02dc",diam:"\u22c4",Diamond:"\u22c4",diamond:"\u22c4",diamondsuit:"\u2666",diams:"\u2666",die:"\xa8",DifferentialD:"\u2146",digamma:"\u03dd",disin:"\u22f2",div:"\xf7",divide:"\xf7",divideontimes:"\u22c7",divonx:"\u22c7",DJcy:"\u0402",djcy:"\u0452",dlcorn:"\u231e",dlcrop:"\u230d",dollar:"$",Dopf:"\ud835\udd3b",dopf:"\ud835\udd55",Dot:"\xa8",dot:"\u02d9",DotDot:"\u20dc",doteq:"\u2250",doteqdot:"\u2251",DotEqual:"\u2250",dotminus:"\u2238",dotplus:"\u2214",dotsquare:"\u22a1",doublebarwedge:"\u2306",DoubleContourIntegral:"\u222f",DoubleDot:"\xa8",DoubleDownArrow:"\u21d3",DoubleLeftArrow:"\u21d0",DoubleLeftRightArrow:"\u21d4",DoubleLeftTee:"\u2ae4",DoubleLongLeftArrow:"\u27f8",DoubleLongLeftRightArrow:"\u27fa",DoubleLongRightArrow:"\u27f9",DoubleRightArrow:"\u21d2",DoubleRightTee:"\u22a8",DoubleUpArrow:"\u21d1",DoubleUpDownArrow:"\u21d5",DoubleVerticalBar:"\u2225",DownArrow:"\u2193",Downarrow:"\u21d3",downarrow:"\u2193",DownArrowBar:"\u2913",DownArrowUpArrow:"\u21f5",DownBreve:"\u0311",downdownarrows:"\u21ca",downharpoonleft:"\u21c3",downharpoonright:"\u21c2",DownLeftRightVector:"\u2950",DownLeftTeeVector:"\u295e",DownLeftVector:"\u21bd",DownLeftVectorBar:"\u2956",DownRightTeeVector:"\u295f",DownRightVector:"\u21c1",DownRightVectorBar:"\u2957",DownTee:"\u22a4",DownTeeArrow:"\u21a7",drbkarow:"\u2910",drcorn:"\u231f",drcrop:"\u230c",Dscr:"\ud835\udc9f",dscr:"\ud835\udcb9",DScy:"\u0405",dscy:"\u0455",dsol:"\u29f6",Dstrok:"\u0110",dstrok:"\u0111",dtdot:"\u22f1",dtri:"\u25bf",dtrif:"\u25be",duarr:"\u21f5",duhar:"\u296f",dwangle:"\u29a6",DZcy:"\u040f",dzcy:"\u045f",dzigrarr:"\u27ff",Eacute:"\xc9",eacute:"\xe9",easter:"\u2a6e",Ecaron:"\u011a",ecaron:"\u011b",ecir:"\u2256",Ecirc:"\xca",ecirc:"\xea",ecolon:"\u2255",Ecy:"\u042d",ecy:"\u044d",eDDot:"\u2a77",Edot:"\u0116",eDot:"\u2251",edot:"\u0117",ee:"\u2147",efDot:"\u2252",Efr:"\ud835\udd08",efr:"\ud835\udd22",eg:"\u2a9a",Egrave:"\xc8",egrave:"\xe8",egs:"\u2a96",egsdot:"\u2a98",el:"\u2a99",Element:"\u2208",elinters:"\u23e7",ell:"\u2113",els:"\u2a95",elsdot:"\u2a97",Emacr:"\u0112",emacr:"\u0113",empty:"\u2205",emptyset:"\u2205",EmptySmallSquare:"\u25fb",emptyv:"\u2205",EmptyVerySmallSquare:"\u25ab",emsp:"\u2003",emsp13:"\u2004",emsp14:"\u2005",ENG:"\u014a",eng:"\u014b",ensp:"\u2002",Eogon:"\u0118",eogon:"\u0119",Eopf:"\ud835\udd3c",eopf:"\ud835\udd56",epar:"\u22d5",eparsl:"\u29e3",eplus:"\u2a71",epsi:"\u03b5",Epsilon:"\u0395",epsilon:"\u03b5",epsiv:"\u03f5",eqcirc:"\u2256",eqcolon:"\u2255",eqsim:"\u2242",eqslantgtr:"\u2a96",eqslantless:"\u2a95",Equal:"\u2a75",equals:"=",EqualTilde:"\u2242",equest:"\u225f",Equilibrium:"\u21cc",equiv:"\u2261",equivDD:"\u2a78",eqvparsl:"\u29e5",erarr:"\u2971",erDot:"\u2253",Escr:"\u2130",escr:"\u212f",esdot:"\u2250",Esim:"\u2a73",esim:"\u2242",Eta:"\u0397",eta:"\u03b7",ETH:"\xd0",eth:"\xf0",Euml:"\xcb",euml:"\xeb",euro:"\u20ac",excl:"!",exist:"\u2203",Exists:"\u2203",expectation:"\u2130",ExponentialE:"\u2147",exponentiale:"\u2147",fallingdotseq:"\u2252",Fcy:"\u0424",fcy:"\u0444",female:"\u2640",ffilig:"\ufb03",fflig:"\ufb00",ffllig:"\ufb04",Ffr:"\ud835\udd09",ffr:"\ud835\udd23",filig:"\ufb01",FilledSmallSquare:"\u25fc",FilledVerySmallSquare:"\u25aa",fjlig:"fj",flat:"\u266d",fllig:"\ufb02",fltns:"\u25b1",fnof:"\u0192",Fopf:"\ud835\udd3d",fopf:"\ud835\udd57",ForAll:"\u2200",forall:"\u2200",fork:"\u22d4",forkv:"\u2ad9",Fouriertrf:"\u2131",fpartint:"\u2a0d",frac12:"\xbd",frac13:"\u2153",frac14:"\xbc",frac15:"\u2155",frac16:"\u2159",frac18:"\u215b",frac23:"\u2154",frac25:"\u2156",frac34:"\xbe",frac35:"\u2157",frac38:"\u215c",frac45:"\u2158",frac56:"\u215a",frac58:"\u215d",frac78:"\u215e",frasl:"\u2044",frown:"\u2322",Fscr:"\u2131",fscr:"\ud835\udcbb",gacute:"\u01f5",Gamma:"\u0393",gamma:"\u03b3",Gammad:"\u03dc",gammad:"\u03dd",gap:"\u2a86",Gbreve:"\u011e",gbreve:"\u011f",Gcedil:"\u0122",Gcirc:"\u011c",gcirc:"\u011d",Gcy:"\u0413",gcy:"\u0433",Gdot:"\u0120",gdot:"\u0121",gE:"\u2267",ge:"\u2265",gEl:"\u2a8c",gel:"\u22db",geq:"\u2265",geqq:"\u2267",geqslant:"\u2a7e",ges:"\u2a7e",gescc:"\u2aa9",gesdot:"\u2a80",gesdoto:"\u2a82",gesdotol:"\u2a84",gesl:"\u22db\ufe00",gesles:"\u2a94",Gfr:"\ud835\udd0a",gfr:"\ud835\udd24",Gg:"\u22d9",gg:"\u226b",ggg:"\u22d9",gimel:"\u2137",GJcy:"\u0403",gjcy:"\u0453",gl:"\u2277",gla:"\u2aa5",glE:"\u2a92",glj:"\u2aa4",gnap:"\u2a8a",gnapprox:"\u2a8a",gnE:"\u2269",gne:"\u2a88",gneq:"\u2a88",gneqq:"\u2269",gnsim:"\u22e7",Gopf:"\ud835\udd3e",gopf:"\ud835\udd58",grave:"`",GreaterEqual:"\u2265",GreaterEqualLess:"\u22db",GreaterFullEqual:"\u2267",GreaterGreater:"\u2aa2",GreaterLess:"\u2277",GreaterSlantEqual:"\u2a7e",GreaterTilde:"\u2273",Gscr:"\ud835\udca2",gscr:"\u210a",gsim:"\u2273",gsime:"\u2a8e",gsiml:"\u2a90",GT:">",Gt:"\u226b",gt:">",gtcc:"\u2aa7",gtcir:"\u2a7a",gtdot:"\u22d7",gtlPar:"\u2995",gtquest:"\u2a7c",gtrapprox:"\u2a86",gtrarr:"\u2978",gtrdot:"\u22d7",gtreqless:"\u22db",gtreqqless:"\u2a8c",gtrless:"\u2277",gtrsim:"\u2273",gvertneqq:"\u2269\ufe00",gvnE:"\u2269\ufe00",Hacek:"\u02c7",hairsp:"\u200a",half:"\xbd",hamilt:"\u210b",HARDcy:"\u042a",hardcy:"\u044a",hArr:"\u21d4",harr:"\u2194",harrcir:"\u2948",harrw:"\u21ad",Hat:"^",hbar:"\u210f",Hcirc:"\u0124",hcirc:"\u0125",hearts:"\u2665",heartsuit:"\u2665",hellip:"\u2026",hercon:"\u22b9",Hfr:"\u210c",hfr:"\ud835\udd25",HilbertSpace:"\u210b",hksearow:"\u2925",hkswarow:"\u2926",hoarr:"\u21ff",homtht:"\u223b",hookleftarrow:"\u21a9",hookrightarrow:"\u21aa",Hopf:"\u210d",hopf:"\ud835\udd59",horbar:"\u2015",HorizontalLine:"\u2500",Hscr:"\u210b",hscr:"\ud835\udcbd",hslash:"\u210f",Hstrok:"\u0126",hstrok:"\u0127",HumpDownHump:"\u224e",HumpEqual:"\u224f",hybull:"\u2043",hyphen:"\u2010",Iacute:"\xcd",iacute:"\xed",ic:"\u2063",Icirc:"\xce",icirc:"\xee",Icy:"\u0418",icy:"\u0438",Idot:"\u0130",IEcy:"\u0415",iecy:"\u0435",iexcl:"\xa1",iff:"\u21d4",Ifr:"\u2111",ifr:"\ud835\udd26",Igrave:"\xcc",igrave:"\xec",ii:"\u2148",iiiint:"\u2a0c",iiint:"\u222d",iinfin:"\u29dc",iiota:"\u2129",IJlig:"\u0132",ijlig:"\u0133",Im:"\u2111",Imacr:"\u012a",imacr:"\u012b",image:"\u2111",ImaginaryI:"\u2148",imagline:"\u2110",imagpart:"\u2111",imath:"\u0131",imof:"\u22b7",imped:"\u01b5",Implies:"\u21d2",in:"\u2208",incare:"\u2105",infin:"\u221e",infintie:"\u29dd",inodot:"\u0131",Int:"\u222c",int:"\u222b",intcal:"\u22ba",integers:"\u2124",Integral:"\u222b",intercal:"\u22ba",Intersection:"\u22c2",intlarhk:"\u2a17",intprod:"\u2a3c",InvisibleComma:"\u2063",InvisibleTimes:"\u2062",IOcy:"\u0401",iocy:"\u0451",Iogon:"\u012e",iogon:"\u012f",Iopf:"\ud835\udd40",iopf:"\ud835\udd5a",Iota:"\u0399",iota:"\u03b9",iprod:"\u2a3c",iquest:"\xbf",Iscr:"\u2110",iscr:"\ud835\udcbe",isin:"\u2208",isindot:"\u22f5",isinE:"\u22f9",isins:"\u22f4",isinsv:"\u22f3",isinv:"\u2208",it:"\u2062",Itilde:"\u0128",itilde:"\u0129",Iukcy:"\u0406",iukcy:"\u0456",Iuml:"\xcf",iuml:"\xef",Jcirc:"\u0134",jcirc:"\u0135",Jcy:"\u0419",jcy:"\u0439",Jfr:"\ud835\udd0d",jfr:"\ud835\udd27",jmath:"\u0237",Jopf:"\ud835\udd41",jopf:"\ud835\udd5b",Jscr:"\ud835\udca5",jscr:"\ud835\udcbf",Jsercy:"\u0408",jsercy:"\u0458",Jukcy:"\u0404",jukcy:"\u0454",Kappa:"\u039a",kappa:"\u03ba",kappav:"\u03f0",Kcedil:"\u0136",kcedil:"\u0137",Kcy:"\u041a",kcy:"\u043a",Kfr:"\ud835\udd0e",kfr:"\ud835\udd28",kgreen:"\u0138",KHcy:"\u0425",khcy:"\u0445",KJcy:"\u040c",kjcy:"\u045c",Kopf:"\ud835\udd42",kopf:"\ud835\udd5c",Kscr:"\ud835\udca6",kscr:"\ud835\udcc0",lAarr:"\u21da",Lacute:"\u0139",lacute:"\u013a",laemptyv:"\u29b4",lagran:"\u2112",Lambda:"\u039b",lambda:"\u03bb",Lang:"\u27ea",lang:"\u27e8",langd:"\u2991",langle:"\u27e8",lap:"\u2a85",Laplacetrf:"\u2112",laquo:"\xab",Larr:"\u219e",lArr:"\u21d0",larr:"\u2190",larrb:"\u21e4",larrbfs:"\u291f",larrfs:"\u291d",larrhk:"\u21a9",larrlp:"\u21ab",larrpl:"\u2939",larrsim:"\u2973",larrtl:"\u21a2",lat:"\u2aab",lAtail:"\u291b",latail:"\u2919",late:"\u2aad",lates:"\u2aad\ufe00",lBarr:"\u290e",lbarr:"\u290c",lbbrk:"\u2772",lbrace:"{",lbrack:"[",lbrke:"\u298b",lbrksld:"\u298f",lbrkslu:"\u298d",Lcaron:"\u013d",lcaron:"\u013e",Lcedil:"\u013b",lcedil:"\u013c",lceil:"\u2308",lcub:"{",Lcy:"\u041b",lcy:"\u043b",ldca:"\u2936",ldquo:"\u201c",ldquor:"\u201e",ldrdhar:"\u2967",ldrushar:"\u294b",ldsh:"\u21b2",lE:"\u2266",le:"\u2264",LeftAngleBracket:"\u27e8",LeftArrow:"\u2190",Leftarrow:"\u21d0",leftarrow:"\u2190",LeftArrowBar:"\u21e4",LeftArrowRightArrow:"\u21c6",leftarrowtail:"\u21a2",LeftCeiling:"\u2308",LeftDoubleBracket:"\u27e6",LeftDownTeeVector:"\u2961",LeftDownVector:"\u21c3",LeftDownVectorBar:"\u2959",LeftFloor:"\u230a",leftharpoondown:"\u21bd",leftharpoonup:"\u21bc",leftleftarrows:"\u21c7",LeftRightArrow:"\u2194",Leftrightarrow:"\u21d4",leftrightarrow:"\u2194",leftrightarrows:"\u21c6",leftrightharpoons:"\u21cb",leftrightsquigarrow:"\u21ad",LeftRightVector:"\u294e",LeftTee:"\u22a3",LeftTeeArrow:"\u21a4",LeftTeeVector:"\u295a",leftthreetimes:"\u22cb",LeftTriangle:"\u22b2",LeftTriangleBar:"\u29cf",LeftTriangleEqual:"\u22b4",LeftUpDownVector:"\u2951",LeftUpTeeVector:"\u2960",LeftUpVector:"\u21bf",LeftUpVectorBar:"\u2958",LeftVector:"\u21bc",LeftVectorBar:"\u2952",lEg:"\u2a8b",leg:"\u22da",leq:"\u2264",leqq:"\u2266",leqslant:"\u2a7d",les:"\u2a7d",lescc:"\u2aa8",lesdot:"\u2a7f",lesdoto:"\u2a81",lesdotor:"\u2a83",lesg:"\u22da\ufe00",lesges:"\u2a93",lessapprox:"\u2a85",lessdot:"\u22d6",lesseqgtr:"\u22da",lesseqqgtr:"\u2a8b",LessEqualGreater:"\u22da",LessFullEqual:"\u2266",LessGreater:"\u2276",lessgtr:"\u2276",LessLess:"\u2aa1",lesssim:"\u2272",LessSlantEqual:"\u2a7d",LessTilde:"\u2272",lfisht:"\u297c",lfloor:"\u230a",Lfr:"\ud835\udd0f",lfr:"\ud835\udd29",lg:"\u2276",lgE:"\u2a91",lHar:"\u2962",lhard:"\u21bd",lharu:"\u21bc",lharul:"\u296a",lhblk:"\u2584",LJcy:"\u0409",ljcy:"\u0459",Ll:"\u22d8",ll:"\u226a",llarr:"\u21c7",llcorner:"\u231e",Lleftarrow:"\u21da",llhard:"\u296b",lltri:"\u25fa",Lmidot:"\u013f",lmidot:"\u0140",lmoust:"\u23b0",lmoustache:"\u23b0",lnap:"\u2a89",lnapprox:"\u2a89",lnE:"\u2268",lne:"\u2a87",lneq:"\u2a87",lneqq:"\u2268",lnsim:"\u22e6",loang:"\u27ec",loarr:"\u21fd",lobrk:"\u27e6",LongLeftArrow:"\u27f5",Longleftarrow:"\u27f8",longleftarrow:"\u27f5",LongLeftRightArrow:"\u27f7",Longleftrightarrow:"\u27fa",longleftrightarrow:"\u27f7",longmapsto:"\u27fc",LongRightArrow:"\u27f6",Longrightarrow:"\u27f9",longrightarrow:"\u27f6",looparrowleft:"\u21ab",looparrowright:"\u21ac",lopar:"\u2985",Lopf:"\ud835\udd43",lopf:"\ud835\udd5d",loplus:"\u2a2d",lotimes:"\u2a34",lowast:"\u2217",lowbar:"_",LowerLeftArrow:"\u2199",LowerRightArrow:"\u2198",loz:"\u25ca",lozenge:"\u25ca",lozf:"\u29eb",lpar:"(",lparlt:"\u2993",lrarr:"\u21c6",lrcorner:"\u231f",lrhar:"\u21cb",lrhard:"\u296d",lrm:"\u200e",lrtri:"\u22bf",lsaquo:"\u2039",Lscr:"\u2112",lscr:"\ud835\udcc1",Lsh:"\u21b0",lsh:"\u21b0",lsim:"\u2272",lsime:"\u2a8d",lsimg:"\u2a8f",lsqb:"[",lsquo:"\u2018",lsquor:"\u201a",Lstrok:"\u0141",lstrok:"\u0142",LT:"<",Lt:"\u226a",lt:"<",ltcc:"\u2aa6",ltcir:"\u2a79",ltdot:"\u22d6",lthree:"\u22cb",ltimes:"\u22c9",ltlarr:"\u2976",ltquest:"\u2a7b",ltri:"\u25c3",ltrie:"\u22b4",ltrif:"\u25c2",ltrPar:"\u2996",lurdshar:"\u294a",luruhar:"\u2966",lvertneqq:"\u2268\ufe00",lvnE:"\u2268\ufe00",macr:"\xaf",male:"\u2642",malt:"\u2720",maltese:"\u2720",Map:"\u2905",map:"\u21a6",mapsto:"\u21a6",mapstodown:"\u21a7",mapstoleft:"\u21a4",mapstoup:"\u21a5",marker:"\u25ae",mcomma:"\u2a29",Mcy:"\u041c",mcy:"\u043c",mdash:"\u2014",mDDot:"\u223a",measuredangle:"\u2221",MediumSpace:"\u205f",Mellintrf:"\u2133",Mfr:"\ud835\udd10",mfr:"\ud835\udd2a",mho:"\u2127",micro:"\xb5",mid:"\u2223",midast:"*",midcir:"\u2af0",middot:"\xb7",minus:"\u2212",minusb:"\u229f",minusd:"\u2238",minusdu:"\u2a2a",MinusPlus:"\u2213",mlcp:"\u2adb",mldr:"\u2026",mnplus:"\u2213",models:"\u22a7",Mopf:"\ud835\udd44",mopf:"\ud835\udd5e",mp:"\u2213",Mscr:"\u2133",mscr:"\ud835\udcc2",mstpos:"\u223e",Mu:"\u039c",mu:"\u03bc",multimap:"\u22b8",mumap:"\u22b8",nabla:"\u2207",Nacute:"\u0143",nacute:"\u0144",nang:"\u2220\u20d2",nap:"\u2249",napE:"\u2a70\u0338",napid:"\u224b\u0338",napos:"\u0149",napprox:"\u2249",natur:"\u266e",natural:"\u266e",naturals:"\u2115",nbsp:"\xa0",nbump:"\u224e\u0338",nbumpe:"\u224f\u0338",ncap:"\u2a43",Ncaron:"\u0147",ncaron:"\u0148",Ncedil:"\u0145",ncedil:"\u0146",ncong:"\u2247",ncongdot:"\u2a6d\u0338",ncup:"\u2a42",Ncy:"\u041d",ncy:"\u043d",ndash:"\u2013",ne:"\u2260",nearhk:"\u2924",neArr:"\u21d7",nearr:"\u2197",nearrow:"\u2197",nedot:"\u2250\u0338",NegativeMediumSpace:"\u200b",NegativeThickSpace:"\u200b",NegativeThinSpace:"\u200b",NegativeVeryThinSpace:"\u200b",nequiv:"\u2262",nesear:"\u2928",nesim:"\u2242\u0338",NestedGreaterGreater:"\u226b",NestedLessLess:"\u226a",NewLine:"\n",nexist:"\u2204",nexists:"\u2204",Nfr:"\ud835\udd11",nfr:"\ud835\udd2b",ngE:"\u2267\u0338",nge:"\u2271",ngeq:"\u2271",ngeqq:"\u2267\u0338",ngeqslant:"\u2a7e\u0338",nges:"\u2a7e\u0338",nGg:"\u22d9\u0338",ngsim:"\u2275",nGt:"\u226b\u20d2",ngt:"\u226f",ngtr:"\u226f",nGtv:"\u226b\u0338",nhArr:"\u21ce",nharr:"\u21ae",nhpar:"\u2af2",ni:"\u220b",nis:"\u22fc",nisd:"\u22fa",niv:"\u220b",NJcy:"\u040a",njcy:"\u045a",nlArr:"\u21cd",nlarr:"\u219a",nldr:"\u2025",nlE:"\u2266\u0338",nle:"\u2270",nLeftarrow:"\u21cd",nleftarrow:"\u219a",nLeftrightarrow:"\u21ce",nleftrightarrow:"\u21ae",nleq:"\u2270",nleqq:"\u2266\u0338",nleqslant:"\u2a7d\u0338",nles:"\u2a7d\u0338",nless:"\u226e",nLl:"\u22d8\u0338",nlsim:"\u2274",nLt:"\u226a\u20d2",nlt:"\u226e",nltri:"\u22ea",nltrie:"\u22ec",nLtv:"\u226a\u0338",nmid:"\u2224",NoBreak:"\u2060",NonBreakingSpace:"\xa0",Nopf:"\u2115",nopf:"\ud835\udd5f",Not:"\u2aec",not:"\xac",NotCongruent:"\u2262",NotCupCap:"\u226d",NotDoubleVerticalBar:"\u2226",NotElement:"\u2209",NotEqual:"\u2260",NotEqualTilde:"\u2242\u0338",NotExists:"\u2204",NotGreater:"\u226f",NotGreaterEqual:"\u2271",NotGreaterFullEqual:"\u2267\u0338",NotGreaterGreater:"\u226b\u0338",NotGreaterLess:"\u2279",NotGreaterSlantEqual:"\u2a7e\u0338",NotGreaterTilde:"\u2275",NotHumpDownHump:"\u224e\u0338",NotHumpEqual:"\u224f\u0338",notin:"\u2209",notindot:"\u22f5\u0338",notinE:"\u22f9\u0338",notinva:"\u2209",notinvb:"\u22f7",notinvc:"\u22f6",NotLeftTriangle:"\u22ea",NotLeftTriangleBar:"\u29cf\u0338",NotLeftTriangleEqual:"\u22ec",NotLess:"\u226e",NotLessEqual:"\u2270",NotLessGreater:"\u2278",NotLessLess:"\u226a\u0338",NotLessSlantEqual:"\u2a7d\u0338",NotLessTilde:"\u2274",NotNestedGreaterGreater:"\u2aa2\u0338",NotNestedLessLess:"\u2aa1\u0338",notni:"\u220c",notniva:"\u220c",notnivb:"\u22fe",notnivc:"\u22fd",NotPrecedes:"\u2280",NotPrecedesEqual:"\u2aaf\u0338",NotPrecedesSlantEqual:"\u22e0",NotReverseElement:"\u220c",NotRightTriangle:"\u22eb",NotRightTriangleBar:"\u29d0\u0338",NotRightTriangleEqual:"\u22ed",NotSquareSubset:"\u228f\u0338",NotSquareSubsetEqual:"\u22e2",NotSquareSuperset:"\u2290\u0338",NotSquareSupersetEqual:"\u22e3",NotSubset:"\u2282\u20d2",NotSubsetEqual:"\u2288",NotSucceeds:"\u2281",NotSucceedsEqual:"\u2ab0\u0338",NotSucceedsSlantEqual:"\u22e1",NotSucceedsTilde:"\u227f\u0338",NotSuperset:"\u2283\u20d2",NotSupersetEqual:"\u2289",NotTilde:"\u2241",NotTildeEqual:"\u2244",NotTildeFullEqual:"\u2247",NotTildeTilde:"\u2249",NotVerticalBar:"\u2224",npar:"\u2226",nparallel:"\u2226",nparsl:"\u2afd\u20e5",npart:"\u2202\u0338",npolint:"\u2a14",npr:"\u2280",nprcue:"\u22e0",npre:"\u2aaf\u0338",nprec:"\u2280",npreceq:"\u2aaf\u0338",nrArr:"\u21cf",nrarr:"\u219b",nrarrc:"\u2933\u0338",nrarrw:"\u219d\u0338",nRightarrow:"\u21cf",nrightarrow:"\u219b",nrtri:"\u22eb",nrtrie:"\u22ed",nsc:"\u2281",nsccue:"\u22e1",nsce:"\u2ab0\u0338",Nscr:"\ud835\udca9",nscr:"\ud835\udcc3",nshortmid:"\u2224",nshortparallel:"\u2226",nsim:"\u2241",nsime:"\u2244",nsimeq:"\u2244",nsmid:"\u2224",nspar:"\u2226",nsqsube:"\u22e2",nsqsupe:"\u22e3",nsub:"\u2284",nsubE:"\u2ac5\u0338",nsube:"\u2288",nsubset:"\u2282\u20d2",nsubseteq:"\u2288",nsubseteqq:"\u2ac5\u0338",nsucc:"\u2281",nsucceq:"\u2ab0\u0338",nsup:"\u2285",nsupE:"\u2ac6\u0338",nsupe:"\u2289",nsupset:"\u2283\u20d2",nsupseteq:"\u2289",nsupseteqq:"\u2ac6\u0338",ntgl:"\u2279",Ntilde:"\xd1",ntilde:"\xf1",ntlg:"\u2278",ntriangleleft:"\u22ea",ntrianglelefteq:"\u22ec",ntriangleright:"\u22eb",ntrianglerighteq:"\u22ed",Nu:"\u039d",nu:"\u03bd",num:"#",numero:"\u2116",numsp:"\u2007",nvap:"\u224d\u20d2",nVDash:"\u22af",nVdash:"\u22ae",nvDash:"\u22ad",nvdash:"\u22ac",nvge:"\u2265\u20d2",nvgt:">\u20d2",nvHarr:"\u2904",nvinfin:"\u29de",nvlArr:"\u2902",nvle:"\u2264\u20d2",nvlt:"<\u20d2",nvltrie:"\u22b4\u20d2",nvrArr:"\u2903",nvrtrie:"\u22b5\u20d2",nvsim:"\u223c\u20d2",nwarhk:"\u2923",nwArr:"\u21d6",nwarr:"\u2196",nwarrow:"\u2196",nwnear:"\u2927",Oacute:"\xd3",oacute:"\xf3",oast:"\u229b",ocir:"\u229a",Ocirc:"\xd4",ocirc:"\xf4",Ocy:"\u041e",ocy:"\u043e",odash:"\u229d",Odblac:"\u0150",odblac:"\u0151",odiv:"\u2a38",odot:"\u2299",odsold:"\u29bc",OElig:"\u0152",oelig:"\u0153",ofcir:"\u29bf",Ofr:"\ud835\udd12",ofr:"\ud835\udd2c",ogon:"\u02db",Ograve:"\xd2",ograve:"\xf2",ogt:"\u29c1",ohbar:"\u29b5",ohm:"\u03a9",oint:"\u222e",olarr:"\u21ba",olcir:"\u29be",olcross:"\u29bb",oline:"\u203e",olt:"\u29c0",Omacr:"\u014c",omacr:"\u014d",Omega:"\u03a9",omega:"\u03c9",Omicron:"\u039f",omicron:"\u03bf",omid:"\u29b6",ominus:"\u2296",Oopf:"\ud835\udd46",oopf:"\ud835\udd60",opar:"\u29b7",OpenCurlyDoubleQuote:"\u201c",OpenCurlyQuote:"\u2018",operp:"\u29b9",oplus:"\u2295",Or:"\u2a54",or:"\u2228",orarr:"\u21bb",ord:"\u2a5d",order:"\u2134",orderof:"\u2134",ordf:"\xaa",ordm:"\xba",origof:"\u22b6",oror:"\u2a56",orslope:"\u2a57",orv:"\u2a5b",oS:"\u24c8",Oscr:"\ud835\udcaa",oscr:"\u2134",Oslash:"\xd8",oslash:"\xf8",osol:"\u2298",Otilde:"\xd5",otilde:"\xf5",Otimes:"\u2a37",otimes:"\u2297",otimesas:"\u2a36",Ouml:"\xd6",ouml:"\xf6",ovbar:"\u233d",OverBar:"\u203e",OverBrace:"\u23de",OverBracket:"\u23b4",OverParenthesis:"\u23dc",par:"\u2225",para:"\xb6",parallel:"\u2225",parsim:"\u2af3",parsl:"\u2afd",part:"\u2202",PartialD:"\u2202",Pcy:"\u041f",pcy:"\u043f",percnt:"%",period:".",permil:"\u2030",perp:"\u22a5",pertenk:"\u2031",Pfr:"\ud835\udd13",pfr:"\ud835\udd2d",Phi:"\u03a6",phi:"\u03c6",phiv:"\u03d5",phmmat:"\u2133",phone:"\u260e",Pi:"\u03a0",pi:"\u03c0",pitchfork:"\u22d4",piv:"\u03d6",planck:"\u210f",planckh:"\u210e",plankv:"\u210f",plus:"+",plusacir:"\u2a23",plusb:"\u229e",pluscir:"\u2a22",plusdo:"\u2214",plusdu:"\u2a25",pluse:"\u2a72",PlusMinus:"\xb1",plusmn:"\xb1",plussim:"\u2a26",plustwo:"\u2a27",pm:"\xb1",Poincareplane:"\u210c",pointint:"\u2a15",Popf:"\u2119",popf:"\ud835\udd61",pound:"\xa3",Pr:"\u2abb",pr:"\u227a",prap:"\u2ab7",prcue:"\u227c",prE:"\u2ab3",pre:"\u2aaf",prec:"\u227a",precapprox:"\u2ab7",preccurlyeq:"\u227c",Precedes:"\u227a",PrecedesEqual:"\u2aaf",PrecedesSlantEqual:"\u227c",PrecedesTilde:"\u227e",preceq:"\u2aaf",precnapprox:"\u2ab9",precneqq:"\u2ab5",precnsim:"\u22e8",precsim:"\u227e",Prime:"\u2033",prime:"\u2032",primes:"\u2119",prnap:"\u2ab9",prnE:"\u2ab5",prnsim:"\u22e8",prod:"\u220f",Product:"\u220f",profalar:"\u232e",profline:"\u2312",profsurf:"\u2313",prop:"\u221d",Proportion:"\u2237",Proportional:"\u221d",propto:"\u221d",prsim:"\u227e",prurel:"\u22b0",Pscr:"\ud835\udcab",pscr:"\ud835\udcc5",Psi:"\u03a8",psi:"\u03c8",puncsp:"\u2008",Qfr:"\ud835\udd14",qfr:"\ud835\udd2e",qint:"\u2a0c",Qopf:"\u211a",qopf:"\ud835\udd62",qprime:"\u2057",Qscr:"\ud835\udcac",qscr:"\ud835\udcc6",quaternions:"\u210d",quatint:"\u2a16",quest:"?",questeq:"\u225f",QUOT:'"',quot:'"',rAarr:"\u21db",race:"\u223d\u0331",Racute:"\u0154",racute:"\u0155",radic:"\u221a",raemptyv:"\u29b3",Rang:"\u27eb",rang:"\u27e9",rangd:"\u2992",range:"\u29a5",rangle:"\u27e9",raquo:"\xbb",Rarr:"\u21a0",rArr:"\u21d2",rarr:"\u2192",rarrap:"\u2975",rarrb:"\u21e5",rarrbfs:"\u2920",rarrc:"\u2933",rarrfs:"\u291e",rarrhk:"\u21aa",rarrlp:"\u21ac",rarrpl:"\u2945",rarrsim:"\u2974",Rarrtl:"\u2916",rarrtl:"\u21a3",rarrw:"\u219d",rAtail:"\u291c",ratail:"\u291a",ratio:"\u2236",rationals:"\u211a",RBarr:"\u2910",rBarr:"\u290f",rbarr:"\u290d",rbbrk:"\u2773",rbrace:"}",rbrack:"]",rbrke:"\u298c",rbrksld:"\u298e",rbrkslu:"\u2990",Rcaron:"\u0158",rcaron:"\u0159",Rcedil:"\u0156",rcedil:"\u0157",rceil:"\u2309",rcub:"}",Rcy:"\u0420",rcy:"\u0440",rdca:"\u2937",rdldhar:"\u2969",rdquo:"\u201d",rdquor:"\u201d",rdsh:"\u21b3",Re:"\u211c",real:"\u211c",realine:"\u211b",realpart:"\u211c",reals:"\u211d",rect:"\u25ad",REG:"\xae",reg:"\xae",ReverseElement:"\u220b",ReverseEquilibrium:"\u21cb",ReverseUpEquilibrium:"\u296f",rfisht:"\u297d",rfloor:"\u230b",Rfr:"\u211c",rfr:"\ud835\udd2f",rHar:"\u2964",rhard:"\u21c1",rharu:"\u21c0",rharul:"\u296c",Rho:"\u03a1",rho:"\u03c1",rhov:"\u03f1",RightAngleBracket:"\u27e9",RightArrow:"\u2192",Rightarrow:"\u21d2",rightarrow:"\u2192",RightArrowBar:"\u21e5",RightArrowLeftArrow:"\u21c4",rightarrowtail:"\u21a3",RightCeiling:"\u2309",RightDoubleBracket:"\u27e7",RightDownTeeVector:"\u295d",RightDownVector:"\u21c2",RightDownVectorBar:"\u2955",RightFloor:"\u230b",rightharpoondown:"\u21c1",rightharpoonup:"\u21c0",rightleftarrows:"\u21c4",rightleftharpoons:"\u21cc",rightrightarrows:"\u21c9",rightsquigarrow:"\u219d",RightTee:"\u22a2",RightTeeArrow:"\u21a6",RightTeeVector:"\u295b",rightthreetimes:"\u22cc",RightTriangle:"\u22b3",RightTriangleBar:"\u29d0",RightTriangleEqual:"\u22b5",RightUpDownVector:"\u294f",RightUpTeeVector:"\u295c",RightUpVector:"\u21be",RightUpVectorBar:"\u2954",RightVector:"\u21c0",RightVectorBar:"\u2953",ring:"\u02da",risingdotseq:"\u2253",rlarr:"\u21c4",rlhar:"\u21cc",rlm:"\u200f",rmoust:"\u23b1",rmoustache:"\u23b1",rnmid:"\u2aee",roang:"\u27ed",roarr:"\u21fe",robrk:"\u27e7",ropar:"\u2986",Ropf:"\u211d",ropf:"\ud835\udd63",roplus:"\u2a2e",rotimes:"\u2a35",RoundImplies:"\u2970",rpar:")",rpargt:"\u2994",rppolint:"\u2a12",rrarr:"\u21c9",Rrightarrow:"\u21db",rsaquo:"\u203a",Rscr:"\u211b",rscr:"\ud835\udcc7",Rsh:"\u21b1",rsh:"\u21b1",rsqb:"]",rsquo:"\u2019",rsquor:"\u2019",rthree:"\u22cc",rtimes:"\u22ca",rtri:"\u25b9",rtrie:"\u22b5",rtrif:"\u25b8",rtriltri:"\u29ce",RuleDelayed:"\u29f4",ruluhar:"\u2968",rx:"\u211e",Sacute:"\u015a",sacute:"\u015b",sbquo:"\u201a",Sc:"\u2abc",sc:"\u227b",scap:"\u2ab8",Scaron:"\u0160",scaron:"\u0161",sccue:"\u227d",scE:"\u2ab4",sce:"\u2ab0",Scedil:"\u015e",scedil:"\u015f",Scirc:"\u015c",scirc:"\u015d",scnap:"\u2aba",scnE:"\u2ab6",scnsim:"\u22e9",scpolint:"\u2a13",scsim:"\u227f",Scy:"\u0421",scy:"\u0441",sdot:"\u22c5",sdotb:"\u22a1",sdote:"\u2a66",searhk:"\u2925",seArr:"\u21d8",searr:"\u2198",searrow:"\u2198",sect:"\xa7",semi:";",seswar:"\u2929",setminus:"\u2216",setmn:"\u2216",sext:"\u2736",Sfr:"\ud835\udd16",sfr:"\ud835\udd30",sfrown:"\u2322",sharp:"\u266f",SHCHcy:"\u0429",shchcy:"\u0449",SHcy:"\u0428",shcy:"\u0448",ShortDownArrow:"\u2193",ShortLeftArrow:"\u2190",shortmid:"\u2223",shortparallel:"\u2225",ShortRightArrow:"\u2192",ShortUpArrow:"\u2191",shy:"\xad",Sigma:"\u03a3",sigma:"\u03c3",sigmaf:"\u03c2",sigmav:"\u03c2",sim:"\u223c",simdot:"\u2a6a",sime:"\u2243",simeq:"\u2243",simg:"\u2a9e",simgE:"\u2aa0",siml:"\u2a9d",simlE:"\u2a9f",simne:"\u2246",simplus:"\u2a24",simrarr:"\u2972",slarr:"\u2190",SmallCircle:"\u2218",smallsetminus:"\u2216",smashp:"\u2a33",smeparsl:"\u29e4",smid:"\u2223",smile:"\u2323",smt:"\u2aaa",smte:"\u2aac",smtes:"\u2aac\ufe00",SOFTcy:"\u042c",softcy:"\u044c",sol:"/",solb:"\u29c4",solbar:"\u233f",Sopf:"\ud835\udd4a",sopf:"\ud835\udd64",spades:"\u2660",spadesuit:"\u2660",spar:"\u2225",sqcap:"\u2293",sqcaps:"\u2293\ufe00",sqcup:"\u2294",sqcups:"\u2294\ufe00",Sqrt:"\u221a",sqsub:"\u228f",sqsube:"\u2291",sqsubset:"\u228f",sqsubseteq:"\u2291",sqsup:"\u2290",sqsupe:"\u2292",sqsupset:"\u2290",sqsupseteq:"\u2292",squ:"\u25a1",Square:"\u25a1",square:"\u25a1",SquareIntersection:"\u2293",SquareSubset:"\u228f",SquareSubsetEqual:"\u2291",SquareSuperset:"\u2290",SquareSupersetEqual:"\u2292",SquareUnion:"\u2294",squarf:"\u25aa",squf:"\u25aa",srarr:"\u2192",Sscr:"\ud835\udcae",sscr:"\ud835\udcc8",ssetmn:"\u2216",ssmile:"\u2323",sstarf:"\u22c6",Star:"\u22c6",star:"\u2606",starf:"\u2605",straightepsilon:"\u03f5",straightphi:"\u03d5",strns:"\xaf",Sub:"\u22d0",sub:"\u2282",subdot:"\u2abd",subE:"\u2ac5",sube:"\u2286",subedot:"\u2ac3",submult:"\u2ac1",subnE:"\u2acb",subne:"\u228a",subplus:"\u2abf",subrarr:"\u2979",Subset:"\u22d0",subset:"\u2282",subseteq:"\u2286",subseteqq:"\u2ac5",SubsetEqual:"\u2286",subsetneq:"\u228a",subsetneqq:"\u2acb",subsim:"\u2ac7",subsub:"\u2ad5",subsup:"\u2ad3",succ:"\u227b",succapprox:"\u2ab8",succcurlyeq:"\u227d",Succeeds:"\u227b",SucceedsEqual:"\u2ab0",SucceedsSlantEqual:"\u227d",SucceedsTilde:"\u227f",succeq:"\u2ab0",succnapprox:"\u2aba",succneqq:"\u2ab6",succnsim:"\u22e9",succsim:"\u227f",SuchThat:"\u220b",Sum:"\u2211",sum:"\u2211",sung:"\u266a",Sup:"\u22d1",sup:"\u2283",sup1:"\xb9",sup2:"\xb2",sup3:"\xb3",supdot:"\u2abe",supdsub:"\u2ad8",supE:"\u2ac6",supe:"\u2287",supedot:"\u2ac4",Superset:"\u2283",SupersetEqual:"\u2287",suphsol:"\u27c9",suphsub:"\u2ad7",suplarr:"\u297b",supmult:"\u2ac2",supnE:"\u2acc",supne:"\u228b",supplus:"\u2ac0",Supset:"\u22d1",supset:"\u2283",supseteq:"\u2287",supseteqq:"\u2ac6",supsetneq:"\u228b",supsetneqq:"\u2acc",supsim:"\u2ac8",supsub:"\u2ad4",supsup:"\u2ad6",swarhk:"\u2926",swArr:"\u21d9",swarr:"\u2199",swarrow:"\u2199",swnwar:"\u292a",szlig:"\xdf",Tab:"\t",target:"\u2316",Tau:"\u03a4",tau:"\u03c4",tbrk:"\u23b4",Tcaron:"\u0164",tcaron:"\u0165",Tcedil:"\u0162",tcedil:"\u0163",Tcy:"\u0422",tcy:"\u0442",tdot:"\u20db",telrec:"\u2315",Tfr:"\ud835\udd17",tfr:"\ud835\udd31",there4:"\u2234",Therefore:"\u2234",therefore:"\u2234",Theta:"\u0398",theta:"\u03b8",thetasym:"\u03d1",thetav:"\u03d1",thickapprox:"\u2248",thicksim:"\u223c",ThickSpace:"\u205f\u200a",thinsp:"\u2009",ThinSpace:"\u2009",thkap:"\u2248",thksim:"\u223c",THORN:"\xde",thorn:"\xfe",Tilde:"\u223c",tilde:"\u02dc",TildeEqual:"\u2243",TildeFullEqual:"\u2245",TildeTilde:"\u2248",times:"\xd7",timesb:"\u22a0",timesbar:"\u2a31",timesd:"\u2a30",tint:"\u222d",toea:"\u2928",top:"\u22a4",topbot:"\u2336",topcir:"\u2af1",Topf:"\ud835\udd4b",topf:"\ud835\udd65",topfork:"\u2ada",tosa:"\u2929",tprime:"\u2034",TRADE:"\u2122",trade:"\u2122",triangle:"\u25b5",triangledown:"\u25bf",triangleleft:"\u25c3",trianglelefteq:"\u22b4",triangleq:"\u225c",triangleright:"\u25b9",trianglerighteq:"\u22b5",tridot:"\u25ec",trie:"\u225c",triminus:"\u2a3a",TripleDot:"\u20db",triplus:"\u2a39",trisb:"\u29cd",tritime:"\u2a3b",trpezium:"\u23e2",Tscr:"\ud835\udcaf",tscr:"\ud835\udcc9",TScy:"\u0426",tscy:"\u0446",TSHcy:"\u040b",tshcy:"\u045b",Tstrok:"\u0166",tstrok:"\u0167",twixt:"\u226c",twoheadleftarrow:"\u219e",twoheadrightarrow:"\u21a0",Uacute:"\xda",uacute:"\xfa",Uarr:"\u219f",uArr:"\u21d1",uarr:"\u2191",Uarrocir:"\u2949",Ubrcy:"\u040e",ubrcy:"\u045e",Ubreve:"\u016c",ubreve:"\u016d",Ucirc:"\xdb",ucirc:"\xfb",Ucy:"\u0423",ucy:"\u0443",udarr:"\u21c5",Udblac:"\u0170",udblac:"\u0171",udhar:"\u296e",ufisht:"\u297e",Ufr:"\ud835\udd18",ufr:"\ud835\udd32",Ugrave:"\xd9",ugrave:"\xf9",uHar:"\u2963",uharl:"\u21bf",uharr:"\u21be",uhblk:"\u2580",ulcorn:"\u231c",ulcorner:"\u231c",ulcrop:"\u230f",ultri:"\u25f8",Umacr:"\u016a",umacr:"\u016b",uml:"\xa8",UnderBar:"_",UnderBrace:"\u23df",UnderBracket:"\u23b5",UnderParenthesis:"\u23dd",Union:"\u22c3",UnionPlus:"\u228e",Uogon:"\u0172",uogon:"\u0173",Uopf:"\ud835\udd4c",uopf:"\ud835\udd66",UpArrow:"\u2191",Uparrow:"\u21d1",uparrow:"\u2191",UpArrowBar:"\u2912",UpArrowDownArrow:"\u21c5",UpDownArrow:"\u2195",Updownarrow:"\u21d5",updownarrow:"\u2195",UpEquilibrium:"\u296e",upharpoonleft:"\u21bf",upharpoonright:"\u21be",uplus:"\u228e",UpperLeftArrow:"\u2196",UpperRightArrow:"\u2197",Upsi:"\u03d2",upsi:"\u03c5",upsih:"\u03d2",Upsilon:"\u03a5",upsilon:"\u03c5",UpTee:"\u22a5",UpTeeArrow:"\u21a5",upuparrows:"\u21c8",urcorn:"\u231d",urcorner:"\u231d",urcrop:"\u230e",Uring:"\u016e",uring:"\u016f",urtri:"\u25f9",Uscr:"\ud835\udcb0",uscr:"\ud835\udcca",utdot:"\u22f0",Utilde:"\u0168",utilde:"\u0169",utri:"\u25b5",utrif:"\u25b4",uuarr:"\u21c8",Uuml:"\xdc",uuml:"\xfc",uwangle:"\u29a7",vangrt:"\u299c",varepsilon:"\u03f5",varkappa:"\u03f0",varnothing:"\u2205",varphi:"\u03d5",varpi:"\u03d6",varpropto:"\u221d",vArr:"\u21d5",varr:"\u2195",varrho:"\u03f1",varsigma:"\u03c2",varsubsetneq:"\u228a\ufe00",varsubsetneqq:"\u2acb\ufe00",varsupsetneq:"\u228b\ufe00",varsupsetneqq:"\u2acc\ufe00",vartheta:"\u03d1",vartriangleleft:"\u22b2",vartriangleright:"\u22b3",Vbar:"\u2aeb",vBar:"\u2ae8",vBarv:"\u2ae9",Vcy:"\u0412",vcy:"\u0432",VDash:"\u22ab",Vdash:"\u22a9",vDash:"\u22a8",vdash:"\u22a2",Vdashl:"\u2ae6",Vee:"\u22c1",vee:"\u2228",veebar:"\u22bb",veeeq:"\u225a",vellip:"\u22ee",Verbar:"\u2016",verbar:"|",Vert:"\u2016",vert:"|",VerticalBar:"\u2223",VerticalLine:"|",VerticalSeparator:"\u2758",VerticalTilde:"\u2240",VeryThinSpace:"\u200a",Vfr:"\ud835\udd19",vfr:"\ud835\udd33",vltri:"\u22b2",vnsub:"\u2282\u20d2",vnsup:"\u2283\u20d2",Vopf:"\ud835\udd4d",vopf:"\ud835\udd67",vprop:"\u221d",vrtri:"\u22b3",Vscr:"\ud835\udcb1",vscr:"\ud835\udccb",vsubnE:"\u2acb\ufe00",vsubne:"\u228a\ufe00",vsupnE:"\u2acc\ufe00",vsupne:"\u228b\ufe00",Vvdash:"\u22aa",vzigzag:"\u299a",Wcirc:"\u0174",wcirc:"\u0175",wedbar:"\u2a5f",Wedge:"\u22c0",wedge:"\u2227",wedgeq:"\u2259",weierp:"\u2118",Wfr:"\ud835\udd1a",wfr:"\ud835\udd34",Wopf:"\ud835\udd4e",wopf:"\ud835\udd68",wp:"\u2118",wr:"\u2240",wreath:"\u2240",Wscr:"\ud835\udcb2",wscr:"\ud835\udccc",xcap:"\u22c2",xcirc:"\u25ef",xcup:"\u22c3",xdtri:"\u25bd",Xfr:"\ud835\udd1b",xfr:"\ud835\udd35",xhArr:"\u27fa",xharr:"\u27f7",Xi:"\u039e",xi:"\u03be",xlArr:"\u27f8",xlarr:"\u27f5",xmap:"\u27fc",xnis:"\u22fb",xodot:"\u2a00",Xopf:"\ud835\udd4f",xopf:"\ud835\udd69",xoplus:"\u2a01",xotime:"\u2a02",xrArr:"\u27f9",xrarr:"\u27f6",Xscr:"\ud835\udcb3",xscr:"\ud835\udccd",xsqcup:"\u2a06",xuplus:"\u2a04",xutri:"\u25b3",xvee:"\u22c1",xwedge:"\u22c0",Yacute:"\xdd",yacute:"\xfd",YAcy:"\u042f",yacy:"\u044f",Ycirc:"\u0176",ycirc:"\u0177",Ycy:"\u042b",ycy:"\u044b",yen:"\xa5",Yfr:"\ud835\udd1c",yfr:"\ud835\udd36",YIcy:"\u0407",yicy:"\u0457",Yopf:"\ud835\udd50",yopf:"\ud835\udd6a",Yscr:"\ud835\udcb4",yscr:"\ud835\udcce",YUcy:"\u042e",yucy:"\u044e",Yuml:"\u0178",yuml:"\xff",Zacute:"\u0179",zacute:"\u017a",Zcaron:"\u017d",zcaron:"\u017e",Zcy:"\u0417",zcy:"\u0437",Zdot:"\u017b",zdot:"\u017c",zeetrf:"\u2128",ZeroWidthSpace:"\u200b",Zeta:"\u0396",zeta:"\u03b6",Zfr:"\u2128",zfr:"\ud835\udd37",ZHcy:"\u0416",zhcy:"\u0436",zigrarr:"\u21dd",Zopf:"\u2124",zopf:"\ud835\udd6b",Zscr:"\ud835\udcb5",zscr:"\ud835\udccf",zwj:"\u200d",zwnj:"\u200c"},t.NGSP_UNICODE="\ue500",t.NAMED_ENTITIES.ngsp=t.NGSP_UNICODE;}));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class bi{constructor({closedByChildren:e,implicitNamespacePrefix:t,contentType:r=vi.TagContentType.PARSABLE_DATA,closedByParent:n=!1,isVoid:i=!1,ignoreFirstLf:s=!1}={}){this.closedByChildren={},this.closedByParent=!1,this.canSelfClose=!1,e&&e.length>0&&e.forEach((e=>this.closedByChildren[e]=!0)),this.isVoid=i,this.closedByParent=n||i,this.implicitNamespacePrefix=t||null,this.contentType=r,this.ignoreFirstLf=s;}isClosedByChild(e){return this.isVoid||e.toLowerCase()in this.closedByChildren}}var Fi=bi;let Ai,wi;var Ni=function(e){return wi||(Ai=new bi,wi={base:new bi({isVoid:!0}),meta:new bi({isVoid:!0}),area:new bi({isVoid:!0}),embed:new bi({isVoid:!0}),link:new bi({isVoid:!0}),img:new bi({isVoid:!0}),input:new bi({isVoid:!0}),param:new bi({isVoid:!0}),hr:new bi({isVoid:!0}),br:new bi({isVoid:!0}),source:new bi({isVoid:!0}),track:new bi({isVoid:!0}),wbr:new bi({isVoid:!0}),p:new bi({closedByChildren:["address","article","aside","blockquote","div","dl","fieldset","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","main","nav","ol","p","pre","section","table","ul"],closedByParent:!0}),thead:new bi({closedByChildren:["tbody","tfoot"]}),tbody:new bi({closedByChildren:["tbody","tfoot"],closedByParent:!0}),tfoot:new bi({closedByChildren:["tbody"],closedByParent:!0}),tr:new bi({closedByChildren:["tr"],closedByParent:!0}),td:new bi({closedByChildren:["td","th"],closedByParent:!0}),th:new bi({closedByChildren:["td","th"],closedByParent:!0}),col:new bi({isVoid:!0}),svg:new bi({implicitNamespacePrefix:"svg"}),math:new bi({implicitNamespacePrefix:"math"}),li:new bi({closedByChildren:["li"],closedByParent:!0}),dt:new bi({closedByChildren:["dt","dd"]}),dd:new bi({closedByChildren:["dt","dd"],closedByParent:!0}),rb:new bi({closedByChildren:["rb","rt","rtc","rp"],closedByParent:!0}),rt:new bi({closedByChildren:["rb","rt","rtc","rp"],closedByParent:!0}),rtc:new bi({closedByChildren:["rb","rtc","rp"],closedByParent:!0}),rp:new bi({closedByChildren:["rb","rt","rtc","rp"],closedByParent:!0}),optgroup:new bi({closedByChildren:["optgroup"],closedByParent:!0}),option:new bi({closedByChildren:["option","optgroup"],closedByParent:!0}),pre:new bi({ignoreFirstLf:!0}),listing:new bi({ignoreFirstLf:!0}),style:new bi({contentType:vi.TagContentType.RAW_TEXT}),script:new bi({contentType:vi.TagContentType.RAW_TEXT}),title:new bi({contentType:vi.TagContentType.ESCAPABLE_RAW_TEXT}),textarea:new bi({contentType:vi.TagContentType.ESCAPABLE_RAW_TEXT,ignoreFirstLf:!0})}),wi[e]||Ai},ki=Object.defineProperty({HtmlTagDefinition:Fi,getHtmlTagDefinition:Ni},"__esModule",{value:!0});var Oi=
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class{constructor(e,t=-1){this.path=e,this.position=t;}get empty(){return !this.path||!this.path.length}get head(){return this.path[0]}get tail(){return this.path[this.path.length-1]}parentOf(e){return e&&this.path[this.path.indexOf(e)-1]}childOf(e){return this.path[this.path.indexOf(e)+1]}first(e){for(let t=this.path.length-1;t>=0;t--){let r=this.path[t];if(r instanceof e)return r}}push(e){this.path.push(e);}pop(){return this.path.pop()}},xi=Object.defineProperty({AstPath:Oi},"__esModule",{value:!0});var Ii=
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class{constructor(e,t,r){this.value=e,this.sourceSpan=t,this.i18n=r,this.type="text";}visit(e,t){return e.visitText(this,t)}};var Pi=class{constructor(e,t){this.value=e,this.sourceSpan=t,this.type="cdata";}visit(e,t){return e.visitCdata(this,t)}};var Ri=class{constructor(e,t,r,n,i,s){this.switchValue=e,this.type=t,this.cases=r,this.sourceSpan=n,this.switchValueSourceSpan=i,this.i18n=s;}visit(e,t){return e.visitExpansion(this,t)}};var Li=class{constructor(e,t,r,n,i){this.value=e,this.expression=t,this.sourceSpan=r,this.valueSourceSpan=n,this.expSourceSpan=i;}visit(e,t){return e.visitExpansionCase(this,t)}};var Bi=class{constructor(e,t,r,n=null,i=null,s=null){this.name=e,this.value=t,this.sourceSpan=r,this.valueSpan=n,this.nameSpan=i,this.i18n=s,this.type="attribute";}visit(e,t){return e.visitAttribute(this,t)}};class $i{constructor(e,t,r,n,i=null,s=null,o=null,a=null){this.name=e,this.attrs=t,this.children=r,this.sourceSpan=n,this.startSourceSpan=i,this.endSourceSpan=s,this.nameSpan=o,this.i18n=a,this.type="element";}visit(e,t){return e.visitElement(this,t)}}var qi=$i;var Mi=class{constructor(e,t){this.value=e,this.sourceSpan=t,this.type="comment";}visit(e,t){return e.visitComment(this,t)}};var Ui=class{constructor(e,t){this.value=e,this.sourceSpan=t,this.type="docType";}visit(e,t){return e.visitDocType(this,t)}};function Gi(e,t,r=null){const n=[],i=e.visit?t=>e.visit(t,r)||t.visit(e,r):t=>t.visit(e,r);return t.forEach((e=>{const t=i(e);t&&n.push(t);})),n}var ji=Gi;class Vi{constructor(){}visitElement(e,t){this.visitChildren(t,(t=>{t(e.attrs),t(e.children);}));}visitAttribute(e,t){}visitText(e,t){}visitCdata(e,t){}visitComment(e,t){}visitDocType(e,t){}visitExpansion(e,t){return this.visitChildren(t,(t=>{t(e.cases);}))}visitExpansionCase(e,t){}visitChildren(e,t){let r=[],n=this;return t((function(t){t&&r.push(Gi(n,t,e));})),Array.prototype.concat.apply([],r)}}var Hi=Vi;function Xi(e){const t=e.sourceSpan.start.offset;let r=e.sourceSpan.end.offset;return e instanceof $i&&(e.endSourceSpan?r=e.endSourceSpan.end.offset:e.children&&e.children.length&&(r=Xi(e.children[e.children.length-1]).end)),{start:t,end:r}}var zi=function(e,t){const r=[];return Gi(new class extends Vi{visit(e,n){const i=Xi(e);if(!(i.start<=t&&t<i.end))return !0;r.push(e);}},e),new xi.AstPath(r,t)},Wi=Object.defineProperty({Text:Ii,CDATA:Pi,Expansion:Ri,ExpansionCase:Li,Attribute:Bi,Element:qi,Comment:Mi,DocType:Ui,visitAll:ji,RecursiveVisitor:Hi,findNode:zi},"__esModule",{value:!0});var Yi=
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function(e,t){if(null!=t){if(!Array.isArray(t))throw new Error(`Expected '${e}' to be an array of strings.`);for(let r=0;r<t.length;r+=1)if("string"!=typeof t[r])throw new Error(`Expected '${e}' to be an array of strings.`)}};const Qi=[/^\s*$/,/[<>]/,/^[{}]$/,/&(#|[a-z])/i,/^\/\//];var Ji=function(e,t){if(!(null==t||Array.isArray(t)&&2==t.length))throw new Error(`Expected '${e}' to be an array, [start, end].`);if(null!=t){const e=t[0],r=t[1];Qi.forEach((t=>{if(t.test(e)||t.test(r))throw new Error(`['${e}', '${r}'] contains unusable interpolation symbol.`)}));}},Ki=Object.defineProperty({assertArrayOfStrings:Yi,assertInterpolationSymbols:Ji},"__esModule",{value:!0}),Zi=t$1((function(e,t){
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
Object.defineProperty(t,"__esModule",{value:!0});class r{constructor(e,t){this.start=e,this.end=t;}static fromArray(e){return e?(Ki.assertInterpolationSymbols("interpolation",e),new r(e[0],e[1])):t.DEFAULT_INTERPOLATION_CONFIG}}t.InterpolationConfig=r,t.DEFAULT_INTERPOLATION_CONFIG=new r("{{","}}");})),es=t$1((function(e,t){
/**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
Object.defineProperty(t,"__esModule",{value:!0});const n=r$1;var i;!function(e){e[e.TAG_OPEN_START=0]="TAG_OPEN_START",e[e.TAG_OPEN_END=1]="TAG_OPEN_END",e[e.TAG_OPEN_END_VOID=2]="TAG_OPEN_END_VOID",e[e.TAG_CLOSE=3]="TAG_CLOSE",e[e.TEXT=4]="TEXT",e[e.ESCAPABLE_RAW_TEXT=5]="ESCAPABLE_RAW_TEXT",e[e.RAW_TEXT=6]="RAW_TEXT",e[e.COMMENT_START=7]="COMMENT_START",e[e.COMMENT_END=8]="COMMENT_END",e[e.CDATA_START=9]="CDATA_START",e[e.CDATA_END=10]="CDATA_END",e[e.ATTR_NAME=11]="ATTR_NAME",e[e.ATTR_QUOTE=12]="ATTR_QUOTE",e[e.ATTR_VALUE=13]="ATTR_VALUE",e[e.DOC_TYPE_START=14]="DOC_TYPE_START",e[e.DOC_TYPE_END=15]="DOC_TYPE_END",e[e.EXPANSION_FORM_START=16]="EXPANSION_FORM_START",e[e.EXPANSION_CASE_VALUE=17]="EXPANSION_CASE_VALUE",e[e.EXPANSION_CASE_EXP_START=18]="EXPANSION_CASE_EXP_START",e[e.EXPANSION_CASE_EXP_END=19]="EXPANSION_CASE_EXP_END",e[e.EXPANSION_FORM_END=20]="EXPANSION_FORM_END",e[e.EOF=21]="EOF";}(i=t.TokenType||(t.TokenType={}));class s{constructor(e,t,r){this.type=e,this.parts=t,this.sourceSpan=r;}}t.Token=s;class o extends B.ParseError{constructor(e,t,r){super(r,e),this.tokenType=t;}}t.TokenError=o;class a{constructor(e,t){this.tokens=e,this.errors=t;}}t.TokenizeResult=a,t.tokenize=function(e,t,r,n={}){return new D(new B.ParseSourceFile(e,t),r,n).tokenize()};const u=/\r\n?/g;function c(e){return `Unexpected character "${e===n.$EOF?"EOF":String.fromCharCode(e)}"`}function l(e){return `Unknown entity "${e}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`}class p{constructor(e){this.error=e;}}class D{constructor(e,t,r){this._getTagContentType=t,this._currentTokenStart=null,this._currentTokenType=null,this._expansionCaseStack=[],this._inInterpolation=!1,this._fullNameStack=[],this.tokens=[],this.errors=[],this._tokenizeIcu=r.tokenizeExpansionForms||!1,this._interpolationConfig=r.interpolationConfig||Zi.DEFAULT_INTERPOLATION_CONFIG,this._leadingTriviaCodePoints=r.leadingTriviaChars&&r.leadingTriviaChars.map((e=>e.codePointAt(0)||0)),this._canSelfClose=r.canSelfClose||!1,this._allowHtmComponentClosingTags=r.allowHtmComponentClosingTags||!1;const n=r.range||{endPos:e.content.length,startPos:0,startLine:0,startCol:0};this._cursor=r.escapedString?new C(e,n):new E(e,n);try{this._cursor.init();}catch(e){this.handleError(e);}}_processCarriageReturns(e){return e.replace(u,"\n")}tokenize(){for(;this._cursor.peek()!==n.$EOF;){const e=this._cursor.clone();try{if(this._attemptCharCode(n.$LT))if(this._attemptCharCode(n.$BANG))this._attemptStr("[CDATA[")?this._consumeCdata(e):this._attemptStr("--")?this._consumeComment(e):this._attemptStrCaseInsensitive("doctype")?this._consumeDocType(e):this._consumeBogusComment(e);else if(this._attemptCharCode(n.$SLASH))this._consumeTagClose(e);else {const t=this._cursor.clone();this._attemptCharCode(n.$QUESTION)?(this._cursor=t,this._consumeBogusComment(e)):this._consumeTagOpen(e);}else this._tokenizeIcu&&this._tokenizeExpansionForm()||this._consumeText();}catch(e){this.handleError(e);}}return this._beginToken(i.EOF),this._endToken([]),new a(function(e){const t=[];let r;for(let n=0;n<e.length;n++){const s=e[n];r&&r.type==i.TEXT&&s.type==i.TEXT?(r.parts[0]+=s.parts[0],r.sourceSpan.end=s.sourceSpan.end):(r=s,t.push(r));}return t}(this.tokens),this.errors)}_tokenizeExpansionForm(){if(this.isExpansionFormStart())return this._consumeExpansionFormStart(),!0;if(((e=this._cursor.peek())===n.$EQ||n.isAsciiLetter(e)||n.isDigit(e))&&this._isInExpansionForm())return this._consumeExpansionCaseStart(),!0;var e;if(this._cursor.peek()===n.$RBRACE){if(this._isInExpansionCase())return this._consumeExpansionCaseEnd(),!0;if(this._isInExpansionForm())return this._consumeExpansionFormEnd(),!0}return !1}_beginToken(e,t=this._cursor.clone()){this._currentTokenStart=t,this._currentTokenType=e;}_endToken(e,t=this._cursor.clone()){if(null===this._currentTokenStart)throw new o("Programming error - attempted to end a token when there was no start to the token",this._currentTokenType,this._cursor.getSpan(t));if(null===this._currentTokenType)throw new o("Programming error - attempted to end a token which has no token type",null,this._cursor.getSpan(this._currentTokenStart));const r=new s(this._currentTokenType,e,this._cursor.getSpan(this._currentTokenStart,this._leadingTriviaCodePoints));return this.tokens.push(r),this._currentTokenStart=null,this._currentTokenType=null,r}_createError(e,t){this._isInExpansionForm()&&(e+=' (Do you have an unescaped "{" in your template? Use "{{ \'{\' }}") to escape it.)');const r=new o(e,this._currentTokenType,t);return this._currentTokenStart=null,this._currentTokenType=null,new p(r)}handleError(e){if(e instanceof T&&(e=this._createError(e.msg,this._cursor.getSpan(e.cursor))),!(e instanceof p))throw e;this.errors.push(e.error);}_attemptCharCode(e){return this._cursor.peek()===e&&(this._cursor.advance(),!0)}_attemptCharCodeCaseInsensitive(e){return t=this._cursor.peek(),r=e,g(t)==g(r)&&(this._cursor.advance(),!0);var t,r;}_requireCharCode(e){const t=this._cursor.clone();if(!this._attemptCharCode(e))throw this._createError(c(this._cursor.peek()),this._cursor.getSpan(t))}_attemptStr(e){const t=e.length;if(this._cursor.charsLeft()<t)return !1;const r=this._cursor.clone();for(let n=0;n<t;n++)if(!this._attemptCharCode(e.charCodeAt(n)))return this._cursor=r,!1;return !0}_attemptStrCaseInsensitive(e){for(let t=0;t<e.length;t++)if(!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t)))return !1;return !0}_requireStr(e){const t=this._cursor.clone();if(!this._attemptStr(e))throw this._createError(c(this._cursor.peek()),this._cursor.getSpan(t))}_requireStrCaseInsensitive(e){const t=this._cursor.clone();if(!this._attemptStrCaseInsensitive(e))throw this._createError(c(this._cursor.peek()),this._cursor.getSpan(t))}_attemptCharCodeUntilFn(e){for(;!e(this._cursor.peek());)this._cursor.advance();}_requireCharCodeUntilFn(e,t){const r=this._cursor.clone();this._attemptCharCodeUntilFn(e);if(this._cursor.clone().diff(r)<t)throw this._createError(c(this._cursor.peek()),this._cursor.getSpan(r))}_attemptUntilChar(e){for(;this._cursor.peek()!==e;)this._cursor.advance();}_readChar(e){if(e&&this._cursor.peek()===n.$AMPERSAND)return this._decodeEntity();{const e=String.fromCodePoint(this._cursor.peek());return this._cursor.advance(),e}}_decodeEntity(){const e=this._cursor.clone();if(this._cursor.advance(),!this._attemptCharCode(n.$HASH)){const t=this._cursor.clone();if(this._attemptCharCodeUntilFn(m),this._cursor.peek()!=n.$SEMICOLON)return this._cursor=t,"&";const r=this._cursor.getChars(t);this._cursor.advance();const i=vi.NAMED_ENTITIES[r];if(!i)throw this._createError(l(r),this._cursor.getSpan(e));return i}{const t=this._attemptCharCode(n.$x)||this._attemptCharCode(n.$X),r=this._cursor.clone();if(this._attemptCharCodeUntilFn(f),this._cursor.peek()!=n.$SEMICOLON)throw this._createError(c(this._cursor.peek()),this._cursor.getSpan());const i=this._cursor.getChars(r);this._cursor.advance();try{const e=parseInt(i,t?16:10);return String.fromCharCode(e)}catch(t){throw this._createError(l(this._cursor.getChars(e)),this._cursor.getSpan())}}}_consumeRawText(e,t){this._beginToken(e?i.ESCAPABLE_RAW_TEXT:i.RAW_TEXT);const r=[];for(;;){const n=this._cursor.clone(),i=t();if(this._cursor=n,i)break;r.push(this._readChar(e));}return this._endToken([this._processCarriageReturns(r.join(""))])}_consumeComment(e){this._beginToken(i.COMMENT_START,e),this._endToken([]),this._consumeRawText(!1,(()=>this._attemptStr("--\x3e"))),this._beginToken(i.COMMENT_END),this._requireStr("--\x3e"),this._endToken([]);}_consumeBogusComment(e){this._beginToken(i.COMMENT_START,e),this._endToken([]),this._consumeRawText(!1,(()=>this._cursor.peek()===n.$GT)),this._beginToken(i.COMMENT_END),this._cursor.advance(),this._endToken([]);}_consumeCdata(e){this._beginToken(i.CDATA_START,e),this._endToken([]),this._consumeRawText(!1,(()=>this._attemptStr("]]>"))),this._beginToken(i.CDATA_END),this._requireStr("]]>"),this._endToken([]);}_consumeDocType(e){this._beginToken(i.DOC_TYPE_START,e),this._endToken([]),this._consumeRawText(!1,(()=>this._cursor.peek()===n.$GT)),this._beginToken(i.DOC_TYPE_END),this._cursor.advance(),this._endToken([]);}_consumePrefixAndName(){const e=this._cursor.clone();let t="";for(;this._cursor.peek()!==n.$COLON&&!(((r=this._cursor.peek())<n.$a||n.$z<r)&&(r<n.$A||n.$Z<r)&&(r<n.$0||r>n.$9));)this._cursor.advance();var r;let i;this._cursor.peek()===n.$COLON?(t=this._cursor.getChars(e),this._cursor.advance(),i=this._cursor.clone()):i=e,this._requireCharCodeUntilFn(d,""===t?0:1);return [t,this._cursor.getChars(i)]}_consumeTagOpen(e){let t,r,s,o=this.tokens.length;const a=this._cursor.clone(),u=[];try{if(!n.isAsciiLetter(this._cursor.peek()))throw this._createError(c(this._cursor.peek()),this._cursor.getSpan(e));for(s=this._consumeTagOpenStart(e),r=s.parts[0],t=s.parts[1],this._attemptCharCodeUntilFn(h);this._cursor.peek()!==n.$SLASH&&this._cursor.peek()!==n.$GT;){const[e,t]=this._consumeAttributeName();if(this._attemptCharCodeUntilFn(h),this._attemptCharCode(n.$EQ)){this._attemptCharCodeUntilFn(h);const r=this._consumeAttributeValue();u.push({prefix:e,name:t,value:r});}else u.push({prefix:e,name:t});this._attemptCharCodeUntilFn(h);}this._consumeTagOpenEnd();}catch(t){if(t instanceof p)return this._cursor=a,s&&(this.tokens.length=o),this._beginToken(i.TEXT,e),void this._endToken(["<"]);throw t}if(this._canSelfClose&&this.tokens[this.tokens.length-1].type===i.TAG_OPEN_END_VOID)return;const l=this._getTagContentType(t,r,this._fullNameStack.length>0,u);this._handleFullNameStackForTagOpen(r,t),l===vi.TagContentType.RAW_TEXT?this._consumeRawTextWithTagClose(r,t,!1):l===vi.TagContentType.ESCAPABLE_RAW_TEXT&&this._consumeRawTextWithTagClose(r,t,!0);}_consumeRawTextWithTagClose(e,t,r){this._consumeRawText(r,(()=>!!this._attemptCharCode(n.$LT)&&(!!this._attemptCharCode(n.$SLASH)&&(this._attemptCharCodeUntilFn(h),!!this._attemptStrCaseInsensitive(e?`${e}:${t}`:t)&&(this._attemptCharCodeUntilFn(h),this._attemptCharCode(n.$GT)))))),this._beginToken(i.TAG_CLOSE),this._requireCharCodeUntilFn((e=>e===n.$GT),3),this._cursor.advance(),this._endToken([e,t]),this._handleFullNameStackForTagClose(e,t);}_consumeTagOpenStart(e){this._beginToken(i.TAG_OPEN_START,e);const t=this._consumePrefixAndName();return this._endToken(t)}_consumeAttributeName(){const e=this._cursor.peek();if(e===n.$SQ||e===n.$DQ)throw this._createError(c(e),this._cursor.getSpan());this._beginToken(i.ATTR_NAME);const t=this._consumePrefixAndName();return this._endToken(t),t}_consumeAttributeValue(){let e;if(this._cursor.peek()===n.$SQ||this._cursor.peek()===n.$DQ){this._beginToken(i.ATTR_QUOTE);const t=this._cursor.peek();this._cursor.advance(),this._endToken([String.fromCodePoint(t)]),this._beginToken(i.ATTR_VALUE);const r=[];for(;this._cursor.peek()!==t;)r.push(this._readChar(!0));e=this._processCarriageReturns(r.join("")),this._endToken([e]),this._beginToken(i.ATTR_QUOTE),this._cursor.advance(),this._endToken([String.fromCodePoint(t)]);}else {this._beginToken(i.ATTR_VALUE);const t=this._cursor.clone();this._requireCharCodeUntilFn(d,1),e=this._processCarriageReturns(this._cursor.getChars(t)),this._endToken([e]);}return e}_consumeTagOpenEnd(){const e=this._attemptCharCode(n.$SLASH)?i.TAG_OPEN_END_VOID:i.TAG_OPEN_END;this._beginToken(e),this._requireCharCode(n.$GT),this._endToken([]);}_consumeTagClose(e){if(this._beginToken(i.TAG_CLOSE,e),this._attemptCharCodeUntilFn(h),this._allowHtmComponentClosingTags&&this._attemptCharCode(n.$SLASH))this._attemptCharCodeUntilFn(h),this._requireCharCode(n.$GT),this._endToken([]);else {const[e,t]=this._consumePrefixAndName();this._attemptCharCodeUntilFn(h),this._requireCharCode(n.$GT),this._endToken([e,t]),this._handleFullNameStackForTagClose(e,t);}}_consumeExpansionFormStart(){this._beginToken(i.EXPANSION_FORM_START),this._requireCharCode(n.$LBRACE),this._endToken([]),this._expansionCaseStack.push(i.EXPANSION_FORM_START),this._beginToken(i.RAW_TEXT);const e=this._readUntil(n.$COMMA);this._endToken([e]),this._requireCharCode(n.$COMMA),this._attemptCharCodeUntilFn(h),this._beginToken(i.RAW_TEXT);const t=this._readUntil(n.$COMMA);this._endToken([t]),this._requireCharCode(n.$COMMA),this._attemptCharCodeUntilFn(h);}_consumeExpansionCaseStart(){this._beginToken(i.EXPANSION_CASE_VALUE);const e=this._readUntil(n.$LBRACE).trim();this._endToken([e]),this._attemptCharCodeUntilFn(h),this._beginToken(i.EXPANSION_CASE_EXP_START),this._requireCharCode(n.$LBRACE),this._endToken([]),this._attemptCharCodeUntilFn(h),this._expansionCaseStack.push(i.EXPANSION_CASE_EXP_START);}_consumeExpansionCaseEnd(){this._beginToken(i.EXPANSION_CASE_EXP_END),this._requireCharCode(n.$RBRACE),this._endToken([]),this._attemptCharCodeUntilFn(h),this._expansionCaseStack.pop();}_consumeExpansionFormEnd(){this._beginToken(i.EXPANSION_FORM_END),this._requireCharCode(n.$RBRACE),this._endToken([]),this._expansionCaseStack.pop();}_consumeText(){const e=this._cursor.clone();this._beginToken(i.TEXT,e);const t=[];do{this._interpolationConfig&&this._attemptStr(this._interpolationConfig.start)?(t.push(this._interpolationConfig.start),this._inInterpolation=!0):this._interpolationConfig&&this._inInterpolation&&this._attemptStr(this._interpolationConfig.end)?(t.push(this._interpolationConfig.end),this._inInterpolation=!1):t.push(this._readChar(!0));}while(!this._isTextEnd());this._endToken([this._processCarriageReturns(t.join(""))]);}_isTextEnd(){if(this._cursor.peek()===n.$LT||this._cursor.peek()===n.$EOF)return !0;if(this._tokenizeIcu&&!this._inInterpolation){if(this.isExpansionFormStart())return !0;if(this._cursor.peek()===n.$RBRACE&&this._isInExpansionCase())return !0}return !1}_readUntil(e){const t=this._cursor.clone();return this._attemptUntilChar(e),this._cursor.getChars(t)}_isInExpansionCase(){return this._expansionCaseStack.length>0&&this._expansionCaseStack[this._expansionCaseStack.length-1]===i.EXPANSION_CASE_EXP_START}_isInExpansionForm(){return this._expansionCaseStack.length>0&&this._expansionCaseStack[this._expansionCaseStack.length-1]===i.EXPANSION_FORM_START}isExpansionFormStart(){if(this._cursor.peek()!==n.$LBRACE)return !1;if(this._interpolationConfig){const e=this._cursor.clone(),t=this._attemptStr(this._interpolationConfig.start);return this._cursor=e,!t}return !0}_handleFullNameStackForTagOpen(e,t){const r=vi.mergeNsAndName(e,t);0!==this._fullNameStack.length&&this._fullNameStack[this._fullNameStack.length-1]!==r||this._fullNameStack.push(r);}_handleFullNameStackForTagClose(e,t){const r=vi.mergeNsAndName(e,t);0!==this._fullNameStack.length&&this._fullNameStack[this._fullNameStack.length-1]===r&&this._fullNameStack.pop();}}function h(e){return !n.isWhitespace(e)||e===n.$EOF}function d(e){return n.isWhitespace(e)||e===n.$GT||e===n.$SLASH||e===n.$SQ||e===n.$DQ||e===n.$EQ}function f(e){return e==n.$SEMICOLON||e==n.$EOF||!n.isAsciiHexDigit(e)}function m(e){return e==n.$SEMICOLON||e==n.$EOF||!n.isAsciiLetter(e)}function g(e){return e>=n.$a&&e<=n.$z?e-n.$a+n.$A:e}class E{constructor(e,t){if(e instanceof E)this.file=e.file,this.input=e.input,this.end=e.end,this.state=Object.assign({},e.state);else {if(!t)throw new Error("Programming error: the range argument must be provided with a file argument.");this.file=e,this.input=e.content,this.end=t.endPos,this.state={peek:-1,offset:t.startPos,line:t.startLine,column:t.startCol};}}clone(){return new E(this)}peek(){return this.state.peek}charsLeft(){return this.end-this.state.offset}diff(e){return this.state.offset-e.state.offset}advance(){this.advanceState(this.state);}init(){this.updatePeek(this.state);}getSpan(e,t){if(e=e||this,t)for(e=e.clone();this.diff(e)>0&&-1!==t.indexOf(e.peek());)e.advance();return new B.ParseSourceSpan(new B.ParseLocation(e.file,e.state.offset,e.state.line,e.state.column),new B.ParseLocation(this.file,this.state.offset,this.state.line,this.state.column))}getChars(e){return this.input.substring(e.state.offset,this.state.offset)}charAt(e){return this.input.charCodeAt(e)}advanceState(e){if(e.offset>=this.end)throw this.state=e,new T('Unexpected character "EOF"',this);const t=this.charAt(e.offset);t===n.$LF?(e.line++,e.column=0):n.isNewLine(t)||e.column++,e.offset++,this.updatePeek(e);}updatePeek(e){e.peek=e.offset>=this.end?n.$EOF:this.charAt(e.offset);}}class C extends E{constructor(e,t){e instanceof C?(super(e),this.internalState=Object.assign({},e.internalState)):(super(e,t),this.internalState=this.state);}advance(){this.state=this.internalState,super.advance(),this.processEscapeSequence();}init(){super.init(),this.processEscapeSequence();}clone(){return new C(this)}getChars(e){const t=e.clone();let r="";for(;t.internalState.offset<this.internalState.offset;)r+=String.fromCodePoint(t.peek()),t.advance();return r}processEscapeSequence(){const e=()=>this.internalState.peek;if(e()===n.$BACKSLASH)if(this.internalState=Object.assign({},this.state),this.advanceState(this.internalState),e()===n.$n)this.state.peek=n.$LF;else if(e()===n.$r)this.state.peek=n.$CR;else if(e()===n.$v)this.state.peek=n.$VTAB;else if(e()===n.$t)this.state.peek=n.$TAB;else if(e()===n.$b)this.state.peek=n.$BSPACE;else if(e()===n.$f)this.state.peek=n.$FF;else if(e()===n.$u)if(this.advanceState(this.internalState),e()===n.$LBRACE){this.advanceState(this.internalState);const t=this.clone();let r=0;for(;e()!==n.$RBRACE;)this.advanceState(this.internalState),r++;this.state.peek=this.decodeHexDigits(t,r);}else {const e=this.clone();this.advanceState(this.internalState),this.advanceState(this.internalState),this.advanceState(this.internalState),this.state.peek=this.decodeHexDigits(e,4);}else if(e()===n.$x){this.advanceState(this.internalState);const e=this.clone();this.advanceState(this.internalState),this.state.peek=this.decodeHexDigits(e,2);}else if(n.isOctalDigit(e())){let t="",r=0,i=this.clone();for(;n.isOctalDigit(e())&&r<3;)i=this.clone(),t+=String.fromCodePoint(e()),this.advanceState(this.internalState),r++;this.state.peek=parseInt(t,8),this.internalState=i.internalState;}else n.isNewLine(this.internalState.peek)?(this.advanceState(this.internalState),this.state=this.internalState):this.state.peek=this.internalState.peek;}decodeHexDigits(e,t){const r=this.input.substr(e.internalState.offset,t),n=parseInt(r,16);if(isNaN(n))throw e.state=e.internalState,new T("Invalid hexadecimal escape sequence",e);return n}}class T{constructor(e,t){this.msg=e,this.cursor=t;}}t.CursorError=T;}));
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class ts extends B.ParseError{constructor(e,t,r){super(t,r),this.elementName=e;}static create(e,t,r){return new ts(e,t,r)}}var rs=ts;class ns{constructor(e,t){this.rootNodes=e,this.errors=t;}}var is$1=ns;var ss=class{constructor(e){this.getTagDefinition=e;}parse(e,t,r,n=!1,i){const s=e=>(t,...r)=>e(t.toLowerCase(),...r),o=n?this.getTagDefinition:s(this.getTagDefinition),a=e=>o(e).contentType,u=n?i:s(i),c=i?(e,t,r,n)=>{const i=u(e,t,r,n);return void 0!==i?i:a(e)}:a,l=es.tokenize(e,t,c,r),p=r&&r.canSelfClose||!1,D=r&&r.allowHtmComponentClosingTags||!1,h=new os(l.tokens,o,p,D,n).build();return new ns(h.rootNodes,l.errors.concat(h.errors))}};class os{constructor(e,t,r,n,i){this.tokens=e,this.getTagDefinition=t,this.canSelfClose=r,this.allowHtmComponentClosingTags=n,this.isTagNameCaseSensitive=i,this._index=-1,this._rootNodes=[],this._errors=[],this._elementStack=[],this._advance();}build(){for(;this._peek.type!==es.TokenType.EOF;)this._peek.type===es.TokenType.TAG_OPEN_START?this._consumeStartTag(this._advance()):this._peek.type===es.TokenType.TAG_CLOSE?(this._closeVoidElement(),this._consumeEndTag(this._advance())):this._peek.type===es.TokenType.CDATA_START?(this._closeVoidElement(),this._consumeCdata(this._advance())):this._peek.type===es.TokenType.COMMENT_START?(this._closeVoidElement(),this._consumeComment(this._advance())):this._peek.type===es.TokenType.TEXT||this._peek.type===es.TokenType.RAW_TEXT||this._peek.type===es.TokenType.ESCAPABLE_RAW_TEXT?(this._closeVoidElement(),this._consumeText(this._advance())):this._peek.type===es.TokenType.EXPANSION_FORM_START?this._consumeExpansion(this._advance()):this._peek.type===es.TokenType.DOC_TYPE_START?this._consumeDocType(this._advance()):this._advance();return new ns(this._rootNodes,this._errors)}_advance(){const e=this._peek;return this._index<this.tokens.length-1&&this._index++,this._peek=this.tokens[this._index],e}_advanceIf(e){return this._peek.type===e?this._advance():null}_consumeCdata(e){const t=this._advance(),r=this._getText(t),n=this._advanceIf(es.TokenType.CDATA_END);this._addToParent(new Wi.CDATA(r,new B.ParseSourceSpan(e.sourceSpan.start,(n||t).sourceSpan.end)));}_consumeComment(e){const t=this._advanceIf(es.TokenType.RAW_TEXT),r=this._advanceIf(es.TokenType.COMMENT_END),n=null!=t?t.parts[0].trim():null,i=new B.ParseSourceSpan(e.sourceSpan.start,(r||t||e).sourceSpan.end);this._addToParent(new Wi.Comment(n,i));}_consumeDocType(e){const t=this._advanceIf(es.TokenType.RAW_TEXT),r=this._advanceIf(es.TokenType.DOC_TYPE_END),n=null!=t?t.parts[0].trim():null,i=new B.ParseSourceSpan(e.sourceSpan.start,(r||t||e).sourceSpan.end);this._addToParent(new Wi.DocType(n,i));}_consumeExpansion(e){const t=this._advance(),r=this._advance(),n=[];for(;this._peek.type===es.TokenType.EXPANSION_CASE_VALUE;){const e=this._parseExpansionCase();if(!e)return;n.push(e);}if(this._peek.type!==es.TokenType.EXPANSION_FORM_END)return void this._errors.push(ts.create(null,this._peek.sourceSpan,"Invalid ICU message. Missing '}'."));const i=new B.ParseSourceSpan(e.sourceSpan.start,this._peek.sourceSpan.end);this._addToParent(new Wi.Expansion(t.parts[0],r.parts[0],n,i,t.sourceSpan)),this._advance();}_parseExpansionCase(){const e=this._advance();if(this._peek.type!==es.TokenType.EXPANSION_CASE_EXP_START)return this._errors.push(ts.create(null,this._peek.sourceSpan,"Invalid ICU message. Missing '{'.")),null;const t=this._advance(),r=this._collectExpansionExpTokens(t);if(!r)return null;const n=this._advance();r.push(new es.Token(es.TokenType.EOF,[],n.sourceSpan));const i=new os(r,this.getTagDefinition,this.canSelfClose,this.allowHtmComponentClosingTags,this.isTagNameCaseSensitive).build();if(i.errors.length>0)return this._errors=this._errors.concat(i.errors),null;const s=new B.ParseSourceSpan(e.sourceSpan.start,n.sourceSpan.end),o=new B.ParseSourceSpan(t.sourceSpan.start,n.sourceSpan.end);return new Wi.ExpansionCase(e.parts[0],i.rootNodes,s,e.sourceSpan,o)}_collectExpansionExpTokens(e){const t=[],r=[es.TokenType.EXPANSION_CASE_EXP_START];for(;;){if(this._peek.type!==es.TokenType.EXPANSION_FORM_START&&this._peek.type!==es.TokenType.EXPANSION_CASE_EXP_START||r.push(this._peek.type),this._peek.type===es.TokenType.EXPANSION_CASE_EXP_END){if(!as(r,es.TokenType.EXPANSION_CASE_EXP_START))return this._errors.push(ts.create(null,e.sourceSpan,"Invalid ICU message. Missing '}'.")),null;if(r.pop(),0==r.length)return t}if(this._peek.type===es.TokenType.EXPANSION_FORM_END){if(!as(r,es.TokenType.EXPANSION_FORM_START))return this._errors.push(ts.create(null,e.sourceSpan,"Invalid ICU message. Missing '}'.")),null;r.pop();}if(this._peek.type===es.TokenType.EOF)return this._errors.push(ts.create(null,e.sourceSpan,"Invalid ICU message. Missing '}'.")),null;t.push(this._advance());}}_getText(e){let t=e.parts[0];if(t.length>0&&"\n"==t[0]){const e=this._getParentElement();null!=e&&0==e.children.length&&this.getTagDefinition(e.name).ignoreFirstLf&&(t=t.substring(1));}return t}_consumeText(e){const t=this._getText(e);t.length>0&&this._addToParent(new Wi.Text(t,e.sourceSpan));}_closeVoidElement(){const e=this._getParentElement();e&&this.getTagDefinition(e.name).isVoid&&this._elementStack.pop();}_consumeStartTag(e){const t=e.parts[0],r=e.parts[1],n=[];for(;this._peek.type===es.TokenType.ATTR_NAME;)n.push(this._consumeAttr(this._advance()));const i=this._getElementFullName(t,r,this._getParentElement());let s=!1;if(this._peek.type===es.TokenType.TAG_OPEN_END_VOID){this._advance(),s=!0;const t=this.getTagDefinition(i);this.canSelfClose||t.canSelfClose||null!==vi.getNsPrefix(i)||t.isVoid||this._errors.push(ts.create(i,e.sourceSpan,`Only void and foreign elements can be self closed "${e.parts[1]}"`));}else this._peek.type===es.TokenType.TAG_OPEN_END&&(this._advance(),s=!1);const o=this._peek.sourceSpan.start,a=new B.ParseSourceSpan(e.sourceSpan.start,o),u=new B.ParseSourceSpan(e.sourceSpan.start.moveBy(1),e.sourceSpan.end),c=new Wi.Element(i,n,[],a,a,void 0,u);this._pushElement(c),s&&(this._popElement(i),c.endSourceSpan=a);}_pushElement(e){const t=this._getParentElement();t&&this.getTagDefinition(t.name).isClosedByChild(e.name)&&this._elementStack.pop(),this._addToParent(e),this._elementStack.push(e);}_consumeEndTag(e){const t=this.allowHtmComponentClosingTags&&0===e.parts.length?null:this._getElementFullName(e.parts[0],e.parts[1],this._getParentElement());if(this._getParentElement()&&(this._getParentElement().endSourceSpan=e.sourceSpan),t&&this.getTagDefinition(t).isVoid)this._errors.push(ts.create(t,e.sourceSpan,`Void elements do not have end tags "${e.parts[1]}"`));else if(!this._popElement(t)){const r=`Unexpected closing tag "${t}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;this._errors.push(ts.create(t,e.sourceSpan,r));}}_popElement(e){for(let t=this._elementStack.length-1;t>=0;t--){const r=this._elementStack[t];if(!e||(vi.getNsPrefix(r.name)?r.name==e:r.name.toLowerCase()==e.toLowerCase()))return this._elementStack.splice(t,this._elementStack.length-t),!0;if(!this.getTagDefinition(r.name).closedByParent)return !1}return !1}_consumeAttr(e){const t=vi.mergeNsAndName(e.parts[0],e.parts[1]);let r,n,i=e.sourceSpan.end,s="";if(this._peek.type===es.TokenType.ATTR_QUOTE){n=this._advance().sourceSpan.start;}if(this._peek.type===es.TokenType.ATTR_VALUE){const e=this._advance();s=e.parts[0],i=e.sourceSpan.end,r=e.sourceSpan;}if(this._peek.type===es.TokenType.ATTR_QUOTE){i=this._advance().sourceSpan.end,r=new B.ParseSourceSpan(n,i);}return new Wi.Attribute(t,s,new B.ParseSourceSpan(e.sourceSpan.start,i),r,e.sourceSpan)}_getParentElement(){return this._elementStack.length>0?this._elementStack[this._elementStack.length-1]:null}_getParentElementSkippingContainers(){let e=null;for(let t=this._elementStack.length-1;t>=0;t--){if(!vi.isNgContainer(this._elementStack[t].name))return {parent:this._elementStack[t],container:e};e=this._elementStack[t];}return {parent:null,container:e}}_addToParent(e){const t=this._getParentElement();null!=t?t.children.push(e):this._rootNodes.push(e);}_insertBeforeContainer(e,t,r){if(t){if(e){const n=e.children.indexOf(t);e.children[n]=r;}else this._rootNodes.push(r);r.children.push(t),this._elementStack.splice(this._elementStack.indexOf(t),0,r);}else this._addToParent(r),this._elementStack.push(r);}_getElementFullName(e,t,r){return ""===e&&""===(e=this.getTagDefinition(t).implicitNamespacePrefix||"")&&null!=r&&(e=vi.getNsPrefix(r.name)),vi.mergeNsAndName(e,t)}}function as(e,t){return e.length>0&&e[e.length-1]===t}var us=Object.defineProperty({TreeError:rs,ParseTreeResult:is$1,Parser:ss},"__esModule",{value:!0}),cs=us,ls=cs.ParseTreeResult,ps=cs.TreeError;
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */class Ds extends us.Parser{constructor(){super(ki.getHtmlTagDefinition);}parse(e,t,r,n=!1,i){return super.parse(e,t,r,n,i)}}var hs=Ds,ds=Object.defineProperty({ParseTreeResult:ls,TreeError:ps,HtmlParser:hs},"__esModule",{value:!0}),fs=vi.TagContentType;let ms=null;var gs=function(e,t={}){const{canSelfClose:r=!1,allowHtmComponentClosingTags:n=!1,isTagNameCaseSensitive:i=!1,getTagContentType:s}=t;return (ms||(ms=new ds.HtmlParser),ms).parse(e,"angular-html-parser",{tokenizeExpansionForms:!1,interpolationConfig:void 0,canSelfClose:r,allowHtmComponentClosingTags:n},i,s)},Es=Object.defineProperty({TagContentType:fs,parse:gs},"__esModule",{value:!0});const{ParseSourceSpan:Cs,ParseLocation:Ts,ParseSourceFile:ys}=B,{inferParserByLanguage:Ss}=Pn,{HTML_ELEMENT_ATTRIBUTES:_s,HTML_TAGS:vs,isUnknownNamespace:bs}=Di,{hasPragma:Fs}=hi,{Node:As}=Ci,{parseIeConditionalComment:ws}=Si,{locStart:Ns,locEnd:ks}=_i;function Os(e,{recognizeSelfClosing:t,normalizeTagName:r,normalizeAttributeName:n,allowHtmComponentClosingTags:i,isTagNameCaseSensitive:s,getTagContentType:o},a){const u=Es,{RecursiveVisitor:c,visitAll:l}=Wi,{ParseSourceSpan:p}=B,{getHtmlTagDefinition:D}=ki;let{rootNodes:h,errors:d}=u.parse(e,{canSelfClose:t,allowHtmComponentClosingTags:i,isTagNameCaseSensitive:s,getTagContentType:o});if("vue"===a.parser){if(h.some((e=>"docType"===e.type&&"html"===e.value||"element"===e.type&&"html"===e.name.toLowerCase()))){t=!0,r=!0,n=!0,i=!0,s=!1;const o=u.parse(e,{canSelfClose:t,allowHtmComponentClosingTags:i,isTagNameCaseSensitive:s});h=o.rootNodes,d=o.errors;}else {const r=e=>{if(!e)return !1;if("element"!==e.type||"template"!==e.name)return !1;const t=e.attrs.find((e=>"lang"===e.name)),r=t&&t.value;return !r||"html"===Ss(r,a)};if(h.some(r)){let n;const o=()=>u.parse(e,{canSelfClose:t,allowHtmComponentClosingTags:i,isTagNameCaseSensitive:s}),a=()=>n||(n=o()),c=e=>a().rootNodes.find((({startSourceSpan:t})=>t&&t.start.offset===e.startSourceSpan.start.offset));for(let e=0;e<h.length;e++){const t=h[e],{endSourceSpan:n,startSourceSpan:i}=t;if(null===n){d=a().errors,h[e]=c(t)||t;}else if(r(t)){const r=a(),s=i.end.offset,o=n.start.offset;for(const e of r.errors){const{offset:t}=e.span.start;if(s<t&&t<o){d=[e];break}}h[e]=c(t)||t;}}}}}if(d.length>0){const{msg:e,span:{start:t,end:r}}=d[0];throw U(e,{start:{line:t.line+1,column:t.col+1},end:{line:r.line+1,column:r.col+1}})}const f=e=>{const t=e.name.startsWith(":")?e.name.slice(1).split(":")[0]:null,r=e.nameSpan.toString(),n=null!==t&&r.startsWith(`${t}:`),i=n?r.slice(t.length+1):r;e.name=i,e.namespace=t,e.hasExplicitNamespace=n;},m=(e,t)=>{const r=e.toLowerCase();return t(r)?r:e};return l(new class extends c{visit(e){(e=>{if("element"===e.type){f(e);for(const t of e.attrs)f(t),t.valueSpan?(t.value=t.valueSpan.toString(),/["']/.test(t.value[0])&&(t.value=t.value.slice(1,-1))):t.value=null;}else "comment"===e.type?e.value=e.sourceSpan.toString().slice("\x3c!--".length,-"--\x3e".length):"text"===e.type&&(e.value=e.sourceSpan.toString());})(e),(e=>{if("element"===e.type){const t=D(s?e.name:e.name.toLowerCase());!e.namespace||e.namespace===t.implicitNamespacePrefix||bs(e)?e.tagDefinition=t:e.tagDefinition=D("");}})(e),(e=>{if("element"===e.type&&(!r||e.namespace&&e.namespace!==e.tagDefinition.implicitNamespacePrefix&&!bs(e)||(e.name=m(e.name,(e=>e in vs))),n)){const t=_s[e.name]||Object.create(null);for(const r of e.attrs)r.namespace||(r.name=m(r.name,(r=>e.name in _s&&(r in _s["*"]||r in t))));}})(e),(e=>{e.sourceSpan&&e.endSourceSpan&&(e.sourceSpan=new p(e.sourceSpan.start,e.endSourceSpan.end));})(e);}},h),h}function xs(e,t,r,n=!0){const{frontMatter:i,content:s}=n?q(e):{frontMatter:null,content:e},o=new ys(e,t.filepath),a=new Ts(o,0,0,0),u=a.moveBy(e.length),c={type:"root",sourceSpan:new Cs(a,u),children:Os(s,r,t)};if(i){const e=new Ts(o,0,0,0),t=e.moveBy(i.raw.length);i.sourceSpan=new Cs(e,t),c.children.unshift(i);}const l=new As(c),p=(n,i)=>{const{offset:s}=i,o=xs(e.slice(0,s).replace(/[^\n\r]/g," ")+n,t,r,!1);o.sourceSpan=new Cs(i,M(o.children).sourceSpan.end);const a=o.children[0];return a.length===s?o.children.shift():(a.sourceSpan=new Cs(a.sourceSpan.start.moveBy(s),a.sourceSpan.end),a.value=a.value.slice(s)),o};return l.map((e=>{if("comment"===e.type){const t=ws(e,p);if(t)return t}return e}))}function Is({recognizeSelfClosing:e=!1,normalizeTagName:t=!1,normalizeAttributeName:r=!1,allowHtmComponentClosingTags:n=!1,isTagNameCaseSensitive:i=!1,getTagContentType:s}={}){return {parse:(o,a,u)=>xs(o,u,{recognizeSelfClosing:e,normalizeTagName:t,normalizeAttributeName:r,allowHtmComponentClosingTags:n,isTagNameCaseSensitive:i,getTagContentType:s}),hasPragma:Fs,astFormat:"html",locStart:Ns,locEnd:ks}}var Ps={parsers:{html:Is({recognizeSelfClosing:!0,normalizeTagName:!0,normalizeAttributeName:!0,allowHtmComponentClosingTags:!0}),angular:Is(),vue:Is({recognizeSelfClosing:!0,isTagNameCaseSensitive:!0,getTagContentType:(e,t,r,n)=>{if("html"!==e.toLowerCase()&&!r&&("template"!==e||n.some((({name:e,value:t})=>"lang"===e&&"html"!==t))))return Es.TagContentType.RAW_TEXT}}),lwc:Is()}};

const SpxEditor$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.controlsSelected = true;
    this.setActive = (e) => {
      if (e.target.getAttribute('name-inner')) {
        this.activeName = e.target.getAttribute('name-inner');
      }
      else {
        this.active = e.target.name;
        if (this.currentData[this.active].examples) {
          this.activeName = this.currentData[this.active].examples[0];
        }
      }
    };
    this.onSearch = (e) => {
      if (e.target.value === '') {
        this.currentData = this.data;
      }
      else {
        this.currentData = filter$1(this.data, function (o) {
          return o.name.includes(e.target.value);
        });
      }
    };
    this.switchControls = () => {
      this.controlsSelected = !this.controlsSelected;
    };
    this.onChangeControl = () => {
      //
    };
  }
  onChangeComponent() {
    const template = (this.data[this.active].examples.length >= 2
      ? this.el.querySelector(`template[data-spx-element="${this.active}"][data-spx-name="${this.activeName}"]`)
      : this.el.querySelector(`template[data-spx-element="${this.active}"]`));
    if (template) {
      const node = template.content.cloneNode(true);
      const wrapper = document.createElement('div');
      wrapper.appendChild(node);
      this.currentElement = wrapper.firstChild.nextSibling;
      this.currentCode = S$.format(wrapper.innerHTML, {
        parser: 'html',
        plugins: [Ps],
      });
    }
  }
  componentWillLoad() {
    const data = {};
    [
      accordion,
      animate,
      classToggle,
      code,
      editButton,
      group,
      icon,
      iframe,
      imageComparison,
      lightbox,
      masonry,
      mockup,
      navigation,
      notation,
      offset$4,
      scrollspy,
      share,
      slider,
      slideshow,
      snackbar,
      textPath,
      typewriter,
    ].forEach((item) => {
      const examples = {
        examples: [],
      };
      this.el
        .querySelectorAll(`template[data-spx-element="${item.name}"]`)
        .forEach((item) => {
        examples['examples'].push(item.getAttribute('data-spx-name'));
      });
      data[item['name']] = Object.assign(Object.assign({}, item), examples);
    });
    this.data = data;
    this.currentData = data;
    this.onChangeComponent();
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
  }
  componentWillUpdate() {
    globalComponentWillUpdate({ el: this.el });
  }
  /**
   * Load an array of JSON objects in the spx format.
   *
   * @param {Array} data Array of JSON objects.
   */
  async load(data) {
    console.log(data);
  }
  render() {
    var _a;
    const { css } = cssEmotion(this.el.shadowRoot);
    const { tw } = cssTw(this.el.shadowRoot);
    const stw = {
      text: 'text-blue-gray-700',
      textActive: 'text-blue-gray-900',
      hover: 'hover:text-blue-gray-700 hover:bg-blue-gray-100',
    };
    /** Host styles. */
    const styleHost = css$2({
      display: 'block',
      height: '100%',
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      gridTemplateColumns: '250px minmax(0, 1fr) 250px',
      gridTemplateRows: '40px 1fr',
      fontFamily: 'inter, sans-serif',
      '*': {
        boxSizing: 'border-box',
        fontFamily: 'inter, sans-serif !important',
      },
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { class: `${styleShadowHost} ${tw(`bg-white grid antialiased
            ${this.fullscreen
        ? 'fixed top-0 left-0 w-screen h-screen z-[9999999999]'
        : 'h-full'}`)}` }, h$4("div", { class: tw(`border-b border-r flex items-center relative border-blue-gray-200`) }, h$4("spx-icon", { class: tw(`absolute top-1/2 -translate-y-1/2 left-2`), icon: "search-outline" }), h$4(TextInput, { class: tw(`pl-7 border-none w-full h-full text-md focus`), placeholder: "Search here", onInput: this.onSearch })), h$4("div", { class: tw(`flex items-center border-b border-blue-gray-200 pl-4 justify-between`) }, h$4("h1", { class: tw(`font-semibold text-md`) }, (_a = titleCase(this.active.replace('spx-', '').replaceAll('-', ' '))) !== null && _a !== void 0 ? _a : 'No component active'), h$4("div", { class: tw(`flex h-full`) }, [
      {
        icon: 'code-slash-outline',
        function: () => (this.code = !this.code),
        active: this.code,
      },
      {
        icon: 'expand-outline',
        function: () => (this.fullscreen = !this.fullscreen),
        active: this.fullscreen,
      },
    ].map((item) => {
      return (h$4(Button, { class: tw(`focus flex items-center relative justify-center w-12 h-full rounded-none text-blue-gray-500 ${stw.hover}
                      ${item.active && stw.textActive}`), onClick: item.function }, item.active && (h$4("span", { class: tw(`absolute h-0.5 w-full bg-blue-gray-700 w-full -bottom-px`) })), h$4("spx-icon", { icon: item.icon })));
    }))), h$4("div", { class: tw(`border-l border-b border-blue-gray-200`) }, h$4(Button, { class: tw(`focus flex px-2 text-center font-medium items-center relative justify-center w-full h-full rounded-none text-blue-gray-500 text-sm ${stw.hover}`), onClick: this.switchControls }, !this.controlsSelected
      ? 'Show Selected Settings'
      : 'Show All Settings')), h$4("div", { tabindex: "-1", class: tw(`grid auto-rows-max border-r border-blue-gray-200 divide-dashed divide-y divide-blue-gray-200 overflow-y-auto`) }, Object.values(this.currentData).map((object) => {
      const isActive = this.active === object.name;
      return (h$4("div", { class: tw(`relative only-child:border-b only-child:border-blue-gray-100`) }, h$4(Button, { name: object.name, tabindex: isActive ? '-1' : '0', class: tw(`focus w-full p-3 pl-7 text-sm ${stw.hover}
                    ${isActive
          ? `font-semibold pointer-events-none ${stw.textActive}`
          : stw.text}`), onClick: this.setActive }, titleCase(object.name.replace('spx-', '').replaceAll('-', ' '))), isActive && object.examples.length >= 2 && (h$4("div", { class: tw(`grid`) }, Object.values(object.examples).map((item) => {
        const isActiveName = this.activeName === item;
        return (h$4(Button, { "name-inner": item, class: tw(`relative ml-1 p-2 pl-6 text-sm focus ${stw.hover}
                              ${isActiveName
            ? `font-medium pointer-events-none ${stw.textActive}`
            : stw.text}
                              `), onClick: this.setActive }, isActiveName && (h$4("span", { class: tw(`absolute -left-1 w-1 top-0 h-full bg-blue-gray-700 z-10`) })), item));
      }))), this.active === object.name && (h$4("span", { class: tw(`absolute left-0 w-1 top-0 h-full bg-blue-gray-300`) }))));
    })), h$4("div", { class: tw(`bg-blue-gray-50 flex items-center justify-center`) }, this.code ? (h$4("spx-code", { style: {
        filter: 'saturate(1.25)',
      }, class: tw(`w-full h-full`), "border-radius": "0", height: "100%", theme: "dracula" }, this.currentCode)) : (h$4("div", { class: tw(`w-[80%] h-[80%] flex flex-col items-center justify-center`), innerHTML: this.currentCode }))), h$4("div", { class: tw(`border-l border-blue-gray-200 px-4 py-6 h-full overflow-y-auto`) }, h$4("spx-control-group", null, Object.values(this.data[this.active].properties).map((item) => {
      var _a;
      const value = (func) => {
        var _a;
        return ((_a = this.currentElement.getAttribute(item.attribute)) !== null && _a !== void 0 ? _a : func);
      };
      const select = find$1(item.tags, function (o) {
        return o.name === 'choice';
      });
      const label = item.attribute
        .replaceAll('-', ' ')
        .toUpperCase();
      return (h$4("div", null, item.type === 'string' && select ? (h$4("spx-control-select", { "data-attr": item.attribute, handleChange: this.onChangeControl, label: label, options: select === null || select === void 0 ? void 0 : select.text.replaceAll("', '", ',').slice(1, -1), selected: value(item.defaultValue) })) : item.type === 'string' &&
        !item.attribute.includes('color') ? (h$4("spx-control-text", { "data-attr": item.attribute, handleChange: this.onChangeControl, label: label, value: value((_a = item.defaultValue) === null || _a === void 0 ? void 0 : _a.slice(1, -1)) })) : item.type === 'number' ? (h$4("spx-control-slider", { "data-attr": item.attribute, handleChange: this.onChangeControl, label: label, start: value(item.defaultValue), max: item.defaultValue * 1.5, min: item.defaultValue * 0.5 })) : item.type === 'boolean' ? (h$4("spx-control-switch", { "data-attr": item.attribute, handleChange: this.onChangeControl, label: label, checked: this.currentElement.getAttribute(item.attribute) ===
          'true'
          ? true
          : this.currentElement.getAttribute(item.attribute) === 'false'
            ? false
            : this.currentElement.hasAttribute(item.attribute)
              ? true
              : item.defaultValue === 'true' })) : (item.attribute.includes('color') && (h$4("spx-control-color", { color: "#f7f7f7", label: label })))));
    }))))));
  }
  get el() { return this; }
  static get watchers() { return {
    "active": ["onChangeComponent"],
    "activeName": ["onChangeComponent"]
  }; }
};

const tag$g = 'spx-group';
const SpxGroup$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.spxGroupDidLoad = createEvent(this, "spxGroupDidLoad", 7);
    this.display = display$1;
    this.forwardAttributes = () => {
      const getAllTagMatches = (regEx) => {
        return Array.prototype.slice
          .call(this.el.querySelectorAll('*'))
          .filter(function (el) {
          return el.tagName.match(regEx);
        });
      };
      /** Get all tag matches. */
      const elements = this.target
        ? getAllTagMatches(new RegExp(this.target, 'i'))
        : getAllTagMatches(/^spx/i);
      /** Loop matches. */
      for (let att, i = 0, atts = this.el.attributes, n = atts.length; i < n; i++) {
        att = atts[i];
        if (startsWith(att.nodeName, 'g-')) {
          elements.forEach((item) => {
            item.setAttribute(att.nodeName.substring(2), att.nodeValue);
          });
        }
      }
    };
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.forwardAttributes();
    /** Set up mutation observer. */
    const observer = new MutationObserver((mutations) => {
      mutations.forEach(() => {
        this.forwardAttributes();
      });
    });
    observer.observe(this.el, {
      attributes: true,
    });
    this.spxGroupDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    var _a;
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$g, 'display', this.display),
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { innerHTML: (_a = this.content) !== null && _a !== void 0 ? _a : this.el.innerHTML })));
  }
  get el() { return this; }
};

const spxIconCss = "@keyframes loader{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}:host div.loader{animation-duration:1s;animation-fill-mode:forwards;animation-iteration-count:infinite;animation-name:loader;animation-timing-function:linear;transform-origin:center}";

const tag$f = 'spx-icon';
const SpxIcon$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxIconDidLoad = createEvent(this, "spxIconDidLoad", 7);
    this.color = 'inherit';
    this.display = 'inline-block';
    /**
     * Icon type.
     *
     * @choice 'ionicons', 'caret'
     */
    this.type = 'ionicons';
    /** Icon size. */
    this.size = '1em';
    this.sizeMin = 0.8;
    this.sizeMax = 1;
    /**
     * Styling.
     *
     * @choice 'default', 'fluid'
     */
    this.styling = 'default';
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.spxIconDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$f, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      color: setVar(tag$f, 'color', this.color),
    });
    /** Ionicon styles. */
    const styleIonicon = css({
      color: setVar(tag$f, 'color', this.color),
      fontSize: setStyle(tag$f, 'size', this.size, this.sizeMin, this.sizeMax, this.styling),
    });
    /** Loader styles. */
    const styleLoader = css({
      fontSize: '1em',
      width: '1em',
      color: setVar(tag$f, 'color', this.color),
    });
    /** Caret styles. */
    const styleIcon = css({
      fontSize: '0.7em',
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleShadowHost + (this.type === 'loader' && ' loader') }, this.type === 'ionicons' ? (h$4("ion-icon", { name: this.icon, class: styleIonicon })) : this.type === 'caret' ? (h$4("i", { class: styleIcon }, "\u25BC")) : (this.type === 'loader' && (h$4("svg", { "aria-hidden": "true", focusable: "false", role: "img", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", class: styleLoader }, h$4("path", { fill: "currentColor", d: "M460.116 373.846l-20.823-12.022c-5.541-3.199-7.54-10.159-4.663-15.874 30.137-59.886 28.343-131.652-5.386-189.946-33.641-58.394-94.896-95.833-161.827-99.676C261.028 55.961 256 50.751 256 44.352V20.309c0-6.904 5.808-12.337 12.703-11.982 83.556 4.306 160.163 50.864 202.11 123.677 42.063 72.696 44.079 162.316 6.031 236.832-3.14 6.148-10.75 8.461-16.728 5.01z" })))))));
  }
  get el() { return this; }
  static get style() { return spxIconCss; }
};

const tag$e = 'spx-iframe';
const SpxIframe$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxIframeDidLoad = createEvent(this, "spxIframeDidLoad", 7);
    this.display = display$1;
    this.documentBorder = 'none';
    this.documentBorderRadius = 'none';
    this.documentHeight = 'auto';
    this.documentWidth = '100%';
    this.loaderBackground = 'var(--spx-color-gray-900)';
    this.loaderColor = '#ffffff';
    this.loaderBorderRadius = borderRadius;
    this.minHeight = '400px';
    /** Screen size of the site shown inside the iframe. */
    this.size = '1440px';
    /** Source for the iframe. */
    this.src = 'https://spx.dev';
    /**
     * Screen size of the site shown inside the iframe.
     *
     * @choice 'resize', 'document'
     */
    this.type = 'resize';
    /** Fit function. */
    this.setHeight = () => {
      const set = () => {
        if (this.el.shadowRoot.querySelector('iframe').contentWindow.document
          .body === undefined ||
          this.el.shadowRoot.querySelector('iframe').contentWindow.document
            .body === null) {
          setTimeout(set, 100);
        }
        else {
          this.iframe.style.height =
            this.el.shadowRoot.querySelector('iframe').contentWindow.document.body
              .scrollHeight + 'px';
        }
      };
      set();
    };
    /** Set up mutation observer. */
    this.setUpMutationObserver = () => {
      mutationObserver(this.el.shadowRoot.querySelector('iframe').contentWindow.document.body, {
        attributes: true,
        childList: true,
        subtree: true,
      }, () => {
        this.setHeight();
        setTimeout(() => this.setHeight(), 500);
      });
    };
    /** Type: resize - function to keep src element in proportion. */
    this.handleResize = () => {
      if (this.parent && this.iframe) {
        const ratio = this.parent.offsetWidth / this.iframe.offsetWidth;
        this.iframe.style.transform = 'scale(calc((' + ratio + '))';
        this.parentHeight = this.parent.offsetHeight;
        this.iframe.style.height = this.parentHeight / ratio + 'px';
      }
    };
    /** Type: document - add all slot elements to iframe. */
    this.createIframeContent = () => {
      const doc = this.iframe.contentDocument;
      this.content.querySelectorAll('*').forEach((item) => {
        doc.body.appendChild(item);
      });
      this.content.remove();
    };
  }
  onResize() {
    if (this.type === 'resize') {
      this.handleResize();
    }
    if (this.fit) {
      this.setHeight();
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    /** Setup lazy loading. */
    if (this.lazy) {
      // @ts-ignore
      // eslint-disable-next-line no-unused-vars
      new lazyload_min({
        unobserve_entered: true,
        unobserve_completed: true,
        callback_loaded: () => {
          setTimeout(() => {
            if (this.fit) {
              this.setHeight();
              this.setUpMutationObserver();
            }
            if (this.type === 'resize') {
              this.handleResize();
            }
          }, 10);
        },
      }, this.el.shadowRoot.querySelectorAll('[data-src]'));
    }
    if (this.type === 'resize') {
      /** Assign states. */
      this.iframe = this.el.shadowRoot.querySelector('iframe');
      this.parent = this.el.shadowRoot.querySelector(':scope > div');
      /** Wait for Iframe to load before showing content. */
      this.el.shadowRoot.querySelector('iframe').onload = () => {
        this.loaded = true;
        if (!this.lazy) {
          this.handleResize();
        }
      };
    }
    if (this.type === 'document') {
      this.createIframeContent();
    }
    if (this.fit && !this.lazy) {
      this.setHeight();
      this.setUpMutationObserver();
    }
    this.spxIframeDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  componentDidUpdate() {
    if (this.type === 'resize') {
      this.handleResize();
    }
    if (this.type === 'document') {
      this.createIframeContent();
    }
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$e, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      height: 'auto',
      width: '100%',
      position: 'relative',
      minHeight: setVar(tag$e, 'min-height', this.minHeight),
    });
    /** Iframe resize styles. */
    const styleIframeResize = css({
      border: 'none',
      width: this.size,
      transformOrigin: 'left top',
      position: 'absolute',
      minHeight: setVar(tag$e, 'min-height', this.minHeight),
    });
    /** Iframe document styles. */
    const styleIframeDocument = css({
      border: setVar(tag$e, 'document-border', this.documentBorder),
      borderRadius: setVar(tag$e, 'document-border-radius', this.documentBorderRadius),
      width: setVar(tag$e, 'document-width', this.documentWidth),
      height: setVar(tag$e, 'document-height', this.documentHeight),
    });
    /** Iframe styles. */
    const styleIframe = this.type === 'resize'
      ? styleIframeResize
      : this.type === 'document' && styleIframeDocument;
    /** Loader styles. */
    const styleLoader = css({
      padding: '0.8em',
      borderRadius: setVar(tag$e, 'loader-border-radius', this.loaderBorderRadius),
      backgroundColor: setVar(tag$e, 'loader-background', this.loaderBackground),
      position: 'absolute',
      left: '50%',
      top: '50%',
      transform: 'translate(-50%, -50%) scale(2)',
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleShadowHost }, this.type === 'document' && (h$4("div", { ref: (el) => (this.content = el), innerHTML: this.el.innerHTML })), this.type === 'resize' ? (h$4("iframe", { class: styleIframe, ref: (el) => (this.iframe = el), tabindex: "-1", src: !this.lazy ? this.src : '', "data-src": this.lazy && this.src })) : (h$4("iframe", { class: styleIframe, ref: (el) => (this.iframe = el), tabindex: "-1" })), this.type === 'resize' && !this.loaded && (h$4("div", { class: styleLoader }, h$4("spx-icon", { type: "loader", color: setVar(tag$e, 'loader-color', this.loaderColor) }))))));
  }
  get el() { return this; }
};

const tag$d = 'spx-image-comparison';
const SpxImageComparison$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxImageComparisonDidLoad = createEvent(this, "spxImageComparisonDidLoad", 7);
    this.color = '#ffffff';
    this.display = display$1;
    this.height = '100%';
    this.iconColor = 'var(--spx-color-gray-900)';
    /** Image URL of the before image. */
    this.srcAfter = 'https://source.unsplash.com/random/1200x300';
    /** Image URL of the after image. */
    this.srcBefore = 'https://source.unsplash.com/random/1201x300';
    /** Step amount when using component with arrow keys. */
    this.steps = 10;
    /** Opening state in pixels. */
    this.start = 150;
    /**
     * Thumb mover function.
     *
     * @param {event} e Mover function.
     */
    this.mover = (e) => {
      if (!this.active)
        return;
      let x = e.pageX;
      x -= this.container.getBoundingClientRect().left;
      this.move(x);
    };
    this.moveLeft = () => {
      if (this.x >= 2) {
        this.move(this.x - this.steps);
      }
    };
    this.moveRight = () => {
      if (this.x <= this.width) {
        this.move(this.x + this.steps);
      }
    };
  }
  onResize() {
    if (this.el.offsetWidth !== this.width) {
      this.move(this.start);
      this.width = this.root.offsetWidth;
    }
  }
  move(x) {
    /** Show image in start. */
    const transform = Math.max(0, Math.min(x, this.container.offsetWidth));
    this.imageAfter.style.width = transform + 2 + 'px';
    this.scroller.style.left = transform - 25 + 'px';
    if (x >= 2 && x <= this.width) {
      this.x = x;
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el, lazy: this.lazy });
    /** Set starting width. */
    this.width = this.root.offsetWidth;
    /** Disable for Oxygen. */
    if (document.body.classList.contains('oxygen-builder-body')) {
      this.scroller.style.pointerEvents = 'none';
    }
    /** Use boolean to know when it is being used. */
    this.active = false;
    /** Watch for clicks on scroller. */
    this.scroller.addEventListener('mousedown', () => {
      this.active = true;
    });
    /** Add scrolling class to the scroller so it has full opacity while active. */
    document.body.addEventListener('mouseup', () => {
      this.active = false;
    });
    /** Watch body for changes to the state. */
    document.body.addEventListener('mouseleave', () => {
      this.active = false;
    });
    /** Figure out where the mouse is. */
    document.body.addEventListener('mousemove', (e) => {
      this.mover(e);
    });
    /** Set starting width. */
    this.move(this.start);
    /** Repeat for touch events. */
    this.scroller.addEventListener('touchstart', () => {
      this.active = true;
    });
    document.body.addEventListener('touchend', () => {
      this.active = false;
    });
    document.body.addEventListener('touchcancel', () => {
      this.active = false;
    });
    document.body.addEventListener('touchmove', (e) => {
      this.mover(e);
    });
    this.spxImageComparisonDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$d, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      display: 'block',
      position: 'relative',
      height: setVar(tag$d, 'height', this.height),
      width: '100%',
      overflow: 'hidden',
    });
    /** Container styles. */
    const styleContainer = css({
      width: '100%',
      height: setVar(tag$d, 'height', this.height),
      backgroundRepeat: 'no-repeat',
      backgroundColor: 'white',
      backgroundSize: 'cover',
      backgroundPosition: 'center',
      position: 'absolute',
      top: '0',
      left: '0',
      pointerEvents: 'none',
      overflow: 'hidden',
      userSelect: 'none',
    });
    /** Image styles. */
    const styleImage = css({
      height: '100%',
      maxWidth: 'none !important',
    });
    /** Image after styles. */
    const styleImageAfter = css({
      width: '125px',
    });
    /** Scroller styles. */
    const styleScroller = css(Object.assign({ width: '50px', height: '50px', position: 'absolute', left: '100px', top: '50%', transform: 'translateY(-50%)', borderRadius: '50%', backgroundColor: ' transparent', opacity: this.active ? 1 : 0.9, pointerEvents: !this.active ? 'auto' : 'none', cursor: 'pointer', background: setVar(tag$d, 'color', this.color), border: '4px solid ' + setVar(tag$d, 'color', this.color) + '', transitionProperty: 'box-shadow, opacity', transitionDuration: transitionDuration, transitionTimingFunction: transitionTimingFunction, '&:hover': {
        opacity: 1,
      }, '&:after, &:before': {
        content: '" "',
        display: 'block',
        width: '4px',
        height: '9999px',
        position: 'absolute',
        left: '50%',
        marginLeft: '-2px',
        zIndex: 30,
        transition: '0.1s',
        background: setVar(tag$d, 'color', this.color),
      }, '&:before': {
        top: '100%',
      }, '&:after': {
        bottom: '100%',
      } }, focus));
    /** Thumb styles. */
    const styleThumb = css({
      height: '100%',
      width: '100%',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      'spx-icon': {
        transform: 'rotate(45deg)',
      },
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { ref: (el) => (this.root = el), class: styleShadowHost }, this.srcBefore &&
      this.srcAfter && [
      h$4("div", { ref: (el) => (this.container = el), class: styleContainer }, h$4("img", { class: styleImage, src: !this.lazy && this.srcBefore, "data-src": this.lazy && this.srcBefore, alt: "before" })),
      h$4("div", { ref: (el) => (this.imageAfter = el), class: css([styleContainer, styleImageAfter]) }, h$4("img", { class: styleImage, src: !this.lazy && this.srcAfter, "data-src": this.lazy && this.srcAfter, alt: "after" })),
      h$4(Button, { as: "button", ref: (el) => (this.scroller = el), class: styleScroller, onArrowLeft: this.moveLeft, onArrowRight: this.moveRight }, h$4("div", { class: styleThumb }, h$4("spx-icon", { icon: "resize", size: "32px", color: this.iconColor }))),
    ])));
  }
  get el() { return this; }
  static get watchers() { return {
    "start": ["move"]
  }; }
};

var glightbox_min = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,(function(){function e(t){return (e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function n(e,t,n){return t&&i(e.prototype,t),n&&i(e,n),e}var s=Date.now();function l(){var e={},t=!0,i=0,n=arguments.length;"[object Boolean]"===Object.prototype.toString.call(arguments[0])&&(t=arguments[0],i++);for(var s=function(i){for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(t&&"[object Object]"===Object.prototype.toString.call(i[n])?e[n]=l(!0,e[n],i[n]):e[n]=i[n]);};i<n;i++){var o=arguments[i];s(o);}return e}function o(e,t){if((k(e)||e===window||e===document)&&(e=[e]),A(e)||L(e)||(e=[e]),0!=P(e))if(A(e)&&!L(e))for(var i=e.length,n=0;n<i&&!1!==t.call(e[n],e[n],n,e);n++);else if(L(e))for(var s in e)if(O(e,s)&&!1===t.call(e[s],e[s],s,e))break}function r(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=e[s]=e[s]||[],l={all:n,evt:null,found:null};return t&&i&&P(n)>0&&o(n,(function(e,n){if(e.eventName==t&&e.fn.toString()==i.toString())return l.found=!0,l.evt=n,!1})),l}function a(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=t.onElement,n=t.withCallback,s=t.avoidDuplicate,l=void 0===s||s,a=t.once,h=void 0!==a&&a,d=t.useCapture,c=void 0!==d&&d,u=arguments.length>2?arguments[2]:void 0,g=i||[];function v(e){T(n)&&n.call(u,e,this),h&&v.destroy();}return C(g)&&(g=document.querySelectorAll(g)),v.destroy=function(){o(g,(function(t){var i=r(t,e,v);i.found&&i.all.splice(i.evt,1),t.removeEventListener&&t.removeEventListener(e,v,c);}));},o(g,(function(t){var i=r(t,e,v);(t.addEventListener&&l&&!i.found||!l)&&(t.addEventListener(e,v,c),i.all.push({eventName:e,fn:v}));})),v}function h(e,t){o(t.split(" "),(function(t){return e.classList.add(t)}));}function d(e,t){o(t.split(" "),(function(t){return e.classList.remove(t)}));}function c(e,t){return e.classList.contains(t)}function u(e,t){for(;e!==document.body;){if(!(e=e.parentElement))return !1;if("function"==typeof e.matches?e.matches(t):e.msMatchesSelector(t))return e}}function g(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e||""===t)return !1;if("none"==t)return T(i)&&i(),!1;var n=x(),s=t.split(" ");o(s,(function(t){h(e,"g"+t);})),a(n,{onElement:e,avoidDuplicate:!1,once:!0,withCallback:function(e,t){o(s,(function(e){d(t,"g"+e);})),T(i)&&i();}});}function v(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if(""==t)return e.style.webkitTransform="",e.style.MozTransform="",e.style.msTransform="",e.style.OTransform="",e.style.transform="",!1;e.style.webkitTransform=t,e.style.MozTransform=t,e.style.msTransform=t,e.style.OTransform=t,e.style.transform=t;}function f(e){e.style.display="block";}function p(e){e.style.display="none";}function m(e){var t=document.createDocumentFragment(),i=document.createElement("div");for(i.innerHTML=e;i.firstChild;)t.appendChild(i.firstChild);return t}function y(){return {width:window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,height:window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}}function x(){var e,t=document.createElement("fakeelement"),i={animation:"animationend",OAnimation:"oAnimationEnd",MozAnimation:"animationend",WebkitAnimation:"webkitAnimationEnd"};for(e in i)if(void 0!==t.style[e])return i[e]}function b(e,t,i,n){if(e())t();else {var s;i||(i=100);var l=setInterval((function(){e()&&(clearInterval(l),s&&clearTimeout(s),t());}),i);n&&(s=setTimeout((function(){clearInterval(l);}),n));}}function S(e,t,i){if(I(e))console.error("Inject assets error");else if(T(t)&&(i=t,t=!1),C(t)&&t in window)T(i)&&i();else {var n;if(-1!==e.indexOf(".css")){if((n=document.querySelectorAll('link[href="'+e+'"]'))&&n.length>0)return void(T(i)&&i());var s=document.getElementsByTagName("head")[0],l=s.querySelectorAll('link[rel="stylesheet"]'),o=document.createElement("link");return o.rel="stylesheet",o.type="text/css",o.href=e,o.media="all",l?s.insertBefore(o,l[0]):s.appendChild(o),void(T(i)&&i())}if((n=document.querySelectorAll('script[src="'+e+'"]'))&&n.length>0){if(T(i)){if(C(t))return b((function(){return void 0!==window[t]}),(function(){i();})),!1;i();}}else {var r=document.createElement("script");r.type="text/javascript",r.src=e,r.onload=function(){if(T(i)){if(C(t))return b((function(){return void 0!==window[t]}),(function(){i();})),!1;i();}},document.body.appendChild(r);}}}function w(){return "navigator"in window&&window.navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(Android)|(PlayBook)|(BB10)|(BlackBerry)|(Opera Mini)|(IEMobile)|(webOS)|(MeeGo)/i)}function T(e){return "function"==typeof e}function C(e){return "string"==typeof e}function k(e){return !(!e||!e.nodeType||1!=e.nodeType)}function E(e){return Array.isArray(e)}function A(e){return e&&e.length&&isFinite(e.length)}function L(t){return "object"===e(t)&&null!=t&&!T(t)&&!E(t)}function I(e){return null==e}function O(e,t){return null!==e&&hasOwnProperty.call(e,t)}function P(e){if(L(e)){if(e.keys)return e.keys().length;var t=0;for(var i in e)O(e,i)&&t++;return t}return e.length}function M(e){return !isNaN(parseFloat(e))&&isFinite(e)}function X(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,t=document.querySelectorAll(".gbtn[data-taborder]:not(.disabled)");if(!t.length)return !1;if(1==t.length)return t[0];"string"==typeof e&&(e=parseInt(e));var i=e<0?1:e+1;i>t.length&&(i="1");var n=[];o(t,(function(e){n.push(e.getAttribute("data-taborder"));}));var s=n.filter((function(e){return e>=parseInt(i)})),l=s.sort()[0];return document.querySelector('.gbtn[data-taborder="'.concat(l,'"]'))}function z(e){if(e.events.hasOwnProperty("keyboard"))return !1;e.events.keyboard=a("keydown",{onElement:window,withCallback:function(t,i){var n=(t=t||window.event).keyCode;if(9==n){var s=document.querySelector(".gbtn.focused");if(!s){var l=!(!document.activeElement||!document.activeElement.nodeName)&&document.activeElement.nodeName.toLocaleLowerCase();if("input"==l||"textarea"==l||"button"==l)return}t.preventDefault();var o=document.querySelectorAll(".gbtn[data-taborder]");if(!o||o.length<=0)return;if(!s){var r=X();return void(r&&(r.focus(),h(r,"focused")))}var a=X(s.getAttribute("data-taborder"));d(s,"focused"),a&&(a.focus(),h(a,"focused"));}39==n&&e.nextSlide(),37==n&&e.prevSlide(),27==n&&e.close();}});}function Y(e){return Math.sqrt(e.x*e.x+e.y*e.y)}function q(e,t){var i=function(e,t){var i=Y(e)*Y(t);if(0===i)return 0;var n=function(e,t){return e.x*t.x+e.y*t.y}(e,t)/i;return n>1&&(n=1),Math.acos(n)}(e,t);return function(e,t){return e.x*t.y-t.x*e.y}(e,t)>0&&(i*=-1),180*i/Math.PI}var N=function(){function e(i){t(this,e),this.handlers=[],this.el=i;}return n(e,[{key:"add",value:function(e){this.handlers.push(e);}},{key:"del",value:function(e){e||(this.handlers=[]);for(var t=this.handlers.length;t>=0;t--)this.handlers[t]===e&&this.handlers.splice(t,1);}},{key:"dispatch",value:function(){for(var e=0,t=this.handlers.length;e<t;e++){var i=this.handlers[e];"function"==typeof i&&i.apply(this.el,arguments);}}}]),e}();function D(e,t){var i=new N(e);return i.add(t),i}var _=function(){function e(i,n){t(this,e),this.element="string"==typeof i?document.querySelector(i):i,this.start=this.start.bind(this),this.move=this.move.bind(this),this.end=this.end.bind(this),this.cancel=this.cancel.bind(this),this.element.addEventListener("touchstart",this.start,!1),this.element.addEventListener("touchmove",this.move,!1),this.element.addEventListener("touchend",this.end,!1),this.element.addEventListener("touchcancel",this.cancel,!1),this.preV={x:null,y:null},this.pinchStartLen=null,this.zoom=1,this.isDoubleTap=!1;var s=function(){};this.rotate=D(this.element,n.rotate||s),this.touchStart=D(this.element,n.touchStart||s),this.multipointStart=D(this.element,n.multipointStart||s),this.multipointEnd=D(this.element,n.multipointEnd||s),this.pinch=D(this.element,n.pinch||s),this.swipe=D(this.element,n.swipe||s),this.tap=D(this.element,n.tap||s),this.doubleTap=D(this.element,n.doubleTap||s),this.longTap=D(this.element,n.longTap||s),this.singleTap=D(this.element,n.singleTap||s),this.pressMove=D(this.element,n.pressMove||s),this.twoFingerPressMove=D(this.element,n.twoFingerPressMove||s),this.touchMove=D(this.element,n.touchMove||s),this.touchEnd=D(this.element,n.touchEnd||s),this.touchCancel=D(this.element,n.touchCancel||s),this.translateContainer=this.element,this._cancelAllHandler=this.cancelAll.bind(this),window.addEventListener("scroll",this._cancelAllHandler),this.delta=null,this.last=null,this.now=null,this.tapTimeout=null,this.singleTapTimeout=null,this.longTapTimeout=null,this.swipeTimeout=null,this.x1=this.x2=this.y1=this.y2=null,this.preTapPosition={x:null,y:null};}return n(e,[{key:"start",value:function(e){if(e.touches){if(e.target&&e.target.nodeName&&["a","button","input"].indexOf(e.target.nodeName.toLowerCase())>=0)console.log("ignore drag for this touched element",e.target.nodeName.toLowerCase());else {this.now=Date.now(),this.x1=e.touches[0].pageX,this.y1=e.touches[0].pageY,this.delta=this.now-(this.last||this.now),this.touchStart.dispatch(e,this.element),null!==this.preTapPosition.x&&(this.isDoubleTap=this.delta>0&&this.delta<=250&&Math.abs(this.preTapPosition.x-this.x1)<30&&Math.abs(this.preTapPosition.y-this.y1)<30,this.isDoubleTap&&clearTimeout(this.singleTapTimeout)),this.preTapPosition.x=this.x1,this.preTapPosition.y=this.y1,this.last=this.now;var t=this.preV;if(e.touches.length>1){this._cancelLongTap(),this._cancelSingleTap();var i={x:e.touches[1].pageX-this.x1,y:e.touches[1].pageY-this.y1};t.x=i.x,t.y=i.y,this.pinchStartLen=Y(t),this.multipointStart.dispatch(e,this.element);}this._preventTap=!1,this.longTapTimeout=setTimeout(function(){this.longTap.dispatch(e,this.element),this._preventTap=!0;}.bind(this),750);}}}},{key:"move",value:function(e){if(e.touches){var t=this.preV,i=e.touches.length,n=e.touches[0].pageX,s=e.touches[0].pageY;if(this.isDoubleTap=!1,i>1){var l=e.touches[1].pageX,o=e.touches[1].pageY,r={x:e.touches[1].pageX-n,y:e.touches[1].pageY-s};null!==t.x&&(this.pinchStartLen>0&&(e.zoom=Y(r)/this.pinchStartLen,this.pinch.dispatch(e,this.element)),e.angle=q(r,t),this.rotate.dispatch(e,this.element)),t.x=r.x,t.y=r.y,null!==this.x2&&null!==this.sx2?(e.deltaX=(n-this.x2+l-this.sx2)/2,e.deltaY=(s-this.y2+o-this.sy2)/2):(e.deltaX=0,e.deltaY=0),this.twoFingerPressMove.dispatch(e,this.element),this.sx2=l,this.sy2=o;}else {if(null!==this.x2){e.deltaX=n-this.x2,e.deltaY=s-this.y2;var a=Math.abs(this.x1-this.x2),h=Math.abs(this.y1-this.y2);(a>10||h>10)&&(this._preventTap=!0);}else e.deltaX=0,e.deltaY=0;this.pressMove.dispatch(e,this.element);}this.touchMove.dispatch(e,this.element),this._cancelLongTap(),this.x2=n,this.y2=s,i>1&&e.preventDefault();}}},{key:"end",value:function(e){if(e.changedTouches){this._cancelLongTap();var t=this;e.touches.length<2&&(this.multipointEnd.dispatch(e,this.element),this.sx2=this.sy2=null),this.x2&&Math.abs(this.x1-this.x2)>30||this.y2&&Math.abs(this.y1-this.y2)>30?(e.direction=this._swipeDirection(this.x1,this.x2,this.y1,this.y2),this.swipeTimeout=setTimeout((function(){t.swipe.dispatch(e,t.element);}),0)):(this.tapTimeout=setTimeout((function(){t._preventTap||t.tap.dispatch(e,t.element),t.isDoubleTap&&(t.doubleTap.dispatch(e,t.element),t.isDoubleTap=!1);}),0),t.isDoubleTap||(t.singleTapTimeout=setTimeout((function(){t.singleTap.dispatch(e,t.element);}),250))),this.touchEnd.dispatch(e,this.element),this.preV.x=0,this.preV.y=0,this.zoom=1,this.pinchStartLen=null,this.x1=this.x2=this.y1=this.y2=null;}}},{key:"cancelAll",value:function(){this._preventTap=!0,clearTimeout(this.singleTapTimeout),clearTimeout(this.tapTimeout),clearTimeout(this.longTapTimeout),clearTimeout(this.swipeTimeout);}},{key:"cancel",value:function(e){this.cancelAll(),this.touchCancel.dispatch(e,this.element);}},{key:"_cancelLongTap",value:function(){clearTimeout(this.longTapTimeout);}},{key:"_cancelSingleTap",value:function(){clearTimeout(this.singleTapTimeout);}},{key:"_swipeDirection",value:function(e,t,i,n){return Math.abs(e-t)>=Math.abs(i-n)?e-t>0?"Left":"Right":i-n>0?"Up":"Down"}},{key:"on",value:function(e,t){this[e]&&this[e].add(t);}},{key:"off",value:function(e,t){this[e]&&this[e].del(t);}},{key:"destroy",value:function(){return this.singleTapTimeout&&clearTimeout(this.singleTapTimeout),this.tapTimeout&&clearTimeout(this.tapTimeout),this.longTapTimeout&&clearTimeout(this.longTapTimeout),this.swipeTimeout&&clearTimeout(this.swipeTimeout),this.element.removeEventListener("touchstart",this.start),this.element.removeEventListener("touchmove",this.move),this.element.removeEventListener("touchend",this.end),this.element.removeEventListener("touchcancel",this.cancel),this.rotate.del(),this.touchStart.del(),this.multipointStart.del(),this.multipointEnd.del(),this.pinch.del(),this.swipe.del(),this.tap.del(),this.doubleTap.del(),this.longTap.del(),this.singleTap.del(),this.pressMove.del(),this.twoFingerPressMove.del(),this.touchMove.del(),this.touchEnd.del(),this.touchCancel.del(),this.preV=this.pinchStartLen=this.zoom=this.isDoubleTap=this.delta=this.last=this.now=this.tapTimeout=this.singleTapTimeout=this.longTapTimeout=this.swipeTimeout=this.x1=this.x2=this.y1=this.y2=this.preTapPosition=this.rotate=this.touchStart=this.multipointStart=this.multipointEnd=this.pinch=this.swipe=this.tap=this.doubleTap=this.longTap=this.singleTap=this.pressMove=this.touchMove=this.touchEnd=this.touchCancel=this.twoFingerPressMove=null,window.removeEventListener("scroll",this._cancelAllHandler),null}}]),e}();function W(e){var t=function(){var e,t=document.createElement("fakeelement"),i={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(e in i)if(void 0!==t.style[e])return i[e]}(),i=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=c(e,"gslide-media")?e:e.querySelector(".gslide-media"),s=u(n,".ginner-container"),l=e.querySelector(".gslide-description");i>769&&(n=s),h(n,"greset"),v(n,"translate3d(0, 0, 0)"),a(t,{onElement:n,once:!0,withCallback:function(e,t){d(n,"greset");}}),n.style.opacity="",l&&(l.style.opacity="");}function B(e){if(e.events.hasOwnProperty("touch"))return !1;var t,i,n,s=y(),l=s.width,o=s.height,r=!1,a=null,g=null,f=null,p=!1,m=1,x=1,b=!1,S=!1,w=null,T=null,C=null,k=null,E=0,A=0,L=!1,I=!1,O={},P={},M=0,X=0,z=document.getElementById("glightbox-slider"),Y=document.querySelector(".goverlay"),q=new _(z,{touchStart:function(t){if(r=!0,(c(t.targetTouches[0].target,"ginner-container")||u(t.targetTouches[0].target,".gslide-desc")||"a"==t.targetTouches[0].target.nodeName.toLowerCase())&&(r=!1),u(t.targetTouches[0].target,".gslide-inline")&&!c(t.targetTouches[0].target.parentNode,"gslide-inline")&&(r=!1),r){if(P=t.targetTouches[0],O.pageX=t.targetTouches[0].pageX,O.pageY=t.targetTouches[0].pageY,M=t.targetTouches[0].clientX,X=t.targetTouches[0].clientY,a=e.activeSlide,g=a.querySelector(".gslide-media"),n=a.querySelector(".gslide-inline"),f=null,c(g,"gslide-image")&&(f=g.querySelector("img")),(window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth)>769&&(g=a.querySelector(".ginner-container")),d(Y,"greset"),t.pageX>20&&t.pageX<window.innerWidth-20)return;t.preventDefault();}},touchMove:function(s){if(r&&(P=s.targetTouches[0],!b&&!S)){if(n&&n.offsetHeight>o){var a=O.pageX-P.pageX;if(Math.abs(a)<=13)return !1}p=!0;var h,d=s.targetTouches[0].clientX,c=s.targetTouches[0].clientY,u=M-d,m=X-c;if(Math.abs(u)>Math.abs(m)?(L=!1,I=!0):(I=!1,L=!0),t=P.pageX-O.pageX,E=100*t/l,i=P.pageY-O.pageY,A=100*i/o,L&&f&&(h=1-Math.abs(i)/o,Y.style.opacity=h,e.settings.touchFollowAxis&&(E=0)),I&&(h=1-Math.abs(t)/l,g.style.opacity=h,e.settings.touchFollowAxis&&(A=0)),!f)return v(g,"translate3d(".concat(E,"%, 0, 0)"));v(g,"translate3d(".concat(E,"%, ").concat(A,"%, 0)"));}},touchEnd:function(){if(r){if(p=!1,S||b)return C=w,void(k=T);var t=Math.abs(parseInt(A)),i=Math.abs(parseInt(E));if(!(t>29&&f))return t<29&&i<25?(h(Y,"greset"),Y.style.opacity=1,W(g)):void 0;e.close();}},multipointEnd:function(){setTimeout((function(){b=!1;}),50);},multipointStart:function(){b=!0,m=x||1;},pinch:function(e){if(!f||p)return !1;b=!0,f.scaleX=f.scaleY=m*e.zoom;var t=m*e.zoom;if(S=!0,t<=1)return S=!1,t=1,k=null,C=null,w=null,T=null,void f.setAttribute("style","");t>4.5&&(t=4.5),f.style.transform="scale3d(".concat(t,", ").concat(t,", 1)"),x=t;},pressMove:function(e){if(S&&!b){var t=P.pageX-O.pageX,i=P.pageY-O.pageY;C&&(t+=C),k&&(i+=k),w=t,T=i;var n="translate3d(".concat(t,"px, ").concat(i,"px, 0)");x&&(n+=" scale3d(".concat(x,", ").concat(x,", 1)")),v(f,n);}},swipe:function(t){if(!S)if(b)b=!1;else {if("Left"==t.direction){if(e.index==e.elements.length-1)return W(g);e.nextSlide();}if("Right"==t.direction){if(0==e.index)return W(g);e.prevSlide();}}}});e.events.touch=q;}var H=function(){function e(i,n){var s=this,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(t(this,e),this.img=i,this.slide=n,this.onclose=l,this.img.setZoomEvents)return !1;this.active=!1,this.zoomedIn=!1,this.dragging=!1,this.currentX=null,this.currentY=null,this.initialX=null,this.initialY=null,this.xOffset=0,this.yOffset=0,this.img.addEventListener("mousedown",(function(e){return s.dragStart(e)}),!1),this.img.addEventListener("mouseup",(function(e){return s.dragEnd(e)}),!1),this.img.addEventListener("mousemove",(function(e){return s.drag(e)}),!1),this.img.addEventListener("click",(function(e){return s.slide.classList.contains("dragging-nav")?(s.zoomOut(),!1):s.zoomedIn?void(s.zoomedIn&&!s.dragging&&s.zoomOut()):s.zoomIn()}),!1),this.img.setZoomEvents=!0;}return n(e,[{key:"zoomIn",value:function(){var e=this.widowWidth();if(!(this.zoomedIn||e<=768)){var t=this.img;if(t.setAttribute("data-style",t.getAttribute("style")),t.style.maxWidth=t.naturalWidth+"px",t.style.maxHeight=t.naturalHeight+"px",t.naturalWidth>e){var i=e/2-t.naturalWidth/2;this.setTranslate(this.img.parentNode,i,0);}this.slide.classList.add("zoomed"),this.zoomedIn=!0;}}},{key:"zoomOut",value:function(){this.img.parentNode.setAttribute("style",""),this.img.setAttribute("style",this.img.getAttribute("data-style")),this.slide.classList.remove("zoomed"),this.zoomedIn=!1,this.currentX=null,this.currentY=null,this.initialX=null,this.initialY=null,this.xOffset=0,this.yOffset=0,this.onclose&&"function"==typeof this.onclose&&this.onclose();}},{key:"dragStart",value:function(e){e.preventDefault(),this.zoomedIn?("touchstart"===e.type?(this.initialX=e.touches[0].clientX-this.xOffset,this.initialY=e.touches[0].clientY-this.yOffset):(this.initialX=e.clientX-this.xOffset,this.initialY=e.clientY-this.yOffset),e.target===this.img&&(this.active=!0,this.img.classList.add("dragging"))):this.active=!1;}},{key:"dragEnd",value:function(e){var t=this;e.preventDefault(),this.initialX=this.currentX,this.initialY=this.currentY,this.active=!1,setTimeout((function(){t.dragging=!1,t.img.isDragging=!1,t.img.classList.remove("dragging");}),100);}},{key:"drag",value:function(e){this.active&&(e.preventDefault(),"touchmove"===e.type?(this.currentX=e.touches[0].clientX-this.initialX,this.currentY=e.touches[0].clientY-this.initialY):(this.currentX=e.clientX-this.initialX,this.currentY=e.clientY-this.initialY),this.xOffset=this.currentX,this.yOffset=this.currentY,this.img.isDragging=!0,this.dragging=!0,this.setTranslate(this.img,this.currentX,this.currentY));}},{key:"onMove",value:function(e){if(this.zoomedIn){var t=e.clientX-this.img.naturalWidth/2,i=e.clientY-this.img.naturalHeight/2;this.setTranslate(this.img,t,i);}}},{key:"setTranslate",value:function(e,t,i){e.style.transform="translate3d("+t+"px, "+i+"px, 0)";}},{key:"widowWidth",value:function(){return window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth}}]),e}(),V=function(){function e(){var i=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t(this,e);var s=n.dragEl,l=n.toleranceX,o=void 0===l?40:l,r=n.toleranceY,a=void 0===r?65:r,h=n.slide,d=void 0===h?null:h,c=n.instance,u=void 0===c?null:c;this.el=s,this.active=!1,this.dragging=!1,this.currentX=null,this.currentY=null,this.initialX=null,this.initialY=null,this.xOffset=0,this.yOffset=0,this.direction=null,this.lastDirection=null,this.toleranceX=o,this.toleranceY=a,this.toleranceReached=!1,this.dragContainer=this.el,this.slide=d,this.instance=u,this.el.addEventListener("mousedown",(function(e){return i.dragStart(e)}),!1),this.el.addEventListener("mouseup",(function(e){return i.dragEnd(e)}),!1),this.el.addEventListener("mousemove",(function(e){return i.drag(e)}),!1);}return n(e,[{key:"dragStart",value:function(e){if(this.slide.classList.contains("zoomed"))this.active=!1;else {"touchstart"===e.type?(this.initialX=e.touches[0].clientX-this.xOffset,this.initialY=e.touches[0].clientY-this.yOffset):(this.initialX=e.clientX-this.xOffset,this.initialY=e.clientY-this.yOffset);var t=e.target.nodeName.toLowerCase();e.target.classList.contains("nodrag")||u(e.target,".nodrag")||-1!==["input","select","textarea","button","a"].indexOf(t)?this.active=!1:(e.preventDefault(),(e.target===this.el||"img"!==t&&u(e.target,".gslide-inline"))&&(this.active=!0,this.el.classList.add("dragging"),this.dragContainer=u(e.target,".ginner-container")));}}},{key:"dragEnd",value:function(e){var t=this;e&&e.preventDefault(),this.initialX=0,this.initialY=0,this.currentX=null,this.currentY=null,this.initialX=null,this.initialY=null,this.xOffset=0,this.yOffset=0,this.active=!1,this.doSlideChange&&(this.instance.preventOutsideClick=!0,"right"==this.doSlideChange&&this.instance.prevSlide(),"left"==this.doSlideChange&&this.instance.nextSlide()),this.doSlideClose&&this.instance.close(),this.toleranceReached||this.setTranslate(this.dragContainer,0,0,!0),setTimeout((function(){t.instance.preventOutsideClick=!1,t.toleranceReached=!1,t.lastDirection=null,t.dragging=!1,t.el.isDragging=!1,t.el.classList.remove("dragging"),t.slide.classList.remove("dragging-nav"),t.dragContainer.style.transform="",t.dragContainer.style.transition="";}),100);}},{key:"drag",value:function(e){if(this.active){e.preventDefault(),this.slide.classList.add("dragging-nav"),"touchmove"===e.type?(this.currentX=e.touches[0].clientX-this.initialX,this.currentY=e.touches[0].clientY-this.initialY):(this.currentX=e.clientX-this.initialX,this.currentY=e.clientY-this.initialY),this.xOffset=this.currentX,this.yOffset=this.currentY,this.el.isDragging=!0,this.dragging=!0,this.doSlideChange=!1,this.doSlideClose=!1;var t=Math.abs(this.currentX),i=Math.abs(this.currentY);if(t>0&&t>=Math.abs(this.currentY)&&(!this.lastDirection||"x"==this.lastDirection)){this.yOffset=0,this.lastDirection="x",this.setTranslate(this.dragContainer,this.currentX,0);var n=this.shouldChange();if(!this.instance.settings.dragAutoSnap&&n&&(this.doSlideChange=n),this.instance.settings.dragAutoSnap&&n)return this.instance.preventOutsideClick=!0,this.toleranceReached=!0,this.active=!1,this.instance.preventOutsideClick=!0,this.dragEnd(null),"right"==n&&this.instance.prevSlide(),void("left"==n&&this.instance.nextSlide())}if(this.toleranceY>0&&i>0&&i>=t&&(!this.lastDirection||"y"==this.lastDirection)){this.xOffset=0,this.lastDirection="y",this.setTranslate(this.dragContainer,0,this.currentY);var s=this.shouldClose();return !this.instance.settings.dragAutoSnap&&s&&(this.doSlideClose=!0),void(this.instance.settings.dragAutoSnap&&s&&this.instance.close())}}}},{key:"shouldChange",value:function(){var e=!1;if(Math.abs(this.currentX)>=this.toleranceX){var t=this.currentX>0?"right":"left";("left"==t&&this.slide!==this.slide.parentNode.lastChild||"right"==t&&this.slide!==this.slide.parentNode.firstChild)&&(e=t);}return e}},{key:"shouldClose",value:function(){var e=!1;return Math.abs(this.currentY)>=this.toleranceY&&(e=!0),e}},{key:"setTranslate",value:function(e,t,i){var n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];e.style.transition=n?"all .2s ease":"",e.style.transform="translate3d(".concat(t,"px, ").concat(i,"px, 0)");}}]),e}();function j(e,t,i,n){var s=e.querySelector(".gslide-media"),l=new Image,o="gSlideTitle_"+i,r="gSlideDesc_"+i;l.addEventListener("load",(function(){T(n)&&n();}),!1),l.src=t.href,l.alt="",""!==t.title&&l.setAttribute("aria-labelledby",o),""!==t.description&&l.setAttribute("aria-describedby",r),t.hasOwnProperty("_hasCustomWidth")&&t._hasCustomWidth&&(l.style.width=t.width),t.hasOwnProperty("_hasCustomHeight")&&t._hasCustomHeight&&(l.style.height=t.height),s.insertBefore(l,s.firstChild);}function F(e,t,i,n){var s=this,l=e.querySelector(".ginner-container"),o="gvideo"+i,r=e.querySelector(".gslide-media"),a=this.getAllPlayers();h(l,"gvideo-container"),r.insertBefore(m('<div class="gvideo-wrapper"></div>'),r.firstChild);var d=e.querySelector(".gvideo-wrapper");S(this.settings.plyr.css,"Plyr");var c=t.href;location.protocol.replace(":","");var g="",v="",f=!1;r.style.maxWidth=t.width,S(this.settings.plyr.js,"Plyr",(function(){if(c.match(/vimeo\.com\/([0-9]*)/)){var l=/vimeo.*\/(\d+)/i.exec(c);g="vimeo",v=l[1];}if(c.match(/(youtube\.com|youtube-nocookie\.com)\/watch\?v=([a-zA-Z0-9\-_]+)/)||c.match(/youtu\.be\/([a-zA-Z0-9\-_]+)/)||c.match(/(youtube\.com|youtube-nocookie\.com)\/embed\/([a-zA-Z0-9\-_]+)/)){var r=function(e){var t="";t=void 0!==(e=e.replace(/(>|<)/gi,"").split(/(vi\/|v=|\/v\/|youtu\.be\/|\/embed\/)/))[2]?(t=e[2].split(/[^0-9a-z_\-]/i))[0]:e;return t}(c);g="youtube",v=r;}if(null!==c.match(/\.(mp4|ogg|webm|mov)$/)){g="local";var u='<video id="'+o+'" ';u+='style="background:#000; max-width: '.concat(t.width,';" '),u+='preload="metadata" ',u+='x-webkit-airplay="allow" ',u+='webkit-playsinline="" ',u+="controls ",u+='class="gvideo-local">';var p=c.toLowerCase().split(".").pop(),y={mp4:"",ogg:"",webm:""};for(var x in y[p="mov"==p?"mp4":p]=c,y)if(y.hasOwnProperty(x)){var S=y[x];t.hasOwnProperty(x)&&(S=t[x]),""!==S&&(u+='<source src="'.concat(S,'" type="video/').concat(x,'">'));}f=m(u+="</video>");}var w=f||m('<div id="'.concat(o,'" data-plyr-provider="').concat(g,'" data-plyr-embed-id="').concat(v,'"></div>'));h(d,"".concat(g,"-video gvideo")),d.appendChild(w),d.setAttribute("data-id",o),d.setAttribute("data-index",i);var C=O(s.settings.plyr,"config")?s.settings.plyr.config:{},k=new Plyr("#"+o,C);k.on("ready",(function(e){var t=e.detail.plyr;a[o]=t,T(n)&&n();})),b((function(){return e.querySelector("iframe")&&"true"==e.querySelector("iframe").dataset.ready}),(function(){s.resize(e);})),k.on("enterfullscreen",R),k.on("exitfullscreen",R);}));}function R(e){var t=u(e.target,".gslide-media");"enterfullscreen"==e.type&&h(t,"fullscreen"),"exitfullscreen"==e.type&&d(t,"fullscreen");}function G(e,t,i,n){var s,l=this,o=e.querySelector(".gslide-media"),r=!(!O(t,"href")||!t.href)&&t.href.split("#").pop().trim(),d=!(!O(t,"content")||!t.content)&&t.content;if(d&&(C(d)&&(s=m('<div class="ginlined-content">'.concat(d,"</div>"))),k(d))){"none"==d.style.display&&(d.style.display="block");var c=document.createElement("div");c.className="ginlined-content",c.appendChild(d),s=c;}if(r){var u=document.getElementById(r);if(!u)return !1;var g=u.cloneNode(!0);g.style.height=t.height,g.style.maxWidth=t.width,h(g,"ginlined-content"),s=g;}if(!s)return console.error("Unable to append inline slide content",t),!1;o.style.height=t.height,o.style.width=t.width,o.appendChild(s),this.events["inlineclose"+r]=a("click",{onElement:o.querySelectorAll(".gtrigger-close"),withCallback:function(e){e.preventDefault(),l.close();}}),T(n)&&n();}function Z(e,t,i,n){var s=e.querySelector(".gslide-media"),l=function(e){var t=e.url,i=e.allow,n=e.callback,s=e.appendTo,l=document.createElement("iframe");return l.className="vimeo-video gvideo",l.src=t,l.style.width="100%",l.style.height="100%",i&&l.setAttribute("allow",i),l.onload=function(){h(l,"node-ready"),T(n)&&n();},s&&s.appendChild(l),l}({url:t.href,callback:n});s.parentNode.style.maxWidth=t.width,s.parentNode.style.height=t.height,s.appendChild(l);}var $=function(){function e(){var i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t(this,e),this.defaults={href:"",title:"",type:"",description:"",descPosition:"bottom",effect:"",width:"",height:"",content:!1,zoomable:!0,draggable:!0},L(i)&&(this.defaults=l(this.defaults,i));}return n(e,[{key:"sourceType",value:function(e){var t=e;if(null!==(e=e.toLowerCase()).match(/\.(jpeg|jpg|jpe|gif|png|apn|webp|svg)$/))return "image";if(e.match(/(youtube\.com|youtube-nocookie\.com)\/watch\?v=([a-zA-Z0-9\-_]+)/)||e.match(/youtu\.be\/([a-zA-Z0-9\-_]+)/)||e.match(/(youtube\.com|youtube-nocookie\.com)\/embed\/([a-zA-Z0-9\-_]+)/))return "video";if(e.match(/vimeo\.com\/([0-9]*)/))return "video";if(null!==e.match(/\.(mp4|ogg|webm|mov)$/))return "video";if(null!==e.match(/\.(mp3|wav|wma|aac|ogg)$/))return "audio";if(e.indexOf("#")>-1&&""!==t.split("#").pop().trim())return "inline";return e.indexOf("goajax=true")>-1?"ajax":"external"}},{key:"parseConfig",value:function(e,t){var i=this,n=l({descPosition:t.descPosition},this.defaults);if(L(e)&&!k(e)){O(e,"type")||(O(e,"content")&&e.content?e.type="inline":O(e,"href")&&(e.type=this.sourceType(e.href)));var s=l(n,e);return this.setSize(s,t),s}var r="",a=e.getAttribute("data-glightbox"),h=e.nodeName.toLowerCase();if("a"===h&&(r=e.href),"img"===h&&(r=e.src),n.href=r,o(n,(function(s,l){O(t,l)&&"width"!==l&&(n[l]=t[l]);var o=e.dataset[l];I(o)||(n[l]=i.sanitizeValue(o));})),n.content&&(n.type="inline"),!n.type&&r&&(n.type=this.sourceType(r)),I(a)){if(!n.title&&"a"==h){var d=e.title;I(d)||""===d||(n.title=d);}if(!n.title&&"img"==h){var c=e.alt;I(c)||""===c||(n.title=c);}}else {var u=[];o(n,(function(e,t){u.push(";\\s?"+t);})),u=u.join("\\s?:|"),""!==a.trim()&&o(n,(function(e,t){var s=a,l=new RegExp("s?"+t+"s?:s?(.*?)("+u+"s?:|$)"),o=s.match(l);if(o&&o.length&&o[1]){var r=o[1].trim().replace(/;\s*$/,"");n[t]=i.sanitizeValue(r);}}));}if(n.description&&"."===n.description.substring(0,1)){var g;try{g=document.querySelector(n.description).innerHTML;}catch(e){if(!(e instanceof DOMException))throw e}g&&(n.description=g);}if(!n.description){var v=e.querySelector(".glightbox-desc");v&&(n.description=v.innerHTML);}return this.setSize(n,t,e),this.slideConfig=n,n}},{key:"setSize",value:function(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n="video"==e.type?this.checkSize(t.videosWidth):this.checkSize(t.width),s=this.checkSize(t.height);return e.width=O(e,"width")&&""!==e.width?this.checkSize(e.width):n,e.height=O(e,"height")&&""!==e.height?this.checkSize(e.height):s,i&&"image"==e.type&&(e._hasCustomWidth=!!i.dataset.width,e._hasCustomHeight=!!i.dataset.height),e}},{key:"checkSize",value:function(e){return M(e)?"".concat(e,"px"):e}},{key:"sanitizeValue",value:function(e){return "true"!==e&&"false"!==e?e:"true"===e}}]),e}(),U=function(){function e(i,n,s){t(this,e),this.element=i,this.instance=n,this.index=s;}return n(e,[{key:"setContent",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(c(t,"loaded"))return !1;var n=this.instance.settings,s=this.slideConfig,l=w();T(n.beforeSlideLoad)&&n.beforeSlideLoad({index:this.index,slide:t,player:!1});var o=s.type,r=s.descPosition,a=t.querySelector(".gslide-media"),d=t.querySelector(".gslide-title"),u=t.querySelector(".gslide-desc"),g=t.querySelector(".gdesc-inner"),v=i,f="gSlideTitle_"+this.index,p="gSlideDesc_"+this.index;if(T(n.afterSlideLoad)&&(v=function(){T(i)&&i(),n.afterSlideLoad({index:e.index,slide:t,player:e.instance.getSlidePlayerInstance(e.index)});}),""==s.title&&""==s.description?g&&g.parentNode.parentNode.removeChild(g.parentNode):(d&&""!==s.title?(d.id=f,d.innerHTML=s.title):d.parentNode.removeChild(d),u&&""!==s.description?(u.id=p,l&&n.moreLength>0?(s.smallDescription=this.slideShortDesc(s.description,n.moreLength,n.moreText),u.innerHTML=s.smallDescription,this.descriptionEvents(u,s)):u.innerHTML=s.description):u.parentNode.removeChild(u),h(a.parentNode,"desc-".concat(r)),h(g.parentNode,"description-".concat(r))),h(a,"gslide-".concat(o)),h(t,"loaded"),"video"!==o){if("external"!==o)return "inline"===o?(G.apply(this.instance,[t,s,this.index,v]),void(n.draggable&&new V({dragEl:t.querySelector(".gslide-inline"),toleranceX:n.dragToleranceX,toleranceY:n.dragToleranceY,slide:t,instance:this.instance}))):void("image"!==o?T(v)&&v():j(t,s,this.index,(function(){var i=t.querySelector("img");n.draggable&&new V({dragEl:i,toleranceX:n.dragToleranceX,toleranceY:n.dragToleranceY,slide:t,instance:e.instance}),s.zoomable&&i.naturalWidth>i.offsetWidth&&(h(i,"zoomable"),new H(i,t,(function(){e.instance.resize();}))),T(v)&&v();})));Z.apply(this,[t,s,this.index,v]);}else F.apply(this.instance,[t,s,this.index,v]);}},{key:"slideShortDesc",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:50,i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=document.createElement("div");n.innerHTML=e;var s=n.innerText,l=i;if((e=s.trim()).length<=t)return e;var o=e.substr(0,t-1);return l?(n=null,o+'... <a href="#" class="desc-more">'+i+"</a>"):o}},{key:"descriptionEvents",value:function(e,t){var i=this,n=e.querySelector(".desc-more");if(!n)return !1;a("click",{onElement:n,withCallback:function(e,n){e.preventDefault();var s=document.body,l=u(n,".gslide-desc");if(!l)return !1;l.innerHTML=t.description,h(s,"gdesc-open");var o=a("click",{onElement:[s,u(l,".gslide-description")],withCallback:function(e,n){"a"!==e.target.nodeName.toLowerCase()&&(d(s,"gdesc-open"),h(s,"gdesc-closed"),l.innerHTML=t.smallDescription,i.descriptionEvents(l,t),setTimeout((function(){d(s,"gdesc-closed");}),400),o.destroy());}});}});}},{key:"create",value:function(){return m(this.instance.settings.slideHTML)}},{key:"getConfig",value:function(){var e=new $(this.instance.settings.slideExtraAttributes);return this.slideConfig=e.parseConfig(this.element,this.instance.settings),this.slideConfig}}]),e}(),J=w(),K=null!==w()||void 0!==document.createTouch||"ontouchstart"in window||"onmsgesturechange"in window||navigator.msMaxTouchPoints,Q=document.getElementsByTagName("html")[0],ee={selector:".glightbox",elements:null,skin:"clean",theme:"clean",closeButton:!0,startAt:null,autoplayVideos:!0,autofocusVideos:!0,descPosition:"bottom",width:"900px",height:"506px",videosWidth:"960px",beforeSlideChange:null,afterSlideChange:null,beforeSlideLoad:null,afterSlideLoad:null,slideInserted:null,slideRemoved:null,slideExtraAttributes:null,onOpen:null,onClose:null,loop:!1,zoomable:!0,draggable:!0,dragAutoSnap:!1,dragToleranceX:40,dragToleranceY:65,preload:!0,oneSlidePerOpen:!1,touchNavigation:!0,touchFollowAxis:!0,keyboardNavigation:!0,closeOnOutsideClick:!0,plugins:!1,plyr:{css:"https://cdn.plyr.io/3.6.8/plyr.css",js:"https://cdn.plyr.io/3.6.8/plyr.js",config:{ratio:"16:9",fullscreen:{enabled:!0,iosNative:!0},youtube:{noCookie:!0,rel:0,showinfo:0,iv_load_policy:3},vimeo:{byline:!1,portrait:!1,title:!1,transparent:!1}}},openEffect:"zoom",closeEffect:"zoom",slideEffect:"slide",moreText:"See more",moreLength:60,cssEfects:{fade:{in:"fadeIn",out:"fadeOut"},zoom:{in:"zoomIn",out:"zoomOut"},slide:{in:"slideInRight",out:"slideOutLeft"},slideBack:{in:"slideInLeft",out:"slideOutRight"},none:{in:"none",out:"none"}},svg:{close:'<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 512 512" xml:space="preserve"><g><g><path d="M505.943,6.058c-8.077-8.077-21.172-8.077-29.249,0L6.058,476.693c-8.077,8.077-8.077,21.172,0,29.249C10.096,509.982,15.39,512,20.683,512c5.293,0,10.586-2.019,14.625-6.059L505.943,35.306C514.019,27.23,514.019,14.135,505.943,6.058z"/></g></g><g><g><path d="M505.942,476.694L35.306,6.059c-8.076-8.077-21.172-8.077-29.248,0c-8.077,8.076-8.077,21.171,0,29.248l470.636,470.636c4.038,4.039,9.332,6.058,14.625,6.058c5.293,0,10.587-2.019,14.624-6.057C514.018,497.866,514.018,484.771,505.942,476.694z"/></g></g></svg>',next:'<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 477.175 477.175" xml:space="preserve"> <g><path d="M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z"/></g></svg>',prev:'<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 477.175 477.175" xml:space="preserve"><g><path d="M145.188,238.575l215.5-215.5c5.3-5.3,5.3-13.8,0-19.1s-13.8-5.3-19.1,0l-225.1,225.1c-5.3,5.3-5.3,13.8,0,19.1l225.1,225c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1L145.188,238.575z"/></g></svg>'},slideHTML:'<div class="gslide">\n    <div class="gslide-inner-content">\n        <div class="ginner-container">\n            <div class="gslide-media">\n            </div>\n            <div class="gslide-description">\n                <div class="gdesc-inner">\n                    <h4 class="gslide-title"></h4>\n                    <div class="gslide-desc"></div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>',lightboxHTML:'<div id="glightbox-body" class="glightbox-container" tabindex="-1" role="dialog" aria-hidden="false">\n    <div class="gloader visible"></div>\n    <div class="goverlay"></div>\n    <div class="gcontainer">\n    <div id="glightbox-slider" class="gslider"></div>\n    <button class="gclose gbtn" aria-label="Close" data-taborder="3">{closeSVG}</button>\n    <button class="gprev gbtn" aria-label="Previous" data-taborder="2">{prevSVG}</button>\n    <button class="gnext gbtn" aria-label="Next" data-taborder="1">{nextSVG}</button>\n</div>\n</div>'},te=function(){function e(){var i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t(this,e),this.customOptions=i,this.settings=l(ee,i),this.effectsClasses=this.getAnimationClasses(),this.videoPlayers={},this.apiEvents=[],this.fullElementsList=!1;}return n(e,[{key:"init",value:function(){var e=this,t=this.getSelector();t&&(this.baseEvents=a("click",{onElement:t,withCallback:function(t,i){t.preventDefault(),e.open(i);}})),this.elements=this.getElements();}},{key:"open",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(0==this.elements.length)return !1;this.activeSlide=null,this.prevActiveSlideIndex=null,this.prevActiveSlide=null;var i=M(t)?t:this.settings.startAt;if(k(e)){var n=e.getAttribute("data-gallery");n&&(this.fullElementsList=this.elements,this.elements=this.getGalleryElements(this.elements,n)),I(i)&&(i=this.getElementIndex(e))<0&&(i=0);}M(i)||(i=0),this.build(),g(this.overlay,"none"==this.settings.openEffect?"none":this.settings.cssEfects.fade.in);var s=document.body,l=window.innerWidth-document.documentElement.clientWidth;if(l>0){var o=document.createElement("style");o.type="text/css",o.className="gcss-styles",o.innerText=".gscrollbar-fixer {margin-right: ".concat(l,"px}"),document.head.appendChild(o),h(s,"gscrollbar-fixer");}h(s,"glightbox-open"),h(Q,"glightbox-open"),J&&(h(document.body,"glightbox-mobile"),this.settings.slideEffect="slide"),this.showSlide(i,!0),1==this.elements.length?(h(this.prevButton,"glightbox-button-hidden"),h(this.nextButton,"glightbox-button-hidden")):(d(this.prevButton,"glightbox-button-hidden"),d(this.nextButton,"glightbox-button-hidden")),this.lightboxOpen=!0,this.trigger("open"),T(this.settings.onOpen)&&this.settings.onOpen(),K&&this.settings.touchNavigation&&B(this),this.settings.keyboardNavigation&&z(this);}},{key:"openAt",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.open(null,e);}},{key:"showSlide",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];f(this.loader),this.index=parseInt(t);var n=this.slidesContainer.querySelector(".current");n&&d(n,"current"),this.slideAnimateOut();var s=this.slidesContainer.querySelectorAll(".gslide")[t];if(c(s,"loaded"))this.slideAnimateIn(s,i),p(this.loader);else {f(this.loader);var l=this.elements[t],o={index:this.index,slide:s,slideNode:s,slideConfig:l.slideConfig,slideIndex:this.index,trigger:l.node,player:null};this.trigger("slide_before_load",o),l.instance.setContent(s,(function(){p(e.loader),e.resize(),e.slideAnimateIn(s,i),e.trigger("slide_after_load",o);}));}this.slideDescription=s.querySelector(".gslide-description"),this.slideDescriptionContained=this.slideDescription&&c(this.slideDescription.parentNode,"gslide-media"),this.settings.preload&&(this.preloadSlide(t+1),this.preloadSlide(t-1)),this.updateNavigationClasses(),this.activeSlide=s;}},{key:"preloadSlide",value:function(e){var t=this;if(e<0||e>this.elements.length-1)return !1;if(I(this.elements[e]))return !1;var i=this.slidesContainer.querySelectorAll(".gslide")[e];if(c(i,"loaded"))return !1;var n=this.elements[e],s=n.type,l={index:e,slide:i,slideNode:i,slideConfig:n.slideConfig,slideIndex:e,trigger:n.node,player:null};this.trigger("slide_before_load",l),"video"==s||"external"==s?setTimeout((function(){n.instance.setContent(i,(function(){t.trigger("slide_after_load",l);}));}),200):n.instance.setContent(i,(function(){t.trigger("slide_after_load",l);}));}},{key:"prevSlide",value:function(){this.goToSlide(this.index-1);}},{key:"nextSlide",value:function(){this.goToSlide(this.index+1);}},{key:"goToSlide",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.prevActiveSlide=this.activeSlide,this.prevActiveSlideIndex=this.index,!this.loop()&&(e<0||e>this.elements.length-1))return !1;e<0?e=this.elements.length-1:e>=this.elements.length&&(e=0),this.showSlide(e);}},{key:"insertSlide",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;t<0&&(t=this.elements.length);var i=new U(e,this,t),n=i.getConfig(),s=l({},n),o=i.create(),r=this.elements.length-1;s.index=t,s.node=!1,s.instance=i,s.slideConfig=n,this.elements.splice(t,0,s);var a=null,h=null;if(this.slidesContainer){if(t>r)this.slidesContainer.appendChild(o);else {var d=this.slidesContainer.querySelectorAll(".gslide")[t];this.slidesContainer.insertBefore(o,d);}(this.settings.preload&&0==this.index&&0==t||this.index-1==t||this.index+1==t)&&this.preloadSlide(t),0==this.index&&0==t&&(this.index=1),this.updateNavigationClasses(),a=this.slidesContainer.querySelectorAll(".gslide")[t],h=this.getSlidePlayerInstance(t),s.slideNode=a;}this.trigger("slide_inserted",{index:t,slide:a,slideNode:a,slideConfig:n,slideIndex:t,trigger:null,player:h}),T(this.settings.slideInserted)&&this.settings.slideInserted({index:t,slide:a,player:h});}},{key:"removeSlide",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;if(e<0||e>this.elements.length-1)return !1;var t=this.slidesContainer&&this.slidesContainer.querySelectorAll(".gslide")[e];t&&(this.getActiveSlideIndex()==e&&(e==this.elements.length-1?this.prevSlide():this.nextSlide()),t.parentNode.removeChild(t)),this.elements.splice(e,1),this.trigger("slide_removed",e),T(this.settings.slideRemoved)&&this.settings.slideRemoved(e);}},{key:"slideAnimateIn",value:function(e,t){var i=this,n=e.querySelector(".gslide-media"),s=e.querySelector(".gslide-description"),l={index:this.prevActiveSlideIndex,slide:this.prevActiveSlide,slideNode:this.prevActiveSlide,slideIndex:this.prevActiveSlide,slideConfig:I(this.prevActiveSlideIndex)?null:this.elements[this.prevActiveSlideIndex].slideConfig,trigger:I(this.prevActiveSlideIndex)?null:this.elements[this.prevActiveSlideIndex].node,player:this.getSlidePlayerInstance(this.prevActiveSlideIndex)},o={index:this.index,slide:this.activeSlide,slideNode:this.activeSlide,slideConfig:this.elements[this.index].slideConfig,slideIndex:this.index,trigger:this.elements[this.index].node,player:this.getSlidePlayerInstance(this.index)};if(n.offsetWidth>0&&s&&(p(s),s.style.display=""),d(e,this.effectsClasses),t)g(e,this.settings.cssEfects[this.settings.openEffect].in,(function(){i.settings.autoplayVideos&&i.slidePlayerPlay(e),i.trigger("slide_changed",{prev:l,current:o}),T(i.settings.afterSlideChange)&&i.settings.afterSlideChange.apply(i,[l,o]);}));else {var r=this.settings.slideEffect,a="none"!==r?this.settings.cssEfects[r].in:r;this.prevActiveSlideIndex>this.index&&"slide"==this.settings.slideEffect&&(a=this.settings.cssEfects.slideBack.in),g(e,a,(function(){i.settings.autoplayVideos&&i.slidePlayerPlay(e),i.trigger("slide_changed",{prev:l,current:o}),T(i.settings.afterSlideChange)&&i.settings.afterSlideChange.apply(i,[l,o]);}));}setTimeout((function(){i.resize(e);}),100),h(e,"current");}},{key:"slideAnimateOut",value:function(){if(!this.prevActiveSlide)return !1;var e=this.prevActiveSlide;d(e,this.effectsClasses),h(e,"prev");var t=this.settings.slideEffect,i="none"!==t?this.settings.cssEfects[t].out:t;this.slidePlayerPause(e),this.trigger("slide_before_change",{prev:{index:this.prevActiveSlideIndex,slide:this.prevActiveSlide,slideNode:this.prevActiveSlide,slideIndex:this.prevActiveSlideIndex,slideConfig:I(this.prevActiveSlideIndex)?null:this.elements[this.prevActiveSlideIndex].slideConfig,trigger:I(this.prevActiveSlideIndex)?null:this.elements[this.prevActiveSlideIndex].node,player:this.getSlidePlayerInstance(this.prevActiveSlideIndex)},current:{index:this.index,slide:this.activeSlide,slideNode:this.activeSlide,slideIndex:this.index,slideConfig:this.elements[this.index].slideConfig,trigger:this.elements[this.index].node,player:this.getSlidePlayerInstance(this.index)}}),T(this.settings.beforeSlideChange)&&this.settings.beforeSlideChange.apply(this,[{index:this.prevActiveSlideIndex,slide:this.prevActiveSlide,player:this.getSlidePlayerInstance(this.prevActiveSlideIndex)},{index:this.index,slide:this.activeSlide,player:this.getSlidePlayerInstance(this.index)}]),this.prevActiveSlideIndex>this.index&&"slide"==this.settings.slideEffect&&(i=this.settings.cssEfects.slideBack.out),g(e,i,(function(){var t=e.querySelector(".ginner-container"),i=e.querySelector(".gslide-media"),n=e.querySelector(".gslide-description");t.style.transform="",i.style.transform="",d(i,"greset"),i.style.opacity="",n&&(n.style.opacity=""),d(e,"prev");}));}},{key:"getAllPlayers",value:function(){return this.videoPlayers}},{key:"getSlidePlayerInstance",value:function(e){var t="gvideo"+e,i=this.getAllPlayers();return !(!O(i,t)||!i[t])&&i[t]}},{key:"stopSlideVideo",value:function(e){if(k(e)){var t=e.querySelector(".gvideo-wrapper");t&&(e=t.getAttribute("data-index"));}console.log("stopSlideVideo is deprecated, use slidePlayerPause");var i=this.getSlidePlayerInstance(e);i&&i.playing&&i.pause();}},{key:"slidePlayerPause",value:function(e){if(k(e)){var t=e.querySelector(".gvideo-wrapper");t&&(e=t.getAttribute("data-index"));}var i=this.getSlidePlayerInstance(e);i&&i.playing&&i.pause();}},{key:"playSlideVideo",value:function(e){if(k(e)){var t=e.querySelector(".gvideo-wrapper");t&&(e=t.getAttribute("data-index"));}console.log("playSlideVideo is deprecated, use slidePlayerPlay");var i=this.getSlidePlayerInstance(e);i&&!i.playing&&i.play();}},{key:"slidePlayerPlay",value:function(e){if(k(e)){var t=e.querySelector(".gvideo-wrapper");t&&(e=t.getAttribute("data-index"));}var i=this.getSlidePlayerInstance(e);i&&!i.playing&&(i.play(),this.settings.autofocusVideos&&i.elements.container.focus());}},{key:"setElements",value:function(e){var t=this;this.settings.elements=!1;var i=[];e&&e.length&&o(e,(function(e,n){var s=new U(e,t,n),o=s.getConfig(),r=l({},o);r.slideConfig=o,r.instance=s,r.index=n,i.push(r);})),this.elements=i,this.lightboxOpen&&(this.slidesContainer.innerHTML="",this.elements.length&&(o(this.elements,(function(){var e=m(t.settings.slideHTML);t.slidesContainer.appendChild(e);})),this.showSlide(0,!0)));}},{key:"getElementIndex",value:function(e){var t=!1;return o(this.elements,(function(i,n){if(O(i,"node")&&i.node==e)return t=n,!0})),t}},{key:"getElements",value:function(){var e=this,t=[];this.elements=this.elements?this.elements:[],!I(this.settings.elements)&&E(this.settings.elements)&&this.settings.elements.length&&o(this.settings.elements,(function(i,n){var s=new U(i,e,n),o=s.getConfig(),r=l({},o);r.node=!1,r.index=n,r.instance=s,r.slideConfig=o,t.push(r);}));var i=!1;return this.getSelector()&&(i=document.querySelectorAll(this.getSelector())),i?(o(i,(function(i,n){var s=new U(i,e,n),o=s.getConfig(),r=l({},o);r.node=i,r.index=n,r.instance=s,r.slideConfig=o,r.gallery=i.getAttribute("data-gallery"),t.push(r);})),t):t}},{key:"getGalleryElements",value:function(e,t){return e.filter((function(e){return e.gallery==t}))}},{key:"getSelector",value:function(){return !this.settings.elements&&(this.settings.selector&&"data-"==this.settings.selector.substring(0,5)?"*[".concat(this.settings.selector,"]"):this.settings.selector)}},{key:"getActiveSlide",value:function(){return this.slidesContainer.querySelectorAll(".gslide")[this.index]}},{key:"getActiveSlideIndex",value:function(){return this.index}},{key:"getAnimationClasses",value:function(){var e=[];for(var t in this.settings.cssEfects)if(this.settings.cssEfects.hasOwnProperty(t)){var i=this.settings.cssEfects[t];e.push("g".concat(i.in)),e.push("g".concat(i.out));}return e.join(" ")}},{key:"build",value:function(){var e=this;if(this.built)return !1;var t=document.body.childNodes,i=[];o(t,(function(e){e.parentNode==document.body&&"#"!==e.nodeName.charAt(0)&&e.hasAttribute&&!e.hasAttribute("aria-hidden")&&(i.push(e),e.setAttribute("aria-hidden","true"));}));var n=O(this.settings.svg,"next")?this.settings.svg.next:"",s=O(this.settings.svg,"prev")?this.settings.svg.prev:"",l=O(this.settings.svg,"close")?this.settings.svg.close:"",r=this.settings.lightboxHTML;r=m(r=(r=(r=r.replace(/{nextSVG}/g,n)).replace(/{prevSVG}/g,s)).replace(/{closeSVG}/g,l)),document.body.appendChild(r);var d=document.getElementById("glightbox-body");this.modal=d;var g=d.querySelector(".gclose");this.prevButton=d.querySelector(".gprev"),this.nextButton=d.querySelector(".gnext"),this.overlay=d.querySelector(".goverlay"),this.loader=d.querySelector(".gloader"),this.slidesContainer=document.getElementById("glightbox-slider"),this.bodyHiddenChildElms=i,this.events={},h(this.modal,"glightbox-"+this.settings.skin),this.settings.closeButton&&g&&(this.events.close=a("click",{onElement:g,withCallback:function(t,i){t.preventDefault(),e.close();}})),g&&!this.settings.closeButton&&g.parentNode.removeChild(g),this.nextButton&&(this.events.next=a("click",{onElement:this.nextButton,withCallback:function(t,i){t.preventDefault(),e.nextSlide();}})),this.prevButton&&(this.events.prev=a("click",{onElement:this.prevButton,withCallback:function(t,i){t.preventDefault(),e.prevSlide();}})),this.settings.closeOnOutsideClick&&(this.events.outClose=a("click",{onElement:d,withCallback:function(t,i){e.preventOutsideClick||c(document.body,"glightbox-mobile")||u(t.target,".ginner-container")||u(t.target,".gbtn")||c(t.target,"gnext")||c(t.target,"gprev")||e.close();}})),o(this.elements,(function(t,i){e.slidesContainer.appendChild(t.instance.create()),t.slideNode=e.slidesContainer.querySelectorAll(".gslide")[i];})),K&&h(document.body,"glightbox-touch"),this.events.resize=a("resize",{onElement:window,withCallback:function(){e.resize();}}),this.built=!0;}},{key:"resize",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if((e=e||this.activeSlide)&&!c(e,"zoomed")){var t=y(),i=e.querySelector(".gvideo-wrapper"),n=e.querySelector(".gslide-image"),s=this.slideDescription,l=t.width,o=t.height;if(l<=768?h(document.body,"glightbox-mobile"):d(document.body,"glightbox-mobile"),i||n){var r=!1;if(s&&(c(s,"description-bottom")||c(s,"description-top"))&&!c(s,"gabsolute")&&(r=!0),n)if(l<=768)n.querySelector("img");else if(r){var a=s.offsetHeight,u=n.querySelector("img");u.setAttribute("style","max-height: calc(100vh - ".concat(a,"px)")),s.setAttribute("style","max-width: ".concat(u.offsetWidth,"px;"));}if(i){var g=O(this.settings.plyr.config,"ratio")?this.settings.plyr.config.ratio:"";if(!g){var v=i.clientWidth,f=i.clientHeight,p=v/f;g="".concat(v/p,":").concat(f/p);}var m=g.split(":"),x=this.settings.videosWidth,b=this.settings.videosWidth,S=(b=M(x)||-1!==x.indexOf("px")?parseInt(x):-1!==x.indexOf("vw")?l*parseInt(x)/100:-1!==x.indexOf("vh")?o*parseInt(x)/100:-1!==x.indexOf("%")?l*parseInt(x)/100:parseInt(i.clientWidth))/(parseInt(m[0])/parseInt(m[1]));if(S=Math.floor(S),r&&(o-=s.offsetHeight),b>l||S>o||o<S&&l>b){var w=i.offsetWidth,T=i.offsetHeight,C=o/T,k={width:w*C,height:T*C};i.parentNode.setAttribute("style","max-width: ".concat(k.width,"px")),r&&s.setAttribute("style","max-width: ".concat(k.width,"px;"));}else i.parentNode.style.maxWidth="".concat(x),r&&s.setAttribute("style","max-width: ".concat(x,";"));}}}}},{key:"reload",value:function(){this.init();}},{key:"updateNavigationClasses",value:function(){var e=this.loop();d(this.nextButton,"disabled"),d(this.prevButton,"disabled"),0==this.index&&this.elements.length-1==0?(h(this.prevButton,"disabled"),h(this.nextButton,"disabled")):0!==this.index||e?this.index!==this.elements.length-1||e||h(this.nextButton,"disabled"):h(this.prevButton,"disabled");}},{key:"loop",value:function(){var e=O(this.settings,"loopAtEnd")?this.settings.loopAtEnd:null;return e=O(this.settings,"loop")?this.settings.loop:e,e}},{key:"close",value:function(){var e=this;if(!this.lightboxOpen){if(this.events){for(var t in this.events)this.events.hasOwnProperty(t)&&this.events[t].destroy();this.events=null;}return !1}if(this.closing)return !1;this.closing=!0,this.slidePlayerPause(this.activeSlide),this.fullElementsList&&(this.elements=this.fullElementsList),this.bodyHiddenChildElms.length&&o(this.bodyHiddenChildElms,(function(e){e.removeAttribute("aria-hidden");})),h(this.modal,"glightbox-closing"),g(this.overlay,"none"==this.settings.openEffect?"none":this.settings.cssEfects.fade.out),g(this.activeSlide,this.settings.cssEfects[this.settings.closeEffect].out,(function(){if(e.activeSlide=null,e.prevActiveSlideIndex=null,e.prevActiveSlide=null,e.built=!1,e.events){for(var t in e.events)e.events.hasOwnProperty(t)&&e.events[t].destroy();e.events=null;}var i=document.body;d(Q,"glightbox-open"),d(i,"glightbox-open touching gdesc-open glightbox-touch glightbox-mobile gscrollbar-fixer"),e.modal.parentNode.removeChild(e.modal),e.trigger("close"),T(e.settings.onClose)&&e.settings.onClose();var n=document.querySelector(".gcss-styles");n&&n.parentNode.removeChild(n),e.lightboxOpen=!1,e.closing=null;}));}},{key:"destroy",value:function(){this.close(),this.clearAllEvents(),this.baseEvents&&this.baseEvents.destroy();}},{key:"on",value:function(e,t){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e||!T(t))throw new TypeError("Event name and callback must be defined");this.apiEvents.push({evt:e,once:i,callback:t});}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"trigger",value:function(e){var t=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=[];o(this.apiEvents,(function(t,s){var l=t.evt,o=t.once,r=t.callback;l==e&&(r(i),o&&n.push(s));})),n.length&&o(n,(function(e){return t.apiEvents.splice(e,1)}));}},{key:"clearAllEvents",value:function(){this.apiEvents.splice(0,this.apiEvents.length);}},{key:"version",value:function(){return "3.0.9"}}]),e}();return function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=new te(e);return t.init(),t}}));
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Older browsers don't support event options, feature detect it.

// Adopted and modified solution from Bohdan Didukh (2017)
// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi

var hasPassiveEvents = false;
if (typeof window !== 'undefined') {
  var passiveTestOptions = {
    get passive() {
      hasPassiveEvents = true;
      return undefined;
    }
  };
  window.addEventListener('testPassive', null, passiveTestOptions);
  window.removeEventListener('testPassive', null, passiveTestOptions);
}

var isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);


var locks = [];
var documentListenerAdded = false;
var initialClientY = -1;
var previousBodyOverflowSetting = void 0;
var previousBodyPaddingRight = void 0;

// returns true if `el` should be allowed to receive touchmove events.
var allowTouchMove = function allowTouchMove(el) {
  return locks.some(function (lock) {
    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
      return true;
    }

    return false;
  });
};

var preventDefault = function preventDefault(rawEvent) {
  var e = rawEvent || window.event;

  // For the case whereby consumers adds a touchmove event listener to document.
  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })
  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then
  // the touchmove event on document will break.
  if (allowTouchMove(e.target)) {
    return true;
  }

  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).
  if (e.touches.length > 1) return true;

  if (e.preventDefault) e.preventDefault();

  return false;
};

var setOverflowHidden = function setOverflowHidden(options) {
  // If previousBodyPaddingRight is already set, don't set it again.
  if (previousBodyPaddingRight === undefined) {
    var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
    var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;

    if (_reserveScrollBarGap && scrollBarGap > 0) {
      previousBodyPaddingRight = document.body.style.paddingRight;
      document.body.style.paddingRight = scrollBarGap + 'px';
    }
  }

  // If previousBodyOverflowSetting is already set, don't set it again.
  if (previousBodyOverflowSetting === undefined) {
    previousBodyOverflowSetting = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
  }
};

var restoreOverflowSetting = function restoreOverflowSetting() {
  if (previousBodyPaddingRight !== undefined) {
    document.body.style.paddingRight = previousBodyPaddingRight;

    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
    // can be set again.
    previousBodyPaddingRight = undefined;
  }

  if (previousBodyOverflowSetting !== undefined) {
    document.body.style.overflow = previousBodyOverflowSetting;

    // Restore previousBodyOverflowSetting to undefined
    // so setOverflowHidden knows it can be set again.
    previousBodyOverflowSetting = undefined;
  }
};

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions
var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {
  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
};

var handleScroll = function handleScroll(event, targetElement) {
  var clientY = event.targetTouches[0].clientY - initialClientY;

  if (allowTouchMove(event.target)) {
    return false;
  }

  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
    // element is at the top of its scroll.
    return preventDefault(event);
  }

  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
    // element is at the bottom of its scroll.
    return preventDefault(event);
  }

  event.stopPropagation();
  return true;
};

var disableBodyScroll = function disableBodyScroll(targetElement, options) {
  // targetElement must be provided
  if (!targetElement) {
    // eslint-disable-next-line no-console
    console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');
    return;
  }

  // disableBodyScroll must not have been called on this targetElement before
  if (locks.some(function (lock) {
    return lock.targetElement === targetElement;
  })) {
    return;
  }

  var lock = {
    targetElement: targetElement,
    options: options || {}
  };

  locks = [].concat(_toConsumableArray(locks), [lock]);

  if (isIosDevice) {
    targetElement.ontouchstart = function (event) {
      if (event.targetTouches.length === 1) {
        // detect single touch.
        initialClientY = event.targetTouches[0].clientY;
      }
    };
    targetElement.ontouchmove = function (event) {
      if (event.targetTouches.length === 1) {
        // detect single touch.
        handleScroll(event, targetElement);
      }
    };

    if (!documentListenerAdded) {
      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);
      documentListenerAdded = true;
    }
  } else {
    setOverflowHidden(options);
  }
};

var clearAllBodyScrollLocks = function clearAllBodyScrollLocks() {
  if (isIosDevice) {
    // Clear all locks ontouchstart/ontouchmove handlers, and the references.
    locks.forEach(function (lock) {
      lock.targetElement.ontouchstart = null;
      lock.targetElement.ontouchmove = null;
    });

    if (documentListenerAdded) {
      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);
      documentListenerAdded = false;
    }

    // Reset initial clientY.
    initialClientY = -1;
  } else {
    restoreOverflowSetting();
  }

  locks = [];
};

const glightboxCss = ".glightbox-container{width:100%;height:100%;position:fixed;top:0;left:0;z-index:999999 !important;overflow:hidden;-ms-touch-action:none;touch-action:none;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;outline:none;overflow:hidden}.glightbox-container.inactive{display:none}.glightbox-container .gcontainer{position:relative;width:100%;height:100%;z-index:9999;overflow:hidden}.glightbox-container .gslider{-webkit-transition:-webkit-transform 0.4s ease;transition:-webkit-transform 0.4s ease;transition:transform 0.4s ease;transition:transform 0.4s ease, -webkit-transform 0.4s ease;height:100%;left:0;top:0;width:100%;position:relative;overflow:hidden;display:-webkit-box !important;display:-ms-flexbox !important;display:flex !important;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0)}.glightbox-container .gslide{width:100%;position:absolute;opacity:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;opacity:0}.glightbox-container .gslide.current{opacity:1;z-index:99999;position:relative}.glightbox-container .gslide.prev{opacity:1;z-index:9999}.glightbox-container .gslide-inner-content{width:100%}.glightbox-container .ginner-container{position:relative;width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;max-width:100%;margin:auto;height:100vh}.glightbox-container .ginner-container.gvideo-container{width:100%}.glightbox-container .ginner-container.desc-bottom,.glightbox-container .ginner-container.desc-top{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.glightbox-container .ginner-container.desc-left,.glightbox-container .ginner-container.desc-right{max-width:100% !important}.gslide iframe,.gslide video{outline:none !important;border:none;min-height:165px;-webkit-overflow-scrolling:touch;-ms-touch-action:auto;touch-action:auto}.gslide-image{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.gslide-image img{max-height:100vh;display:block;padding:0;float:none;outline:none;border:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;max-width:100vw;width:auto;height:auto;-o-object-fit:cover;object-fit:cover;-ms-touch-action:none;touch-action:none;margin:auto;min-width:200px}.desc-top .gslide-image img,.desc-bottom .gslide-image img{width:auto}.desc-left .gslide-image img,.desc-right .gslide-image img{width:auto;max-width:100%}.gslide-image img.zoomable{position:relative}.gslide-image img.dragging{cursor:-webkit-grabbing !important;cursor:grabbing !important;-webkit-transition:none;transition:none}.gslide-video{position:relative;max-width:100vh;width:100% !important}.gslide-video .gvideo-wrapper{width:100%;margin:auto}.gslide-video::before{content:'';display:block;position:absolute;width:100%;height:100%;background:rgba(255, 0, 0, 0.34);display:none}.gslide-video.playing::before{display:none}.gslide-video.fullscreen{max-width:100% !important;min-width:100%;height:75vh}.gslide-video.fullscreen video{max-width:100% !important;width:100% !important}.gslide-inline{background:#fff;text-align:left;max-height:calc(100vh - 40px);overflow:auto;max-width:100%}.gslide-inline .ginlined-content{padding:20px;width:100%}.gslide-inline .dragging{cursor:-webkit-grabbing !important;cursor:grabbing !important;-webkit-transition:none;transition:none}.ginlined-content{overflow:auto;display:block !important;opacity:1}.gslide-external{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;min-width:100%;background:#fff;padding:0;overflow:auto;max-height:75vh;height:100%}.gslide-media{display:-webkit-box;display:-ms-flexbox;display:flex;width:auto}.zoomed .gslide-media{-webkit-box-shadow:none !important;box-shadow:none !important}.desc-top .gslide-media,.desc-bottom .gslide-media{margin:0 auto;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.gslide-description{position:relative;-webkit-box-flex:1;-ms-flex:1 0 100%;flex:1 0 100%}.gslide-description.description-left,.gslide-description.description-right{max-width:100%}.gslide-description.description-bottom,.gslide-description.description-top{margin:0 auto;width:100%}.gslide-description p{margin-bottom:12px}.gslide-description p:last-child{margin-bottom:0}.zoomed .gslide-description{display:none}.glightbox-button-hidden{display:none}.glightbox-mobile .glightbox-container .gslide-description{height:auto !important;width:100%;background:transparent;position:absolute;bottom:15px;padding:19px 11px;max-width:100vw !important;-webkit-box-ordinal-group:3 !important;-ms-flex-order:2 !important;order:2 !important;max-height:78vh;overflow:auto !important;background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0)), to(rgba(0, 0, 0, 0.75)));background:linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.75) 100%);-webkit-transition:opacity 0.3s linear;transition:opacity 0.3s linear;padding-bottom:50px}.glightbox-mobile .glightbox-container .gslide-title{color:#fff;font-size:1em}.glightbox-mobile .glightbox-container .gslide-desc{color:#a1a1a1}.glightbox-mobile .glightbox-container .gslide-desc a{color:#fff;font-weight:bold}.glightbox-mobile .glightbox-container .gslide-desc *{color:inherit}.glightbox-mobile .glightbox-container .gslide-desc string{color:#fff}.glightbox-mobile .glightbox-container .gslide-desc .desc-more{color:#fff;opacity:0.4}.gdesc-open .gslide-media{-webkit-transition:opacity 0.5s ease;transition:opacity 0.5s ease;opacity:0.4}.gdesc-open .gdesc-inner{padding-bottom:30px}.gdesc-closed .gslide-media{-webkit-transition:opacity 0.5s ease;transition:opacity 0.5s ease;opacity:1}.greset{-webkit-transition:all 0.3s ease;transition:all 0.3s ease}.gabsolute{position:absolute}.grelative{position:relative}.glightbox-desc{display:none !important}.glightbox-open{overflow:hidden}.gloader{height:25px;width:25px;-webkit-animation:lightboxLoader 0.8s infinite linear;animation:lightboxLoader 0.8s infinite linear;border:2px solid #fff;border-right-color:transparent;border-radius:50%;position:absolute;display:block;z-index:9999;left:0;right:0;margin:0 auto;top:47%}.goverlay{width:100%;height:calc(100vh + 1px);position:fixed;top:-1px;left:0;background:#000;will-change:opacity}.glightbox-mobile .goverlay{background:#000}.gprev,.gnext,.gclose{z-index:99999;cursor:pointer;width:26px;height:44px;border:none;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.gprev svg,.gnext svg,.gclose svg{display:block;width:25px;height:auto;margin:0;padding:0}.gprev.disabled,.gnext.disabled,.gclose.disabled{opacity:0.1}.gprev .garrow,.gnext .garrow,.gclose .garrow{stroke:#fff}.gbtn.focused{outline:2px solid #0f3d81}iframe.wait-autoplay{opacity:0}.glightbox-closing .gnext,.glightbox-closing .gprev,.glightbox-closing .gclose{opacity:0 !important}.glightbox-clean .gslide-description{background:#fff}.glightbox-clean .gdesc-inner{padding:22px 20px}.glightbox-clean .gslide-title{font-size:1em;font-weight:normal;font-family:arial;color:#000;margin-bottom:19px;line-height:1.4em}.glightbox-clean .gslide-desc{font-size:0.86em;margin-bottom:0;font-family:arial;line-height:1.4em}.glightbox-clean .gslide-video{background:#000}.glightbox-clean .gprev,.glightbox-clean .gnext,.glightbox-clean .gclose{background-color:rgba(0, 0, 0, 0.75);border-radius:4px}.glightbox-clean .gprev path,.glightbox-clean .gnext path,.glightbox-clean .gclose path{fill:#fff}.glightbox-clean .gprev{position:absolute;top:-100%;left:30px;width:40px;height:50px}.glightbox-clean .gnext{position:absolute;top:-100%;right:30px;width:40px;height:50px}.glightbox-clean .gclose{width:35px;height:35px;top:15px;right:10px;position:absolute}.glightbox-clean .gclose svg{width:18px;height:auto}.glightbox-clean .gclose:hover{opacity:1}.gfadeIn{-webkit-animation:gfadeIn 0.5s ease;animation:gfadeIn 0.5s ease}.gfadeOut{-webkit-animation:gfadeOut 0.5s ease;animation:gfadeOut 0.5s ease}.gslideOutLeft{-webkit-animation:gslideOutLeft 0.3s ease;animation:gslideOutLeft 0.3s ease}.gslideInLeft{-webkit-animation:gslideInLeft 0.3s ease;animation:gslideInLeft 0.3s ease}.gslideOutRight{-webkit-animation:gslideOutRight 0.3s ease;animation:gslideOutRight 0.3s ease}.gslideInRight{-webkit-animation:gslideInRight 0.3s ease;animation:gslideInRight 0.3s ease}.gzoomIn{-webkit-animation:gzoomIn 0.5s ease;animation:gzoomIn 0.5s ease}.gzoomOut{-webkit-animation:gzoomOut 0.5s ease;animation:gzoomOut 0.5s ease}@-webkit-keyframes lightboxLoader{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes lightboxLoader{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes gfadeIn{from{opacity:0}to{opacity:1}}@keyframes gfadeIn{from{opacity:0}to{opacity:1}}@-webkit-keyframes gfadeOut{from{opacity:1}to{opacity:0}}@keyframes gfadeOut{from{opacity:1}to{opacity:0}}@-webkit-keyframes gslideInLeft{from{opacity:0;-webkit-transform:translate3d(-60%, 0, 0);transform:translate3d(-60%, 0, 0)}to{visibility:visible;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);opacity:1}}@keyframes gslideInLeft{from{opacity:0;-webkit-transform:translate3d(-60%, 0, 0);transform:translate3d(-60%, 0, 0)}to{visibility:visible;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);opacity:1}}@-webkit-keyframes gslideOutLeft{from{opacity:1;visibility:visible;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0)}to{-webkit-transform:translate3d(-60%, 0, 0);transform:translate3d(-60%, 0, 0);opacity:0;visibility:hidden}}@keyframes gslideOutLeft{from{opacity:1;visibility:visible;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0)}to{-webkit-transform:translate3d(-60%, 0, 0);transform:translate3d(-60%, 0, 0);opacity:0;visibility:hidden}}@-webkit-keyframes gslideInRight{from{opacity:0;visibility:visible;-webkit-transform:translate3d(60%, 0, 0);transform:translate3d(60%, 0, 0)}to{-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);opacity:1}}@keyframes gslideInRight{from{opacity:0;visibility:visible;-webkit-transform:translate3d(60%, 0, 0);transform:translate3d(60%, 0, 0)}to{-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);opacity:1}}@-webkit-keyframes gslideOutRight{from{opacity:1;visibility:visible;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0)}to{-webkit-transform:translate3d(60%, 0, 0);transform:translate3d(60%, 0, 0);opacity:0}}@keyframes gslideOutRight{from{opacity:1;visibility:visible;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0)}to{-webkit-transform:translate3d(60%, 0, 0);transform:translate3d(60%, 0, 0);opacity:0}}@-webkit-keyframes gzoomIn{from{opacity:0;-webkit-transform:scale3d(0.3, 0.3, 0.3);transform:scale3d(0.3, 0.3, 0.3)}to{opacity:1}}@keyframes gzoomIn{from{opacity:0;-webkit-transform:scale3d(0.3, 0.3, 0.3);transform:scale3d(0.3, 0.3, 0.3)}to{opacity:1}}@-webkit-keyframes gzoomOut{from{opacity:1}50%{opacity:0;-webkit-transform:scale3d(0.3, 0.3, 0.3);transform:scale3d(0.3, 0.3, 0.3)}to{opacity:0}}@keyframes gzoomOut{from{opacity:1}50%{opacity:0;-webkit-transform:scale3d(0.3, 0.3, 0.3);transform:scale3d(0.3, 0.3, 0.3)}to{opacity:0}}@media (min-width: 769px){.glightbox-container .ginner-container{width:auto;height:auto;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.glightbox-container .ginner-container.desc-top .gslide-description{-webkit-box-ordinal-group:1;-ms-flex-order:0;order:0}.glightbox-container .ginner-container.desc-top .gslide-image,.glightbox-container .ginner-container.desc-top .gslide-image img{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}.glightbox-container .ginner-container.desc-left .gslide-description{-webkit-box-ordinal-group:1;-ms-flex-order:0;order:0}.glightbox-container .ginner-container.desc-left .gslide-image{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}.gslide-image img{max-height:97vh;max-width:100%}.gslide-image img.zoomable{cursor:-webkit-zoom-in;cursor:zoom-in}.zoomed .gslide-image img.zoomable{cursor:-webkit-grab;cursor:grab}.gslide-inline{max-height:95vh}.gslide-external{max-height:100vh}.gslide-description.description-left,.gslide-description.description-right{max-width:275px}.glightbox-open{height:auto}.goverlay{background:rgba(0, 0, 0, 0.92)}.glightbox-clean .gslide-media{-webkit-box-shadow:1px 2px 9px 0px rgba(0, 0, 0, 0.65);box-shadow:1px 2px 9px 0px rgba(0, 0, 0, 0.65)}.glightbox-clean .description-left .gdesc-inner,.glightbox-clean .description-right .gdesc-inner{position:absolute;height:100%;overflow-y:auto}.glightbox-clean .gprev,.glightbox-clean .gnext,.glightbox-clean .gclose{background-color:rgba(0, 0, 0, 0.32)}.glightbox-clean .gprev:hover,.glightbox-clean .gnext:hover,.glightbox-clean .gclose:hover{background-color:rgba(0, 0, 0, 0.7)}.glightbox-clean .gprev{top:45%}.glightbox-clean .gnext{top:45%}}@media (min-width: 992px){.glightbox-clean .gclose{opacity:0.7;right:20px}}@media screen and (max-height: 420px){.goverlay{background:#000}}";

const tag$c = 'spx-lightbox';
const SpxLightbox$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.spxLightboxDidLoad = createEvent(this, "spxLightboxDidLoad", 7);
    this.display = 'block';
    this.height = 'auto';
    this.overlayColor = 'rgba(0, 0, 0, 0.92)';
    this.width = '100%';
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    /** Generate random string as gallery ID. */
    const random = '_' + Math.random().toString(36).substr(2, 9);
    /** Wrap elements in <a> element. */
    const elements = this.el.querySelectorAll('img, video, iframe');
    elements.forEach((item) => {
      const src = item.getAttribute('src');
      wrap(item, document.createElement('a'));
      item.parentElement.setAttribute('href', src);
      item.parentElement.style.display = 'block';
      item.parentElement.style.maxWidth = '100%';
      item.parentElement.classList.add('spx-lightbox__item');
      item.parentElement.setAttribute('data-gallery', random);
    });
    /** Create lightbox. */
    // eslint-disable-next-line no-new
    new glightbox_min({
      selector: '.spx-lightbox__item',
      touchNavigation: true,
      openEffect: 'none',
      closeEffect: 'none',
      height: this.height,
      width: this.width,
      svg: {
        close: '<spx-icon icon="close" color="#ffffff" size="32px"/>',
        prev: '<spx-icon icon="arrow-back" color="#ffffff" size="32px"/>',
        next: '<spx-icon icon="arrow-forward" color="#ffffff" size="32px"/>',
      },
      onOpen: () => {
        const lightbox = document.querySelector('#glightbox-body');
        lightbox.classList.add(css$2({
          'spx-icon': {
            height: '32px',
            width: '32px',
          },
          '.gslide-media': {
            boxShadow: 'none !important',
          },
          '.goverlay': {
            background: setVar(tag$c, 'overlay-color', this.overlayColor) + ' !important',
          },
          '.gbtn': {
            display: 'flex',
            alignItems: 'center !important',
            justifyContent: 'center !important',
            backgroundColor: 'transparent !important',
            padding: '0 !important',
            opacity: '0.7',
            width: 'unset !important',
            height: 'unset !important',
            '&:hover': {
              opacity: 1,
            },
            '&.gnext': {
              right: '20px !important',
            },
            '&.gprev': {
              left: '20px !important',
            },
          },
          '.gprev.disabled, .gnext.disabled, .gclose.disabled': {
            opacity: '0 !important',
          },
        }));
        disableBodyScroll(lightbox);
      },
      onClose: () => {
        clearAllBodyScrollLocks();
      },
    });
    this.spxLightboxDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$c, 'display', this.display),
      img: {
        verticalAlign: 'top',
      },
    });
    return h$4(Host, { class: styleHost });
  }
  get el() { return this; }
  static get style() { return glightboxCss; }
};

var macy = createCommonjsModule(function (module, exports) {
!function(t,n){module.exports=n();}(commonjsGlobal,function(){function t(t,n){var e=void 0;return function(){e&&clearTimeout(e),e=setTimeout(t,n);}}function n(t,n){for(var e=t.length,r=e,o=[];e--;)o.push(n(t[r-e-1]));return o}function e(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(window.Promise)return A(t,n,e);t.recalculate(!0,!0);}function r(t){for(var n=t.options,e=t.responsiveOptions,r=t.keys,o=t.docWidth,i=void 0,s=0;s<r.length;s++){var a=parseInt(r[s],10);o>=a&&(i=n.breakAt[a],O(i,e));}return e}function o(t){for(var n=t.options,e=t.responsiveOptions,r=t.keys,o=t.docWidth,i=void 0,s=r.length-1;s>=0;s--){var a=parseInt(r[s],10);o<=a&&(i=n.breakAt[a],O(i,e));}return e}function i(t){var n=t.useContainerForBreakpoints?t.container.clientWidth:window.innerWidth,e={columns:t.columns};b(t.margin)?e.margin={x:t.margin.x,y:t.margin.y}:e.margin={x:t.margin,y:t.margin};var i=Object.keys(t.breakAt);return t.mobileFirst?r({options:t,responsiveOptions:e,keys:i,docWidth:n}):o({options:t,responsiveOptions:e,keys:i,docWidth:n})}function s(t){return i(t).columns}function a(t){return i(t).margin}function c(t){var n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],e=s(t),r=a(t).x,o=100/e;if(!n)return o;if(1===e)return "100%";var i="px";if("string"==typeof r){var c=parseFloat(r);i=r.replace(c,""),r=c;}return r=(e-1)*r/e,"%"===i?o-r+"%":"calc("+o+"% - "+r+i+")"}function u(t,n){var e=s(t.options),r=0,o=void 0,i=void 0;if(1===++n)return 0;i=a(t.options).x;var u="px";if("string"==typeof i){var l=parseFloat(i,10);u=i.replace(l,""),i=l;}return o=(i-(e-1)*i/e)*(n-1),r+=c(t.options,!1)*(n-1),"%"===u?r+o+"%":"calc("+r+"% + "+o+u+")"}function l(t){var n=0,e=t.container,r=t.rows;v(r,function(t){n=t>n?t:n;}),e.style.height=n+"px";}function p(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=s(t.options),i=a(t.options).y;M(t,o,e),v(n,function(n){var e=0,o=parseInt(n.offsetHeight,10);isNaN(o)||(t.rows.forEach(function(n,r){n<t.rows[e]&&(e=r);}),n.style.position="absolute",n.style.top=t.rows[e]+"px",n.style.left=""+t.cols[e],t.rows[e]+=isNaN(o)?0:o+i,r&&(n.dataset.macyComplete=1));}),r&&(t.tmpRows=null),l(t);}function f(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=s(t.options),i=a(t.options).y;M(t,o,e),v(n,function(n){t.lastcol===o&&(t.lastcol=0);var e=C(n,"height");e=parseInt(n.offsetHeight,10),isNaN(e)||(n.style.position="absolute",n.style.top=t.rows[t.lastcol]+"px",n.style.left=""+t.cols[t.lastcol],t.rows[t.lastcol]+=isNaN(e)?0:e+i,t.lastcol+=1,r&&(n.dataset.macyComplete=1));}),r&&(t.tmpRows=null),l(t);}var h=function t(n,e){if(!(this instanceof t))return new t(n,e);if(n&&n.nodeName)return n;if(n=n.replace(/^\s*/,"").replace(/\s*$/,""),e)return this.byCss(n,e);for(var r in this.selectors)if(e=r.split("/"),new RegExp(e[1],e[2]).test(n))return this.selectors[r](n);return this.byCss(n)};h.prototype.byCss=function(t,n){return (n||document).querySelectorAll(t)},h.prototype.selectors={},h.prototype.selectors[/^\.[\w\-]+$/]=function(t){return document.getElementsByClassName(t.substring(1))},h.prototype.selectors[/^\w+$/]=function(t){return document.getElementsByTagName(t)},h.prototype.selectors[/^\#[\w\-]+$/]=function(t){return document.getElementById(t.substring(1))};var v=function(t,n){for(var e=t.length,r=e;e--;)n(t[r-e-1]);},m=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.running=!1,this.events=[],this.add(t);};m.prototype.run=function(){if(!this.running&&this.events.length>0){var t=this.events.shift();this.running=!0,t(),this.running=!1,this.run();}},m.prototype.add=function(){var t=this,n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return !!n&&(Array.isArray(n)?v(n,function(n){return t.add(n)}):(this.events.push(n),void this.run()))},m.prototype.clear=function(){this.events=[];};var d=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.instance=t,this.data=n,this},y=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.events={},this.instance=t;};y.prototype.on=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return !(!t||!n)&&(Array.isArray(this.events[t])||(this.events[t]=[]),this.events[t].push(n))},y.prototype.emit=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t||!Array.isArray(this.events[t]))return !1;var e=new d(this.instance,n);v(this.events[t],function(t){return t(e)});};var g=function(t){return !("naturalHeight"in t&&t.naturalHeight+t.naturalWidth===0)||t.width+t.height!==0},E=function(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new Promise(function(t,e){if(n.complete)return g(n)?t(n):e(n);n.addEventListener("load",function(){return g(n)?t(n):e(n)}),n.addEventListener("error",function(){return e(n)});}).then(function(n){e&&t.emit(t.constants.EVENT_IMAGE_LOAD,{img:n});}).catch(function(n){return t.emit(t.constants.EVENT_IMAGE_ERROR,{img:n})})},w=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return n(e,function(n){return E(t,n,r)})},A=function(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Promise.all(w(t,n,e)).then(function(){t.emit(t.constants.EVENT_IMAGE_COMPLETE);})},I=function(n){return t(function(){n.emit(n.constants.EVENT_RESIZE),n.queue.add(function(){return n.recalculate(!0,!0)});},100)},N=function(t){if(t.container=h(t.options.container),t.container instanceof h||!t.container)return !!t.options.debug&&console.error("Error: Container not found");t.container.length&&(t.container=t.container[0]),t.options.container=t.container,t.container.style.position="relative";},T=function(t){t.queue=new m,t.events=new y(t),t.rows=[],t.resizer=I(t);},L=function(t){var n=h("img",t.container);window.addEventListener("resize",t.resizer),t.on(t.constants.EVENT_IMAGE_LOAD,function(){return t.recalculate(!1,!1)}),t.on(t.constants.EVENT_IMAGE_COMPLETE,function(){return t.recalculate(!0,!0)}),t.options.useOwnImageLoader||e(t,n,!t.options.waitForImages),t.emit(t.constants.EVENT_INITIALIZED);},_=function(t){N(t),T(t),L(t);},b=function(t){return t===Object(t)&&"[object Array]"!==Object.prototype.toString.call(t)},O=function(t,n){b(t)||(n.columns=t),b(t)&&t.columns&&(n.columns=t.columns),b(t)&&t.margin&&!b(t.margin)&&(n.margin={x:t.margin,y:t.margin}),b(t)&&t.margin&&b(t.margin)&&t.margin.x&&(n.margin.x=t.margin.x),b(t)&&t.margin&&b(t.margin)&&t.margin.y&&(n.margin.y=t.margin.y);},C=function(t,n){return window.getComputedStyle(t,null).getPropertyValue(n)},M=function(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.lastcol||(t.lastcol=0),t.rows.length<1&&(e=!0),e){t.rows=[],t.cols=[],t.lastcol=0;for(var r=n-1;r>=0;r--)t.rows[r]=0,t.cols[r]=u(t,r);}else if(t.tmpRows){t.rows=[];for(var r=n-1;r>=0;r--)t.rows[r]=t.tmpRows[r];}else {t.tmpRows=[];for(var r=n-1;r>=0;r--)t.tmpRows[r]=t.rows[r];}},V=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=n?t.container.children:h(':scope > *:not([data-macy-complete="1"])',t.container);r=Array.from(r).filter(function(t){return null!==t.offsetParent});var o=c(t.options);return v(r,function(t){n&&(t.dataset.macyComplete=0),t.style.width=o;}),t.options.trueOrder?(f(t,r,n,e),t.emit(t.constants.EVENT_RECALCULATED)):(p(t,r,n,e),t.emit(t.constants.EVENT_RECALCULATED))},R=function(){return !!window.Promise},x=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);}return t};Array.from||(Array.from=function(t){for(var n=0,e=[];n<t.length;)e.push(t[n++]);return e});var k={columns:4,margin:2,trueOrder:!1,waitForImages:!1,useImageLoader:!0,breakAt:{},useOwnImageLoader:!1,onInit:!1,cancelLegacy:!1,useContainerForBreakpoints:!1};!function(){try{document.createElement("a").querySelector(":scope *");}catch(t){!function(){function t(t){return function(e){if(e&&n.test(e)){var r=this.getAttribute("id");r||(this.id="q"+Math.floor(9e6*Math.random())+1e6),arguments[0]=e.replace(n,"#"+this.id);var o=t.apply(this,arguments);return null===r?this.removeAttribute("id"):r||(this.id=r),o}return t.apply(this,arguments)}}var n=/:scope\b/gi,e=t(Element.prototype.querySelector);Element.prototype.querySelector=function(t){return e.apply(this,arguments)};var r=t(Element.prototype.querySelectorAll);Element.prototype.querySelectorAll=function(t){return r.apply(this,arguments)};}();}}();var q=function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:k;if(!(this instanceof t))return new t(n);this.options={},x(this.options,k,n),this.options.cancelLegacy&&!R()||_(this);};return q.init=function(t){return console.warn("Depreciated: Macy.init will be removed in v3.0.0 opt to use Macy directly like so Macy({ /*options here*/ }) "),new q(t)},q.prototype.recalculateOnImageLoad=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return e(this,h("img",this.container),!t)},q.prototype.runOnImageLoad=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=h("img",this.container);return this.on(this.constants.EVENT_IMAGE_COMPLETE,t),n&&this.on(this.constants.EVENT_IMAGE_LOAD,t),e(this,r,n)},q.prototype.recalculate=function(){var t=this,n=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return e&&this.queue.clear(),this.queue.add(function(){return V(t,n,e)})},q.prototype.remove=function(){window.removeEventListener("resize",this.resizer),v(this.container.children,function(t){t.removeAttribute("data-macy-complete"),t.removeAttribute("style");}),this.container.removeAttribute("style");},q.prototype.reInit=function(){this.recalculate(!0,!0),this.emit(this.constants.EVENT_INITIALIZED),window.addEventListener("resize",this.resizer),this.container.style.position="relative";},q.prototype.on=function(t,n){this.events.on(t,n);},q.prototype.emit=function(t,n){this.events.emit(t,n);},q.constants={EVENT_INITIALIZED:"macy.initialized",EVENT_RECALCULATED:"macy.recalculated",EVENT_IMAGE_LOAD:"macy.image.load",EVENT_IMAGE_ERROR:"macy.image.error",EVENT_IMAGE_COMPLETE:"macy.images.complete",EVENT_RESIZE:"macy.resize"},q.prototype.constants=q.constants,q});
});

// eslint-disable-next-line no-unused-vars
/**
 * Render elements from images prop.
 *
 * @param {object} obj Settings.
 * @returns {HTMLCollection} Collection of HTML elements.
 */
function helperImages(obj) {
  return obj.images && (!obj.src || obj.src === 'acf')
    ? /** Iterate through ACF array if prop was set. */
      obj.array.map((el) => (h$4("img", { src: !obj.lazy && (obj.size ? el['sizes'][obj.size] : el['url']), "data-src": obj.lazy && (obj.size ? el['sizes'][obj.size] : el['url']), alt: "" })))
    : /** Iterate through MB array if prop was set. */
      obj.images &&
        obj.src === 'mb' &&
        Object.values(obj.array).map((el) => (h$4("img", { src: !obj.lazy &&
            (obj.size ? el['sizes'][obj.size].url : el['full_url']), "data-src": obj.lazy &&
            (obj.size ? el['sizes'][obj.size].url : el['full_url']), alt: "" })));
}

// eslint-disable-next-line no-unused-vars
/**
 * Either renders image helper or inner content.
 *
 * @param {object} obj Settings.
 * @returns {HTMLElement} HTML element with innerHTML or generated content.
 */
function helperImagesOrInner(obj) {
  return (h$4("div", { ref: obj.ref, class: obj.class, innerHTML: !obj.condition ? sanitize(obj.content) : '' }, obj.condition && helperImages(obj.helper)));
}

const tag$b = 'spx-masonry';
const SpxMasonry$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxMasonryDidLoad = createEvent(this, "spxMasonryDidLoad", 7);
    /** Number of columns. */
    this.columns = 4;
    this.display = display$1;
    /**
     * Gap between images.
     *
     * @CSS
     */
    this.gap = '10px';
    /** Init Macy. */
    this.initMacy = () => {
      /** Wrap all children in div. */
      Array.from(this.container.children).forEach((item) => {
        wrap(item, document.createElement('div'));
      });
      this.macyState = macy({
        container: this.container,
        margin: 0,
        mobileFirst: true,
        runOnImageLoad: true,
        columns: this.columns,
        breakAt: this.bpColumns
          ? this.bpColumnsObject
          : {
            9999: this.columns ? this.columns : 4,
          },
      });
    };
    /** Update. */
    this.update = () => {
      this.macyState.remove();
      this.container.innerHTML = '';
      this.content = this.el.innerHTML;
      setTimeout(() => {
        lazy({
          el: this.el,
          condition: this.lazy,
        });
        this.initMacy();
      }, 100);
    };
  }
  /**
   * Watch images.
   *
   * @param {string} newValue Array string.
   */
  imagesChanged(newValue) {
    if (newValue)
      this.imagesArray = JSON.parse(newValue);
  }
  componentWillLoad() {
    this.content = this.el.innerHTML;
    /** If image prop is set. */
    if (this.images) {
      this.imagesChanged(this.images);
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el, lazy: this.lazy, cb: this.update });
    /** Create object for breakpoint attribute. */
    if (this.bpColumns) {
      this.bpColumnsObject = JSON.parse('{' + this.bpColumns.replace(/([0-9]+)/g, '"$1"') + '}');
    }
    /** Init Macy. */
    this.initMacy();
    /** Emit event to document when Masonry finished loading. */
    this.spxMasonryDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  componentDidUpdate() {
    this.macyState.reInit();
  }
  disconnectedCallback() {
    this.macyState.remove();
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$b, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      /** Adjust container margin to make up for element paddings. */
      margin: 'calc(var(--spx-masonry-gap, ' +
        this.gap +
        ') * -1) calc(var(--spx-masonry-gap, ' +
        this.gap +
        ') / 2 * -1) 0 calc(var(--spx-masonry-gap, ' +
        this.gap +
        ') / 2 * -1)',
      /** Convert gap to correct padding for elements. */
      '& > div': {
        padding: 'var(--spx-masonry-gap, ' +
          this.gap +
          ') calc(var(--spx-masonry-gap, ' +
          this.gap +
          ') / 2) 0 calc(var(--spx-masonry-gap, ' +
          this.gap +
          ') / 2)',
        boxSizing: 'border-box',
        '*': {
          width: '100%',
          maxWidth: '100%',
        },
        img: {
          verticalAlign: 'top',
        },
      },
    });
    return (h$4(Host, { class: styleHost }, helperImagesOrInner({
      class: styleShadowHost,
      condition: this.images,
      content: this.content,
      el: this.el,
      ref: (el) => (this.container = el),
      helper: {
        array: this.imagesArray,
        el: this.el,
        images: this.images,
        lazy: this.lazy,
        size: this.imageSize,
        src: this.imageSrc,
      },
    })));
  }
  get el() { return this; }
  static get watchers() { return {
    "images": ["imagesChanged"]
  }; }
};

const tag$a = 'spx-mockup';
const SpxMockup$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxMockupDidLoad = createEvent(this, "spxMockupDidLoad", 7);
    /**
     * Samsung S8 color.
     *
     * @choice 'black', 'blue'
     */
    this.colorGalaxyS8 = 'black';
    /**
     * Google Pixel color.
     *
     * @choice 'silver', 'black', 'blue'
     */
    this.colorGooglePixel = 'silver';
    /**
     * IPad Pro color.
     *
     * @choice 'silver', 'gold', 'rosegold', 'spacegray'
     */
    this.colorIpadPro = 'silver';
    /**
     * IPhone 8 color.
     *
     * @choice 'silver', 'gold', 'spacegray'
     */
    this.colorIphone8 = 'silver';
    /**
     * MacBook color.
     *
     * @choice 'silver', 'gold', 'rosegold', 'spacegray'
     */
    this.colorMacbook = 'silver';
    /**
     * MacBook Pro color.
     *
     * @choice 'silver', 'spacegray'
     */
    this.colorMacbookPro = 'silver';
    this.display = 'inline-block';
    this.imagePosition = '50% 50%';
    /** Mockup size maximum. */
    this.sizeMax = 0.6;
    /** Mockup size minimum. */
    this.sizeMin = 0.3;
    /**
     * Device type.
     *
     * @choice 'iphone-8', 'iphone-x', 'google-pixel-2-xl', 'google-pixel', 'galaxy-s8', 'ipad-pro', 'surface-pro', 'surface-book', 'macbook', 'macbook-pro', 'surface-studio', 'imac-pro', 'apple-watch'
     */
    this.type = 'iphone-8';
    /** Resize function to keep src element in proportion. */
    this.handleResize = () => {
      const percentage = ((window.innerWidth - state.minWidthPx) * 100) /
        (state.maxWidthPx - state.minWidthPx);
      const slope = ((this.sizeMax - this.sizeMin) / 100) * percentage;
      const size = window.innerWidth <= state.minWidthPx
        ? this.sizeMin
        : window.innerWidth >= state.maxWidthPx
          ? this.sizeMax
          : this.sizeMin + slope;
      this.mockup.style.transform = 'scale(' + size + ')';
      this.parent.style.height = (this.mockup.offsetHeight / 1) * size + 'px';
      this.parent.style.width = (this.mockup.offsetWidth / 1) * size + 'px';
    };
  }
  onResize() {
    this.handleResize();
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    /** Assign states. */
    this.parent = this.el.shadowRoot.querySelector('.spx-mockup-wrap');
    this.mockup = this.el.shadowRoot.querySelector('.spx-mockup');
    /** Resize mockup. */
    this.handleResize();
    this.spxMockupDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  componentDidUpdate() {
    this.handleResize();
  }
  render() {
    /** Set the correct color. */
    const color = this.type === 'galaxy-s8'
      ? this.colorGalaxyS8
      : this.type === 'google-pixel'
        ? this.colorGooglePixel
        : this.type === 'ipad-pro'
          ? this.colorIpadPro
          : this.type === 'iphone-8'
            ? this.colorIphone8
            : this.type === 'macbook'
              ? this.colorMacbook
              : this.type === 'macbook-pro'
                ? this.colorMacbookPro
                : null;
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$a, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      position: 'relative',
      display: setVar(tag$a, 'display', this.display),
      maxWidth: '100%',
    });
    /** Image styles. */
    const styleImg = css({
      width: '100%',
      height: '100%',
      objectFit: 'cover',
      objectPosition: this.imagePosition,
    });
    /** Image styles. */
    const styleDevice = css({
      '.spx-mockup, .spx-mockup::before, .spx-mockup::after, .spx-mockup *, .spx-mockup *::before, .spx-mockup *::after': {
        boxSizing: 'border-box',
        display: 'block',
      },
      '.spx-mockup': {
        position: 'relative',
        transform: 'scale(1)',
        transformOrigin: 'left top',
        zIndex: 1,
      },
      '.spx-mockup .spx-mockup-frame': { zIndex: 1 },
      '.spx-mockup .spx-mockup-content': {
        backgroundColor: '#fff',
        backgroundPosition: 'center center',
        backgroundSize: 'cover',
        objectFit: 'cover',
        position: 'relative',
        overflow: 'hidden',
        height: '100%',
        width: '100%',
      },
      '.spx-mockup .spx-mockup-content script': { display: 'none' },
      '.spx-mockup-iphone-x': { height: '868px', width: '428px' },
      '.spx-mockup-iphone-x .spx-mockup-frame': {
        background: '#222',
        borderRadius: '68px',
        boxShadow: 'inset 0 0 2px 2px #c8cacb, inset 0 0 0 7px #e2e3e4',
        height: '868px',
        padding: '28px',
        width: '428px',
      },
      '.spx-mockup-iphone-x .spx-mockup-content': {
        borderRadius: '40px',
        height: '812px',
        width: '375px',
      },
      '.spx-mockup-iphone-x .spx-mockup-stripe::after, .spx-mockup-iphone-x .spx-mockup-stripe::before': {
        border: 'solid rgba(51, 51, 51, 0.25)',
        borderWidth: '0 7px',
        content: "''",
        height: '7px',
        left: '0',
        position: 'absolute',
        width: '100%',
        zIndex: 9,
      },
      '.spx-mockup-iphone-x .spx-mockup-stripe::after': { top: '85px' },
      '.spx-mockup-iphone-x .spx-mockup-stripe::before': { bottom: '85px' },
      '.spx-mockup-iphone-x .spx-mockup-header': {
        background: '#222',
        borderBottomLeftRadius: '20px',
        borderBottomRightRadius: '20px',
        height: '30px',
        left: '50%',
        marginLeft: '-102px',
        position: 'absolute',
        top: '28px',
        width: '204px',
      },
      '.spx-mockup-iphone-x .spx-mockup-header::after, .spx-mockup-iphone-x .spx-mockup-header::before': {
        content: "''",
        height: '10px',
        position: 'absolute',
        top: '0',
        width: '10px',
      },
      '.spx-mockup-iphone-x .spx-mockup-header::after': {
        background: 'radial-gradient( circle at bottom left, transparent 0, transparent 75%, #222 75%, #222 100%)',
        left: '-10px',
      },
      '.spx-mockup-iphone-x .spx-mockup-header::before': {
        background: 'radial-gradient( circle at bottom right, transparent 0, transparent 75%, #222 75%, #222 100%)',
        right: '-10px',
      },
      '.spx-mockup-iphone-x .spx-mockup-sensors::after, .spx-mockup-iphone-x .spx-mockup-sensors::before': {
        content: "''",
        position: 'absolute',
      },
      '.spx-mockup-iphone-x .spx-mockup-sensors::after': {
        background: '#444',
        borderRadius: '3px',
        height: '6px',
        left: '50%',
        marginLeft: '-25px',
        top: '32px',
        width: '50px',
      },
      '.spx-mockup-iphone-x .spx-mockup-sensors::before': {
        background: '#444',
        borderRadius: '50%',
        height: '14px',
        left: '50%',
        marginLeft: '40px',
        top: '28px',
        width: '14px',
      },
      '.spx-mockup-iphone-x .spx-mockup-btns': {
        background: '#c8cacb',
        height: '32px',
        left: '-3px',
        position: 'absolute',
        top: '115px',
        width: '3px',
      },
      '.spx-mockup-iphone-x .spx-mockup-btns::after, .spx-mockup-iphone-x .spx-mockup-btns::before': {
        background: '#c8cacb',
        content: "''",
        height: '62px',
        left: '0',
        position: 'absolute',
        width: '3px',
      },
      '.spx-mockup-iphone-x .spx-mockup-btns::after': { top: '60px' },
      '.spx-mockup-iphone-x .spx-mockup-btns::before': { top: '140px' },
      '.spx-mockup-iphone-x .spx-mockup-power': {
        background: '#c8cacb',
        height: '100px',
        position: 'absolute',
        right: '-3px',
        top: '200px',
        width: '3px',
      },
      '.spx-mockup-iphone-8': { height: '871px', width: '419px' },
      '.spx-mockup-iphone-8 .spx-mockup-frame': {
        background: '#fff',
        borderRadius: '68px',
        boxShadow: 'inset 0 0 0 2px #c8cacb, inset 0 0 0 7px #e2e3e4',
        height: '871px',
        padding: '102px 22px',
        width: '419px',
      },
      '.spx-mockup-iphone-8 .spx-mockup-content': {
        border: '2px solid #222',
        borderRadius: '4px',
        height: '667px',
        width: '375px',
      },
      '.spx-mockup-iphone-8 .spx-mockup-stripe::after, .spx-mockup-iphone-8 .spx-mockup-stripe::before': {
        border: 'solid rgba(51, 51, 51, 0.15)',
        borderWidth: '0 7px',
        content: "''",
        height: '6px',
        left: '0',
        position: 'absolute',
        width: '100%',
        zIndex: 9,
      },
      '.spx-mockup-iphone-8 .spx-mockup-stripe::after': { top: '68px' },
      '.spx-mockup-iphone-8 .spx-mockup-stripe::before': { bottom: '68px' },
      '.spx-mockup-iphone-8 .spx-mockup-header': {
        border: '2px solid #c8cacb',
        borderRadius: '50%',
        bottom: '25px',
        height: '58px',
        left: '50%',
        marginLeft: '-29px',
        position: 'absolute',
        width: '58px',
      },
      '.spx-mockup-iphone-8 .spx-mockup-sensors': {
        background: '#666',
        borderRadius: '3px',
        height: '6px',
        left: '50%',
        marginLeft: '-38px',
        position: 'absolute',
        top: '52px',
        width: '76px',
      },
      '.spx-mockup-iphone-8 .spx-mockup-sensors::after, .spx-mockup-iphone-8 .spx-mockup-sensors::before': {
        background: '#666',
        borderRadius: '50%',
        content: "''",
        position: 'absolute',
      },
      '.spx-mockup-iphone-8 .spx-mockup-sensors::after': {
        height: '10px',
        left: '50%',
        marginLeft: '-5px',
        top: '-25px',
        width: '10px',
      },
      '.spx-mockup-iphone-8 .spx-mockup-sensors::before': {
        height: '12px',
        left: '-42px',
        marginTop: '-6px',
        top: '50%',
        width: '12px',
      },
      '.spx-mockup-iphone-8 .spx-mockup-btns': {
        background: '#c8cacb',
        height: '30px',
        left: '-3px',
        position: 'absolute',
        top: '102px',
        width: '3px',
      },
      '.spx-mockup-iphone-8 .spx-mockup-btns::after, .spx-mockup-iphone-8 .spx-mockup-btns::before': {
        background: '#c8cacb',
        content: "''",
        height: '56px',
        left: '0',
        position: 'absolute',
        width: '3px',
      },
      '.spx-mockup-iphone-8 .spx-mockup-btns::after': { top: '62px' },
      '.spx-mockup-iphone-8 .spx-mockup-btns::before': { top: '132px' },
      '.spx-mockup-iphone-8 .spx-mockup-power': {
        background: '#c8cacb',
        height: '80px',
        position: 'absolute',
        right: '-2px',
        top: '160px',
        width: '3px',
      },
      '.spx-mockup-iphone-8.spx-mockup-gold .spx-mockup-frame': {
        boxShadow: 'inset 0 0 0 2px #e4b08a, inset 0 0 0 7px #f7e8dd',
      },
      '.spx-mockup-iphone-8.spx-mockup-gold .spx-mockup-header': {
        borderColor: '#e4b08a',
      },
      '.spx-mockup-iphone-8.spx-mockup-gold .spx-mockup-btns, .spx-mockup-iphone-8.spx-mockup-gold .spx-mockup-btns::after, .spx-mockup-iphone-8.spx-mockup-gold .spx-mockup-btns::before': {
        background: '#e4b08a',
      },
      '.spx-mockup-iphone-8.spx-mockup-gold .spx-mockup-power': {
        background: '#e4b08a',
      },
      '.spx-mockup-iphone-8.spx-mockup-spacegray .spx-mockup-frame': {
        background: '#222',
        boxShadow: 'inset 0 0 0 2px #74747a, inset 0 0 0 7px #9b9ba0',
      },
      '.spx-mockup-iphone-8.spx-mockup-spacegray .spx-mockup-stripe::after, .spx-mockup-iphone-8.spx-mockup-spacegray .spx-mockup-stripe::before': {
        borderColor: 'rgba(204, 204, 204, 0.35)',
      },
      '.spx-mockup-iphone-8.spx-mockup-spacegray .spx-mockup-btns, .spx-mockup-iphone-8.spx-mockup-spacegray .spx-mockup-btns::after, .spx-mockup-iphone-8.spx-mockup-spacegray .spx-mockup-btns::before': {
        background: '#74747a',
      },
      '.spx-mockup-google-pixel-2-xl': { height: '832px', width: '404px' },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-frame': {
        background: '#121212',
        borderRadius: '36px',
        boxShadow: 'inset 0 0 0 2px #cfcfcf, inset 0 0 0 7px #9c9c9c',
        height: '832px',
        padding: '56px 22px',
        width: '404px',
      },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-content': {
        borderRadius: '27px',
        height: '720px',
        width: '360px',
      },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-header': {
        height: '832px',
        left: '50%',
        marginLeft: '-150px',
        position: 'absolute',
        top: '0',
        width: '300px',
      },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-header::after, .spx-mockup-google-pixel-2-xl .spx-mockup-header::before': {
        background: '#333',
        borderRadius: '3px',
        content: "''",
        height: '6px',
        left: '50%',
        marginLeft: '-73px',
        marginTop: '-3px',
        position: 'absolute',
        width: '146px',
      },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-header::after': {
        top: '24px',
      },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-header::before': {
        bottom: '28px',
      },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-sensors': {
        background: '#333',
        borderRadius: '7px',
        height: '14px',
        left: '54px',
        marginTop: '-7px',
        position: 'absolute',
        top: '36px',
        width: '14px',
      },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-btns': {
        background: '#cfcfcf',
        height: '102px',
        position: 'absolute',
        right: '-3px',
        top: '306px',
        width: '3px',
      },
      '.spx-mockup-google-pixel-2-xl .spx-mockup-power': {
        background: '#cfcfcf',
        height: '58px',
        position: 'absolute',
        right: '-3px',
        top: '194px',
        width: '3px',
      },
      '.spx-mockup-google-pixel': { height: '744px', width: '360px' },
      '.spx-mockup-google-pixel .spx-mockup-frame': {
        background: '#f7f7f8',
        borderRadius: '54px',
        boxShadow: 'inset 0 0 0 2px #c8cacb, inset 0 0 0 6px #e2e3e4, inset 0 0 0 10px white',
        height: '744px',
        padding: '82px 18px 86px 18px',
        width: '360px',
      },
      '.spx-mockup-google-pixel .spx-mockup-content': {
        border: '2px solid #222',
        borderRadius: '2px',
        height: '576px',
        width: '324px',
      },
      '.spx-mockup-google-pixel .spx-mockup-stripe': {
        borderTop: '6px solid rgba(51, 51, 51, 0.15)',
        bottom: '0',
        left: '254px',
        position: 'absolute',
        top: '0',
        width: '8px',
      },
      '.spx-mockup-google-pixel .spx-mockup-stripe::after, .spx-mockup-google-pixel .spx-mockup-stripe::before': {
        border: 'solid rgba(51, 51, 51, 0.15)',
        borderWidth: '0 6px',
        content: "''",
        height: '10px',
        left: '-254px',
        position: 'absolute',
        width: '360px',
        zIndex: 9,
      },
      '.spx-mockup-google-pixel .spx-mockup-stripe::after': { top: '60px' },
      '.spx-mockup-google-pixel .spx-mockup-stripe::before': { bottom: '46px' },
      '.spx-mockup-google-pixel .spx-mockup-sensors': {
        background: '#ddd',
        borderRadius: '2.5px',
        height: '5px',
        left: '50%',
        marginLeft: '-39px',
        marginTop: '-2.5px',
        position: 'absolute',
        top: '41px',
        width: '78px',
      },
      '.spx-mockup-google-pixel .spx-mockup-sensors::after, .spx-mockup-google-pixel .spx-mockup-sensors::before': {
        background: '#333',
        borderRadius: '6px',
        content: "''",
        position: 'absolute',
      },
      '.spx-mockup-google-pixel .spx-mockup-sensors::after': {
        height: '12px',
        left: '50%',
        marginLeft: '-14px',
        top: '21.5px',
        width: '28px',
      },
      '.spx-mockup-google-pixel .spx-mockup-sensors::before': {
        height: '10px',
        left: '-81px',
        marginTop: '-5px',
        top: '50%',
        width: '10px',
      },
      '.spx-mockup-google-pixel .spx-mockup-btns': {
        background: '#c8cacb',
        height: '102px',
        position: 'absolute',
        right: '-2px',
        top: '298px',
        width: '3px',
      },
      '.spx-mockup-google-pixel .spx-mockup-power': {
        background: '#c8cacb',
        height: '50px',
        position: 'absolute',
        right: '-2px',
        top: '184px',
        width: '3px',
      },
      '.spx-mockup-google-pixel.spx-mockup-black .spx-mockup-frame': {
        background: '#211d1c',
        boxShadow: 'inset 0 0 0 2px #363635, inset 0 0 0 6px #6a6967, inset 0 0 0 10px #3d3533',
      },
      '.spx-mockup-google-pixel.spx-mockup-black .spx-mockup-stripe, .spx-mockup-google-pixel.spx-mockup-black .spx-mockup-stripe::after, .spx-mockup-google-pixel.spx-mockup-black .spx-mockup-stripe::before': {
        borderColor: 'rgba(13, 13, 13, 0.35)',
      },
      '.spx-mockup-google-pixel.spx-mockup-black .spx-mockup-sensors': {
        background: '#444',
      },
      '.spx-mockup-google-pixel.spx-mockup-black .spx-mockup-sensors::after': {
        background: '#0d0d0d',
      },
      '.spx-mockup-google-pixel.spx-mockup-black .spx-mockup-btns, .spx-mockup-google-pixel.spx-mockup-black .spx-mockup-btns::after, .spx-mockup-google-pixel.spx-mockup-black .spx-mockup-btns::before': {
        background: '#363635',
      },
      '.spx-mockup-google-pixel.spx-mockup-black .spx-mockup-power': {
        background: '#363635',
      },
      '.spx-mockup-google-pixel.spx-mockup-blue .spx-mockup-frame': {
        boxShadow: 'inset 0 0 0 2px #2a5aff, inset 0 0 0 6px #7695ff, inset 0 0 0 10px white',
      },
      '.spx-mockup-google-pixel.spx-mockup-blue .spx-mockup-btns, .spx-mockup-google-pixel.spx-mockup-blue .spx-mockup-btns::after, .spx-mockup-google-pixel.spx-mockup-blue .spx-mockup-btns::before': {
        background: '#2a5aff',
      },
      '.spx-mockup-google-pixel.spx-mockup-blue .spx-mockup-power': {
        background: '#2a5aff',
      },
      '.spx-mockup-galaxy-s8': { height: '828px', width: '380px' },
      '.spx-mockup-galaxy-s8 .spx-mockup-frame': {
        background: '#222',
        border: 'solid #cfcfcf',
        borderRadius: '55px',
        borderWidth: '5px 0',
        boxShadow: 'inset 0 0 0 2px #9c9c9c',
        height: '828px',
        padding: '48px 10px 40px 10px',
        width: '380px',
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-content': {
        border: '2px solid #222',
        borderRadius: '34px',
        height: '740px',
        width: '360px',
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-stripe::after, .spx-mockup-galaxy-s8 .spx-mockup-stripe::before': {
        border: 'solid rgba(51, 51, 51, 0.15)',
        borderWidth: '5px 0',
        content: "''",
        height: '828px',
        position: 'absolute',
        top: '0',
        width: '6px',
        zIndex: 9,
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-stripe::after': { left: '48px' },
      '.spx-mockup-galaxy-s8 .spx-mockup-stripe::before': { right: '48px' },
      '.spx-mockup-galaxy-s8 .spx-mockup-sensors': {
        background: '#666',
        borderRadius: '3px',
        height: '6px',
        left: '50%',
        marginLeft: '-24px',
        marginTop: '-3px',
        position: 'absolute',
        top: '32px',
        width: '48px',
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-sensors::after, .spx-mockup-galaxy-s8 .spx-mockup-sensors::before': {
        background: '#666',
        borderRadius: '50%',
        content: "''",
        position: 'absolute',
        top: '50%',
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-sensors::after': {
        boxShadow: '-192px 0 #333, -174px 0 #333, -240px 0 #333',
        height: '8px',
        marginTop: '-4px',
        right: '-90px',
        width: '8px',
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-sensors::before': {
        boxShadow: '186px 0 #666',
        height: '12px',
        left: '-90px',
        marginTop: '-6px',
        width: '12px',
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-btns': {
        background: '#9c9c9c',
        borderRadius: '3px 0 0 3px',
        height: '116px',
        left: '-3px',
        position: 'absolute',
        top: '144px',
        width: '3px',
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-btns::after': {
        background: '#9c9c9c',
        borderRadius: '3px 0 0 3px',
        content: "''",
        height: '54px',
        left: '0',
        position: 'absolute',
        top: '164px',
        width: '3px',
      },
      '.spx-mockup-galaxy-s8 .spx-mockup-power': {
        background: '#9c9c9c',
        borderRadius: '0 3px 3px 0',
        height: '54px',
        position: 'absolute',
        right: '-3px',
        top: '260px',
        width: '3px',
      },
      '.spx-mockup-galaxy-s8.spx-mockup-blue .spx-mockup-frame': {
        borderColor: '#a3c5e8',
        boxShadow: 'inset 0 0 0 2px #5192d4',
      },
      '.spx-mockup-galaxy-s8.spx-mockup-blue .spx-mockup-stripe::after, .spx-mockup-galaxy-s8.spx-mockup-blue .spx-mockup-stripe::before': {
        borderColor: 'rgba(255, 255, 255, 0.35)',
      },
      '.spx-mockup-galaxy-s8.spx-mockup-blue .spx-mockup-btns, .spx-mockup-galaxy-s8.spx-mockup-blue .spx-mockup-btns::after': {
        background: '#5192d4',
      },
      '.spx-mockup-galaxy-s8.spx-mockup-blue .spx-mockup-power': {
        background: '#5192d4',
      },
      '.spx-mockup-ipad-pro': { height: '804px', width: '560px' },
      '.spx-mockup-ipad-pro .spx-mockup-frame': {
        background: '#fff',
        borderRadius: '38px',
        boxShadow: 'inset 0 0 0 2px #c8cacb, inset 0 0 0 6px #e2e3e4',
        height: '804px',
        padding: '62px 25px',
        width: '560px',
      },
      '.spx-mockup-ipad-pro .spx-mockup-content': {
        border: '2px solid #222',
        borderRadius: '2px',
        height: '680px',
        width: '510px',
      },
      '.spx-mockup-ipad-pro .spx-mockup-header': {
        border: '2px solid #c8cacb',
        borderRadius: '50%',
        bottom: '17px',
        height: '34px',
        left: '50%',
        marginLeft: '-17px',
        position: 'absolute',
        width: '34px',
      },
      '.spx-mockup-ipad-pro .spx-mockup-sensors': {
        background: '#666',
        borderRadius: '50%',
        height: '10px',
        left: '50%',
        marginLeft: '-5px',
        marginTop: '-5px',
        position: 'absolute',
        top: '34px',
        width: '10px',
      },
      '.spx-mockup-ipad-pro.spx-mockup-gold .spx-mockup-frame': {
        boxShadow: 'inset 0 0 0 2px #e4b08a, inset 0 0 0 6px #f7e8dd',
      },
      '.spx-mockup-ipad-pro.spx-mockup-gold .spx-mockup-header': {
        borderColor: '#e4b08a',
      },
      '.spx-mockup-ipad-pro.spx-mockup-rosegold .spx-mockup-frame': {
        boxShadow: 'inset 0 0 0 2px #f6a69a, inset 0 0 0 6px #facfc9',
      },
      '.spx-mockup-ipad-pro.spx-mockup-rosegold .spx-mockup-header': {
        borderColor: '#f6a69a',
      },
      '.spx-mockup-ipad-pro.spx-mockup-spacegray .spx-mockup-frame': {
        background: '#222',
        boxShadow: 'inset 0 0 0 2px #818187, inset 0 0 0 6px #9b9ba0',
      },
      '.spx-mockup-ipad-pro.spx-mockup-spacegray .spx-mockup-header': {
        borderColor: '#818187',
      },
      '.spx-mockup-surface-pro': { height: '394px', width: '561px' },
      '.spx-mockup-surface-pro .spx-mockup-frame': {
        background: '#0d0d0d',
        borderRadius: '10px',
        boxShadow: 'inset 0 0 0 2px #c8c8c8',
        height: '394px',
        margin: '0 auto',
        padding: '26px 24px',
        width: '561px',
      },
      '.spx-mockup-surface-pro .spx-mockup-content': {
        border: '2px solid #121212',
        borderRadius: '2px',
        height: '342px',
        width: '513px',
      },
      '.spx-mockup-surface-pro .spx-mockup-btns::after, .spx-mockup-surface-pro .spx-mockup-btns::before': {
        background: '#c8c8c8',
        content: "''",
        height: '2px',
        position: 'absolute',
        top: '-2px',
      },
      '.spx-mockup-surface-pro .spx-mockup-btns::after': {
        left: '48px',
        width: '26px',
      },
      '.spx-mockup-surface-pro .spx-mockup-btns::before': {
        left: '94px',
        width: '48px',
      },
      '.spx-mockup-surface-pro .spx-mockup-sensors': {
        background: '#333',
        borderRadius: '50%',
        height: '6px',
        left: '50%',
        marginLeft: '-3px',
        marginTop: '-3px',
        position: 'absolute',
        top: '14px',
        width: '6px',
      },
      '.spx-mockup-surface-book': { height: '424px', width: '728px' },
      '.spx-mockup-surface-book .spx-mockup-frame': {
        background: '#0d0d0d',
        borderRadius: '12px',
        boxShadow: 'inset 0 0 0 2px #c8c8c8',
        height: '408px',
        margin: '0 auto',
        padding: '24px 22px',
        position: 'relative',
        width: '584px',
      },
      '.spx-mockup-surface-book .spx-mockup-content': {
        border: '2px solid #121212',
        borderRadius: '2px',
        height: '360px',
        width: '540px',
      },
      '.spx-mockup-surface-book .spx-mockup-btns::after, .spx-mockup-surface-book .spx-mockup-btns::before': {
        background: '#c8c8c8',
        content: "''",
        height: '2px',
        position: 'absolute',
        top: '-2px',
      },
      '.spx-mockup-surface-book .spx-mockup-btns::after': {
        left: '122px',
        width: '20px',
      },
      '.spx-mockup-surface-book .spx-mockup-btns::before': {
        left: '168px',
        width: '44px',
      },
      '.spx-mockup-surface-book .spx-mockup-power': {
        background: 'linear-gradient(to bottom, #eee, #c8c8c8)',
        border: 'solid #c8c8c8',
        borderRadius: '2px',
        borderWidth: '0 2px',
        height: '12px',
        marginTop: '4px',
        position: 'relative',
        width: '728px',
      },
      '.spx-mockup-surface-book .spx-mockup-power::after, .spx-mockup-surface-book .spx-mockup-power::before': {
        content: "''",
        position: 'absolute',
      },
      '.spx-mockup-surface-book .spx-mockup-power::after': {
        background: 'radial-gradient( circle at center, #eee 0, #eee 95%, #a2a1a1 100%)',
        borderRadius: '0 0 6px 6px',
        height: '8px',
        left: '50%',
        marginLeft: '-125px',
        top: '0',
        width: '250px',
        zIndex: 1,
      },
      '.spx-mockup-surface-book .spx-mockup-power::before': {
        background: 'linear-gradient(to bottom, #eee, #c8c8c8)',
        borderRadius: '2px 2px 0 0',
        bottom: '12px',
        height: '8px',
        left: '50%',
        marginLeft: '-292px',
        width: '584px',
      },
      '.spx-mockup-macbook-pro': { height: '444px', width: '740px' },
      '.spx-mockup-macbook-pro .spx-mockup-frame': {
        background: '#0d0d0d',
        borderRadius: '20px',
        boxShadow: 'inset 0 0 0 2px #c8cacb',
        height: '428px',
        margin: '0 auto',
        padding: '29px 19px 39px 19px',
        position: 'relative',
        width: '614px',
      },
      '.spx-mockup-macbook-pro .spx-mockup-frame::after': {
        background: '#272626',
        borderRadius: '0 0 20px 20px',
        bottom: '2px',
        content: "''",
        height: '26px',
        left: '2px',
        position: 'absolute',
        width: '610px',
      },
      '.spx-mockup-macbook-pro .spx-mockup-frame::before': {
        bottom: '10px',
        color: '#c8cacb',
        content: "'MacBook Pro'",
        fontSize: '12px',
        height: '16px',
        left: '50%',
        lineHeight: '16px',
        marginLeft: '-100px',
        position: 'absolute',
        textAlign: 'center',
        width: '200px',
        zIndex: 1,
      },
      '.spx-mockup-macbook-pro .spx-mockup-content': {
        border: '2px solid #121212',
        borderRadius: '2px',
        height: '360px',
        width: '576px',
      },
      '.spx-mockup-macbook-pro .spx-mockup-power': {
        background: '#e2e3e4',
        border: 'solid #d5d6d8',
        borderRadius: '2px 2px 0 0',
        borderWidth: '2px 4px 0 4px',
        height: '14px',
        marginTop: '-10px',
        position: 'relative',
        width: '740px',
        zIndex: 9,
      },
      '.spx-mockup-macbook-pro .spx-mockup-power::after, .spx-mockup-macbook-pro .spx-mockup-power::before': {
        content: "''",
        position: 'absolute',
      },
      '.spx-mockup-macbook-pro .spx-mockup-power::after': {
        background: '#d5d6d8',
        borderRadius: '0 0 10px 10px',
        boxShadow: 'inset 0 0 4px 2px #babdbf',
        height: '10px',
        left: '50%',
        marginLeft: '-60px',
        top: '-2px',
        width: '120px',
      },
      '.spx-mockup-macbook-pro .spx-mockup-power::before': {
        background: '#a0a3a7',
        borderRadius: '0 0 180px 180px/ 0 0 12px 12px',
        boxShadow: 'inset 0 -2px 6px 0 #474a4d',
        height: '12px',
        left: '-4px',
        margin: '0 auto',
        top: '10px',
        width: '740px',
      },
      '.spx-mockup-macbook-pro.spx-mockup-spacegray .spx-mockup-frame': {
        boxShadow: 'inset 0 0 0 2px #767a7d',
      },
      '.spx-mockup-macbook-pro.spx-mockup-spacegray .spx-mockup-power': {
        background: '#909496',
        borderColor: '#767a7d',
      },
      '.spx-mockup-macbook-pro.spx-mockup-spacegray .spx-mockup-power::after': {
        background: '#83878a',
        boxShadow: 'inset 0 0 4px 2px #6a6d70',
      },
      '.spx-mockup-macbook-pro.spx-mockup-spacegray .spx-mockup-power::before': {
        background: '#515456',
        boxShadow: 'inset 0 -2px 6px 0 black',
      },
      '.spx-mockup-macbook': { height: '432px', width: '740px' },
      '.spx-mockup-macbook .spx-mockup-frame': {
        background: '#0d0d0d',
        borderRadius: '20px',
        boxShadow: 'inset 0 0 0 2px #c8cacb',
        height: '428px',
        margin: '0 auto',
        padding: '29px 19px 39px 19px',
        position: 'relative',
        width: '614px',
      },
      '.spx-mockup-macbook .spx-mockup-frame::after': {
        background: '#272626',
        borderRadius: '0 0 20px 20px',
        bottom: '2px',
        content: "''",
        height: '26px',
        left: '2px',
        position: 'absolute',
        width: '610px',
      },
      '.spx-mockup-macbook .spx-mockup-frame::before': {
        bottom: '10px',
        color: '#c8cacb',
        content: "'MacBook'",
        fontSize: '12px',
        height: '16px',
        left: '50%',
        lineHeight: '16px',
        marginLeft: '-100px',
        position: 'absolute',
        textAlign: 'center',
        width: '200px',
        zIndex: 1,
      },
      '.spx-mockup-macbook .spx-mockup-content': {
        border: '2px solid #121212',
        borderRadius: '2px',
        height: '360px',
        width: '576px',
      },
      '.spx-mockup-macbook .spx-mockup-power': {
        background: '#e2e3e4',
        border: 'solid #d5d6d8',
        borderRadius: '2px 2px 0 0',
        borderWidth: '0 4px',
        height: '4px',
        marginTop: '-10px',
        position: 'relative',
        width: '740px',
        zIndex: 9,
      },
      '.spx-mockup-macbook .spx-mockup-power::after, .spx-mockup-macbook .spx-mockup-power::before': {
        content: "''",
        position: 'absolute',
      },
      '.spx-mockup-macbook .spx-mockup-power::after': {
        background: 'radial-gradient( circle at center, #e2e3e4 0, #e2e3e4 85%, #a0a3a7 100%)',
        border: 'solid #adb0b3',
        borderWidth: '0 2px',
        height: '4px',
        left: '50%',
        marginLeft: '-60px',
        width: '120px',
      },
      '.spx-mockup-macbook .spx-mockup-power::before': {
        background: '#a0a3a7',
        borderRadius: '0 0 180px 180px/ 0 0 10px 10px',
        boxShadow: 'inset 0 -2px 6px 0 #474a4d',
        height: '10px',
        left: '-4px',
        margin: '0 auto',
        top: '4px',
        width: '740px',
      },
      '.spx-mockup-macbook.spx-mockup-gold .spx-mockup-frame': {
        boxShadow: 'inset 0 0 0 2px #edccb4',
      },
      '.spx-mockup-macbook.spx-mockup-gold .spx-mockup-power': {
        background: '#f7e8dd',
        borderColor: '#edccb4',
      },
      '.spx-mockup-macbook.spx-mockup-gold .spx-mockup-power::after': {
        background: 'radial-gradient( circle at center, #f7e8dd 0, #f7e8dd 85%, #dfa276 100%)',
        borderColor: '#e4b08a',
      },
      '.spx-mockup-macbook.spx-mockup-gold .spx-mockup-power::before': {
        background: '#edccb4',
        boxShadow: 'inset 0 -2px 6px 0 #83491f',
      },
      '.spx-mockup-macbook.spx-mockup-rosegold .spx-mockup-frame': {
        boxShadow: 'inset 0 0 0 2px #f6a69a',
      },
      '.spx-mockup-macbook.spx-mockup-rosegold .spx-mockup-power': {
        background: '#facfc9',
        borderColor: '#f6a69a',
      },
      '.spx-mockup-macbook.spx-mockup-rosegold .spx-mockup-power::after': {
        background: 'radial-gradient( circle at center, #facfc9 0, #facfc9 85%, #ef6754 100%)',
        borderColor: '#f6a69a',
      },
      '.spx-mockup-macbook.spx-mockup-rosegold .spx-mockup-power::before': {
        background: '#f6a69a',
        boxShadow: 'inset 0 -2px 6px 0 #851b0c',
      },
      '.spx-mockup-macbook.spx-mockup-spacegray .spx-mockup-frame': {
        boxShadow: 'inset 0 0 0 2px #767a7d',
      },
      '.spx-mockup-macbook.spx-mockup-spacegray .spx-mockup-power': {
        background: '#909496',
        borderColor: '#767a7d',
      },
      '.spx-mockup-macbook.spx-mockup-spacegray .spx-mockup-power::after': {
        background: 'radial-gradient( circle at center, #909496 0, #909496 85%, #515456 100%)',
        borderColor: '#5d6163',
      },
      '.spx-mockup-macbook.spx-mockup-spacegray .spx-mockup-power::before': {
        background: '#515456',
        boxShadow: 'inset 0 -2px 6px 0 black',
      },
      '.spx-mockup-surface-studio': { height: '506px', width: '640px' },
      '.spx-mockup-surface-studio .spx-mockup-frame': {
        background: '#0d0d0d',
        borderRadius: '10px',
        boxShadow: 'inset 0 0 0 2px black',
        height: '440px',
        padding: '20px',
        width: '640px',
      },
      '.spx-mockup-surface-studio .spx-mockup-content': {
        border: '2px solid #121212',
        borderRadius: '2px',
        height: '400px',
        width: '600px',
      },
      '.spx-mockup-surface-studio .spx-mockup-stripe': {
        background: '#444',
        borderRadius: '0 0 2px 2px',
        bottom: '0',
        height: '4px',
        left: '50%',
        marginLeft: '-117px',
        position: 'absolute',
        width: '234px',
      },
      '.spx-mockup-surface-studio .spx-mockup-stripe::after, .spx-mockup-surface-studio .spx-mockup-stripe::before': {
        content: "''",
        left: '50%',
        position: 'absolute',
        top: '-75px',
      },
      '.spx-mockup-surface-studio .spx-mockup-stripe::after': {
        border: '6px solid #d5d6d8',
        borderRadius: '0 0 18px 18px',
        borderTop: '0',
        boxShadow: 'inset 0 0 0 4px #c8cacb',
        height: '60px',
        marginLeft: '-140px',
        width: '280px',
        zIndex: -1,
      },
      '.spx-mockup-surface-studio .spx-mockup-stripe::before': {
        border: '15px solid #e2e3e4',
        borderRadius: '0 0 4px 4px',
        borderTop: '0',
        height: '70px',
        marginLeft: '-150px',
        width: '300px',
        zIndex: -2,
      },
      '.spx-mockup-surface-studio .spx-mockup-power': {
        background: '#eff0f0',
        border: 'solid #e2e3e4',
        borderRadius: '0 0 2px 2px',
        borderWidth: '0 4px 2px 4px',
        height: '32px',
        margin: '30px auto 0 auto',
        position: 'relative',
        width: '250px',
      },
      '.spx-mockup-surface-studio .spx-mockup-power::after': {
        background: '#adb0b3',
        content: "''",
        height: '2px',
        left: '-4px',
        position: 'absolute',
        top: '4px',
        width: '250px',
      },
      '.spx-mockup-imac-pro': { height: '484px', width: '624px' },
      '.spx-mockup-imac-pro .spx-mockup-frame': {
        background: '#0d0d0d',
        borderRadius: '18px',
        boxShadow: 'inset 0 0 0 2px #080808',
        height: '428px',
        padding: '24px 24px 80px 24px',
        position: 'relative',
        width: '624px',
      },
      '.spx-mockup-imac-pro .spx-mockup-frame::after': {
        background: '#2f2e33',
        borderRadius: '0 0 18px 18px',
        bottom: '2px',
        content: "''",
        height: '54px',
        left: '2px',
        position: 'absolute',
        width: '620px',
      },
      '.spx-mockup-imac-pro .spx-mockup-frame::before': {
        bottom: '15px',
        color: '#0d0d0d',
        content: "''",
        fontSize: '24px',
        height: '24px',
        left: '50%',
        lineHeight: '24px',
        marginLeft: '-100px',
        position: 'absolute',
        textAlign: 'center',
        width: '200px',
        zIndex: 9,
      },
      '.spx-mockup-imac-pro .spx-mockup-content': {
        border: '2px solid #121212',
        borderRadius: '2px',
        height: '324px',
        width: '576px',
      },
      '.spx-mockup-imac-pro .spx-mockup-power::after, .spx-mockup-imac-pro .spx-mockup-power::before': {
        content: "''",
      },
      '.spx-mockup-imac-pro .spx-mockup-power::after': {
        background: '#222225',
        borderRadius: '2px',
        height: '6px',
        margin: '0 auto',
        position: 'relative',
        width: '180px',
      },
      '.spx-mockup-imac-pro .spx-mockup-power::before': {
        border: 'solid transparent',
        borderBottomColor: '#333',
        borderWidth: '0 8px 50px 8px',
        height: '50px',
        margin: '0 auto',
        position: 'relative',
        width: '130px',
      },
      '.spx-mockup-apple-watch': { height: '234px', maxWidth: '300px' },
      '.spx-mockup-apple-watch .spx-mockup-frame': {
        background: '#0d0d0d',
        borderRadius: '40px',
        boxShadow: 'inset 0 0 2px 2px #adb0b3, inset 0 0 0 6px #e2e3e4, inset 0 0 0 8px #e2e3e4',
        height: '234px',
        padding: '32px',
        position: 'relative',
        width: '200px',
      },
      '.spx-mockup-apple-watch .spx-mockup-frame::after': {
        borderRadius: '30px',
        boxShadow: 'inset 0 0 25px 0 rgba(255, 255, 255, 0.75)',
        content: "''",
        height: '216px',
        left: '9px',
        position: 'absolute',
        top: '9px',
        width: '182px',
      },
      '.spx-mockup-apple-watch .spx-mockup-content': {
        border: '2px solid #121212',
        borderRadius: '2px',
        height: '170px',
        width: '136px',
      },
      '.spx-mockup-apple-watch .spx-mockup-btns': {
        background: '#e2e3e4',
        borderLeft: '2px solid #adb0b3',
        borderRadius: '8px 4px 4px 8px / 20px 4px 4px 20px',
        boxShadow: 'inset 0 0 2px 2px #adb0b3',
        height: '44px',
        position: 'absolute',
        right: '-10px',
        top: '52px',
        width: '16px',
        zIndex: 9,
      },
      '.spx-mockup-apple-watch .spx-mockup-btns::after': {
        background: '#e2e3e4',
        borderRadius: '4px 2px 2px 4px / 10px 2px 2px 10px',
        boxShadow: 'inset 0 0 1px 2px #adb0b3',
        content: "''",
        height: '66px',
        position: 'absolute',
        right: '6px',
        top: '68px',
        width: '8px',
      },
      '.spx-mockup-apple-watch .spx-mockup-btns::before': {
        background: '#adb0b3',
        boxShadow: '0 -16px #adb0b3, 0 -12px #adb0b3, 0 -8px #adb0b3, 0 -4px #adb0b3, 0 4px #adb0b3, 0 8px #adb0b3, 0 12px #adb0b3, 0 16px #adb0b3',
        content: "''",
        height: '2px',
        marginTop: '-1px',
        position: 'absolute',
        right: '0',
        top: '50%',
        width: '6px',
      },
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { class: cx$1(styleShadowHost, styleDevice) + ' spx-mockup-wrap' }, h$4("div", { class: 'spx-mockup spx-mockup-' +
        this.type +
        ' ' +
        (color !== null && 'spx-mockup-' + color) +
        '' }, h$4("div", { class: "spx-mockup-frame" }, h$4("div", { class: "spx-mockup-content" }, this.src ? (h$4("img", { class: styleImg, src: this.src, alt: "" })) : (h$4("div", { innerHTML: this.el.innerHTML })))), h$4("div", { class: "spx-mockup-stripe" }), h$4("div", { class: "spx-mockup-header" }), h$4("div", { class: "spx-mockup-sensors" }), h$4("div", { class: "spx-mockup-btns" }), h$4("div", { class: "spx-mockup-power" }), this.type === 'iphone-x' && h$4("div", { class: "spx-mockup-home" })))));
  }
  get el() { return this; }
};

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow$1(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow$1(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow$1(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


const applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$2(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle$2(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$2(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow$1(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$2(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


const arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(round(x * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets;

  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
      _ref3$x = _ref3.x,
      x = _ref3$x === void 0 ? 0 : _ref3$x,
      _ref3$y = _ref3.y,
      y = _ref3$y === void 0 ? 0 : _ref3$y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow$1(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle$2(offsetParent).position !== 'static') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top) {
      sideY = bottom; // $FlowFixMe[prop-missing]

      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left) {
      sideX = right; // $FlowFixMe[prop-missing]

      x -= offsetParent[widthProp] - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref4) {
  var state = _ref4.state,
      options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


const computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow$1(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


const eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow$1(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element) {
  var win = getWindow$1(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle$2(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle$2(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow$1(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getVariation(placement) {
  return placement.split('-')[1];
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


const flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


const hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset$2(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


const offset$3 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset$2
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


const popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
    var max$1 = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

    if (checkMainAxis) {
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


const preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow$1(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$3, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

const tag$9 = 'spx-navigation';
const SpxNavigation$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxNavigationDidLoad = createEvent(this, "spxNavigationDidLoad", 7);
    this.childBorder = '1px solid var(--spx-color-gray-200)';
    /**
     * Child menu border-radius.
     *
     * @CSS
     */
    this.childBorderRadius = '0';
    /**
     * Child menu box-shadow.
     *
     * @CSS
     */
    this.childBoxShadow = '0 3px 10px 0 rgba(0,0,0,0.05)';
    /**
     * Gap between nested child menus.
     *
     * @CSS
     */
    this.childChildGap = '0.8em';
    /**
     * Gap between top level menu items and child menus.
     *
     * @CSS
     */
    this.childGap = '0.5em';
    /** Indicator icon. */
    this.childIcon = 'arrow-down';
    /** Indicator icon type. */
    this.childIconType = 'ionicons';
    /**
     * Gap between child menu indicator and text.
     *
     * @CSS
     */
    this.childIndicatorGap = '0.2em';
    this.childItemBackground = '#ffffff';
    this.childItemBackgroundHover = 'var(--spx-color-gray-100)';
    this.childItemColor = 'var(--spx-color-gray-700)';
    this.childItemColorHover = 'var(--spx-color-gray-900)';
    this.childItemPadding = '0.6em 0.8em';
    /**
     * Child menu placement.
     *
     * @CSS
     * @choice 'start', 'end'
     */
    this.childPlacement = 'start';
    this.display = display$1;
    this.fontSize = 'clamp(18px, 1.6vw, 20px)';
    this.itemTransitionDuration = transitionDuration;
    this.itemTransitionTimingFunction = transitionTimingFunction;
    /** Mobile breakpoint. */
    this.mobile = bpMobileWidth;
    /** Mobile button icon type. */
    this.mobileIconType = 'ionicons';
    this.mobileItemBackground = '#ffffff';
    this.mobileItemBackgroundHover = 'var(--spx-color-gray-100)';
    this.mobileItemColor = 'var(--spx-color-gray-800)';
    this.mobileItemColorHover = 'var(--spx-color-gray-900)';
    this.mobileItemNestedMarginLeft = '0.8em';
    this.mobileItemPadding = '0.6em';
    /**
     * Mobile placement.
     *
     * @CSS
     * @choice 'start', 'end'
     */
    this.mobilePlacement = 'start';
    this.parentItemBackground = '#ffffff';
    this.parentItemBackgroundHover = 'var(--spx-color-gray-100)';
    this.parentItemColor = 'var(--spx-color-gray-800)';
    this.parentItemColorHover = 'var(--spx-color-gray-900)';
    /**
     * Gap between parent menu items.
     *
     * @CSS
     */
    this.parentItemGap = '0.4em';
    this.parentItemPadding = '0.6em';
    this.renderMenu = (obj, type, mobile) => {
      const checkMobile = () => {
        if (mobile) {
          return 'spx-navigation--' + type + '' + ' ' + 'spx-navigation--mobile';
        }
        else {
          return 'spx-navigation--' + type + '';
        }
      };
      return (h$4("div", { class: checkMobile() }, h$4("ul", null, Object.values(obj).map((object) => {
        const objectChild = object['spxChildren'];
        const extraClasses = object['classes']
          .map((objectClasses) => objectClasses)
          .toString()
          .replace(/,/g, '  ');
        return (h$4("li", { class: object['spxChildren']
            ? /** Check if menu has any children. */
              'spx-navigation__item--' +
                type +
                '' +
                ' ' +
                'spx-navigation__item--has-child' +
                extraClasses
            : 'spx-navigation__item--' + type + '' + ' ' + extraClasses, "data-order": object['menu_order'] }, h$4(Button, { href: object['url'] === '#' ? '#0' : object['url'] }, object['title'], objectChild &&
          !this.mobileBp &&
          !this.vertical &&
          this.childIcon && (h$4("spx-icon", { type: this.childIconType, icon: this.childIcon }))), objectChild &&
          !mobile &&
          this.renderMenu(object['spxChildren'], 'child', false), objectChild &&
          mobile &&
          this.renderMenu(object['spxChildren'], 'child', true)));
      }))));
    };
    /** Sort menu items depending on menu order. */
    this.sortMenuItem = () => {
      const dataItems = this.el.shadowRoot.querySelectorAll('li');
      const dataArray = [];
      for (let i = 0; i < dataItems.length; ++i) {
        dataArray.push(dataItems[i]);
      }
      dataArray.sort(function (a, b) {
        return +a.getAttribute('data-order') - +b.getAttribute('data-order');
      });
      dataArray.forEach((e) => {
        e.closest('ul').appendChild(e);
      });
    };
    /** Init Popper positioning for desktop. */
    this.initPopperDesktop = () => {
      if (!this.vertical) {
        /** Init popper for parent menu. */
        const parentMenu = this.el.shadowRoot.querySelectorAll('nav > .spx-navigation--parent .spx-navigation__item--parent.spx-navigation__item--has-child');
        if (parentMenu) {
          parentMenu.forEach((item) => {
            createPopper(item, item.querySelector('div'), {
              // @ts-ignore
              placement: 'bottom-' + this.childPlacement + '',
            });
          });
        }
        /** Init popper for child menu. */
        const childMenus = this.el.shadowRoot.querySelectorAll('nav > .spx-navigation--parent .spx-navigation--child .spx-navigation__item--child.spx-navigation__item--has-child');
        if (childMenus) {
          childMenus.forEach((item) => {
            createPopper(item, item.querySelector('div'), {
              placement: 'right-start',
              strategy: 'fixed',
              modifiers: [
                {
                  name: 'flip',
                  options: {
                    fallbackPlacements: ['left-start'],
                  },
                },
                /** Calculate offset depending on parent padding/margin. */
                {
                  name: 'offset',
                  options: {
                    offset: ({ placement }) => {
                      if (placement === 'right-start') {
                        return [
                          -Math.abs(item.getBoundingClientRect().top -
                            item.parentElement.getBoundingClientRect().top),
                          Math.abs(item.getBoundingClientRect().right -
                            item.parentElement.getBoundingClientRect().right),
                        ];
                      }
                      else {
                        return [
                          -Math.abs(item.getBoundingClientRect().top -
                            item.parentElement.getBoundingClientRect().top),
                          Math.abs(item.getBoundingClientRect().left -
                            item.parentElement.getBoundingClientRect().left),
                        ];
                      }
                    },
                  },
                },
                /** Make fixed position work properly. */
                {
                  name: 'preventOverflow',
                  options: {
                    rootBoundary: item,
                    padding: -1,
                  },
                },
              ],
            });
          });
        }
      }
    };
    /** Init Popper positioning for mobile. */
    this.initPopperMobile = () => {
      const mobileMenu = this.el.shadowRoot.querySelector('.spx-navigation__mobile-button');
      if (mobileMenu) {
        createPopper(mobileMenu, mobileMenu.querySelector('.spx-navigation--mobile'), {
          // @ts-ignore
          placement: 'bottom-' + this.mobilePlacement + '',
        });
      }
    };
    this.renderNav = () => {
      return (
      /** Render desktop menu. */
      this.menu && [
        this.renderMenu(this.menuArray, 'parent', false),
        /** Render mobile menu. */
        h$4("div", { tabindex: "0", role: "button", class: "spx-navigation__mobile-button" }, this.mobileIcon && (h$4("spx-icon", { type: this.mobileIconType, icon: this.mobileIcon })), h$4("span", null, "Menu"), this.renderMenu(this.menuArray, 'parent', true)),
      ]);
    };
  }
  /**
   * Watch menu prop and parse to iteratable array.
   *
   * @param {string} newValue New value.
   */
  navigationChanged(newValue) {
    if (newValue)
      this.menuArray = JSON.parse(newValue);
  }
  /** Init popper on mouse/touch enter. */
  onClick() {
    if (this.mobileBp) {
      this.initPopperMobile();
    }
    else {
      this.initPopperDesktop();
      this.initPopperDesktop();
    }
  }
  /** Listen to window resize. */
  onResize() {
    this.mobileBp = window.innerWidth < this.mobile;
  }
  componentWillLoad() {
    /** Check if is mobile view. */
    this.onResize();
    /** If menu prop is set. */
    this.navigationChanged(this.menu);
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    /** Sort menu items. */
    this.sortMenuItem();
    /** Emit event after render. */
    this.spxNavigationDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  componentDidUpdate() {
    this.sortMenuItem();
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$9, 'display', this.display),
      fontFamily: fontFamily,
      zIndex: 999999,
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      fontSize: setVar(tag$9, 'font-size', this.fontSize),
      'nav > .spx-navigation--parent': {
        display: this.mobileBp ? 'none' : 'grid',
      },
      ul: {
        margin: '0',
        padding: '0',
        listStyleType: 'none',
        ul: {
          display: this.vertical && 'grid',
          borderLeft: this.mobileBp && '1px solid rgba(0,0,0,0.1)',
          borderRadius: this.mobileBp && '0 !important',
          gridGap: this.vertical && setVar(tag$9, 'parent-item-gap', this.parentItemGap),
          marginLeft: (this.mobileBp || this.vertical) &&
            setVar(tag$9, 'mobile-item-nested-margin-left', this.mobileItemNestedMarginLeft),
        },
      },
      'ul ul, .spx-navigation--mobile ul': {
        border: !this.mobileBp && setVar(tag$9, 'child-border', this.childBorder),
        borderRadius: setVar(tag$9, 'child-border-radius', this.childBorderRadius),
        overflow: 'hidden',
        boxShadow: !this.mobileBp &&
          setVar(tag$9, 'child-box-shadow', this.childBoxShadow),
      },
      '.spx-navigation--parent:not(.spx-navigation--mobile) > ul': {
        display: 'grid',
        gridAutoFlow: this.mobileBp || this.vertical ? 'row' : 'column',
        gridAutoColumns: 'max-content',
        gridAutoRows: (this.mobileBp || this.vertical) && 'max-content',
        gridGap: setVar(tag$9, 'parent-item-gap', this.parentItemGap),
      },
      '.spx-navigation__item--parent': {
        a: {
          padding: setVar(tag$9, 'parent-item-padding', this.parentItemPadding),
          color: setVar(tag$9, 'parent-item-color', this.parentItemColor),
          background: setVar(tag$9, 'parent-item-background', this.parentItemBackground),
          '&:hover': {
            color: setVar(tag$9, 'parent-item-color-hover', this.parentItemColorHover),
            background: setVar(tag$9, 'parent-item-color-background-hover', this.parentItemBackgroundHover),
          },
        },
        '&.spx-navigation__item--has-child > .spx-navigation--child': {
          flexDirection: 'column',
          marginTop: this.vertical && setVar(tag$9, 'parent-item-gap', this.parentItemGap),
          a: {
            display: 'flex',
            justifyContent: 'space-between',
            width: '100%',
            whiteSpace: 'nowrap',
            color: !this.mobileBp &&
              setVar(tag$9, 'child-item-color', this.childItemColor),
            background: !this.mobileBp &&
              setVar(tag$9, 'child-item-background', this.childItemBackground),
            '&:hover': {
              color: !this.mobileBp &&
                setVar(tag$9, 'child-item-color-hover', this.childItemColorHover),
              background: !this.mobileBp &&
                setVar(tag$9, 'child-item-color-background-hover', this.childItemBackgroundHover),
            },
          },
          '::before': {
            content: '" "',
            position: 'relative',
            display: this.mobileBp || this.vertical ? 'none' : 'block',
            minHeight: setVar(tag$9, 'child-gap', this.childGap),
            width: '100%',
          },
        },
      },
      '.spx-navigation--child, .spx-navigation--mobile': {
        pointerEvents: !this.vertical ? 'none' : 'auto',
        opacity: !this.vertical ? '0' : '1',
        position: !this.vertical ? 'absolute' : 'relative',
        display: 'flex',
        flexDirection: this.mobileBp ? 'column' : 'row',
        transitionProperty: 'opacity',
        transitionDuration: setVar(tag$9, 'item-transition-duration', this.itemTransitionDuration),
        transitionTimingFunction: setVar(tag$9, 'item-transition-timing-function', this.itemTransitionTimingFunction),
      },
      '.spx-navigation--mobile .spx-navigation--child': {
        position: 'relative',
      },
      ['li:hover > .spx-navigation--child, ' +
        'li:focus-within > .spx-navigation--child, ' +
        '.spx-navigation__mobile-button:hover .spx-navigation--mobile, ' +
        '.spx-navigation__mobile-button:focus-within .spx-navigation--mobile, ' +
        '.spx-navigation__mobile-button:hover .spx-navigation--child, ' +
        '.spx-navigation__mobile-button:focus-within .spx-navigation--child']: {
        opacity: '1',
        pointerEvents: 'auto',
        transform: 'translateY(0px)',
      },
      '.spx-navigation__item--child': {
        a: {
          padding: setVar(tag$9, 'child-item-padding', this.childItemPadding),
        },
        '[data-popper-placement="left-start"]': {
          flexDirection: 'row-reverse',
        },
        '[data-popper-placement]::before': {
          content: '" "',
          position: 'relative',
          display: this.mobileBp || this.vertical ? 'none' : 'block',
          minWidth: setVar(tag$9, 'child-child-gap', this.childChildGap),
          height: '100%',
        },
      },
      li: {
        position: 'relative',
        display: !this.mobileBp && !this.vertical && 'flex',
        flexDirection: 'row',
      },
      a: Object.assign({ display: 'inline-grid', gridAutoFlow: 'column', alignItems: 'center', gridColumnGap: setVar(tag$9, 'child-indicator-gap', this.childIndicatorGap), textDecoration: this.itemUnderline ? 'underline' : 'none', width: '100%', fontSize: 'inherit', transitionProperty: 'color, background, box-shadow', transitionDuration: setVar(tag$9, 'item-transition-duration', this.itemTransitionDuration), transitionTimingFunction: setVar(tag$9, 'item-transition-timing-function', this.itemTransitionTimingFunction), '&:hover': {
          textDecoration: this.itemUnderlineHover && 'underline',
        } }, focus),
      '.spx-navigation__mobile-button': {
        cursor: 'pointer',
        maxWidth: 'fit-content',
        padding: setVar(tag$9, 'parent-item-padding', this.parentItemPadding),
        color: setVar(tag$9, 'parent-item-color', this.parentItemColor),
        background: setVar(tag$9, 'parent-item-background', this.parentItemBackground),
        gridGap: '0.4em',
        gridAutoFlow: 'column',
        alignItems: 'center',
        display: this.mobileBp ? 'grid' : 'none',
        a: {
          padding: setVar(tag$9, 'mobile-item-padding', this.mobileItemPadding),
          color: setVar(tag$9, 'mobile-item-color', this.mobileItemColor),
          background: setVar(tag$9, 'mobile-item-background', this.mobileItemBackground),
          '&:hover': {
            color: setVar(tag$9, 'mobile-item-color-hover', this.mobileItemColorHover),
            background: setVar(tag$9, 'mobile-item-background-hover', this.mobileItemBackgroundHover),
          },
        },
        '.spx-navigation--parent': {
          '::before': {
            content: '" "',
            position: 'relative',
            display: 'block',
            minHeight: setVar(tag$9, 'child-gap', this.childGap),
            width: '100%',
          },
          '> ul': {
            background: setVar(tag$9, 'child-item-background', this.childItemBackground),
            border: setVar(tag$9, 'child-border', this.childBorder),
            boxShadow: setVar(tag$9, 'child-box-shadow', this.childBoxShadow),
          },
        },
      },
    });
    return (h$4(Host, { class: styleHost }, h$4("nav", { class: styleShadowHost }, this.renderNav())));
  }
  get el() { return this; }
  static get watchers() { return {
    "menu": ["navigationChanged"]
  }; }
};

const t="http://www.w3.org/2000/svg";class e{constructor(t){this.seed=t;}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}function s(t,e,s,i,n){return {type:"path",ops:c(t,e,s,i,n)}}function i(t,e,i){const n=(t||[]).length;if(n>2){const s=[];for(let e=0;e<n-1;e++)s.push(...c(t[e][0],t[e][1],t[e+1][0],t[e+1][1],i));return e&&s.push(...c(t[n-1][0],t[n-1][1],t[0][0],t[0][1],i)),{type:"path",ops:s}}return 2===n?s(t[0][0],t[0][1],t[1][0],t[1][1],i):{type:"path",ops:[]}}function n(t,e,s,n,o){return function(t,e){return i(t,!0,e)}([[t,e],[t+s,e],[t+s,e+n],[t,e+n]],o)}function o(t,e,s,i,n){return function(t,e,s,i){const[n,o]=l(i.increment,t,e,i.rx,i.ry,1,i.increment*h(.1,h(.4,1,s),s),s);let r=f(n,null,s);if(!s.disableMultiStroke){const[n]=l(i.increment,t,e,i.rx,i.ry,1.5,0,s),o=f(n,null,s);r=r.concat(o);}return {estimatedPoints:o,opset:{type:"path",ops:r}}}(t,e,n,function(t,e,s){const i=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),n=Math.max(s.curveStepCount,s.curveStepCount/Math.sqrt(200)*i),o=2*Math.PI/n;let r=Math.abs(t/2),h=Math.abs(e/2);const c=1-s.curveFitting;return r+=a(r*c,s),h+=a(h*c,s),{increment:o,rx:r,ry:h}}(s,i,n)).opset}function r(t){return t.randomizer||(t.randomizer=new e(t.seed||0)),t.randomizer.next()}function h(t,e,s,i=1){return s.roughness*i*(r(s)*(e-t)+t)}function a(t,e,s=1){return h(-t,t,e,s)}function c(t,e,s,i,n,o=!1){const r=o?n.disableMultiStrokeFill:n.disableMultiStroke,h=u(t,e,s,i,n,!0,!1);if(r)return h;const a=u(t,e,s,i,n,!0,!0);return h.concat(a)}function u(t,e,s,i,n,o,h){const c=Math.pow(t-s,2)+Math.pow(e-i,2),u=Math.sqrt(c);let f=1;f=u<200?1:u>500?.4:-.0016668*u+1.233334;let l=n.maxRandomnessOffset||0;l*l*100>c&&(l=u/10);const g=l/2,d=.2+.2*r(n);let p=n.bowing*n.maxRandomnessOffset*(i-e)/200,_=n.bowing*n.maxRandomnessOffset*(t-s)/200;p=a(p,n,f),_=a(_,n,f);const m=[],w=()=>a(g,n,f),v=()=>a(l,n,f);return o&&(h?m.push({op:"move",data:[t+w(),e+w()]}):m.push({op:"move",data:[t+a(l,n,f),e+a(l,n,f)]})),h?m.push({op:"bcurveTo",data:[p+t+(s-t)*d+w(),_+e+(i-e)*d+w(),p+t+2*(s-t)*d+w(),_+e+2*(i-e)*d+w(),s+w(),i+w()]}):m.push({op:"bcurveTo",data:[p+t+(s-t)*d+v(),_+e+(i-e)*d+v(),p+t+2*(s-t)*d+v(),_+e+2*(i-e)*d+v(),s+v(),i+v()]}),m}function f(t,e,s){const i=t.length,n=[];if(i>3){const o=[],r=1-s.curveTightness;n.push({op:"move",data:[t[1][0],t[1][1]]});for(let e=1;e+2<i;e++){const s=t[e];o[0]=[s[0],s[1]],o[1]=[s[0]+(r*t[e+1][0]-r*t[e-1][0])/6,s[1]+(r*t[e+1][1]-r*t[e-1][1])/6],o[2]=[t[e+1][0]+(r*t[e][0]-r*t[e+2][0])/6,t[e+1][1]+(r*t[e][1]-r*t[e+2][1])/6],o[3]=[t[e+1][0],t[e+1][1]],n.push({op:"bcurveTo",data:[o[1][0],o[1][1],o[2][0],o[2][1],o[3][0],o[3][1]]});}if(e&&2===e.length){const t=s.maxRandomnessOffset;n.push({op:"lineTo",data:[e[0]+a(t,s),e[1]+a(t,s)]});}}else 3===i?(n.push({op:"move",data:[t[1][0],t[1][1]]}),n.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===i&&n.push(...c(t[0][0],t[0][1],t[1][0],t[1][1],s));return n}function l(t,e,s,i,n,o,r,h){const c=[],u=[],f=a(.5,h)-Math.PI/2;u.push([a(o,h)+e+.9*i*Math.cos(f-t),a(o,h)+s+.9*n*Math.sin(f-t)]);for(let r=f;r<2*Math.PI+f-.01;r+=t){const t=[a(o,h)+e+i*Math.cos(r),a(o,h)+s+n*Math.sin(r)];c.push(t),u.push(t);}return u.push([a(o,h)+e+i*Math.cos(f+2*Math.PI+.5*r),a(o,h)+s+n*Math.sin(f+2*Math.PI+.5*r)]),u.push([a(o,h)+e+.98*i*Math.cos(f+r),a(o,h)+s+.98*n*Math.sin(f+r)]),u.push([a(o,h)+e+.9*i*Math.cos(f+.5*r),a(o,h)+s+.9*n*Math.sin(f+.5*r)]),[u,c]}function g(t,e){return {maxRandomnessOffset:2,roughness:"highlight"===t?3:1.5,bowing:1,stroke:"#000",strokeWidth:1.5,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,combineNestedSvgPaths:!1,disableMultiStroke:"double"!==t,disableMultiStrokeFill:!1,seed:e}}function d(e,r,h,a,c,u){const f=[];let l=h.strokeWidth||2;const d=function(t){const e=t.padding;if(e||0===e){if("number"==typeof e)return [e,e,e,e];if(Array.isArray(e)){const t=e;if(t.length)switch(t.length){case 4:return [...t];case 1:return [t[0],t[0],t[0],t[0]];case 2:return [...t,...t];case 3:return [...t,t[1]];default:return [t[0],t[1],t[2],t[3]]}}}return [5,5,5,5]}(h),p=void 0===h.animate||!!h.animate,_=h.iterations||2,m=h.rtl?1:0,w=g("single",u);switch(h.type){case"underline":{const t=r.y+r.h+d[2];for(let e=m;e<_+m;e++)e%2?f.push(s(r.x+r.w,t,r.x,t,w)):f.push(s(r.x,t,r.x+r.w,t,w));break}case"strike-through":{const t=r.y+r.h/2;for(let e=m;e<_+m;e++)e%2?f.push(s(r.x+r.w,t,r.x,t,w)):f.push(s(r.x,t,r.x+r.w,t,w));break}case"box":{const t=r.x-d[3],e=r.y-d[0],s=r.w+(d[1]+d[3]),i=r.h+(d[0]+d[2]);for(let o=0;o<_;o++)f.push(n(t,e,s,i,w));break}case"bracket":{const t=Array.isArray(h.brackets)?h.brackets:h.brackets?[h.brackets]:["right"],e=r.x-2*d[3],s=r.x+r.w+2*d[1],n=r.y-2*d[0],o=r.y+r.h+2*d[2];for(const h of t){let t;switch(h){case"bottom":t=[[e,r.y+r.h],[e,o],[s,o],[s,r.y+r.h]];break;case"top":t=[[e,r.y],[e,n],[s,n],[s,r.y]];break;case"left":t=[[r.x,n],[e,n],[e,o],[r.x,o]];break;case"right":t=[[r.x+r.w,n],[s,n],[s,o],[r.x+r.w,o]];}t&&f.push(i(t,!1,w));}break}case"crossed-off":{const t=r.x,e=r.y,i=t+r.w,n=e+r.h;for(let o=m;o<_+m;o++)o%2?f.push(s(i,n,t,e,w)):f.push(s(t,e,i,n,w));for(let o=m;o<_+m;o++)o%2?f.push(s(t,n,i,e,w)):f.push(s(i,e,t,n,w));break}case"circle":{const t=g("double",u),e=r.w+(d[1]+d[3]),s=r.h+(d[0]+d[2]),i=r.x-d[3]+e/2,n=r.y-d[0]+s/2,h=Math.floor(_/2),a=_-2*h;for(let r=0;r<h;r++)f.push(o(i,n,e,s,t));for(let t=0;t<a;t++)f.push(o(i,n,e,s,w));break}case"highlight":{const t=g("highlight",u);l=.95*r.h;const e=r.y+r.h/2;for(let i=m;i<_+m;i++)i%2?f.push(s(r.x+r.w,e,r.x,e,t)):f.push(s(r.x,e,r.x+r.w,e,t));break}}if(f.length){const s=function(t){const e=[];for(const s of t){let t="";for(const i of s.ops){const s=i.data;switch(i.op){case"move":t.trim()&&e.push(t.trim()),t=`M${s[0]} ${s[1]} `;break;case"bcurveTo":t+=`C${s[0]} ${s[1]}, ${s[2]} ${s[3]}, ${s[4]} ${s[5]} `;break;case"lineTo":t+=`L${s[0]} ${s[1]} `;}}t.trim()&&e.push(t.trim());}return e}(f),i=[],n=[];let o=0;const r=(t,e,s)=>t.setAttribute(e,s);for(const a of s){const s=document.createElementNS(t,"path");if(r(s,"d",a),r(s,"fill","none"),r(s,"stroke",h.color||"currentColor"),r(s,"stroke-width",""+l),p){const t=s.getTotalLength();i.push(t),o+=t;}e.appendChild(s),n.push(s);}if(p){let t=0;for(let e=0;e<n.length;e++){const s=n[e],r=i[e],h=o?c*(r/o):0,u=a+t,f=s.style;f.strokeDashoffset=""+r,f.strokeDasharray=""+r,f.animation=`rough-notation-dash ${h}ms ease-out ${u}ms forwards`,t+=h;}}}}class p{constructor(t,e){this._state="unattached",this._resizing=!1,this._seed=Math.floor(Math.random()*2**31),this._lastSizes=[],this._animationDelay=0,this._resizeListener=()=>{this._resizing||(this._resizing=!0,setTimeout(()=>{this._resizing=!1,"showing"===this._state&&this.haveRectsChanged()&&this.show();},400));},this._e=t,this._config=JSON.parse(JSON.stringify(e)),this.attach();}get animate(){return this._config.animate}set animate(t){this._config.animate=t;}get animationDuration(){return this._config.animationDuration}set animationDuration(t){this._config.animationDuration=t;}get iterations(){return this._config.iterations}set iterations(t){this._config.iterations=t;}get color(){return this._config.color}set color(t){this._config.color!==t&&(this._config.color=t,this.refresh());}get strokeWidth(){return this._config.strokeWidth}set strokeWidth(t){this._config.strokeWidth!==t&&(this._config.strokeWidth=t,this.refresh());}get padding(){return this._config.padding}set padding(t){this._config.padding!==t&&(this._config.padding=t,this.refresh());}attach(){if("unattached"===this._state&&this._e.parentElement){!function(){if(!window.__rno_kf_s){const t=window.__rno_kf_s=document.createElement("style");t.textContent="@keyframes rough-notation-dash { to { stroke-dashoffset: 0; } }",document.head.appendChild(t);}}();const e=this._svg=document.createElementNS(t,"svg");e.setAttribute("class","rough-annotation");const s=e.style;s.position="absolute",s.top="0",s.left="0",s.overflow="visible",s.pointerEvents="none",s.width="100px",s.height="100px";const i="highlight"===this._config.type;if(this._e.insertAdjacentElement(i?"beforebegin":"afterend",e),this._state="not-showing",i){const t=window.getComputedStyle(this._e).position;(!t||"static"===t)&&(this._e.style.position="relative");}this.attachListeners();}}detachListeners(){window.removeEventListener("resize",this._resizeListener),this._ro&&this._ro.unobserve(this._e);}attachListeners(){this.detachListeners(),window.addEventListener("resize",this._resizeListener,{passive:!0}),!this._ro&&"ResizeObserver"in window&&(this._ro=new window.ResizeObserver(t=>{for(const e of t)e.contentRect&&this._resizeListener();})),this._ro&&this._ro.observe(this._e);}haveRectsChanged(){if(this._lastSizes.length){const t=this.rects();if(t.length!==this._lastSizes.length)return !0;for(let e=0;e<t.length;e++)if(!this.isSameRect(t[e],this._lastSizes[e]))return !0}return !1}isSameRect(t,e){const s=(t,e)=>Math.round(t)===Math.round(e);return s(t.x,e.x)&&s(t.y,e.y)&&s(t.w,e.w)&&s(t.h,e.h)}isShowing(){return "not-showing"!==this._state}refresh(){this.isShowing()&&!this.pendingRefresh&&(this.pendingRefresh=Promise.resolve().then(()=>{this.isShowing()&&this.show(),delete this.pendingRefresh;}));}show(){switch(this._state){case"unattached":break;case"showing":this.hide(),this._svg&&this.render(this._svg,!0);break;case"not-showing":this.attach(),this._svg&&this.render(this._svg,!1);}}hide(){if(this._svg)for(;this._svg.lastChild;)this._svg.removeChild(this._svg.lastChild);this._state="not-showing";}remove(){this._svg&&this._svg.parentElement&&this._svg.parentElement.removeChild(this._svg),this._svg=void 0,this._state="unattached",this.detachListeners();}render(t,e){let s=this._config;e&&(s=JSON.parse(JSON.stringify(this._config)),s.animate=!1);const i=this.rects();let n=0;i.forEach(t=>n+=t.w);const o=s.animationDuration||800;let r=0;for(let e=0;e<i.length;e++){const h=o*(i[e].w/n);d(t,i[e],s,r+this._animationDelay,h,this._seed),r+=h;}this._lastSizes=i,this._state="showing";}rects(){const t=[];if(this._svg)if(this._config.multiline){const e=this._e.getClientRects();for(let s=0;s<e.length;s++)t.push(this.svgRect(this._svg,e[s]));}else t.push(this.svgRect(this._svg,this._e.getBoundingClientRect()));return t}svgRect(t,e){const s=t.getBoundingClientRect(),i=e;return {x:(i.x||i.left)-(s.x||s.left),y:(i.y||i.top)-(s.y||s.top),w:i.width,h:i.height}}}function _(t,e){return new p(t,e)}function m(t){let e=0;for(const s of t){const t=s;t._animationDelay=e;e+=0===t.animationDuration?0:t.animationDuration||800;}const s=[...t];return {show(){for(const t of s)t.show();},hide(){for(const t of s)t.hide();}}}

const tag$8 = 'spx-notation';
const SpxNotation$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.spxNotationDidLoad = createEvent(this, "spxNotationDidLoad", 7);
    /** Turn animation on or off when animation. */
    this.animation = true;
    /** Animation duration. */
    this.animationDuration = 800;
    /** Autoplay. */
    this.autoplay = true;
    /** Brackets. */
    this.brackets = 'left, right';
    this.color = 'var(--spx-color-gray-100)';
    this.display = 'inline-block';
    /** Number of iterations. */
    this.iterations = 1;
    /** Annotate multiline text. */
    this.multiline = true;
    /** Stroke width. */
    this.strokeWidth = 1;
    /**
     * Type of notation.
     *
     * @choice 'underline', 'box', 'circle', 'highlight', 'strike-through', 'crossed-off', 'bracket'
     */
    this.type = 'underline';
    /** Annotate. */
    this.annotate = () => {
      const groupArray = [];
      /** Get options. */
      const options = {
        animate: this.animation,
        animationDuration: this.animationDuration,
        type: this.type === 'underline'
          ? 'underline'
          : this.type === 'box'
            ? 'box'
            : this.type === 'circle'
              ? 'circle'
              : this.type === 'highlight'
                ? 'highlight'
                : this.type === 'strike-through'
                  ? 'strike-through'
                  : this.type === 'crossed-off'
                    ? 'crossed-off'
                    : 'bracket',
        color: this.color,
        strokeWidth: this.strokeWidth,
        multiline: this.multiline,
        iterations: this.iterations,
        padding: this.padding,
        brackets: this.brackets,
      };
      /** Check if group is active. */
      if (!this.group) {
        this.annotation = _(this.el.querySelector(':scope > span > span'), 
        // @ts-ignore
        options);
      }
      else {
        this.el.querySelectorAll('[data-spx-notation]').forEach((item) => {
          const obj = {};
          const string = item.getAttribute('data-spx-notation');
          const arr = string.replaceAll(':', '').replaceAll(', ', ' ').split(' ');
          for (let i = 0; i < arr.length; i += 2) {
            obj[arr[i]] = isNaN(Number(arr[i + 1]))
              ? arr[i + 1]
              : Number(arr[i + 1]);
          }
          // @ts-ignore
          groupArray.push(_(item, Object.assign(Object.assign({}, options), obj)));
        });
      }
      /** Fire off animation. */
      if (this.delay) {
        setTimeout(() => {
          if (!this.group) {
            this.annotation.show();
          }
          else {
            m(groupArray).show();
          }
        }, this.delay);
      }
      else {
        if (!this.group) {
          this.annotation.show();
        }
        else {
          m(groupArray).show();
        }
      }
    };
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    if (((this.el.querySelector(':scope > span > span') &&
      this.el.querySelector(':scope > span > span').innerHTML.length > 0) ||
      this.group) &&
      this.autoplay) {
      this.annotate();
    }
    this.spxNotationDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  /** Remove the annotation. */
  async clear() {
    this.annotation.remove();
  }
  /** Hides the annotation. (non animated) */
  async hide() {
    this.annotation.hide();
  }
  /** Redraw the animation. */
  async redraw() {
    if (this.annotation) {
      this.annotation.remove();
    }
    if (!this.group) {
      this.annotate();
    }
  }
  /** Draws the annotation. */
  async show() {
    this.annotate();
  }
  render() {
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$8, 'display', this.display),
      position: 'relative',
    });
    /** Span styles. */
    const styleSpan = css$2({ position: 'relative', display: 'inline-block' });
    return (h$4(Host, { class: styleHost }, this.group ? (h$4("slot", null)) : (h$4("span", { class: styleSpan }, h$4("span", { class: styleSpan }, h$4("slot", null))))));
  }
  get el() { return this; }
};

/**
 * Offset something to header.
 *
 * @param {HTMLElement} el Current HTML element.
 * @param {HTMLElement} target Target HTML element to do calculations from.
 */
function offsetHeader(el, target) {
  /** Get height of target element. */
  const value = document.querySelector(target).getBoundingClientRect().height + 'px';
  /** Set root. */
  document.body.style.setProperty('--spx-offset', value);
  /** Apply values as top property and variable. */
  if (el.parentElement.classList.contains('oxy-offset')) {
    el.parentElement.style.marginTop = value;
  }
  else {
    el.style.marginTop = value;
  }
}

const tag$7 = 'spx-offset';
const SpxOffset$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxOffsetDidLoad = createEvent(this, "spxOffsetDidLoad", 7);
    this.display = display$1;
    /** Target element. */
    this.target = 'header';
  }
  /** Listen to window resize. */
  onResize() {
    offsetHeader(this.el, this.target);
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.onResize();
    this.spxOffsetDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  componentDidUpdate() {
    this.onResize();
  }
  /** Recalculate distance. */
  async recalc() {
    this.onResize();
  }
  render() {
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$7, 'display', this.display),
    });
    return (h$4(Host, { class: styleHost }, h$4("slot", null)));
  }
  get el() { return this; }
};

var gumshoe = createCommonjsModule(function (module, exports) {
/*!
 * gumshoejs v5.1.2
 * A simple, framework-agnostic scrollspy script.
 * (c) 2019 Chris Ferdinandi
 * MIT License
 * http://github.com/cferdinandi/gumshoe
 */

(function (root, factory) {
	{
		module.exports = factory(root);
	}
})(typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : commonjsGlobal, (function (window) {

	//
	// Defaults
	//

	var defaults = {

		// Active classes
		navClass: 'active',
		contentClass: 'active',

		// Nested navigation
		nested: false,
		nestedClass: 'active',

		// Offset & reflow
		offset: 0,
		reflow: false,

		// Event support
		events: true

	};


	//
	// Methods
	//

	/**
	 * Merge two or more objects together.
	 * @param   {Object}   objects  The objects to merge together
	 * @returns {Object}            Merged values of defaults and options
	 */
	var extend = function () {
		var merged = {};
		Array.prototype.forEach.call(arguments, (function (obj) {
			for (var key in obj) {
				if (!obj.hasOwnProperty(key)) return;
				merged[key] = obj[key];
			}
		}));
		return merged;
	};

	/**
	 * Emit a custom event
	 * @param  {String} type   The event type
	 * @param  {Node}   elem   The element to attach the event to
	 * @param  {Object} detail Any details to pass along with the event
	 */
	var emitEvent = function (type, elem, detail) {

		// Make sure events are enabled
		if (!detail.settings.events) return;

		// Create a new event
		var event = new CustomEvent(type, {
			bubbles: true,
			cancelable: true,
			detail: detail
		});

		// Dispatch the event
		elem.dispatchEvent(event);

	};

	/**
	 * Get an element's distance from the top of the Document.
	 * @param  {Node} elem The element
	 * @return {Number}    Distance from the top in pixels
	 */
	var getOffsetTop = function (elem) {
		var location = 0;
		if (elem.offsetParent) {
			while (elem) {
				location += elem.offsetTop;
				elem = elem.offsetParent;
			}
		}
		return location >= 0 ? location : 0;
	};

	/**
	 * Sort content from first to last in the DOM
	 * @param  {Array} contents The content areas
	 */
	var sortContents = function (contents) {
		if(contents) {
			contents.sort((function (item1, item2) {
				var offset1 = getOffsetTop(item1.content);
				var offset2 = getOffsetTop(item2.content);
				if (offset1 < offset2) return -1;
				return 1;
			}));
		}
	};

	/**
	 * Get the offset to use for calculating position
	 * @param  {Object} settings The settings for this instantiation
	 * @return {Float}           The number of pixels to offset the calculations
	 */
	var getOffset = function (settings) {

		// if the offset is a function run it
		if (typeof settings.offset === 'function') {
			return parseFloat(settings.offset());
		}

		// Otherwise, return it as-is
		return parseFloat(settings.offset);

	};

	/**
	 * Get the document element's height
	 * @private
	 * @returns {Number}
	 */
	var getDocumentHeight = function () {
		return Math.max(
			document.body.scrollHeight, document.documentElement.scrollHeight,
			document.body.offsetHeight, document.documentElement.offsetHeight,
			document.body.clientHeight, document.documentElement.clientHeight
		);
	};

	/**
	 * Determine if an element is in view
	 * @param  {Node}    elem     The element
	 * @param  {Object}  settings The settings for this instantiation
	 * @param  {Boolean} bottom   If true, check if element is above bottom of viewport instead
	 * @return {Boolean}          Returns true if element is in the viewport
	 */
	var isInView = function (elem, settings, bottom) {
		var bounds = elem.getBoundingClientRect();
		var offset = getOffset(settings);
		if (bottom) {
			return parseInt(bounds.bottom, 10) < (window.innerHeight || document.documentElement.clientHeight);
		}
		return parseInt(bounds.top, 10) <= offset;
	};

	/**
	 * Check if at the bottom of the viewport
	 * @return {Boolean} If true, page is at the bottom of the viewport
	 */
	var isAtBottom = function () {
		if (window.innerHeight + window.pageYOffset >= getDocumentHeight()) return true;
		return false;
	};

	/**
	 * Check if the last item should be used (even if not at the top of the page)
	 * @param  {Object} item     The last item
	 * @param  {Object} settings The settings for this instantiation
	 * @return {Boolean}         If true, use the last item
	 */
	var useLastItem = function (item, settings) {
		if (isAtBottom() && isInView(item.content, settings, true)) return true;
		return false;
	};

	/**
	 * Get the active content
	 * @param  {Array}  contents The content areas
	 * @param  {Object} settings The settings for this instantiation
	 * @return {Object}          The content area and matching navigation link
	 */
	var getActive = function (contents, settings) {
		var last = contents[contents.length-1];
		if (useLastItem(last, settings)) return last;
		for (var i = contents.length - 1; i >= 0; i--) {
			if (isInView(contents[i].content, settings)) return contents[i];
		}
	};

	/**
	 * Deactivate parent navs in a nested navigation
	 * @param  {Node}   nav      The starting navigation element
	 * @param  {Object} settings The settings for this instantiation
	 */
	var deactivateNested = function (nav, settings) {

		// If nesting isn't activated, bail
		if (!settings.nested || !nav.parentNode) return;

		// Get the parent navigation
		var li = nav.parentNode.closest('li');
		if (!li) return;

		// Remove the active class
		li.classList.remove(settings.nestedClass);

		// Apply recursively to any parent navigation elements
		deactivateNested(li, settings);

	};

	/**
	 * Deactivate a nav and content area
	 * @param  {Object} items    The nav item and content to deactivate
	 * @param  {Object} settings The settings for this instantiation
	 */
	var deactivate = function (items, settings) {

		// Make sure there are items to deactivate
		if (!items) return;

		// Get the parent list item
		var li = items.nav.closest('li');
		if (!li) return;

		// Remove the active class from the nav and content
		li.classList.remove(settings.navClass);
		items.content.classList.remove(settings.contentClass);

		// Deactivate any parent navs in a nested navigation
		deactivateNested(li, settings);

		// Emit a custom event
		emitEvent('gumshoeDeactivate', li, {
			link: items.nav,
			content: items.content,
			settings: settings
		});

	};


	/**
	 * Activate parent navs in a nested navigation
	 * @param  {Node}   nav      The starting navigation element
	 * @param  {Object} settings The settings for this instantiation
	 */
	var activateNested = function (nav, settings) {

		// If nesting isn't activated, bail
		if (!settings.nested) return;

		// Get the parent navigation
		var li = nav.parentNode.closest('li');
		if (!li) return;

		// Add the active class
		li.classList.add(settings.nestedClass);

		// Apply recursively to any parent navigation elements
		activateNested(li, settings);

	};

	/**
	 * Activate a nav and content area
	 * @param  {Object} items    The nav item and content to activate
	 * @param  {Object} settings The settings for this instantiation
	 */
	var activate = function (items, settings) {

		// Make sure there are items to activate
		if (!items) return;

		// Get the parent list item
		var li = items.nav.closest('li');
		if (!li) return;

		// Add the active class to the nav and content
		li.classList.add(settings.navClass);
		items.content.classList.add(settings.contentClass);

		// Activate any parent navs in a nested navigation
		activateNested(li, settings);

		// Emit a custom event
		emitEvent('gumshoeActivate', li, {
			link: items.nav,
			content: items.content,
			settings: settings
		});

	};

	/**
	 * Create the Constructor object
	 * @param {String} selector The selector to use for navigation items
	 * @param {Object} options  User options and settings
	 */
	var Constructor = function (selector, options) {

		//
		// Variables
		//

		var publicAPIs = {};
		var navItems, contents, current, timeout, settings;


		//
		// Methods
		//

		/**
		 * Set variables from DOM elements
		 */
		publicAPIs.setup = function () {

			// Get all nav items
			navItems = document.querySelectorAll(selector);

			// Create contents array
			contents = [];

			// Loop through each item, get it's matching content, and push to the array
			Array.prototype.forEach.call(navItems, (function (item) {

				// Get the content for the nav item
				var content = document.getElementById(decodeURIComponent(item.hash.substr(1)));
				if (!content) return;

				// Push to the contents array
				contents.push({
					nav: item,
					content: content
				});

			}));

			// Sort contents by the order they appear in the DOM
			sortContents(contents);

		};

		/**
		 * Detect which content is currently active
		 */
		publicAPIs.detect = function () {

			// Get the active content
			var active = getActive(contents, settings);

			// if there's no active content, deactivate and bail
			if (!active) {
				if (current) {
					deactivate(current, settings);
					current = null;
				}
				return;
			}

			// If the active content is the one currently active, do nothing
			if (current && active.content === current.content) return;

			// Deactivate the current content and activate the new content
			deactivate(current, settings);
			activate(active, settings);

			// Update the currently active content
			current = active;

		};

		/**
		 * Detect the active content on scroll
		 * Debounced for performance
		 */
		var scrollHandler = function (event) {

			// If there's a timer, cancel it
			if (timeout) {
				window.cancelAnimationFrame(timeout);
			}

			// Setup debounce callback
			timeout = window.requestAnimationFrame(publicAPIs.detect);

		};

		/**
		 * Update content sorting on resize
		 * Debounced for performance
		 */
		var resizeHandler = function (event) {

			// If there's a timer, cancel it
			if (timeout) {
				window.cancelAnimationFrame(timeout);
			}

			// Setup debounce callback
			timeout = window.requestAnimationFrame((function () {
				sortContents(contents);
				publicAPIs.detect();
			}));

		};

		/**
		 * Destroy the current instantiation
		 */
		publicAPIs.destroy = function () {

			// Undo DOM changes
			if (current) {
				deactivate(current, settings);
			}

			// Remove event listeners
			window.removeEventListener('scroll', scrollHandler, false);
			if (settings.reflow) {
				window.removeEventListener('resize', resizeHandler, false);
			}

			// Reset variables
			contents = null;
			navItems = null;
			current = null;
			timeout = null;
			settings = null;

		};

		/**
		 * Initialize the current instantiation
		 */
		var init = function () {

			// Merge user options into defaults
			settings = extend(defaults, options || {});

			// Setup variables based on the current DOM
			publicAPIs.setup();

			// Find the currently active content
			publicAPIs.detect();

			// Setup event listeners
			window.addEventListener('scroll', scrollHandler, false);
			if (settings.reflow) {
				window.addEventListener('resize', resizeHandler, false);
			}

		};


		//
		// Initialize and return the public APIs
		//

		init();
		return publicAPIs;

	};


	//
	// Return the Constructor
	//

	return Constructor;

}));
});

/**
 * Get offset number or calculate element height.
 *
 * @param {HTMLElement | number} el Get height from HTML element or set height.
 * @returns {number} Return height.
 */
function offset$1(el) {
  if (el && !isNaN(el)) {
    return el;
  }
  else if (el) {
    return document.querySelector(el).getBoundingClientRect().height;
  }
  else if (!el) {
    return 0;
  }
}

const tag$6 = 'spx-scrollspy';
const SpxScrollspy$2 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.spxScrollspyDidLoad = createEvent(this, "spxScrollspyDidLoad", 7);
    this.spxScrollspyActivate = createEvent(this, "spxScrollspyActivate", 7);
    this.spxScrollspyDeactivate = createEvent(this, "spxScrollspyDeactivate", 7);
    /** Applied class to active content element. */
    this.contentClass = 'spx-scrollspy__content--active';
    this.display = display$1;
    /** Applied class to active navigation element. */
    this.navClass = 'spx-scrollspy__nav--active';
    /**
     * Selects the height of an element (any querySelector value) or number that
     * is used for offsetting how far from the top the next section is activated.
     */
    this.offset = 0;
    /** Target element. Can take any querySelector value. (id, class, tag etc.) */
    this.target = 'a';
    /** Appends the currently active link to the end of the URL. */
    this.urlChange = false;
  }
  /**
   * Replace state of URL bar.
   *
   * @param {event} event Gumshoe activate event.
   */
  onLinkActive(event) {
    if (this.urlChange) {
      history.replaceState(null, null, event.detail.link.getAttribute('href'));
    }
    if (this.scrolling) {
      this.el.scroll({
        top: this.el.querySelector('a[href="' + event.detail.link.getAttribute('href') + '"]')['offsetTop'] - this.scrolling,
        behavior: 'smooth',
      });
    }
    this.spxScrollspyActivate.emit({
      target: 'document',
      link: event.detail.link,
      content: event.detail.content,
    });
  }
  /**
   * Deactivate event.
   *
   * @param {event} event Gumshoe deactivate event.
   */
  onLinkDeactivate(event) {
    this.spxScrollspyDeactivate.emit({
      target: 'document',
      link: event.detail.link,
      content: event.detail.content,
    });
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    /** Init Gumshoe. */
    // eslint-disable-next-line no-new
    this.myGumshoe = new gumshoe(':scope ' + this.target + '', {
      reflow: true,
      navClass: this.navClass,
      contentClass: this.contentClass,
      events: true,
      offset: () => {
        /** Check if prop is a number otherwise look for querySelector. */
        return offset$1(this.offset);
      },
    });
    /** Emit event after render. */
    this.spxScrollspyDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  /** Reload the Scrollspy. */
  async reload() {
    this.myGumshoe.setup();
  }
  render() {
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$6, 'display', this.display),
    });
    return h$4(Host, { class: styleHost });
  }
  get el() { return this; }
};

const tag$5 = 'spx-share';
const SpxShare$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxShareDidLoad = createEvent(this, "spxShareDidLoad", 7);
    this.display = display$1;
    this.fontSize = fontSize;
    this.fontSizeMax = 1.4;
    this.fontSizeMin = 1;
    this.itemBorderRadius = borderRadius;
    /**
     * Filter hover.
     *
     * @CSS
     */
    this.itemFilterHover = 'brightness(110%) saturate(120%)';
    /**
     * Gap between buttons.
     *
     * @CSS
     */
    this.itemGap = '0.5em';
    this.itemGapMin = 0.4;
    this.itemGapMax = 1;
    this.itemPadding = '0.5em';
    this.itemPaddingMin = 0.5;
    this.itemPaddingMax = 1.2;
    this.itemSize = '1em';
    this.itemSizeMin = 0.7;
    this.itemSizeMax = 1;
    this.itemTransitionDuration = transitionDuration;
    this.itemTransitionTimingFunction = transitionTimingFunction;
    /**
     * Styling.
     *
     * @choice 'default', 'fluid', 'headless'
     */
    this.styling = 'default';
    /** Button href target. */
    this.target = '_blank';
    /**
     * Button theme.
     *
     * @choice 'default', 'outline', 'minimal'
     */
    this.theme = 'default';
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.spxShareDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$5, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = (this.styling === 'default' || this.styling === 'fluid') &&
      css({
        fontSize: setVar(tag$5, 'font-size', this.fontSize),
        display: 'grid',
        gridAutoFlow: this.vertical ? 'row' : 'column',
        gridAutoColumns: !this.vertical && 'max-content',
        gridAutoRows: this.vertical && 'max-content',
        gridGap: setStyle(tag$5, 'item-gap', this.itemGap, this.itemGapMin, this.itemGapMax, this.styling),
      });
    /** Link styles. */
    const styleItem = this.styling === 'default' || this.styling === 'fluid'
      ? css(Object.assign({ display: 'flex', alignItems: 'center', justifyContent: 'center', boxSizing: 'content-box', cursor: 'pointer', width: setStyle(tag$5, 'item-size', this.itemSize, this.itemSizeMin, this.itemSizeMax, this.styling), height: setStyle(tag$5, 'item-size', this.itemSize, this.itemSizeMin, this.itemSizeMax, this.styling), padding: setStyle(tag$5, 'item-padding', this.itemPadding, this.itemPaddingMin, this.itemPaddingMax, this.styling), borderRadius: setVar(tag$5, 'item-border-radius', this.itemBorderRadius), color: setVar(tag$5, 'item-color', this.itemColor), background: setVar(tag$5, 'item-background', this.itemBackground), transitionProperty: 'filter, box-shadow', transitionDuration: setVar(tag$5, 'item-transition-duration', this.itemTransitionDuration), transitionTimingFunction: setVar(tag$5, 'item-transition-timing-function', this.itemTransitionTimingFunction), '&:hover': {
          filter: setVar(tag$5, 'item-filter-hover', this.itemFilterHover),
        }, svg: {
          height: '100%',
        } }, focus))
      : this.classItem;
    /** Facebook styles. */
    const styleFacebook = css({
      background: this.theme === 'default' && !this.itemBackground
        ? '#1877F2'
        : this.theme === 'default' && this.itemBackground
          ? this.itemBackground
          : null,
      color: this.theme === 'outline' || this.theme === 'minimal'
        ? '#1877F2'
        : !this.itemColor
          ? '#ffffff'
          : null,
      border: this.theme === 'outline' && '1px solid #1877F2',
    });
    /** Twitter styles. */
    const styleTwitter = css({
      background: this.theme === 'default' && !this.itemBackground
        ? '#1DA1F2'
        : this.theme === 'default' && this.itemBackground
          ? this.itemBackground
          : null,
      color: this.theme === 'outline' || this.theme === 'minimal'
        ? '#1DA1F2'
        : !this.itemColor
          ? '#ffffff'
          : null,
      border: this.theme === 'outline' && '1px solid #1DA1F2',
    });
    /** Email styles. */
    const styleEmail = css({
      background: this.theme === 'default' && !this.itemBackground
        ? '#c6c6c6'
        : this.theme === 'default' && this.itemBackground
          ? this.itemBackground
          : null,
      color: this.theme === 'outline' || this.theme === 'minimal'
        ? '#c6c6c6'
        : !this.itemColor
          ? '#ffffff'
          : null,
      border: this.theme === 'outline' && '1px solid #c6c6c6',
    });
    /** WhatsApp styles. */
    const styleWhatsapp = css({
      background: this.theme === 'default' && !this.itemBackground
        ? '#25D366'
        : this.theme === 'default' && this.itemBackground
          ? this.itemBackground
          : null,
      color: this.theme === 'outline' || this.theme === 'minimal'
        ? '#25D366'
        : !this.itemColor
          ? '#ffffff'
          : null,
      border: this.theme === 'outline' && '1px solid #25D366',
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleShadowHost }, [
      {
        className: styleFacebook,
        href: 'https://www.facebook.com/sharer/sharer.php?u=',
        icon: 'logo-facebook',
      },
      {
        className: styleTwitter,
        href: 'https://www.twitter.com/share?url=',
        icon: 'logo-twitter',
      },
      {
        className: styleWhatsapp,
        href: 'https://web.whatsapp.com/send?text=',
        icon: 'logo-whatsapp',
      },
      {
        className: styleEmail,
        href: 'mailto:?body=',
        icon: 'mail',
      },
    ].map((item) => {
      return (h$4(Button, { class: css([styleItem, item.className]), href: item.href + window.location.href, target: this.target }, h$4("spx-icon", { icon: item.icon })));
    }))));
  }
  get el() { return this; }
};

/**
 * SSR Window 3.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: November 9, 2020
 */
/* eslint-disable no-param-reassign */
function isObject$1(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend$1(target, src) {
    if (target === void 0) { target = {}; }
    if (src === void 0) { src = {}; }
    Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject$1(src[key]) &&
            isObject$1(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend$1(target[key], src[key]);
        }
    });
}

var ssrDocument = {
    body: {},
    addEventListener: function () { },
    removeEventListener: function () { },
    activeElement: {
        blur: function () { },
        nodeName: '',
    },
    querySelector: function () {
        return null;
    },
    querySelectorAll: function () {
        return [];
    },
    getElementById: function () {
        return null;
    },
    createEvent: function () {
        return {
            initEvent: function () { },
        };
    },
    createElement: function () {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function () { },
            getElementsByTagName: function () {
                return [];
            },
        };
    },
    createElementNS: function () {
        return {};
    },
    importNode: function () {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
function getDocument() {
    var doc = typeof document !== 'undefined' ? document : {};
    extend$1(doc, ssrDocument);
    return doc;
}

var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState: function () { },
        pushState: function () { },
        go: function () { },
        back: function () { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener: function () { },
    removeEventListener: function () { },
    getComputedStyle: function () {
        return {
            getPropertyValue: function () {
                return '';
            },
        };
    },
    Image: function () { },
    Date: function () { },
    screen: {},
    setTimeout: function () { },
    clearTimeout: function () { },
    matchMedia: function () {
        return {};
    },
    requestAnimationFrame: function (callback) {
        if (typeof setTimeout === 'undefined') {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame: function (id) {
        if (typeof setTimeout === 'undefined') {
            return;
        }
        clearTimeout(id);
    },
};
function getWindow() {
    var win = typeof window !== 'undefined' ? window : {};
    extend$1(win, ssrWindow);
    return win;
}

/**
 * Dom7 3.0.0
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * https://framework7.io/docs/dom7.html
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: November 9, 2020
 */

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/* eslint-disable no-proto */
function makeReactive(obj) {
  var proto = obj.__proto__;
  Object.defineProperty(obj, '__proto__', {
    get: function get() {
      return proto;
    },
    set: function set(value) {
      proto.__proto__ = value;
    }
  });
}

var Dom7 = /*#__PURE__*/function (_Array) {
  _inheritsLoose(Dom7, _Array);

  function Dom7(items) {
    var _this;

    _this = _Array.call.apply(_Array, [this].concat(items)) || this;
    makeReactive(_assertThisInitialized(_this));
    return _this;
  }

  return Dom7;
}( /*#__PURE__*/_wrapNativeSuper(Array));

function arrayFlat(arr) {
  if (arr === void 0) {
    arr = [];
  }

  var res = [];
  arr.forEach(function (el) {
    if (Array.isArray(el)) {
      res.push.apply(res, arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  var uniqueArray = [];

  for (var i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }

  return uniqueArray;
}

function qsa(selector, context) {
  if (typeof selector !== 'string') {
    return [selector];
  }

  var a = [];
  var res = context.querySelectorAll(selector);

  for (var i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }

  return a;
}

function $(selector, context) {
  var window = getWindow();
  var document = getDocument();
  var arr = [];

  if (!context && selector instanceof Dom7) {
    return selector;
  }

  if (!selector) {
    return new Dom7(arr);
  }

  if (typeof selector === 'string') {
    var html = selector.trim();

    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
      var toCreate = 'div';
      if (html.indexOf('<li') === 0) toCreate = 'ul';
      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
      if (html.indexOf('<tbody') === 0) toCreate = 'table';
      if (html.indexOf('<option') === 0) toCreate = 'select';
      var tempParent = document.createElement(toCreate);
      tempParent.innerHTML = html;

      for (var i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document);
    } // arr = qsa(selector, document);

  } else if (selector.nodeType || selector === window || selector === document) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }

  return new Dom7(arrayUnique(arr));
}

$.fn = Dom7.prototype;

function addClass() {
  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
    classes[_key] = arguments[_key];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList;

    (_el$classList = el.classList).add.apply(_el$classList, classNames);
  });
  return this;
}

function removeClass() {
  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    classes[_key2] = arguments[_key2];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList2;

    (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
  });
  return this;
}

function toggleClass() {
  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    classes[_key3] = arguments[_key3];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    classNames.forEach(function (className) {
      el.classList.toggle(className);
    });
  });
}

function hasClass() {
  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    classes[_key4] = arguments[_key4];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  return arrayFilter(this, function (el) {
    return classNames.filter(function (className) {
      return el.classList.contains(className);
    }).length > 0;
  }).length > 0;
}

function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  } // Set attrs


  for (var i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      for (var attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }

  return this;
}

function removeAttr(attr) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }

  return this;
}

function transform(transform) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform;
  }

  return this;
}

function transition$1(duration) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
  }

  return this;
}

function on() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  var eventType = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  if (!capture) capture = false;

  function handleLiveEvent(e) {
    var target = e.target;
    if (!target) return;
    var eventData = e.target.dom7EventData || [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
      var _parents = $(target).parents(); // eslint-disable-line


      for (var k = 0; k < _parents.length; k += 1) {
        if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
      }
    }
  }

  function handleEvent(e) {
    var eventData = e && e.target ? e.target.dom7EventData || [] : [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    listener.apply(this, eventData);
  }

  var events = eventType.split(' ');
  var j;

  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        var event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener: listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        var _event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

        el.dom7LiveListeners[_event].push({
          listener: listener,
          proxyListener: handleLiveEvent
        });

        el.addEventListener(_event, handleLiveEvent, capture);
      }
    }
  }

  return this;
}

function off() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  var eventType = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  if (!capture) capture = false;
  var events = eventType.split(' ');

  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];

    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];
      var handlers = void 0;

      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }

      if (handlers && handlers.length) {
        for (var k = handlers.length - 1; k >= 0; k -= 1) {
          var handler = handlers[k];

          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }

  return this;
}

function trigger() {
  var window = getWindow();

  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  var events = args[0].split(' ');
  var eventData = args[1];

  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];

    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];

      if (window.CustomEvent) {
        var evt = new window.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter(function (data, dataIndex) {
          return dataIndex > 0;
        });
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }

  return this;
}

function transitionEnd$1(callback) {
  var dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('transitionend', fireCallBack);
  }

  if (callback) {
    dom.on('transitionend', fireCallBack);
  }

  return this;
}

function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles = this.styles();

      return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
    }

    return this[0].offsetWidth;
  }

  return null;
}

function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles2 = this.styles();

      return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
    }

    return this[0].offsetHeight;
  }

  return null;
}

function offset() {
  if (this.length > 0) {
    var window = getWindow();
    var document = getDocument();
    var el = this[0];
    var box = el.getBoundingClientRect();
    var body = document.body;
    var clientTop = el.clientTop || body.clientTop || 0;
    var clientLeft = el.clientLeft || body.clientLeft || 0;
    var scrollTop = el === window ? window.scrollY : el.scrollTop;
    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }

  return null;
}

function styles() {
  var window = getWindow();
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}

function css(props, value) {
  var window = getWindow();
  var i;

  if (arguments.length === 1) {
    if (typeof props === 'string') {
      // .css('width')
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      // .css({ width: '100px' })
      for (i = 0; i < this.length; i += 1) {
        for (var _prop in props) {
          this[i].style[_prop] = props[_prop];
        }
      }

      return this;
    }
  }

  if (arguments.length === 2 && typeof props === 'string') {
    // .css('width', '100px')
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }

    return this;
  }

  return this;
}

function each(callback) {
  if (!callback) return this;
  this.forEach(function (el, index) {
    callback.apply(el, [el, index]);
  });
  return this;
}

function filter(callback) {
  var result = arrayFilter(this, callback);
  return $(result);
}

function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : null;
  }

  for (var i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }

  return this;
}

function text(text) {
  if (typeof text === 'undefined') {
    return this[0] ? this[0].textContent.trim() : null;
  }

  for (var i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }

  return this;
}

function is(selector) {
  var window = getWindow();
  var document = getDocument();
  var el = this[0];
  var compareWith;
  var i;
  if (!el || typeof selector === 'undefined') return false;

  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = $(selector);

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  if (selector === document) {
    return el === document;
  }

  if (selector === window) {
    return el === window;
  }

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  return false;
}

function index() {
  var child = this[0];
  var i;

  if (child) {
    i = 0; // eslint-disable-next-line

    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }

    return i;
  }

  return undefined;
}

function eq(index) {
  if (typeof index === 'undefined') return this;
  var length = this.length;

  if (index > length - 1) {
    return $([]);
  }

  if (index < 0) {
    var returnIndex = length + index;
    if (returnIndex < 0) return $([]);
    return $([this[returnIndex]]);
  }

  return $([this[index]]);
}

function append() {
  var newChild;
  var document = getDocument();

  for (var k = 0; k < arguments.length; k += 1) {
    newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

    for (var i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (var j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}

function prepend(newChild) {
  var document = getDocument();
  var i;
  var j;

  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;

      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }

  return this;
}

function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return $([this[0].nextElementSibling]);
      }

      return $([]);
    }

    if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
    return $([]);
  }

  return $([]);
}

function nextAll(selector) {
  var nextEls = [];
  var el = this[0];
  if (!el) return $([]);

  while (el.nextElementSibling) {
    var _next = el.nextElementSibling; // eslint-disable-line

    if (selector) {
      if ($(_next).is(selector)) nextEls.push(_next);
    } else nextEls.push(_next);

    el = _next;
  }

  return $(nextEls);
}

function prev(selector) {
  if (this.length > 0) {
    var el = this[0];

    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return $([el.previousElementSibling]);
      }

      return $([]);
    }

    if (el.previousElementSibling) return $([el.previousElementSibling]);
    return $([]);
  }

  return $([]);
}

function prevAll(selector) {
  var prevEls = [];
  var el = this[0];
  if (!el) return $([]);

  while (el.previousElementSibling) {
    var _prev = el.previousElementSibling; // eslint-disable-line

    if (selector) {
      if ($(_prev).is(selector)) prevEls.push(_prev);
    } else prevEls.push(_prev);

    el = _prev;
  }

  return $(prevEls);
}

function parent(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }

  return $(parents);
}

function parents(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var _parent = this[i].parentNode; // eslint-disable-line

    while (_parent) {
      if (selector) {
        if ($(_parent).is(selector)) parents.push(_parent);
      } else {
        parents.push(_parent);
      }

      _parent = _parent.parentNode;
    }
  }

  return $(parents);
}

function closest(selector) {
  var closest = this; // eslint-disable-line

  if (typeof selector === 'undefined') {
    return $([]);
  }

  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }

  return closest;
}

function find(selector) {
  var foundElements = [];

  for (var i = 0; i < this.length; i += 1) {
    var found = this[i].querySelectorAll(selector);

    for (var j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }

  return $(foundElements);
}

function children(selector) {
  var children = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var childNodes = this[i].children;

    for (var j = 0; j < childNodes.length; j += 1) {
      if (!selector || $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }

  return $(children);
}

function remove() {
  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }

  return this;
}

var Methods = {
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  toggleClass: toggleClass,
  attr: attr,
  removeAttr: removeAttr,
  transform: transform,
  transition: transition$1,
  on: on,
  off: off,
  trigger: trigger,
  transitionEnd: transitionEnd$1,
  outerWidth: outerWidth,
  outerHeight: outerHeight,
  styles: styles,
  offset: offset,
  css: css,
  each: each,
  html: html,
  text: text,
  is: is,
  index: index,
  eq: eq,
  append: append,
  prepend: prepend,
  next: next,
  nextAll: nextAll,
  prev: prev,
  prevAll: prevAll,
  parent: parent,
  parents: parents,
  closest: closest,
  find: find,
  children: children,
  filter: filter,
  remove: remove
};
Object.keys(Methods).forEach(function (methodName) {
  Object.defineProperty($.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});

function deleteProps(obj) {
  var object = obj;
  Object.keys(object).forEach(function (key) {
    try {
      object[key] = null;
    } catch (e) {// no getter for object
    }

    try {
      delete object[key];
    } catch (e) {// something got wrong
    }
  });
}

function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return setTimeout(callback, delay);
}

function now() {
  return Date.now();
}

function getComputedStyle$1(el) {
  var window = getWindow();
  var style;

  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }

  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }

  if (!style) {
    style = el.style;
  }

  return style;
}

function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }

  var window = getWindow();
  var matrix;
  var curTransform;
  var transformMatrix;
  var curStyle = getComputedStyle$1(el);

  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;

    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(function (a) {
        return a.replace(',', '.');
      }).join(', ');
    } // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case


    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }

  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
  }

  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
  }

  return curTransform || 0;
}

function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined') {
    return node instanceof HTMLElement;
  }

  return node && (node.nodeType === 1 || node.nodeType === 11);
}

function extend() {
  var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  var noExtend = ['__proto__', 'constructor', 'prototype'];

  for (var i = 1; i < arguments.length; i += 1) {
    var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
        return noExtend.indexOf(key) < 0;
      });

      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};

            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}

function bindModuleMethods(instance, obj) {
  Object.keys(obj).forEach(function (key) {
    if (isObject(obj[key])) {
      Object.keys(obj[key]).forEach(function (subKey) {
        if (typeof obj[key][subKey] === 'function') {
          obj[key][subKey] = obj[key][subKey].bind(instance);
        }
      });
    }

    instance[key] = obj[key];
  });
}

function classesToSelector(classes) {
  if (classes === void 0) {
    classes = '';
  }

  return "." + classes.trim().replace(/([\.:\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.');
}

function createElementIfNotDefined($container, params, createElements, checkProps) {
  var document = getDocument();

  if (createElements) {
    Object.keys(checkProps).forEach(function (key) {
      if (!params[key] && params.auto === true) {
        var element = document.createElement('div');
        element.className = checkProps[key];
        $container.append(element);
        params[key] = element;
      }
    });
  }

  return params;
}

var support;

function calcSupport() {
  var window = getWindow();
  var document = getDocument();
  return {
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
    observer: function checkObserver() {
      return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
    }(),
    passiveListener: function checkPassiveListener() {
      var supportsPassive = false;

      try {
        var opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get: function get() {
            supportsPassive = true;
          }
        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {// No support
      }

      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return 'ongesturestart' in window;
    }()
  };
}

function getSupport() {
  if (!support) {
    support = calcSupport();
  }

  return support;
}

var device;

function calcDevice(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      userAgent = _ref.userAgent;

  var support = getSupport();
  var window = getWindow();
  var platform = window.navigator.platform;
  var ua = userAgent || window.navigator.userAgent;
  var device = {
    ios: false,
    android: false
  };
  var screenWidth = window.screen.width;
  var screenHeight = window.screen.height;
  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  var windows = platform === 'Win32';
  var macos = platform === 'MacIntel'; // iPadOs 13 fix

  var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

  if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  } // Android


  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }

  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  } // Export object


  return device;
}

function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }

  if (!device) {
    device = calcDevice(overrides);
  }

  return device;
}

var browser;

function calcBrowser() {
  var window = getWindow();

  function isSafari() {
    var ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }

  return {
    isEdge: !!window.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}

function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }

  return browser;
}

var supportsResizeObserver = function supportsResizeObserver() {
  var window = getWindow();
  return typeof window.ResizeObserver !== 'undefined';
};

const Resize = {
  name: 'resize',
  create: function create() {
    var swiper = this;
    extend(swiper, {
      resize: {
        observer: null,
        createObserver: function createObserver() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.resize.observer = new ResizeObserver(function (entries) {
            var width = swiper.width,
                height = swiper.height;
            var newWidth = width;
            var newHeight = height;
            entries.forEach(function (_ref) {
              var contentBoxSize = _ref.contentBoxSize,
                  contentRect = _ref.contentRect,
                  target = _ref.target;
              if (target && target !== swiper.el) return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });

            if (newWidth !== width || newHeight !== height) {
              swiper.resize.resizeHandler();
            }
          });
          swiper.resize.observer.observe(swiper.el);
        },
        removeObserver: function removeObserver() {
          if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
            swiper.resize.observer.unobserve(swiper.el);
            swiper.resize.observer = null;
          }
        },
        resizeHandler: function resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler: function orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        }
      }
    });
  },
  on: {
    init: function init(swiper) {
      var window = getWindow();

      if (swiper.params.resizeObserver && supportsResizeObserver()) {
        swiper.resize.createObserver();
        return;
      } // Emit resize


      window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy: function destroy(swiper) {
      var window = getWindow();
      swiper.resize.removeObserver();
      window.removeEventListener('resize', swiper.resize.resizeHandler);
      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    }
  }
};

function _extends$7() { _extends$7 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }
var Observer = {
  attach: function attach(target, options) {
    if (options === void 0) {
      options = {};
    }

    var window = getWindow();
    var swiper = this;
    var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    var observer = new ObserverFunc(function (mutations) {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }

      var observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    swiper.observer.observers.push(observer);
  },
  init: function init() {
    var swiper = this;
    if (!swiper.support.observer || !swiper.params.observer) return;

    if (swiper.params.observeParents) {
      var containerParents = swiper.$el.parents();

      for (var i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    } // Observe container


    swiper.observer.attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    }); // Observe wrapper

    swiper.observer.attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  },
  destroy: function destroy() {
    var swiper = this;
    swiper.observer.observers.forEach(function (observer) {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  }
};
const Observer$1 = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      observer: _extends$7({}, Observer, {
        observers: []
      })
    });
  },
  on: {
    init: function init(swiper) {
      swiper.observer.init();
    },
    destroy: function destroy(swiper) {
      swiper.observer.destroy();
    }
  }
};

const modular = {
  useParams: function useParams(instanceParams) {
    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName]; // Extend params

      if (module.params) {
        extend(instanceParams, module.params);
      }
    });
  },
  useModules: function useModules(modulesParams) {
    if (modulesParams === void 0) {
      modulesParams = {};
    }

    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName];
      var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

      if (module.on && instance.on) {
        Object.keys(module.on).forEach(function (moduleEventName) {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      } // Module create callback


      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }
};

/* eslint-disable no-underscore-dangle */
const eventsEmitter = {
  on: function on(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(function (event) {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once: function once(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;

    function onceHandler() {
      self.off(events, onceHandler);

      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      handler.apply(self, args);
    }

    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny: function onAny(handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';

    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }

    return self;
  },
  offAny: function offAny(handler) {
    var self = this;
    if (!self.eventsAnyListeners) return self;
    var index = self.eventsAnyListeners.indexOf(handler);

    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }

    return self;
  },
  off: function off(events, handler) {
    var self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(function (event) {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler, index) {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit: function emit() {
    var self = this;
    if (!self.eventsListeners) return self;
    var events;
    var data;
    var context;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    data.unshift(context);
    var eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(function (event) {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(function (eventHandler) {
          eventHandler.apply(context, [event].concat(data));
        });
      }

      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler) {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};

function updateSize() {
  var swiper = this;
  var width;
  var height;
  var $el = swiper.$el;

  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }

  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }

  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  } // Subtract paddings


  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  extend(swiper, {
    width: width,
    height: height,
    size: swiper.isHorizontal() ? width : height
  });
}

function updateSlides() {
  var swiper = this;

  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore


    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }

  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }

  var params = swiper.params;
  var $wrapperEl = swiper.$wrapperEl,
      swiperSize = swiper.size,
      rtl = swiper.rtlTranslate,
      wrongRTL = swiper.wrongRTL;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  var slides = $wrapperEl.children("." + swiper.params.slideClass);
  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  var snapGrid = [];
  var slidesGrid = [];
  var slidesSizesGrid = [];
  var offsetBefore = params.slidesOffsetBefore;

  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  var offsetAfter = params.slidesOffsetAfter;

  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  var previousSnapGridLength = swiper.snapGrid.length;
  var previousSlidesGridLength = swiper.slidesGrid.length;
  var spaceBetween = params.spaceBetween;
  var slidePosition = -offsetBefore;
  var prevSlideSize = 0;
  var index = 0;

  if (typeof swiperSize === 'undefined') {
    return;
  }

  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  }

  swiper.virtualSize = -spaceBetween; // reset margins

  if (rtl) slides.css({
    marginLeft: '',
    marginTop: ''
  });else slides.css({
    marginRight: '',
    marginBottom: ''
  });
  var slidesNumberEvenToRows;

  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }

    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  } // Calc slides


  var slideSize;
  var slidesPerColumn = params.slidesPerColumn;
  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

  for (var i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    var slide = slides.eq(i);

    if (params.slidesPerColumn > 1) {
      // Set slides order
      var newSlideOrderIndex = void 0;
      var column = void 0;
      var row = void 0;

      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
        var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
        slide.css({
          '-webkit-box-ordinal-group': newSlideOrderIndex,
          '-moz-box-ordinal-group': newSlideOrderIndex,
          '-ms-flex-order': newSlideOrderIndex,
          '-webkit-order': newSlideOrderIndex,
          order: newSlideOrderIndex
        });
      } else if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - column * slidesPerColumn;

        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
          row += 1;

          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }

      slide.css(getDirectionLabel('margin-top'), row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : '');
    }

    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      var slideStyles = getComputedStyle(slide[0]);
      var currentTransform = slide[0].style.transform;
      var currentWebKitTransform = slide[0].style.webkitTransform;

      if (currentTransform) {
        slide[0].style.transform = 'none';
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }

      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        var width = getDirectionPropertyValue(slideStyles, 'width');
        var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        var boxSizing = slideStyles.getPropertyValue('box-sizing');

        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          var _slide$ = slide[0],
              clientWidth = _slide$.clientWidth,
              offsetWidth = _slide$.offsetWidth;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }

      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }

      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = slideSize + "px";
      }
    }

    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }

    slidesSizesGrid.push(slideSize);

    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }

  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  var newSlidesGrid;

  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({
      width: swiper.virtualSize + params.spaceBetween + "px"
    });
  }

  if (params.setWrapperSize) {
    var _$wrapperEl$css;

    $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
  }

  if (params.slidesPerColumn > 1) {
    var _$wrapperEl$css2;

    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));

    if (params.centeredSlides) {
      newSlidesGrid = [];

      for (var _i = 0; _i < snapGrid.length; _i += 1) {
        var slidesGridItem = snapGrid[_i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }

      snapGrid = newSlidesGrid;
    }
  } // Remove last grid elements depending on width


  if (!params.centeredSlides) {
    newSlidesGrid = [];

    for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
      var _slidesGridItem = snapGrid[_i2];
      if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

      if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(_slidesGridItem);
      }
    }

    snapGrid = newSlidesGrid;

    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }

  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    var _slides$filter$css;

    var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter(function (_, slideIndex) {
      if (!params.cssMode) return true;

      if (slideIndex === slides.length - 1) {
        return false;
      }

      return true;
    }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    var allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    var maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(function (snap) {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    var _allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    _allSlidesSize -= params.spaceBetween;

    if (_allSlidesSize < swiperSize) {
      var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
      snapGrid.forEach(function (snap, snapIndex) {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach(function (snap, snapIndex) {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  extend(swiper, {
    slides: slides,
    snapGrid: snapGrid,
    slidesGrid: slidesGrid,
    slidesSizesGrid: slidesSizesGrid
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }

  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }

  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

function updateAutoHeight(speed) {
  var swiper = this;
  var activeSlides = [];
  var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  var newHeight = 0;
  var i;

  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }

  var getSlideByIndex = function getSlideByIndex(index) {
    if (isVirtual) {
      return swiper.slides.filter(function (el) {
        return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;
      })[0];
    }

    return swiper.slides.eq(index)[0];
  }; // Find slides currently in view


  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each(function (slide) {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        var index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  } // Find new height from highest slide in view


  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      var height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  } // Update Height


  if (newHeight) swiper.$wrapperEl.css('height', newHeight + "px");
}

function updateSlidesOffset() {
  var swiper = this;
  var slides = swiper.slides;

  for (var i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }

  var swiper = this;
  var params = swiper.params;
  var slides = swiper.slides,
      rtl = swiper.rtlTranslate;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  var offsetCenter = -translate;
  if (rtl) offsetCenter = translate; // Visible Slides

  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (var i = 0; i < slides.length; i += 1) {
    var slide = slides[i];
    var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

    if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }

    slide.progress = rtl ? -slideProgress : slideProgress;
  }

  swiper.visibleSlides = $(swiper.visibleSlides);
}

function updateProgress(translate) {
  var swiper = this;

  if (typeof translate === 'undefined') {
    var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }

  var params = swiper.params;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  var progress = swiper.progress,
      isBeginning = swiper.isBeginning,
      isEnd = swiper.isEnd;
  var wasBeginning = isBeginning;
  var wasEnd = isEnd;

  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }

  extend(swiper, {
    progress: progress,
    isBeginning: isBeginning,
    isEnd: isEnd
  });
  if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }

  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }

  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

function updateSlidesClasses() {
  var swiper = this;
  var slides = swiper.slides,
      params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex,
      realIndex = swiper.realIndex;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
  var activeSlide;

  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
  } else {
    activeSlide = slides.eq(activeIndex);
  } // Active classes


  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
    }
  } // Next Slide


  var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  } // Prev Slide


  var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }

  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
    }

    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
    }
  }

  swiper.emitSlidesClasses();
}

function updateActiveIndex(newActiveIndex) {
  var swiper = this;
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  var slidesGrid = swiper.slidesGrid,
      snapGrid = swiper.snapGrid,
      params = swiper.params,
      previousIndex = swiper.activeIndex,
      previousRealIndex = swiper.realIndex,
      previousSnapIndex = swiper.snapIndex;
  var activeIndex = newActiveIndex;
  var snapIndex;

  if (typeof activeIndex === 'undefined') {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    } // Normalize slideIndex


    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }

  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }

  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }

    return;
  } // Get real index


  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
  extend(swiper, {
    snapIndex: snapIndex,
    realIndex: realIndex,
    previousIndex: previousIndex,
    activeIndex: activeIndex
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');

  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }

  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

function updateClickedSlide(e) {
  var swiper = this;
  var params = swiper.params;
  var slide = $(e.target).closest("." + params.slideClass)[0];
  var slideFound = false;
  var slideIndex;

  if (slide) {
    for (var i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;

    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }

  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

const update = {
  updateSize: updateSize,
  updateSlides: updateSlides,
  updateAutoHeight: updateAutoHeight,
  updateSlidesOffset: updateSlidesOffset,
  updateSlidesProgress: updateSlidesProgress,
  updateProgress: updateProgress,
  updateSlidesClasses: updateSlidesClasses,
  updateActiveIndex: updateActiveIndex,
  updateClickedSlide: updateClickedSlide
};

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }

  var swiper = this;
  var params = swiper.params,
      rtl = swiper.rtlTranslate,
      translate = swiper.translate,
      $wrapperEl = swiper.$wrapperEl;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  if (params.cssMode) {
    return translate;
  }

  var currentTranslate = getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

function setTranslate(translate, byController) {
  var swiper = this;
  var rtl = swiper.rtlTranslate,
      params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      wrapperEl = swiper.wrapperEl,
      progress = swiper.progress;
  var x = 0;
  var y = 0;
  var z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
  }

  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate() {
  return -this.snapGrid[0];
}

function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (translateBounds === void 0) {
    translateBounds = true;
  }

  var swiper = this;
  var params = swiper.params,
      wrapperEl = swiper.wrapperEl;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  var minTranslate = swiper.minTranslate();
  var maxTranslate = swiper.maxTranslate();
  var newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    var isH = swiper.isHorizontal();

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;

        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      }
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;

          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}

const translate = {
  getTranslate: getSwiperTranslate,
  setTranslate: setTranslate,
  minTranslate: minTranslate,
  maxTranslate: maxTranslate,
  translateTo: translateTo
};

function setTransition(duration, byController) {
  var swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}

function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var activeIndex = swiper.activeIndex,
      params = swiper.params,
      previousIndex = swiper.previousIndex;
  if (params.cssMode) return;

  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  var dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }

    swiper.emit('slideChangeTransitionStart');

    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}

function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var activeIndex = swiper.activeIndex,
      previousIndex = swiper.previousIndex,
      params = swiper.params;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  var dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }

    swiper.emit('slideChangeTransitionEnd');

    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}

const transition = {
  setTransition: setTransition,
  transitionStart: transitionStart,
  transitionEnd: transitionEnd
};

function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (typeof index !== 'number' && typeof index !== 'string') {
    throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index + "] given.");
  }

  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    var indexAsNumber = parseInt(index, 10);
    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */

    var isValidNumber = isFinite(indexAsNumber);

    if (!isValidNumber) {
      throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index + "] given.");
    } // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.


    index = indexAsNumber;
  }

  var swiper = this;
  var slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  var params = swiper.params,
      snapGrid = swiper.snapGrid,
      slidesGrid = swiper.slidesGrid,
      previousIndex = swiper.previousIndex,
      activeIndex = swiper.activeIndex,
      rtl = swiper.rtlTranslate,
      wrapperEl = swiper.wrapperEl,
      enabled = swiper.enabled;

  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }

  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  var translate = -snapGrid[snapIndex]; // Update progress

  swiper.updateProgress(translate); // Normalize slideIndex

  if (params.normalizeSlideIndex) {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      var normalizedTranslate = -Math.floor(translate * 100);
      var normalizedGird = Math.floor(slidesGrid[i] * 100);
      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGird) {
        slideIndex = i;
      }
    }
  } // Directions locks


  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }

    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  var direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex); // Update Height

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    swiper.updateSlidesClasses();

    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }

    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }

    return false;
  }

  if (params.cssMode) {
    var isH = swiper.isHorizontal();
    var t = -translate;

    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;

        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var newIndex = index;

  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var params = swiper.params,
      animating = swiper.animating,
      enabled = swiper.enabled;
  if (!enabled) return swiper;
  var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var params = swiper.params,
      animating = swiper.animating,
      snapGrid = swiper.snapGrid,
      slidesGrid = swiper.slidesGrid,
      rtlTranslate = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return swiper;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  var translate = rtlTranslate ? swiper.translate : -swiper.translate;

  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }

  var normalizedTranslate = normalize(translate);
  var normalizedSnapGrid = snapGrid.map(function (val) {
    return normalize(val);
  });
  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

  if (typeof prevSnap === 'undefined' && params.cssMode) {
    snapGrid.forEach(function (snap) {
      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
    });
  }

  var prevIndex;

  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }

  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (threshold === void 0) {
    threshold = 0.5;
  }

  var swiper = this;
  var index = swiper.activeIndex;
  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    var currentSnap = swiper.snapGrid[snapIndex];
    var nextSnap = swiper.snapGrid[snapIndex + 1];

    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    var prevSnap = swiper.snapGrid[snapIndex - 1];
    var _currentSnap = swiper.snapGrid[snapIndex];

    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }

  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide() {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl;
  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  var slideToIndex = swiper.clickedIndex;
  var realIndex;

  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
        nextTick(function () {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
      nextTick(function () {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

const slide = {
  slideTo: slideTo,
  slideToLoop: slideToLoop,
  slideNext: slideNext,
  slidePrev: slidePrev,
  slideReset: slideReset,
  slideToClosest: slideToClosest,
  slideToClickedSlide: slideToClickedSlide
};

function loopCreate() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
  var slides = $wrapperEl.children("." + params.slideClass);

  if (params.loopFillGroupWithBlank) {
    var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

    if (blankSlidesNum !== params.slidesPerGroup) {
      for (var i = 0; i < blankSlidesNum; i += 1) {
        var blankNode = $(document.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
        $wrapperEl.append(blankNode);
      }

      slides = $wrapperEl.children("." + params.slideClass);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;

  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  var prependSlides = [];
  var appendSlides = [];
  slides.each(function (el, index) {
    var slide = $(el);

    if (index < swiper.loopedSlides) {
      appendSlides.push(el);
    }

    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }

    slide.attr('data-swiper-slide-index', index);
  });

  for (var _i = 0; _i < appendSlides.length; _i += 1) {
    $wrapperEl.append($(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }

  for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
    $wrapperEl.prepend($(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

function loopFix() {
  var swiper = this;
  swiper.emit('beforeLoopFix');
  var activeIndex = swiper.activeIndex,
      slides = swiper.slides,
      loopedSlides = swiper.loopedSlides,
      allowSlidePrev = swiper.allowSlidePrev,
      allowSlideNext = swiper.allowSlideNext,
      snapGrid = swiper.snapGrid,
      rtl = swiper.rtlTranslate;
  var newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  var snapTranslate = -snapGrid[activeIndex];
  var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    var slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;

    var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (_slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }

  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit('loopFix');
}

function loopDestroy() {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params,
      slides = swiper.slides;
  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
  slides.removeAttr('data-swiper-slide-index');
}

const loop = {
  loopCreate: loopCreate,
  loopFix: loopFix,
  loopDestroy: loopDestroy
};

function setGrabCursor(moving) {
  var swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  var el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

function unsetGrabCursor() {
  var swiper = this;

  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }

  swiper.el.style.cursor = '';
}

const grabCursor = {
  setGrabCursor: setGrabCursor,
  unsetGrabCursor: unsetGrabCursor
};

function appendSlide(slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params;

  if (params.loop) {
    swiper.loopDestroy();
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
}

function prependSlide(slides) {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex;

  if (params.loop) {
    swiper.loopDestroy();
  }

  var newActiveIndex = activeIndex + 1;

  if (typeof slides === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }

    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide(index, slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params,
      activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children("." + params.slideClass);
  }

  var baseLength = swiper.slides.length;

  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }

  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }

  var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  var slidesBuffer = [];

  for (var i = baseLength - 1; i >= index; i -= 1) {
    var currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (var _i = 0; _i < slides.length; _i += 1) {
      if (slides[_i]) $wrapperEl.append(slides[_i]);
    }

    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
    $wrapperEl.append(slidesBuffer[_i2]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide(slidesIndexes) {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children("." + params.slideClass);
  }

  var newActiveIndex = activeIndexBuffer;
  var indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (var i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }

    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides() {
  var swiper = this;
  var slidesIndexes = [];

  for (var i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }

  swiper.removeSlide(slidesIndexes);
}

const manipulation = {
  appendSlide: appendSlide,
  prependSlide: prependSlide,
  addSlide: addSlide,
  removeSlide: removeSlide,
  removeAllSlides: removeAllSlides
};

function onTouchStart(event) {
  var swiper = this;
  var document = getDocument();
  var window = getWindow();
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      enabled = swiper.enabled;
  if (!enabled) return;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }

  var e = event;
  if (e.originalEvent) e = e.originalEvent;
  var $targetEl = $(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }

  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return; // change target el for shadow root component

  var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = $(event.path[0]);
  }

  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
    swiper.allowClick = true;
    return;
  }

  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  var startX = touches.currentX;
  var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }

  extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;

  if (e.type !== 'touchstart') {
    var preventDefault = true;
    if ($targetEl.is(data.focusableElements)) preventDefault = false;

    if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }

    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }

  swiper.emit('touchStart', e);
}

function onTouchMove(event) {
  var document = getDocument();
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      rtl = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    return;
  }

  if (data.isTouchEvent && e.type !== 'touchmove') return;
  var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }

  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;

    if (data.isTouched) {
      extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }

    return;
  }

  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }

  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }

  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }

  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  var diffX = touches.currentX - touches.startX;
  var diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    var touchAngle;

    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }

  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }

  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }

  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }

  if (!data.startMoving) {
    return;
  }

  swiper.allowClick = false;

  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }

  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }

    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);

    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }

    data.allowMomentumBounce = false; // Grab Cursor

    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }

    swiper.emit('sliderFirstMove', e);
  }

  swiper.emit('sliderMove', e);
  data.isMoved = true;
  var diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) diff = -diff;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;
  var disableParentSwiper = true;
  var resistanceRatio = params.resistanceRatio;

  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }

  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  } // Directions locks


  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  } // Threshold


  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return; // Update active index in free mode

  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }

    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: now()
    });
  } // Update progress


  swiper.updateProgress(data.currentTranslate); // Update translate

  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd(event) {
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      rtl = swiper.rtlTranslate,
      $wrapperEl = swiper.$wrapperEl,
      slidesGrid = swiper.slidesGrid,
      snapGrid = swiper.snapGrid,
      enabled = swiper.enabled;
  if (!enabled) return;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }

  data.allowTouchCallbacks = false;

  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }

    data.isMoved = false;
    data.startMoving = false;
    return;
  } // Return Grab Cursor


  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  } // Time diff


  var touchEndTime = now();
  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);

    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = now();
  nextTick(function () {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  var currentPos;

  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }

      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        var lastMoveEvent = data.velocities.pop();
        var velocityEvent = data.velocities.pop();
        var distance = lastMoveEvent.position - velocityEvent.position;
        var time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;

        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        } // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.


        if (time > 150 || now() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }

      swiper.velocity *= params.freeModeMomentumVelocityRatio;
      data.velocities.length = 0;
      var momentumDuration = 1000 * params.freeModeMomentumRatio;
      var momentumDistance = swiper.velocity * momentumDuration;
      var newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      var doBounce = false;
      var afterBouncePosition;
      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      var needsLoopFix;

      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }

          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }

          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        var nextSlide;

        for (var j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }

        newPosition = -newPosition;
      }

      if (needsLoopFix) {
        swiper.once('transitionEnd', function () {
          swiper.loopFix();
        });
      } // Fix duration


      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }

        if (params.freeModeSticky) {
          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(function () {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(function () {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);

        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(function () {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      swiper.emit('_freeModeNoMomentumRelease');
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    return;
  } // Find current slide


  var stopIndex = 0;
  var groupSize = swiper.slidesSizesGrid[0];

  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (typeof slidesGrid[i + _increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + _increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  } // Find current slide size


  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }

    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }

      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize() {
  var swiper = this;
  var params = swiper.params,
      el = swiper.el;
  if (el && el.offsetWidth === 0) return; // Breakpoints

  if (params.breakpoints) {
    swiper.setBreakpoint();
  } // Save locks


  var allowSlideNext = swiper.allowSlideNext,
      allowSlidePrev = swiper.allowSlidePrev,
      snapGrid = swiper.snapGrid; // Disable locks on resize

  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();

  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  } // Return locks after resize


  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick(e) {
  var swiper = this;
  if (!swiper.enabled) return;

  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();

    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll() {
  var swiper = this;
  var wrapperEl = swiper.wrapperEl,
      rtlTranslate = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;

  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  } // eslint-disable-next-line


  if (swiper.translate === -0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}

var dummyEventAttached = false;

function dummyEventListener() {}

function attachEvents() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      touchEvents = swiper.touchEvents,
      el = swiper.el,
      wrapperEl = swiper.wrapperEl,
      device = swiper.device,
      support = swiper.support;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);

  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);
  var capture = !!params.nested; // Touch Events

  if (!support.touch && support.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
        passive: false,
        capture: capture
      } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }

      if (!dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    }

    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.addEventListener('mousedown', swiper.onTouchStart, false);
      document.addEventListener('mousemove', swiper.onTouchMove, capture);
      document.addEventListener('mouseup', swiper.onTouchEnd, false);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.addEventListener('scroll', swiper.onScroll);
  } // Resize handler


  if (params.updateOnWindowResize) {
    swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper.on('observerUpdate', onResize, true);
  }
}

function detachEvents() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      touchEvents = swiper.touchEvents,
      el = swiper.el,
      wrapperEl = swiper.wrapperEl,
      device = swiper.device,
      support = swiper.support;
  var capture = !!params.nested; // Touch Events

  if (!support.touch && support.pointerEvents) {
    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }

    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.removeEventListener('mousedown', swiper.onTouchStart, false);
      document.removeEventListener('mousemove', swiper.onTouchMove, capture);
      document.removeEventListener('mouseup', swiper.onTouchEnd, false);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el.removeEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.removeEventListener('scroll', swiper.onScroll);
  } // Resize handler


  swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
}

const events = {
  attachEvents: attachEvents,
  detachEvents: detachEvents
};

function setBreakpoint() {
  var swiper = this;
  var activeIndex = swiper.activeIndex,
      initialized = swiper.initialized,
      _swiper$loopedSlides = swiper.loopedSlides,
      loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
      params = swiper.params,
      $el = swiper.$el;
  var breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

  var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

  if (breakpointOnlyParams) {
    ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
      var paramValue = breakpointOnlyParams[param];
      if (typeof paramValue === 'undefined') return;

      if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
        breakpointOnlyParams[param] = 'auto';
      } else if (param === 'slidesPerView') {
        breakpointOnlyParams[param] = parseFloat(paramValue);
      } else {
        breakpointOnlyParams[param] = parseInt(paramValue, 10);
      }
    });
  }

  var breakpointParams = breakpointOnlyParams || swiper.originalParams;
  var wasMultiRow = params.slidesPerColumn > 1;
  var isMultiRow = breakpointParams.slidesPerColumn > 1;
  var wasEnabled = params.enabled;

  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(params.containerModifierClass + "multirow");

    if (breakpointParams.slidesPerColumnFill === 'column') {
      $el.addClass(params.containerModifierClass + "multirow-column");
    }

    swiper.emitContainerClasses();
  }

  var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

  if (directionChanged && initialized) {
    swiper.changeDirection();
  }

  extend(swiper.params, breakpointParams);
  var isEnabled = swiper.params.enabled;
  extend(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });

  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }

  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);

  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }

  swiper.emit('breakpoint', breakpointParams);
}

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }

  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  var breakpoint = false;
  var window = getWindow();
  var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  var points = Object.keys(breakpoints).map(function (point) {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      var minRatio = parseFloat(point.substr(1));
      var value = currentHeight * minRatio;
      return {
        value: value,
        point: point
      };
    }

    return {
      value: point,
      point: point
    };
  });
  points.sort(function (a, b) {
    return parseInt(a.value, 10) - parseInt(b.value, 10);
  });

  for (var i = 0; i < points.length; i += 1) {
    var _points$i = points[i],
        point = _points$i.point,
        value = _points$i.value;

    if (base === 'window') {
      if (window.matchMedia("(min-width: " + value + "px)").matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }

  return breakpoint || 'max';
}

const breakpoints = {
  setBreakpoint: setBreakpoint,
  getBreakpoint: getBreakpoint
};

function prepareClasses(entries, prefix) {
  var resultClasses = [];
  entries.forEach(function (item) {
    if (typeof item === 'object') {
      Object.keys(item).forEach(function (classNames) {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}

function addClasses() {
  var swiper = this;
  var classNames = swiper.classNames,
      params = swiper.params,
      rtl = swiper.rtl,
      $el = swiper.$el,
      device = swiper.device,
      support = swiper.support; // prettier-ignore

  var suffixes = prepareClasses(['initialized', params.direction, {
    'pointer-events': support.pointerEvents && !support.touch
  }, {
    'free-mode': params.freeMode
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'multirow': params.slidesPerColumn > 1
  }, {
    'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }], params.containerModifierClass);
  classNames.push.apply(classNames, suffixes);
  $el.addClass([].concat(classNames).join(' '));
  swiper.emitContainerClasses();
}

function removeClasses() {
  var swiper = this;
  var $el = swiper.$el,
      classNames = swiper.classNames;
  $el.removeClass(classNames.join(' '));
  swiper.emitContainerClasses();
}

const classes = {
  addClasses: addClasses,
  removeClasses: removeClasses
};

function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  var window = getWindow();
  var image;

  function onReady() {
    if (callback) callback();
  }

  var isPicture = $(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window.Image();
      image.onload = onReady;
      image.onerror = onReady;

      if (sizes) {
        image.sizes = sizes;
      }

      if (srcset) {
        image.srcset = srcset;
      }

      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

function preloadImages() {
  var swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');

  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }

  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
    var imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
  }
}

const images = {
  loadImage: loadImage,
  preloadImages: preloadImages
};

function checkOverflow() {
  var swiper = this;
  var params = swiper.params;
  var wasLocked = swiper.isLocked;
  var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
    swiper.isLocked = lastSlidePosition <= swiper.size;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked; // events

  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    if (swiper.navigation) swiper.navigation.update();
  }
}

const checkOverflow$1 = {
  checkOverflow: checkOverflow
};

const defaults = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: false,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // Images
  preloadImages: true,
  updateOnImagesReady: true,
  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  // NS
  containerModifierClass: 'swiper-container-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var prototypes = {
  modular: modular,
  eventsEmitter: eventsEmitter,
  update: update,
  translate: translate,
  transition: transition,
  slide: slide,
  loop: loop,
  grabCursor: grabCursor,
  manipulation: manipulation,
  events: events,
  breakpoints: breakpoints,
  checkOverflow: checkOverflow$1,
  classes: classes,
  images: images
};
var extendedDefaults = {};

var Swiper = /*#__PURE__*/function () {
  function Swiper() {
    var el;
    var params;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      el = args[0];
      params = args[1];
    }

    if (!params) params = {};
    params = extend({}, params);
    if (el && !params.el) params.el = el;

    if (params.el && $(params.el).length > 1) {
      var swipers = [];
      $(params.el).each(function (containerEl) {
        var newParams = extend({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    } // Swiper Instance


    var swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];

    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }

    Object.keys(swiper.modules).forEach(function (moduleName) {
      var module = swiper.modules[moduleName];

      if (module.params) {
        var moduleParamName = Object.keys(module.params)[0];
        var moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) return;

        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }

        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }

        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }

        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
      }
    }); // Extend defaults with modules params

    var swiperParams = extend({}, defaults);
    swiper.useParams(swiperParams); // Extend defaults with passed params

    swiper.params = extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend({}, swiper.params);
    swiper.passedParams = extend({}, params); // add event listeners

    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(function (eventName) {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }

    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    } // Save Dom lib


    swiper.$ = $; // Extend Swiper

    extend(swiper, {
      enabled: swiper.params.enabled,
      el: el,
      // Classes
      classNames: [],
      // Slides
      slides: $(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal: function isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical: function isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEvents: function touchEvents() {
        var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        var desktop = ['mousedown', 'mousemove', 'mouseup'];

        if (swiper.support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        }

        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    }); // Install Modules

    swiper.useModules();
    swiper.emit('_swiper'); // Init

    if (swiper.params.init) {
      swiper.init();
    } // Return app instance


    return swiper;
  }

  var _proto = Swiper.prototype;

  _proto.enable = function enable() {
    var swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;

    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    swiper.emit('enable');
  };

  _proto.disable = function disable() {
    var swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;

    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }

    swiper.emit('disable');
  };

  _proto.setProgress = function setProgress(progress, speed) {
    var swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    var min = swiper.minTranslate();
    var max = swiper.maxTranslate();
    var current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  };

  _proto.emitContainerClasses = function emitContainerClasses() {
    var swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    var classes = swiper.el.className.split(' ').filter(function (className) {
      return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', classes.join(' '));
  };

  _proto.getSlideClasses = function getSlideClasses(slideEl) {
    var swiper = this;
    return slideEl.className.split(' ').filter(function (className) {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  };

  _proto.emitSlidesClasses = function emitSlidesClasses() {
    var swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    var updates = [];
    swiper.slides.each(function (slideEl) {
      var classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl: slideEl,
        classNames: classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  };

  _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
    var swiper = this;
    var params = swiper.params,
        slides = swiper.slides,
        slidesGrid = swiper.slidesGrid,
        swiperSize = swiper.size,
        activeIndex = swiper.activeIndex;
    var spv = 1;

    if (params.centeredSlides) {
      var slideSize = slides[activeIndex].swiperSlideSize;
      var breakLoop;

      for (var i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }

      for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
        if (slides[_i] && !breakLoop) {
          slideSize += slides[_i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
        if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }

    return spv;
  };

  _proto.update = function update() {
    var swiper = this;
    if (!swiper || swiper.destroyed) return;
    var snapGrid = swiper.snapGrid,
        params = swiper.params; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    }

    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    var translated;

    if (swiper.params.freeMode) {
      setTranslate();

      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (!translated) {
        setTranslate();
      }
    }

    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }

    swiper.emit('update');
  };

  _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }

    var swiper = this;
    var currentDirection = swiper.params.direction;

    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }

    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }

    swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each(function (slideEl) {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  };

  _proto.mount = function mount(el) {
    var swiper = this;
    if (swiper.mounted) return true; // Find el

    var $el = $(el || swiper.params.el);
    el = $el[0];

    if (!el) {
      return false;
    }

    el.swiper = swiper;

    var getWrapperSelector = function getWrapperSelector() {
      return "." + (swiper.params.wrapperClass || '').trim().split(' ').join('.');
    };

    var getWrapper = function getWrapper() {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        var res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

        res.children = function (options) {
          return $el.children(options);
        };

        return res;
      }

      return $el.children(getWrapperSelector());
    }; // Find Wrapper


    var $wrapperEl = getWrapper();

    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      var document = getDocument();
      var wrapper = document.createElement('div');
      $wrapperEl = $(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children("." + swiper.params.slideClass).each(function (slideEl) {
        $wrapperEl.append(slideEl);
      });
    }

    extend(swiper, {
      $el: $el,
      el: el,
      $wrapperEl: $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box'
    });
    return true;
  };

  _proto.init = function init(el) {
    var swiper = this;
    if (swiper.initialized) return swiper;
    var mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit'); // Set breakpoint

    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    } // Add Classes


    swiper.addClasses(); // Create loop

    if (swiper.params.loop) {
      swiper.loopCreate();
    } // Update size


    swiper.updateSize(); // Update slides

    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    } // Set Grab Cursor


    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    } // Slide To Initial Slide


    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    } // Attach events


    swiper.attachEvents(); // Init Flag

    swiper.initialized = true; // Emit

    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  };

  _proto.destroy = function destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }

    if (cleanStyles === void 0) {
      cleanStyles = true;
    }

    var swiper = this;
    var params = swiper.params,
        $el = swiper.$el,
        $wrapperEl = swiper.$wrapperEl,
        slides = swiper.slides;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy'); // Init Flag

    swiper.initialized = false; // Detach events

    swiper.detachEvents(); // Destroy loop

    if (params.loop) {
      swiper.loopDestroy();
    } // Cleanup styles


    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');

      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy'); // Detach emitter events

    Object.keys(swiper.eventsListeners).forEach(function (eventName) {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      deleteProps(swiper);
    }

    swiper.destroyed = true;
    return null;
  };

  Swiper.extendDefaults = function extendDefaults(newDefaults) {
    extend(extendedDefaults, newDefaults);
  };

  Swiper.installModule = function installModule(module) {
    if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
    var name = module.name || Object.keys(Swiper.prototype.modules).length + "_" + now();
    Swiper.prototype.modules[name] = module;
  };

  Swiper.use = function use(module) {
    if (Array.isArray(module)) {
      module.forEach(function (m) {
        return Swiper.installModule(m);
      });
      return Swiper;
    }

    Swiper.installModule(module);
    return Swiper;
  };

  _createClass(Swiper, null, [{
    key: "extendedDefaults",
    get: function get() {
      return extendedDefaults;
    }
  }, {
    key: "defaults",
    get: function get() {
      return defaults;
    }
  }]);

  return Swiper;
}();

Object.keys(prototypes).forEach(function (prototypeGroup) {
  Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer$1]);

function _extends$6() { _extends$6 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }
var Navigation = {
  toggleEl: function toggleEl($el, disabled) {
    $el[disabled ? 'addClass' : 'removeClass'](this.params.navigation.disabledClass);
    if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
  },
  update: function update() {
    // Update Navigation Buttons
    var swiper = this;
    var params = swiper.params.navigation;
    var toggleEl = swiper.navigation.toggleEl;
    if (swiper.params.loop) return;
    var _swiper$navigation = swiper.navigation,
        $nextEl = _swiper$navigation.$nextEl,
        $prevEl = _swiper$navigation.$prevEl;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        toggleEl($prevEl, true);
      } else {
        toggleEl($prevEl, false);
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        $prevEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        toggleEl($nextEl, true);
      } else {
        toggleEl($nextEl, false);
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        $nextEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }
  },
  onPrevClick: function onPrevClick(e) {
    var swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick: function onNextClick(e) {
    var swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init: function init() {
    var swiper = this;
    var params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper.$el, swiper.params.navigation, swiper.params.createElements, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    var $nextEl;
    var $prevEl;

    if (params.nextEl) {
      $nextEl = $(params.nextEl);

      if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }

    if (params.prevEl) {
      $prevEl = $(params.prevEl);

      if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }

    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    extend(swiper.navigation, {
      $nextEl: $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl: $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });

    if (!swiper.enabled) {
      if ($nextEl) $nextEl.addClass(params.lockClass);
      if ($prevEl) $prevEl.addClass(params.lockClass);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var _swiper$navigation2 = swiper.navigation,
        $nextEl = _swiper$navigation2.$nextEl,
        $prevEl = _swiper$navigation2.$prevEl;

    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }

    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }
};
const Navigation$1 = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      navigation: _extends$6({}, Navigation)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge: function toEdge(swiper) {
      swiper.navigation.update();
    },
    fromEdge: function fromEdge(swiper) {
      swiper.navigation.update();
    },
    destroy: function destroy(swiper) {
      swiper.navigation.destroy();
    },
    'enable disable': function enableDisable(swiper) {
      var _swiper$navigation3 = swiper.navigation,
          $nextEl = _swiper$navigation3.$nextEl,
          $prevEl = _swiper$navigation3.$prevEl;

      if ($nextEl) {
        $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }

      if ($prevEl) {
        $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }
    },
    click: function click(swiper, e) {
      var _swiper$navigation4 = swiper.navigation,
          $nextEl = _swiper$navigation4.$nextEl,
          $prevEl = _swiper$navigation4.$prevEl;
      var targetEl = e.target;

      if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        var isHidden;

        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }

        if (isHidden === true) {
          swiper.emit('navigationShow');
        } else {
          swiper.emit('navigationHide');
        }

        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }

        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    }
  }
};

function _extends$5() { _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }
var Pagination = {
  update: function update() {
    // Render || Update Pagination bullets/items
    var swiper = this;
    var rtl = swiper.rtl;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    var $el = swiper.pagination.$el; // Current/Total

    var current;
    var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }

      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    } // Types


    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      var bullets = swiper.pagination.bullets;
      var firstIndex;
      var lastIndex;
      var midIndex;

      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

          if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }

        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }

      bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

      if ($el.length > 1) {
        bullets.each(function (bullet) {
          var $bullet = $(bullet);
          var bulletIndex = $bullet.index();

          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }

          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(params.bulletActiveClass + "-main");
            }

            if (bulletIndex === firstIndex) {
              $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
            }

            if (bulletIndex === lastIndex) {
              $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
            }
          }
        });
      } else {
        var $bullet = bullets.eq(current);
        var bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);

        if (params.dynamicBullets) {
          var $firstDisplayedBullet = bullets.eq(firstIndex);
          var $lastDisplayedBullet = bullets.eq(lastIndex);

          for (var i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(params.bulletActiveClass + "-main");
          }

          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
              for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + "-main");
              }

              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
            } else {
              $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
              $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
            }
          } else {
            $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
            $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
          }
        }
      }

      if (params.dynamicBullets) {
        var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
        var offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
      }
    }

    if (params.type === 'fraction') {
      $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
    }

    if (params.type === 'progressbar') {
      var progressbarDirection;

      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }

      var scale = (current + 1) / total;
      var scaleX = 1;
      var scaleY = 1;

      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }

      $el.find(classesToSelector(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
    }

    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', $el[0]);
    } else {
      swiper.emit('paginationUpdate', $el[0]);
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  render: function render() {
    // Render Container
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    var $el = swiper.pagination.$el;
    var paginationHTML = '';

    if (params.type === 'bullets') {
      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }

      for (var i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
        }
      }

      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
    }

    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + ("<span class=\"" + params.totalClass + "\"></span>");
      }

      $el.html(paginationHTML);
    }

    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
      }

      $el.html(paginationHTML);
    }

    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init: function init() {
    var swiper = this;
    swiper.params.pagination = createElementIfNotDefined(swiper.$el, swiper.params.pagination, swiper.params.createElements, {
      el: 'swiper-pagination'
    });
    var params = swiper.params.pagination;
    if (!params.el) return;
    var $el = $(params.el);
    if ($el.length === 0) return;

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass("" + params.modifierClass + params.type + "-dynamic");
      swiper.pagination.dynamicBulletIndex = 0;

      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }

    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
        e.preventDefault();
        var index = $(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    extend(swiper.pagination, {
      $el: $el,
      el: $el[0]
    });

    if (!swiper.enabled) {
      $el.addClass(params.lockClass);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

    if (params.clickable) {
      $el.off('click', classesToSelector(params.bulletClass));
    }
  }
};
const Pagination$1 = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: function formatFractionCurrent(number) {
        return number;
      },
      formatFractionTotal: function formatFractionTotal(number) {
        return number;
      },
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-',
      // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable',
      // NEW
      lockClass: 'swiper-pagination-lock'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      pagination: _extends$5({
        dynamicBulletIndex: 0
      }, Pagination)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange: function activeIndexChange(swiper) {
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange: function snapIndexChange(swiper) {
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange: function slidesLengthChange(swiper) {
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange: function snapGridLengthChange(swiper) {
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy: function destroy(swiper) {
      swiper.pagination.destroy();
    },
    'enable disable': function enableDisable(swiper) {
      var $el = swiper.pagination.$el;

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
      }
    },
    click: function click(swiper, e) {
      var targetEl = e.target;

      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

        if (isHidden === true) {
          swiper.emit('paginationShow');
        } else {
          swiper.emit('paginationHide');
        }

        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    }
  }
};

function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
var Lazy = {
  loadInSlide: function loadInSlide(index, loadInDuplicate) {
    if (loadInDuplicate === void 0) {
      loadInDuplicate = true;
    }

    var swiper = this;
    var params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + index + "\"]") : swiper.slides.eq(index);
    var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");

    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images.push($slideEl[0]);
    }

    if ($images.length === 0) return;
    $images.each(function (imageEl) {
      var $imageEl = $(imageEl);
      $imageEl.addClass(params.loadingClass);
      var background = $imageEl.attr('data-background');
      var src = $imageEl.attr('data-src');
      var srcset = $imageEl.attr('data-srcset');
      var sizes = $imageEl.attr('data-sizes');
      var $pictureEl = $imageEl.parent('picture');
      swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;

        if (background) {
          $imageEl.css('background-image', "url(\"" + background + "\")");
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }

          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }

          if ($pictureEl.length) {
            $pictureEl.children('source').each(function (sourceEl) {
              var $source = $(sourceEl);

              if ($source.attr('data-srcset')) {
                $source.attr('srcset', $source.attr('data-srcset'));
                $source.removeAttr('data-srcset');
              }
            });
          }

          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find("." + params.preloaderClass).remove();

        if (swiper.params.loop && loadInDuplicate) {
          var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            var originalSlide = swiper.$wrapperEl.children("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + swiper.params.slideDuplicateClass + ")");
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]");
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }

        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });
      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load: function load() {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl,
        swiperParams = swiper.params,
        slides = swiper.slides,
        activeIndex = swiper.activeIndex;
    var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    var params = swiperParams.lazy;
    var slidesPerView = swiperParams.slidesPerView;

    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children("." + swiperParams.slideClass + "[data-swiper-slide-index=\"" + index + "\"]").length) {
          return true;
        }
      } else if (slides[index]) return true;

      return false;
    }

    function slideIndex(slideEl) {
      if (isVirtual) {
        return $(slideEl).attr('data-swiper-slide-index');
      }

      return $(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;

    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function (slideEl) {
        var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }

    if (params.loadPrevNext) {
      if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
        var amount = params.loadPrevNextAmount;
        var spv = slidesPerView;
        var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

        for (var _i = activeIndex + slidesPerView; _i < maxIndex; _i += 1) {
          if (slideExist(_i)) swiper.lazy.loadInSlide(_i);
        } // Prev Slides


        for (var _i2 = minIndex; _i2 < activeIndex; _i2 += 1) {
          if (slideExist(_i2)) swiper.lazy.loadInSlide(_i2);
        }
      } else {
        var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));
        var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
  checkInViewOnLoad: function checkInViewOnLoad() {
    var window = getWindow();
    var swiper = this;
    if (!swiper || swiper.destroyed) return;
    var $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);
    var isWindow = $scrollElement[0] === window;
    var scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
    var scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
    var swiperOffset = swiper.$el.offset();
    var rtl = swiper.rtlTranslate;
    var inView = false;
    if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
    var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

    for (var i = 0; i < swiperCoord.length; i += 1) {
      var point = swiperCoord[i];

      if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

        inView = true;
      }
    }

    var passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;

    if (inView) {
      swiper.lazy.load();
      $scrollElement.off('scroll', swiper.lazy.checkInViewOnLoad, passiveListener);
    } else if (!swiper.lazy.scrollHandlerAttached) {
      swiper.lazy.scrollHandlerAttached = true;
      $scrollElement.on('scroll', swiper.lazy.checkInViewOnLoad, passiveListener);
    }
  }
};
const Lazy$1 = {
  name: 'lazy',
  params: {
    lazy: {
      checkInView: false,
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,
      scrollingElement: '',
      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      lazy: _extends$4({
        initialImageLoaded: false
      }, Lazy)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init: function init(swiper) {
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        if (swiper.params.lazy.checkInView) {
          swiper.lazy.checkInViewOnLoad();
        } else {
          swiper.lazy.load();
        }
      }
    },
    scroll: function scroll(swiper) {
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    'scrollbarDragMove resize _freeModeNoMomentumRelease': function lazyLoad(swiper) {
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart: function transitionStart(swiper) {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd: function transitionEnd(swiper) {
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
    slideChange: function slideChange(swiper) {
      var _swiper$params = swiper.params,
          lazy = _swiper$params.lazy,
          cssMode = _swiper$params.cssMode,
          watchSlidesVisibility = _swiper$params.watchSlidesVisibility,
          watchSlidesProgress = _swiper$params.watchSlidesProgress,
          touchReleaseOnEdges = _swiper$params.touchReleaseOnEdges,
          resistanceRatio = _swiper$params.resistanceRatio;

      if (lazy.enabled && (cssMode || (watchSlidesVisibility || watchSlidesProgress) && (touchReleaseOnEdges || resistanceRatio === 0))) {
        swiper.lazy.load();
      }
    }
  }
};

function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
var A11y = {
  getRandomNumber: function getRandomNumber(size) {
    if (size === void 0) {
      size = 16;
    }

    var randomChar = function randomChar() {
      return Math.round(16 * Math.random()).toString(16);
    };

    return 'x'.repeat(size).replace(/x/g, randomChar);
  },
  makeElFocusable: function makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  makeElNotFocusable: function makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
    return $el;
  },
  addElRole: function addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElRoleDescription: function addElRoleDescription($el, description) {
    $el.attr('aria-roledescription', description);
    return $el;
  },
  addElControls: function addElControls($el, controls) {
    $el.attr('aria-controls', controls);
    return $el;
  },
  addElLabel: function addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  addElId: function addElId($el, id) {
    $el.attr('id', id);
    return $el;
  },
  addElLive: function addElLive($el, live) {
    $el.attr('aria-live', live);
    return $el;
  },
  disableEl: function disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl: function enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterOrSpaceKey: function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    var swiper = this;
    var params = swiper.params.a11y;
    var $targetEl = $(e.target);

    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }

      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }

    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }

      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }

    if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
      $targetEl[0].click();
    }
  },
  notify: function notify(message) {
    var swiper = this;
    var notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation: function updateNavigation() {
    var swiper = this;
    if (swiper.params.loop || !swiper.navigation) return;
    var _swiper$navigation = swiper.navigation,
        $nextEl = _swiper$navigation.$nextEl,
        $prevEl = _swiper$navigation.$prevEl;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
        swiper.a11y.makeElNotFocusable($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
        swiper.a11y.makeElFocusable($prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
        swiper.a11y.makeElNotFocusable($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
        swiper.a11y.makeElFocusable($nextEl);
      }
    }
  },
  updatePagination: function updatePagination() {
    var swiper = this;
    var params = swiper.params.a11y;

    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each(function (bulletEl) {
        var $bulletEl = $(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);

        if (!swiper.params.pagination.renderBullet) {
          swiper.a11y.addElRole($bulletEl, 'button');
          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        }
      });
    }
  },
  init: function init() {
    var swiper = this;
    var params = swiper.params.a11y;
    swiper.$el.append(swiper.a11y.liveRegion); // Container

    var $containerEl = swiper.$el;

    if (params.containerRoleDescriptionMessage) {
      swiper.a11y.addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
    }

    if (params.containerMessage) {
      swiper.a11y.addElLabel($containerEl, params.containerMessage);
    } // Wrapper


    var $wrapperEl = swiper.$wrapperEl;
    var wrapperId = $wrapperEl.attr('id') || "swiper-wrapper-" + swiper.a11y.getRandomNumber(16);
    var live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    swiper.a11y.addElId($wrapperEl, wrapperId);
    swiper.a11y.addElLive($wrapperEl, live); // Slide

    if (params.itemRoleDescriptionMessage) {
      swiper.a11y.addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
    }

    swiper.a11y.addElRole($(swiper.slides), params.slideRole);
    var slidesLength = swiper.params.loop ? swiper.slides.filter(function (el) {
      return !el.classList.contains(swiper.params.slideDuplicateClass);
    }).length : swiper.slides.length;
    swiper.slides.each(function (slideEl, index) {
      var $slideEl = $(slideEl);
      var slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
      var ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
      swiper.a11y.addElLabel($slideEl, ariaLabelMessage);
    }); // Navigation

    var $nextEl;
    var $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl && $nextEl.length) {
      swiper.a11y.makeElFocusable($nextEl);

      if ($nextEl[0].tagName !== 'BUTTON') {
        swiper.a11y.addElRole($nextEl, 'button');
        $nextEl.on('keydown', swiper.a11y.onEnterOrSpaceKey);
      }

      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      swiper.a11y.addElControls($nextEl, wrapperId);
    }

    if ($prevEl && $prevEl.length) {
      swiper.a11y.makeElFocusable($prevEl);

      if ($prevEl[0].tagName !== 'BUTTON') {
        swiper.a11y.addElRole($prevEl, 'button');
        $prevEl.on('keydown', swiper.a11y.onEnterOrSpaceKey);
      }

      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      swiper.a11y.addElControls($prevEl, wrapperId);
    } // Pagination


    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();
    var $nextEl;
    var $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterOrSpaceKey);
    }

    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterOrSpaceKey);
    } // Pagination


    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
    }
  }
};
const A11y$1 = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      a11y: _extends$3({}, A11y, {
        liveRegion: $("<span class=\"" + swiper.params.a11y.notificationClass + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")
      })
    });
  },
  on: {
    afterInit: function afterInit(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge: function toEdge(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge: function fromEdge(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate: function paginationUpdate(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy: function destroy(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    }
  }
};

function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }
var Autoplay = {
  run: function run() {
    var swiper = this;
    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    var delay = swiper.params.autoplay.delay;

    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }

    clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.timeout = nextTick(function () {
      var autoplayResult;

      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }

      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();else if (autoplayResult === false) {
        swiper.autoplay.run();
      }
    }, delay);
  },
  start: function start() {
    var swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop: function stop() {
    var swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }

    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause: function pause(speed) {
    var swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;

    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        swiper.$wrapperEl[0].addEventListener(event, swiper.autoplay.onTransitionEnd);
      });
    }
  },
  onVisibilityChange: function onVisibilityChange() {
    var swiper = this;
    var document = getDocument();

    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
      swiper.autoplay.pause();
    }

    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
      swiper.autoplay.run();
      swiper.autoplay.paused = false;
    }
  },
  onTransitionEnd: function onTransitionEnd(e) {
    var swiper = this;
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
    if (e.target !== swiper.$wrapperEl[0]) return;
    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      swiper.$wrapperEl[0].removeEventListener(event, swiper.autoplay.onTransitionEnd);
    });
    swiper.autoplay.paused = false;

    if (!swiper.autoplay.running) {
      swiper.autoplay.stop();
    } else {
      swiper.autoplay.run();
    }
  },
  onMouseEnter: function onMouseEnter() {
    var swiper = this;

    if (swiper.params.autoplay.disableOnInteraction) {
      swiper.autoplay.stop();
    } else {
      swiper.autoplay.pause();
    }

    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      swiper.$wrapperEl[0].removeEventListener(event, swiper.autoplay.onTransitionEnd);
    });
  },
  onMouseLeave: function onMouseLeave() {
    var swiper = this;

    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }

    swiper.autoplay.paused = false;
    swiper.autoplay.run();
  },
  attachMouseEvents: function attachMouseEvents() {
    var swiper = this;

    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on('mouseenter', swiper.autoplay.onMouseEnter);
      swiper.$el.on('mouseleave', swiper.autoplay.onMouseLeave);
    }
  },
  detachMouseEvents: function detachMouseEvents() {
    var swiper = this;
    swiper.$el.off('mouseenter', swiper.autoplay.onMouseEnter);
    swiper.$el.off('mouseleave', swiper.autoplay.onMouseLeave);
  }
};
const Autoplay$1 = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      autoplay: _extends$2({}, Autoplay, {
        running: false,
        paused: false
      })
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
        var document = getDocument();
        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
        swiper.autoplay.attachMouseEvents();
      }
    },
    beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove: function sliderFirstMove(swiper) {
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    touchEnd: function touchEnd(swiper) {
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.run();
      }
    },
    destroy: function destroy(swiper) {
      swiper.autoplay.detachMouseEvents();

      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }

      var document = getDocument();
      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
    }
  }
};

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
var Fade = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var slides = swiper.slides;

    for (var i = 0; i < slides.length; i += 1) {
      var $slideEl = swiper.slides.eq(i);
      var offset = $slideEl[0].swiperSlideOffset;
      var tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      var ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }

      var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl.css({
        opacity: slideOpacity
      }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    var slides = swiper.slides,
        $wrapperEl = swiper.$wrapperEl;
    slides.transition(duration);

    if (swiper.params.virtualTranslate && duration !== 0) {
      var eventTriggered = false;
      slides.transitionEnd(function () {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

        for (var i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }
};
const EffectFade = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      fadeEffect: _extends$1({}, Fade)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(swiper.params.containerModifierClass + "fade");
      var overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true
      };
      extend(swiper.params, overwriteParams);
      extend(swiper.originalParams, overwriteParams);
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    }
  }
};

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var Thumbs = {
  init: function init() {
    var swiper = this;
    var thumbsParams = swiper.params.thumbs;
    if (swiper.thumbs.initialized) return false;
    swiper.thumbs.initialized = true;
    var SwiperClass = swiper.constructor;

    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      extend(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      extend(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
    } else if (isObject(thumbsParams.swiper)) {
      swiper.thumbs.swiper = new SwiperClass(extend({}, thumbsParams.swiper, {
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        slideToClickedSlide: false
      }));
      swiper.thumbs.swiperCreated = true;
    }

    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
    return true;
  },
  onThumbClick: function onThumbClick() {
    var swiper = this;
    var thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    var clickedIndex = thumbsSwiper.clickedIndex;
    var clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    var slideToIndex;

    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }

    if (swiper.params.loop) {
      var currentIndex = swiper.activeIndex;

      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }

      var prevIndex = swiper.slides.eq(currentIndex).prevAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
      var nextIndex = swiper.slides.eq(currentIndex).nextAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
    }

    swiper.slideTo(slideToIndex);
  },
  update: function update(initial) {
    var swiper = this;
    var thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
    var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      var currentThumbsIndex = thumbsSwiper.activeIndex;
      var newThumbsIndex;
      var direction;

      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix(); // eslint-disable-next-line

          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        } // Find actual thumbs index to slide to


        var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();
        var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();

        if (typeof prevThumbsIndex === 'undefined') {
          newThumbsIndex = nextThumbsIndex;
        } else if (typeof nextThumbsIndex === 'undefined') {
          newThumbsIndex = prevThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = nextThumbsIndex;
        } else {
          newThumbsIndex = prevThumbsIndex;
        }

        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }

      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }

      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        }

        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    } // Activate thumbs


    var thumbsToActivate = 1;
    var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }

    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.removeClass(thumbActiveClass);

    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (var i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]").addClass(thumbActiveClass);
      }
    } else {
      for (var _i = 0; _i < thumbsToActivate; _i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + _i).addClass(thumbActiveClass);
      }
    }
  }
};
const Thumbs$1 = {
  name: 'thumbs',
  params: {
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-container-thumbs'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      thumbs: _extends({
        swiper: null,
        initialized: false
      }, Thumbs)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      var thumbs = swiper.params.thumbs;
      if (!thumbs || !thumbs.swiper) return;
      swiper.thumbs.init();
      swiper.thumbs.update(true);
    },
    slideChange: function slideChange(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    update: function update(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    resize: function resize(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    observerUpdate: function observerUpdate(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    setTransition: function setTransition(swiper, duration) {
      var thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    },
    beforeDestroy: function beforeDestroy(swiper) {
      var thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;

      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    }
  }
};

const spxSliderCss = ":host{}@font-face{font-family:\"swiper-icons\";src:url(\"data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA\") format(\"woff\");font-weight:400;font-style:normal}:host :root{--swiper-theme-color:#007aff}:host .swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}:host .swiper-container-vertical>.swiper-wrapper{flex-direction:column}:host .swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}:host .swiper-container-android .swiper-slide,:host .swiper-wrapper{transform:translate3d(0px, 0, 0)}:host .swiper-container-multirow>.swiper-wrapper{flex-wrap:wrap}:host .swiper-container-multirow-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}:host .swiper-container-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}:host .swiper-container-pointer-events{touch-action:pan-y}:host .swiper-container-pointer-events.swiper-container-vertical{touch-action:pan-x}:host .swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}:host .swiper-slide-invisible-blank{visibility:hidden}:host .swiper-container-autoheight,:host .swiper-container-autoheight .swiper-slide{height:auto}:host .swiper-container-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform, height}:host .swiper-container-3d{perspective:1200px}:host .swiper-container-3d .swiper-wrapper,:host .swiper-container-3d .swiper-slide,:host .swiper-container-3d .swiper-slide-shadow-left,:host .swiper-container-3d .swiper-slide-shadow-right,:host .swiper-container-3d .swiper-slide-shadow-top,:host .swiper-container-3d .swiper-slide-shadow-bottom,:host .swiper-container-3d .swiper-cube-shadow{transform-style:preserve-3d}:host .swiper-container-3d .swiper-slide-shadow-left,:host .swiper-container-3d .swiper-slide-shadow-right,:host .swiper-container-3d .swiper-slide-shadow-top,:host .swiper-container-3d .swiper-slide-shadow-bottom{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}:host .swiper-container-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}:host .swiper-container-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}:host .swiper-container-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}:host .swiper-container-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}:host .swiper-container-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none;}:host .swiper-container-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}:host .swiper-container-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}:host .swiper-container-horizontal.swiper-container-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}:host .swiper-container-vertical.swiper-container-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}:host .swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}:host .swiper-container-fade.swiper-container-free-mode .swiper-slide{transition-timing-function:ease-out}:host .swiper-container-fade .swiper-slide{pointer-events:none;transition-property:opacity}:host .swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}:host .swiper-container-fade .swiper-slide-active,:host .swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}:host :root{}:host .swiper-pagination{position:absolute;text-align:center;transition:300ms opacity;transform:translate3d(0, 0, 0);z-index:10}:host .swiper-pagination.swiper-pagination-hidden{opacity:0}:host .swiper-pagination-fraction,:host .swiper-pagination-custom,:host .swiper-container-horizontal>.swiper-pagination-bullets{bottom:10px;left:0;width:100%}:host .swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}:host .swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(0.33);position:relative}:host .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}:host .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}:host .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(0.66)}:host .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(0.33)}:host .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(0.66)}:host .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(0.33)}:host .swiper-pagination-bullet{width:8px;height:8px;display:inline-block;border-radius:50%;background:#000;opacity:0.2}:host button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;appearance:none}:host .swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}:host .swiper-pagination-bullet-active{opacity:1;background:var(--swiper-pagination-color, var(--swiper-theme-color))}:host .swiper-container-vertical>.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0px, -50%, 0)}:host .swiper-container-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;display:block}:host .swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}:host .swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:200ms transform, 200ms top}:host .swiper-container-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px}:host .swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}:host .swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:200ms transform, 200ms left}:host .swiper-container-horizontal.swiper-container-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:200ms transform, 200ms right}:host .swiper-pagination-progressbar{background:rgba(0, 0, 0, 0.25);position:absolute}:host .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color, var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}:host .swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}:host .swiper-container-horizontal>.swiper-pagination-progressbar,:host .swiper-container-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}:host .swiper-container-vertical>.swiper-pagination-progressbar,:host .swiper-container-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:4px;height:100%;left:0;top:0}:host .swiper-pagination-white{--swiper-pagination-color:#ffffff}:host .swiper-pagination-black{--swiper-pagination-color:#000000}:host .swiper-pagination-lock{display:none}";

const tag$4 = 'spx-slider';
const SpxScrollspy$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxSliderDidLoad = createEvent(this, "spxSliderDidLoad", 7);
    this.counter = 0;
    /** Automatically adjusts height of slider. */
    this.autoheight = false;
    /** Starts navigating to the next slide when page is loaded. */
    this.autoplay = false;
    /** Autoplay delay. */
    this.autoplayDelay = 6000;
    /** Disable autoplay after interaction with slides. */
    this.autoplayDisableOnInteraction = false;
    /** Centers slides in viewport. */
    this.centeredSlides = false;
    this.display = display$1;
    /**
     * Slider effect.
     *
     * @choice 'slide', 'effect'
     */
    this.effect = 'slide';
    /**
     * Image object-fit.
     *
     * @choice 'fill', 'contain', 'cover', 'scale-down', 'none'
     */
    this.imageObjectFit = 'cover';
    this.navigationBackdropFilter = backdropFilter;
    this.navigationBackground = 'rgba(0,0,0,0.7)';
    this.navigationBackgroundHover = 'rgba(0,0,0,1)';
    this.navigationBorderRadius = borderRadius;
    this.navigationColor = '#ffffff';
    /**
     * Navigation distance.
     *
     * @CSS
     */
    this.navigationDistanceX = '12px';
    /** Navigation icon type. */
    this.navigationIconNext = 'arrow-forward';
    /** Navigation icon type. */
    this.navigationIconPrev = 'arrow-back';
    /** Navigation icon type. */
    this.navigationIconType = 'ionicons';
    this.navigationPadding = '12px';
    /**
     * Navigation size.
     *
     * @CSS
     */
    this.navigationSize = '20px';
    this.navigationTransitionDuration = transitionDuration;
    this.navigationTransitionTimingFunction = transitionTimingFunction;
    /**
     * Pagination type.
     *
     * @choice 'bullets', 'none'
     */
    this.pagination = 'bullets';
    this.paginationBackdropFilter = backdropFilter;
    this.paginationBackground = 'rgba(0,0,0,0.7)';
    this.paginationBulletsBackground = 'var(--spx-color-gray-500)';
    this.paginationBulletsBackgroundActive = '#ffffff';
    /** Amount of dynamic bullets. */
    this.paginationBulletsDynamicAmount = 5;
    /**
     * Size of the bullets.
     *
     * @CSS
     */
    this.paginationBulletsSize = '6px';
    /**
     * Space between the bullets.
     *
     * @CSS
     */
    this.paginationBulletsSpaceBetween = '6px';
    this.paginationTransitionDuration = transitionDuration;
    this.paginationTransitionTimingFunction = transitionTimingFunction;
    /** Screen reader message for first slide. */
    this.slideMessageFirst = 'This is the first slide';
    /** Screen reader message for last slide. */
    this.slideMessageLast = 'This is the last slide';
    /** Screen reader message for next slide. */
    this.slideMessageNext = 'Next slide';
    /** Screen reader message for previous slide. */
    this.slideMessagePrevious = 'Previous slide';
    /** Amount of slides shown at once. */
    this.slidesPerView = 1;
    /** Space between slides. */
    this.spaceBetween = 0;
    /** Sliding speed. */
    this.speed = 1000;
    /**
     * Create breakpoint values.
     *
     * @returns {object} Object containing all breakpoints from properties.
     */
    this.createBps = () => {
      for (let att, i = 0, atts = this.el.attributes, n = atts.length; i < n; i++) {
        att = atts[i];
        if (startsWith(att.nodeName, 'bp-')) {
          const attribute = this.el.getAttribute(att.nodeName);
          const array = attribute.split(';');
          const pairsArray = [];
          array.forEach((item) => {
            pairsArray.push(item.replace(/ /g, '').replace(/"/g, '').split(':'));
          });
          const finalArray = fromPairs(pairsArray);
          const camelCaseArray = mapKeys(finalArray, function (_value, key) {
            return camelCase(key);
          });
          const breakpoint = att.nodeName.split('-')[1];
          return { [breakpoint]: camelCaseArray };
        }
      }
    };
    /** Init swiper. */
    this.initSwiper = () => {
      var _a;
      /** Wrap all children in div. */
      this.container.querySelectorAll(':scope > *').forEach((item) => {
        const div = document.createElement('div');
        div.classList.add('swiper-slide');
        wrap(item, div);
        if (this.lazy) {
          div.querySelector('img').classList.add('swiper-lazy');
        }
      });
      /** Use modules so autoplay works in build mode. */
      Swiper.use([
        Autoplay$1,
        Navigation$1,
        Pagination$1,
        A11y$1,
        Thumbs$1,
        Lazy$1,
        EffectFade,
      ]);
      /** Create swiper. */
      this.mySwiper = new Swiper(this.swiperContainer, {
        a11y: {
          firstSlideMessage: this.slideMessageFirst,
          lastSlideMessage: this.slideMessageLast,
          nextSlideMessage: this.slideMessageNext,
          prevSlideMessage: this.slideMessagePrevious,
        },
        autoHeight: this.autoheight,
        autoplay: this.autoplay && {
          delay: this.autoplayDelay,
          disableOnInteraction: this.autoplayDisableOnInteraction,
        },
        breakpoints: this.createBps(),
        centeredSlides: this.centeredSlides,
        direction: 'horizontal',
        effect: this.effect,
        lazy: this.lazy && {
          checkInView: false,
          loadOnTransitionStart: true,
          loadPrevNext: this.lazyLoadPrevNext && true,
          loadPrevNextAmount: (_a = this.lazyLoadPrevNext) !== null && _a !== void 0 ? _a : 0,
        },
        loop: this.loop,
        navigation: {
          prevEl: this.prev,
          nextEl: this.next,
        },
        observer: true,
        observeParents: true,
        observeSlideChildren: true,
        pagination: this.pagination === 'bullets' && {
          el: this.paginationBullets,
          type: 'bullets',
          clickable: this.paginationBulletsClickable,
          dynamicBullets: this.paginationBulletsDynamic,
          dynamicMainBullets: this.paginationBulletsDynamicAmount,
        },
        slidesPerView: this.slidesPerView,
        spaceBetween: this.spaceBetween,
        speed: this.speed,
      });
      this.mySwiper.on('observerUpdate', () => {
        this.mySwiper.update();
      });
      setTimeout(() => {
        this.mySwiper.lazy.load();
        this.mySwiper.lazy.loadInSlide(1);
      }, 1000);
    };
    /** Update. */
    this.update = () => {
      this.mySwiper.destroy();
      this.container.innerHTML = '';
      this.content = this.el.innerHTML;
      setTimeout(() => {
        this.initSwiper();
      }, 100);
    };
  }
  /**
   * Watch images.
   *
   * @param {string} newValue Array string.
   */
  imagesChanged(newValue) {
    if (newValue)
      this.imagesArray = JSON.parse(newValue);
  }
  componentWillLoad() {
    this.content = this.el.innerHTML;
    /** If image prop is set. */
    if (this.images) {
      this.imagesChanged(this.images);
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el, cb: this.update });
    this.initSwiper();
    intersectionObserver(this.el, () => {
      this.mySwiper.update();
    });
    this.spxSliderDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
    this.mySwiper.destroy();
    this.initSwiper();
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$4, 'display', this.display),
      width: '100%',
      height: '100%',
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      width: '100%',
      height: '100%',
      '.swiper-container': {
        height: !this.autoheight && '100%',
      },
      '.swiper-wrapper': {
        maxHeight: setVar(tag$4, 'max-height', this.maxHeight),
      },
      '.swiper-slide': {
        height: 'auto',
        width: '100%',
      },
      '.swiper-pagination-bullet': {
        position: 'static',
        opacity: '1 !important',
        width: setVar(tag$4, 'pagination-bullets-size', this.paginationBulletsSize) +
          ' !important',
        height: setVar(tag$4, 'pagination-bullets-size', this.paginationBulletsSize) +
          ' !important',
        background: setVar(tag$4, 'pagination-bullets-background', this.paginationBulletsBackground) + ' !important',
        margin: `0
          calc(${setVar(tag$4, 'pagination-bullets-space-between', this.paginationBulletsSpaceBetween)} / 2) !important`,
        transitionProperty: 'background',
        transitionDuration: transitionDuration,
        transitionTimingFunction: transitionTimingFunction,
        '&.swiper-pagination-bullet-active': {
          background: setVar(tag$4, 'pagination-bullets-background-active', this.paginationBulletsBackgroundActive) + ' !important',
        },
      },
      '.swiper-slide:not(.swiper-slide-active)': {
        filter: this.prevNextFilter &&
          setVar(tag$4, 'prev-next-filter', this.prevNextFilter),
      },
      img: {
        width: '100% !important',
        height: this.autoheight ? 'auto' : '100%' + '!important',
        objectFit: setVar(tag$4, 'image-object-fit', this.imageObjectFit),
      },
    });
    /** Pagination. */
    const stylePagination = css({
      background: setVar(tag$4, 'pagination-background', this.paginationBackground),
      height: this.paginationBackground &&
        `calc(${setVar(tag$4, 'pagination-bullets-size', this.paginationBulletsSize)} + 2 * ${setVar(tag$4, 'pagination-bullets-size', this.paginationBulletsSize)})`,
      borderRadius: '9999px',
      backdropFilter: setVar(tag$4, 'pagination-backdrop-filter', this.paginationBackdropFilter),
      maxWidth: !this.paginationBulletsDynamic && 'max-content',
      left: !this.paginationBulletsDynamic && '50% !important',
      transform: !this.paginationBulletsDynamic && 'translateX(-50%) !important',
      padding: !this.paginationBulletsDynamic &&
        `0 ${setVar(tag$4, 'pagination-bullets-size', this.paginationBulletsSize)}`,
      '& > span': {
        top: this.paginationBackground &&
          setVar(tag$4, 'pagination-bullets-size', this.paginationBulletsSize),
        position: 'relative !important',
      },
    });
    /** Navigation. */
    const styleNavigation = css({
      display: this.navigation ? 'flex' : 'none',
      position: 'absolute',
      top: 0,
      left: 0,
      height: '100%',
      width: '100%',
      zIndex: 'inherit',
      justifyContent: 'space-between',
      alignItems: 'center',
      '& > button': Object.assign({ display: 'flex', justifyContent: 'center', alignItems: 'center', border: 'none', background: setVar(tag$4, 'navigation-background', this.navigationBackground), borderRadius: setVar(tag$4, 'navigation-border-radius', this.navigationBorderRadius), padding: setVar(tag$4, 'navigation-padding', this.navigationPadding), cursor: 'pointer', transitionProperty: 'background, box-shadow', transitionDuration: setVar(tag$4, 'navigation-transition-duration', this.navigationTransitionDuration), transitionTimingFunction: setVar(tag$4, 'navigation-transition-timing-function', this.navigationTransitionTimingFunction), '&[aria-disabled="true"]': {
          opacity: 0,
          pointerEvents: 'none',
        }, '&:hover': {
          background: setVar(tag$4, 'navigation-background-hover', this.navigationBackgroundHover),
        } }, focus),
    });
    /** Navigation prev. */
    const styleNavigationPrev = css({
      marginLeft: setVar(tag$4, 'navigation-distance', this.navigationDistanceX),
    });
    /** Navigation prev. */
    const styleNavigationNext = css({
      marginRight: setVar(tag$4, 'navigation-distance', this.navigationDistanceX),
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleShadowHost }, h$4("div", { ref: (el) => (this.swiperContainer = el), class: "swiper-container" }, helperImagesOrInner({
      class: 'swiper-wrapper',
      condition: this.images,
      content: this.content,
      el: this.el,
      ref: (el) => (this.container = el),
      helper: {
        array: this.imagesArray,
        images: this.images,
        lazy: this.lazy,
        size: this.imageSize,
        src: this.imageSrc,
      },
    }), this.pagination === 'bullets' && (h$4("div", { class: stylePagination + ' swiper-pagination', ref: (el) => (this.paginationBullets = el) })), h$4("div", { class: styleNavigation }, h$4(Button, { ref: (el) => (this.prev = el), class: styleNavigationPrev }, h$4("spx-icon", { type: this.navigationIconType, icon: this.navigationIconPrev, color: setVar(tag$4, 'navigation-color', this.navigationColor), size: setVar(tag$4, 'navigation-size', this.navigationSize) })), h$4(Button, { ref: (el) => (this.next = el), class: styleNavigationNext }, h$4("spx-icon", { type: this.navigationIconType, icon: this.navigationIconNext, color: setVar(tag$4, 'navigation-color', this.navigationColor), size: setVar(tag$4, 'navigation-size', this.navigationSize) })))))));
  }
  get el() { return this; }
  static get watchers() { return {
    "images": ["imagesChanged"]
  }; }
  static get style() { return spxSliderCss; }
};

const tag$3 = 'spx-slideshow';
const SpxSlideshow$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxSlideshowDidLoad = createEvent(this, "spxSlideshowDidLoad", 7);
    this.display = 'block';
    /**
     * Duration of slideshow to complete one cycle.
     *
     * @CSS
     */
    this.duration = '60s';
    /**
     * Gap between inner elements.
     *
     * @CSS
     */
    this.gap = '1em';
    /**
     * Max width of inner elements.
     *
     * @CSS
     */
    this.maxWidth = '300px';
    this.objectFit = 'contain';
    this.initSlideshow = () => {
      this.container.querySelectorAll(':scope > *').forEach((item) => {
        const clone = item.cloneNode(true);
        this.clone.appendChild(clone);
      });
      this.offsetWidth = this.container.offsetWidth;
    };
    /** Update. */
    this.update = () => {
      this.container.innerHTML = '';
      this.clone.innerHTML = '';
      this.content = this.el.innerHTML;
      setTimeout(() => {
        this.initSlideshow();
        lazy({
          el: this.el,
          condition: this.lazy,
        });
      }, 100);
    };
  }
  /**
   * Watch images prop and parse to array.
   *
   * @param {string} newValue Array string.
   */
  imagesChanged(newValue) {
    if (newValue)
      this.imagesArray = JSON.parse(newValue);
  }
  onResize() {
    if (this.container) {
      this.offsetWidth = this.container.offsetWidth;
    }
  }
  componentWillLoad() {
    this.content = this.el.innerHTML;
    /** If image prop is set. */
    if (this.images) {
      this.imagesChanged(this.images);
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el, lazy: this.lazy, cb: this.update });
    this.initSlideshow();
    this.spxSlideshowDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    const { css, keyframes } = cssEmotion(this.el.shadowRoot);
    /** Animation. */
    const kf = keyframes({
      '0%': {
        transform: 'translate3d(0px, 0px, 0px)',
      },
      to: {
        transform: 'translate3d(calc(-' +
          this.offsetWidth +
          'px - ' +
          this.gap +
          '), 0px, 0px)',
      },
    });
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$3, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = css({
      overflow: setVar(tag$3, 'overflow', this.overflow),
    });
    /** Wrap styles. */
    const styleWrap = css({
      animationName: kf,
      animationDuration: setVar(tag$3, 'speed', this.duration),
      animationTimingFunction: 'linear',
      animationIterationCount: 'infinite',
      animationFillMode: 'none',
      animationPlayState: 'running',
      display: 'flex',
      img: {
        maxWidth: '100%',
        width: '100%',
        height: this.height ? setVar(tag$3, 'image-height', this.height) : 'auto',
        objectFit: setVar(tag$3, 'object-fit', this.objectFit),
      },
      '& > div + div': {
        marginLeft: setVar(tag$3, 'gap', this.gap),
      },
    });
    /** Slideshow style. */
    const slideshowStyle = css({
      display: 'grid',
      gridAutoFlow: 'column',
      gridAutoColumns: setVar(tag$3, 'max-width', this.maxWidth),
      gridGap: setVar(tag$3, 'gap', this.gap),
    });
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleShadowHost }, h$4("div", { class: styleWrap }, helperImagesOrInner({
      class: slideshowStyle,
      condition: this.images,
      content: this.content,
      el: this.el,
      ref: (el) => (this.container = el),
      helper: {
        array: this.imagesArray,
        images: this.images,
        size: this.imageSize,
        src: this.imageSrc,
      },
    }), h$4("div", { class: slideshowStyle, ref: (el) => (this.clone = el) })))));
  }
  get el() { return this; }
  static get watchers() { return {
    "images": ["imagesChanged"]
  }; }
};

const tag$2 = 'spx-snackbar';
const SpxSnackbar$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxSnackbarDidLoad = createEvent(this, "spxSnackbarDidLoad", 7);
    this.animationDelay = '200ms';
    this.animationDuration = '2000ms';
    this.background = 'var(--spx-color-gray-900)';
    this.borderRadius = borderRadius;
    this.buttonBackground = 'var(--spx-color-gray-700)';
    this.buttonBackgroundHover = 'var(--spx-color-gray-800)';
    this.buttonTransitionDuration = transitionDuration;
    this.buttonTransitionTimingFunction = transitionTimingFunction;
    this.color = '#ffffff';
    this.display = display$1;
    /**
     * Distance to the edge of the viewport on the x-axis.
     *
     * @CSS
     */
    this.distanceX = '1em';
    /**
     * Distance to the edge of the viewport on the y-axis.
     *
     * @CSS
     */
    this.distanceY = '1em';
    this.fontSize = '18px';
    this.fontSizeMax = 1.6;
    this.fontSizeMin = 1;
    /**
     * Unique identifier for snackbar instance.
     */
    this.identifier = 'primary';
    this.padding = '0.8em';
    this.paddingMin = 1;
    this.paddingMax = 1.4;
    /**
     * Component position in page.
     *
     * @choice 'bottom-right', 'bottom-center', 'bottom-left', 'top-right', 'top-center', 'top-right'
     */
    this.position = 'bottom-right';
    /** CSS property position of button. */
    this.positionCss = 'fixed';
    /** Space between snackbars. */
    this.spaceBetween = '12px';
    /**
     * Styling.
     *
     * @choice 'default', 'fluid', 'headless'
     */
    this.styling = 'default';
    /** Element where snackbars should be created in. */
    this.target = 'body';
    /** Text inside snackbar. */
    this.text = "Hello, I'm a snackbar.";
    this.zIndex = 103;
    this.createPositionArray = () => {
      this.positionArray = this.position.split('-');
    };
    this.removeItem = () => {
      const container = document.querySelector('#spx-snackbar-container');
      if (container) {
        container.remove();
      }
      else {
        const el = this.el;
        el.remove();
      }
    };
  }
  positionChanged() {
    this.createPositionArray();
    document.querySelector('[data-spx-id="' + this.identifier + '"]').className = '';
    document
      .querySelector('[data-spx-id="' + this.identifier + '"]')
      .classList.add(css$2(Object.assign(Object.assign({}, position$1('snackbar', this.positionArray, this.distanceX, this.distanceY)), { position: this.positionCss, display: 'flex', flexDirection: 'column', zIndex: this.zIndex, 'spx-snackbar + spx-snackbar': {
        marginTop: setVar(tag$2, 'space-Y', this.spaceBetween),
      } })));
  }
  componentWillLoad() {
    this.createPositionArray();
    /** Load into container if more than one snackbar are on screen. */
    if (!document.querySelector('[data-spx-id="' + this.identifier + '"]')) {
      const div = document.createElement('div');
      this.containerClass = {};
      div.classList.add(css$2(Object.assign(Object.assign({}, position$1('snackbar', this.positionArray, this.distanceX, this.distanceY)), { position: this.positionCss, display: 'flex', flexDirection: 'column', zIndex: this.zIndex, 'spx-snackbar + spx-snackbar': {
          marginTop: setVar(tag$2, 'space-Y', this.spaceBetween),
        } })));
      div.setAttribute('data-spx-id', this.identifier);
      div.appendChild(this.el);
      const target = document.querySelector(this.target);
      target.appendChild(div);
    }
    else {
      document
        .querySelector('[data-spx-id="' + this.identifier + '"]')
        .appendChild(this.el);
    }
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.spxSnackbarDidLoad.emit({ target: 'document' });
  }
  componentDidRender() {
    const removeItem = () => {
      const el = this.el;
      el.remove();
    };
    /** Remove snackbar from dom after 5 seconds. */
    if (!this.fixed) {
      setTimeout(removeItem, parseInt(this.animationDuration.replace('ms', '')));
    }
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    var _a, _b;
    const { css, keyframes } = cssEmotion(this.el.shadowRoot);
    const { tw } = cssTw(this.el.shadowRoot);
    /** Animation in and out. */
    const kfOut = keyframes({
      '0%, 100%': {
        opacity: 0,
      },
      '30%, 80%': {
        opacity: 1,
      },
    });
    /** Animation in. */
    const kfIn = keyframes({
      '0%': {
        opacity: 0,
      },
      '30%, 100%': {
        opacity: 1,
      },
    });
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag$2, 'display', this.display),
    });
    /** Shadow Host styles. */
    const styleShadowHost = (this.styling === 'default' || this.styling === 'fluid') &&
      css({
        overflow: 'hidden',
        display: 'grid',
        gridAutoFlow: 'column',
        gridAutoColumns: 'max-content',
        alignItems: 'center',
        userSelect: 'none',
        opacity: 0,
        color: setVar(tag$2, 'color', this.color),
        background: setVar(tag$2, 'background', this.background),
        border: setVar(tag$2, 'border', this.border),
        borderRadius: setVar(tag$2, 'border-radius', this.borderRadius),
        animation: !this.fixed ? kfOut : kfIn,
        animationDelay: setVar(tag$2, 'animation-delay', this.animationDelay),
        animationDuration: setVar(tag$2, 'animation-duration', this.animationDuration),
        animationFillMode: 'forwards',
      });
    /** Button styles. */
    const styleButton = this.styling === 'default' || this.styling === 'fluid'
      ? css(Object.assign({ gridColumn: this.reverse && '1', padding: '0 ' + setVar(tag$2, 'padding', this.padding) + '', background: setVar(tag$2, 'button-background', this.buttonBackground), width: '1em', boxSizing: 'content-box', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', borderBottomLeftRadius: this.reverse && setVar(tag$2, 'border-radius', this.borderRadius), borderTopLeftRadius: this.reverse && setVar(tag$2, 'border-radius', this.borderRadius), borderTopRightRadius: !this.reverse && setVar(tag$2, 'border-radius', this.borderRadius), borderBottomRightRadius: !this.reverse && setVar(tag$2, 'border-radius', this.borderRadius), transitionProperty: 'background, box-shadow', transitionDuration: setVar(tag$2, 'button-transition-duration', this.buttonTransitionDuration), transitionTimingFunction: setVar(tag$2, 'button-transition-timing-function', this.buttonTransitionTimingFunction), '&:hover': {
          background: setVar(tag$2, 'button-background-hover', this.buttonBackgroundHover),
        } }, focus))
      : tw((_a = this.classButton) !== null && _a !== void 0 ? _a : '');
    /** Text styles. */
    const styleText = this.styling === 'default' || this.styling === 'fluid'
      ? css({
        gridColumn: this.reverse && '2',
        whiteSpace: 'nowrap',
        fontFamily: fontFamily,
        fontSize: setStyle(tag$2, 'font-size', this.fontSize, this.fontSizeMin, this.fontSizeMax, this.styling),
        padding: setStyle(tag$2, 'padding', this.padding, this.paddingMin, this.paddingMax, this.styling),
      })
      : tw((_b = this.classText) !== null && _b !== void 0 ? _b : '');
    return (h$4(Host, { class: styleHost }, h$4("div", { class: styleShadowHost }, h$4("span", { class: styleText }, this.text ? this.text : h$4("slot", null)), this.closeable && (h$4(Button, { onClick: this.removeItem, class: styleButton }, h$4("spx-icon", { size: "1.25em", icon: "close" }))))));
  }
  get el() { return this; }
  static get watchers() { return {
    "zIndex": ["positionChanged"],
    "spaceBetween": ["positionChanged"],
    "position": ["positionChanged"]
  }; }
};

const tag$1 = 'spx-text-path';
const SpxTextPath$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.spxTextPathDidLoad = createEvent(this, "spxTextPathDidLoad", 7);
    this.display = 'block';
    /** Space between text and path. */
    this.spaceBetween = '-2%';
    /** Starting offset off the text. */
    this.startOffset = '25%';
    /** Text size. */
    this.textFontSize = 'clamp(20px, 3vw, 24px)';
    /** Text transform. */
    this.textTransform = 'default';
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    this.el.shadowRoot
      .querySelector('foreignObject')
      .setAttribute('height', '100%');
    this.el.shadowRoot
      .querySelector('foreignObject')
      .setAttribute('width', '100%');
    this.spxTextPathDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  render() {
    const { css } = cssEmotion(this.el.shadowRoot);
    /** Host styles. */
    const styleHost = css({
      display: setVar(tag$1, 'display', this.display),
    });
    /** Slot styles. */
    const styleSlot = css({
      display: 'relative',
      height: '100%',
      width: '100%',
      position: 'absolute',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      clipPath: 'path("M250,400 a150,150 0 0,1 0,-300a150,150 0 0,1 0,300Z")',
    });
    /** Slot styles. */
    const styleTextPath = css({
      textTransform: setVar(tag$1, 'text-transform', this.textTransform),
      fontWeight: setVar(tag$1, 'text-font-weight', this.textFontWeight),
      fontSize: setVar(tag$1, 'text-font-size', this.textFontSize),
    });
    return (h$4(Host, { class: styleHost }, h$4("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 500 500", preserveAspectRatio: "none" }, h$4("defs", null, h$4("path", { id: "circlePath", d: "M250,400 a150,150 0 0,1 0,-300a150,150 0 0,1 0,300Z" }), h$4("path", { id: "circlePathInner", d: "M250,400 a150,150 0 0,1 0,-300a150,150 0 0,1 0,300Z" })), h$4("foreignObject", { x: "0", y: "0", height: 0, width: 0 }, h$4("div", { class: styleSlot }, h$4("slot", null))), h$4("use", { xlinkHref: "#circlePathInner", fill: "none" }), h$4("text", { dy: this.spaceBetween, class: styleTextPath, fill: this.textColor }, h$4("textPath", { startOffset: this.startOffset, xlinkHref: "#circlePath" }, this.text)))));
  }
  get el() { return this; }
};

var core = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}("undefined"!=typeof self?self:commonjsGlobal,(function(){return (()=>{var e={75:function(e){(function(){var t,n,r,o,a,s;"undefined"!=typeof performance&&null!==performance&&performance.now?e.exports=function(){return performance.now()}:"undefined"!=typeof process&&null!==process&&process.hrtime?(e.exports=function(){return (t()-a)/1e6},n=process.hrtime,o=(t=function(){var e;return 1e9*(e=n())[0]+e[1]})(),s=1e9*process.uptime(),a=o-s):Date.now?(e.exports=function(){return Date.now()-r},r=Date.now()):(e.exports=function(){return (new Date).getTime()-r},r=(new Date).getTime());}).call(this);},4087:(e,t,n)=>{for(var r=n(75),o="undefined"==typeof window?n.g:window,a=["moz","webkit"],s="AnimationFrame",i=o["request"+s],u=o["cancel"+s]||o["cancelRequest"+s],l=0;!i&&l<a.length;l++)i=o[a[l]+"Request"+s],u=o[a[l]+"Cancel"+s]||o[a[l]+"CancelRequest"+s];if(!i||!u){var c=0,p=0,d=[];i=function(e){if(0===d.length){var t=r(),n=Math.max(0,16.666666666666668-(t-c));c=n+t,setTimeout((function(){var e=d.slice(0);d.length=0;for(var t=0;t<e.length;t++)if(!e[t].cancelled)try{e[t].callback(c);}catch(e){setTimeout((function(){throw e}),0);}}),Math.round(n));}return d.push({handle:++p,callback:e,cancelled:!1}),p},u=function(e){for(var t=0;t<d.length;t++)d[t].handle===e&&(d[t].cancelled=!0);};}e.exports=function(e){return i.call(o,e)},e.exports.cancel=function(){u.apply(o,arguments);},e.exports.polyfill=function(e){e||(e=o),e.requestAnimationFrame=i,e.cancelAnimationFrame=u;};}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={exports:{}};return e[r].call(a.exports,a,a.exports,n),a.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]});},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var r={};return (()=>{n.d(r,{default:()=>S});var e=n(4087),t=n.n(e);const o=function(e){return new RegExp(/<[a-z][\s\S]*>/i).test(e)},a=function(e){var t=document.createElement("div");return t.innerHTML=e,t.childNodes},s=function(e,t){return Math.floor(Math.random()*(t-e+1))+e};var i="TYPE_CHARACTER",u="REMOVE_CHARACTER",l="REMOVE_ALL",c="REMOVE_LAST_VISIBLE_NODE",p="PAUSE_FOR",d="CALL_FUNCTION",f="ADD_HTML_TAG_ELEMENT",v="CHANGE_DELETE_SPEED",h="CHANGE_DELAY",m="CHANGE_CURSOR",y="PASTE_STRING",g="HTML_TAG";function E(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r);}return n}function w(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?E(Object(n),!0).forEach((function(t){N(e,t,n[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):E(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t));}));}return e}function T(e){return function(e){if(Array.isArray(e))return b(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||function(e,t){if(e){if("string"==typeof e)return b(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return "Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?b(e,t):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function b(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function A(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function N(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const S=function(){function n(r,E){var b=this;if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),N(this,"state",{cursorAnimation:null,lastFrameTime:null,pauseUntil:null,eventQueue:[],eventLoop:null,eventLoopPaused:!1,reverseCalledEvents:[],calledEvents:[],visibleNodes:[],initialOptions:null,elements:{container:null,wrapper:document.createElement("span"),cursor:document.createElement("span")}}),N(this,"options",{strings:null,cursor:"|",delay:"natural",pauseFor:1500,deleteSpeed:"natural",loop:!1,autoStart:!1,devMode:!1,skipAddStyles:!1,wrapperClassName:"Typewriter__wrapper",cursorClassName:"Typewriter__cursor",stringSplitter:null,onCreateTextNode:null,onRemoveNode:null}),N(this,"setupWrapperElement",(function(){b.state.elements.container&&(b.state.elements.wrapper.className=b.options.wrapperClassName,b.state.elements.cursor.className=b.options.cursorClassName,b.state.elements.cursor.innerHTML=b.options.cursor,b.state.elements.container.innerHTML="",b.state.elements.container.appendChild(b.state.elements.wrapper),b.state.elements.container.appendChild(b.state.elements.cursor));})),N(this,"start",(function(){return b.state.eventLoopPaused=!1,b.runEventLoop(),b})),N(this,"pause",(function(){return b.state.eventLoopPaused=!0,b})),N(this,"stop",(function(){return b.state.eventLoop&&((0, e.cancel)(b.state.eventLoop),b.state.eventLoop=null),b})),N(this,"pauseFor",(function(e){return b.addEventToQueue(p,{ms:e}),b})),N(this,"typeOutAllStrings",(function(){return "string"==typeof b.options.strings?(b.typeString(b.options.strings).pauseFor(b.options.pauseFor),b):(b.options.strings.forEach((function(e){b.typeString(e).pauseFor(b.options.pauseFor).deleteAll(b.options.deleteSpeed);})),b)})),N(this,"typeString",(function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(o(e))return b.typeOutHTMLString(e,t);if(e){var n=b.options||{},r=n.stringSplitter,a="function"==typeof r?r(e):e.split("");b.typeCharacters(a,t);}return b})),N(this,"pasteString",(function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return o(e)?b.typeOutHTMLString(e,t,!0):(e&&b.addEventToQueue(y,{character:e,node:t}),b)})),N(this,"typeOutHTMLString",(function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2?arguments[2]:void 0,r=a(e);if(r.length>0)for(var o=0;o<r.length;o++){var s=r[o],i=s.innerHTML;s&&3!==s.nodeType?(s.innerHTML="",b.addEventToQueue(f,{node:s,parentNode:t}),n?b.pasteString(i,s):b.typeString(i,s)):s.textContent&&(n?b.pasteString(s.textContent,t):b.typeString(s.textContent,t));}return b})),N(this,"deleteAll",(function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"natural";return b.addEventToQueue(l,{speed:e}),b})),N(this,"changeDeleteSpeed",(function(e){if(!e)throw new Error("Must provide new delete speed");return b.addEventToQueue(v,{speed:e}),b})),N(this,"changeDelay",(function(e){if(!e)throw new Error("Must provide new delay");return b.addEventToQueue(h,{delay:e}),b})),N(this,"changeCursor",(function(e){if(!e)throw new Error("Must provide new cursor");return b.addEventToQueue(m,{cursor:e}),b})),N(this,"deleteChars",(function(e){if(!e)throw new Error("Must provide amount of characters to delete");for(var t=0;t<e;t++)b.addEventToQueue(u);return b})),N(this,"callFunction",(function(e,t){if(!e||"function"!=typeof e)throw new Error("Callbak must be a function");return b.addEventToQueue(d,{cb:e,thisArg:t}),b})),N(this,"typeCharacters",(function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!e||!Array.isArray(e))throw new Error("Characters must be an array");return e.forEach((function(e){b.addEventToQueue(i,{character:e,node:t});})),b})),N(this,"removeCharacters",(function(e){if(!e||!Array.isArray(e))throw new Error("Characters must be an array");return e.forEach((function(){b.addEventToQueue(u);})),b})),N(this,"addEventToQueue",(function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return b.addEventToStateProperty(e,t,n,"eventQueue")})),N(this,"addReverseCalledEvent",(function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=b.options.loop;return r?b.addEventToStateProperty(e,t,n,"reverseCalledEvents"):b})),N(this,"addEventToStateProperty",(function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,o={eventName:e,eventArgs:t||{}};return b.state[r]=n?[o].concat(T(b.state[r])):[].concat(T(b.state[r]),[o]),b})),N(this,"runEventLoop",(function(){b.state.lastFrameTime||(b.state.lastFrameTime=Date.now());var e=Date.now(),n=e-b.state.lastFrameTime;if(!b.state.eventQueue.length){if(!b.options.loop)return;b.state.eventQueue=T(b.state.calledEvents),b.state.calledEvents=[],b.options=w({},b.state.initialOptions);}if(b.state.eventLoop=t()(b.runEventLoop),!b.state.eventLoopPaused){if(b.state.pauseUntil){if(e<b.state.pauseUntil)return;b.state.pauseUntil=null;}var r,o=T(b.state.eventQueue),a=o.shift();if(!(n<=(r=a.eventName===c||a.eventName===u?"natural"===b.options.deleteSpeed?s(40,80):b.options.deleteSpeed:"natural"===b.options.delay?s(120,160):b.options.delay))){var E=a.eventName,A=a.eventArgs;switch(b.logInDevMode({currentEvent:a,state:b.state,delay:r}),E){case y:case i:var N=A.character,S=A.node,C=document.createTextNode(N),_=C;b.options.onCreateTextNode&&"function"==typeof b.options.onCreateTextNode&&(_=b.options.onCreateTextNode(N,C)),_&&(S?S.appendChild(_):b.state.elements.wrapper.appendChild(_)),b.state.visibleNodes=[].concat(T(b.state.visibleNodes),[{type:"TEXT_NODE",character:N,node:_}]);break;case u:o.unshift({eventName:c,eventArgs:{removingCharacterNode:!0}});break;case p:var O=a.eventArgs.ms;b.state.pauseUntil=Date.now()+parseInt(O);break;case d:var L=a.eventArgs,D=L.cb,M=L.thisArg;D.call(M,{elements:b.state.elements});break;case f:var x=a.eventArgs,P=x.node,R=x.parentNode;R?R.appendChild(P):b.state.elements.wrapper.appendChild(P),b.state.visibleNodes=[].concat(T(b.state.visibleNodes),[{type:g,node:P,parentNode:R||b.state.elements.wrapper}]);break;case l:var j=b.state.visibleNodes,k=A.speed,Q=[];k&&Q.push({eventName:v,eventArgs:{speed:k,temp:!0}});for(var F=0,H=j.length;F<H;F++)Q.push({eventName:c,eventArgs:{removingCharacterNode:!1}});k&&Q.push({eventName:v,eventArgs:{speed:b.options.deleteSpeed,temp:!0}}),o.unshift.apply(o,Q);break;case c:var I=a.eventArgs.removingCharacterNode;if(b.state.visibleNodes.length){var U=b.state.visibleNodes.pop(),q=U.type,G=U.node,Y=U.character;b.options.onRemoveNode&&"function"==typeof b.options.onRemoveNode&&b.options.onRemoveNode({node:G,character:Y}),G&&G.parentNode.removeChild(G),q===g&&I&&o.unshift({eventName:c,eventArgs:{}});}break;case v:b.options.deleteSpeed=a.eventArgs.speed;break;case h:b.options.delay=a.eventArgs.delay;break;case m:b.options.cursor=a.eventArgs.cursor,b.state.elements.cursor.innerHTML=a.eventArgs.cursor;}b.options.loop&&(a.eventName===c||a.eventArgs&&a.eventArgs.temp||(b.state.calledEvents=[].concat(T(b.state.calledEvents),[a]))),b.state.eventQueue=o,b.state.lastFrameTime=e;}}})),r)if("string"==typeof r){var A=document.querySelector(r);if(!A)throw new Error("Could not find container element");this.state.elements.container=A;}else this.state.elements.container=r;E&&(this.options=w(w({},this.options),E)),this.state.initialOptions=w({},this.options),this.init();}var r,E;return r=n,(E=[{key:"init",value:function(){var e,t;this.setupWrapperElement(),this.addEventToQueue(m,{cursor:this.options.cursor},!0),this.addEventToQueue(l,null,!0),!window||window.___TYPEWRITER_JS_STYLES_ADDED___||this.options.skipAddStyles||(e=".Typewriter__cursor{-webkit-animation:Typewriter-cursor 1s infinite;animation:Typewriter-cursor 1s infinite;margin-left:1px}@-webkit-keyframes Typewriter-cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}@keyframes Typewriter-cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}",(t=document.createElement("style")).appendChild(document.createTextNode(e)),document.head.appendChild(t),window.___TYPEWRITER_JS_STYLES_ADDED___=!0),!0===this.options.autoStart&&this.options.strings&&this.typeOutAllStrings().start();}},{key:"logInDevMode",value:function(e){this.options.devMode&&console.log(e);}}])&&A(r.prototype,E),n}();})(),r.default})()}));
});

const Typewriter = /*@__PURE__*/getDefaultExportFromCjs(core);

const spxTypewriterCss = ".spx-typewriter__cursor{-webkit-animation:cursor 1s infinite;animation:cursor 1s infinite;margin-left:1px}@-webkit-keyframes cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}@keyframes cursor{0%{opacity:0}50%{opacity:1}100%{opacity:0}}";

const tag = 'spx-typewriter';
const SpxTypewriter$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.spxTypewriterDidLoad = createEvent(this, "spxTypewriterDidLoad", 7);
    /** Automatically starts writing. */
    this.autoStart = true;
    /** Writing delay in ms. Also accepts 'natural' value. */
    this.delay = 'natural';
    /** Delete delay in ms. Also accepts 'natural' value. */
    this.deleteSpeed = 'natural';
    this.display = display$1;
    /** Text that should be written. */
    this.text = "I'm a typewriter";
  }
  componentDidLoad() {
    globalComponentDidLoad({ el: this.el });
    /** Define elements. */
    const el = this.el.querySelector('h1, h2, h3, h4, h5, h6, p, span') || this.el;
    /** Init Typewriter. */
    this.typewriter = new Typewriter(el, {
      strings: this.text[0] === '['
        ? this.text
          .replaceAll("['", '')
          .replaceAll("']", '')
          .replaceAll(" '", '')
          .split("',")
        : this.text,
      delay: this.delay,
      deleteSpeed: this.deleteSpeed,
      loop: this.loop,
      autoStart: this.autoStart,
      wrapperClassName: 'spx-typewriter__wrapper',
      cursorClassName: 'spx-typewriter__cursor',
      skipAddStyles: true,
    });
    this.spxTypewriterDidLoad.emit({ target: 'document' });
  }
  componentWillUpdate() {
    globalComponentWillUpdate(this.el);
  }
  /** Start animation. */
  async play() {
    this.typewriter.typeString(this.text);
    this.typewriter.start();
  }
  /** Stop animation. */
  async stop() {
    this.typewriter.stop();
  }
  render() {
    /** Host styles. */
    const styleHost = css$2({
      display: setVar(tag, 'display', this.display),
    });
    return h$4(Host, { class: styleHost });
  }
  get el() { return this; }
  static get style() { return spxTypewriterCss; }
};

const IonIcon = /*@__PURE__*/proxyCustomElement(Icon, [1,"ion-icon",{"mode":[1025],"color":[1],"ariaLabel":[1537,"aria-label"],"ariaHidden":[513,"aria-hidden"],"ios":[1],"md":[1],"flipRtl":[4,"flip-rtl"],"name":[1],"src":[1],"icon":[8],"size":[1],"lazy":[4],"sanitize":[4],"svgContent":[32],"isVisible":[32]}]);
const SpxAccordion = /*@__PURE__*/proxyCustomElement(SpxAccordion$1, [1,"spx-accordion",{"animation":[516],"classContent":[513,"class-content"],"classContentActive":[513,"class-content-active"],"classContentInactive":[513,"class-content-inactive"],"classContentText":[513,"class-content-text"],"classContentTextActive":[513,"class-content-text-active"],"classContentTextInactive":[513,"class-content-text-inactive"],"classHeader":[513,"class-header"],"classHeaderActive":[513,"class-header-active"],"classHeaderInactive":[513,"class-header-inactive"],"classHeaderText":[513,"class-header-text"],"classHeaderTextActive":[513,"class-header-text-active"],"classHeaderTextInactive":[513,"class-header-text-inactive"],"classHeaderIcon":[513,"class-header-icon"],"classHeaderIconActive":[513,"class-header-icon-active"],"classHeaderIconInactive":[513,"class-header-icon-inactive"],"classHeaderIconContainer":[513,"class-header-icon-container"],"classHeaderIconContainerActive":[513,"class-header-icon-container-active"],"classHeaderIconContainerInactive":[513,"class-header-icon-container-inactive"],"contentColor":[513,"content-color"],"contentText":[513,"content-text"],"contentTextTag":[513,"content-text-tag"],"contentTransitionDuration":[513,"content-transition-duration"],"contentTransitionTimingFunction":[513,"content-transition-timing-function"],"display":[513],"fontSize":[513,"font-size"],"fontSizeMax":[514,"font-size-max"],"fontSizeMin":[514,"font-size-min"],"gap":[513],"gapMax":[514,"gap-max"],"gapMin":[514,"gap-min"],"headerColor":[513,"header-color"],"headerGap":[513,"header-gap"],"headerGapMax":[514,"header-gap-max"],"headerGapMin":[514,"header-gap-min"],"headerText":[513,"header-text"],"headerTextOpen":[513,"header-text-open"],"headerTextTag":[513,"header-text-tag"],"indicatorIcon":[513,"indicator-icon"],"indicatorIconType":[513,"indicator-icon-type"],"indicatorIconTransform":[513,"indicator-icon-transform"],"link":[513],"linkType":[513,"link-type"],"openState":[1540,"open"],"reverse":[516],"styling":[513],"contentCustom":[32],"disableAnimation":[32],"headerCustom":[32],"headerHeight":[32]}]);
const SpxAnimate = /*@__PURE__*/proxyCustomElement(SpxAnimate$1, [4,"spx-animate",{"clipPath":[1,"clip-path"],"delay":[2],"display":[513],"duration":[2],"ease":[1],"filter":[1],"once":[4],"opacity":[2],"repeat":[2],"repeatDelay":[2,"repeat-delay"],"reverse":[4],"stagger":[2],"target":[1],"viewport":[4],"viewportMarginBottom":[1,"viewport-margin-bottom"],"viewportMarginLeft":[1,"viewport-margin-left"],"viewportMarginRight":[1,"viewport-margin-right"],"viewportMarginTop":[1,"viewport-margin-top"],"x":[8],"y":[8],"yoyo":[4],"elements":[32],"tl":[32]}]);
const SpxBlockDocs = /*@__PURE__*/proxyCustomElement(SpxBlockDocs$1, [4,"spx-block-docs",{"bpMobile":[514,"bp-mobile"],"gap":[513],"contentPadding":[513,"content-padding"],"contentPaddingYMin":[514,"content-padding-y-min"],"contentPaddingYMax":[514,"content-padding-y-max"],"navigationBackground":[513,"navigation-background"],"navigationGap":[513,"navigation-gap"],"navigationGapMin":[514,"navigation-gap-min"],"navigationGapMax":[514,"navigation-gap-max"],"navigationHeadingTag":[513,"navigation-heading-tag"],"navigationHeightAdjust":[513,"navigation-height-adjust"],"navigationLinkColor":[513,"navigation-link-color"],"navigationLinkColorActive":[513,"navigation-link-color-active"],"navigationLinkFontSize":[520,"navigation-link-font-size"],"navigationLinkFontSizeMax":[514,"navigation-link-font-size-max"],"navigationLinkFontSizeMin":[514,"navigation-link-font-size-min"],"navigationLinkFontWeight":[513,"navigation-link-font-weight"],"navigationLinkLetterSpacing":[513,"navigation-link-letter-spacing"],"navigationLinkLineHeight":[513,"navigation-link-line-height"],"navigationLinkTextTransform":[513,"navigation-link-text-transform"],"navigationPaddingY":[513,"navigation-padding-y"],"navigationPaddingYMin":[514,"navigation-padding-y-min"],"navigationPaddingYMax":[514,"navigation-padding-y-max"],"navigationTitleColor":[513,"navigation-title-color"],"navigationTitleFontSize":[520,"navigation-title-font-size"],"navigationTitleFontSizeMax":[514,"navigation-title-font-size-max"],"navigationTitleFontSizeMin":[514,"navigation-title-font-size-min"],"navigationTitleFontWeight":[513,"navigation-title-font-weight"],"navigationTitleLetterSpacing":[513,"navigation-title-letter-spacing"],"navigationTitleLineHeight":[513,"navigation-title-line-height"],"navigationTitleTextTransform":[513,"navigation-title-text-transform"],"navigationTitleMarginBottom":[514,"navigation-title-margin-bottom"],"navigationTitleMarginBottomMin":[514,"navigation-title-margin-bottom-min"],"navigationTitleMarginBottomMax":[514,"navigation-title-margin-bottom-max"],"navigationTop":[513,"navigation-top"],"offsetMarginTop":[513,"offset-margin-top"],"separator":[513],"scrolling":[514],"styling":[513],"uniqueId":[516,"unique-id"],"mobile":[32]},[[9,"resize","onResize"]]]);
const SpxClassToggle = /*@__PURE__*/proxyCustomElement(SpxClassToggle$1, [4,"spx-class-toggle",{"display":[513],"local":[513],"target":[513],"toggle":[513],"classesArray":[32],"toggled":[32]}]);
const SpxCode = /*@__PURE__*/proxyCustomElement(SpxCode$1, [1,"spx-code",{"background":[513],"borderRadius":[513,"border-radius"],"clipboard":[516],"clipboardButtonBackground":[513,"clipboard-button-background"],"clipboardButtonColor":[513,"clipboard-button-color"],"clipboardButtonFontSize":[513,"clipboard-button-font-size"],"clipboardButtonFontWeight":[520,"clipboard-button-font-weight"],"clipboardButtonPadding":[513,"clipboard-button-padding"],"clipboardButtonText":[513,"clipboard-button-text"],"clipboardButtonTextCopied":[513,"clipboard-button-text-copied"],"clipboardButtonTextTransform":[513,"clipboard-button-text-transform"],"content":[513],"display":[513],"filter":[513],"fontSize":[513,"font-size"],"height":[513],"lazy":[516],"lineNumbers":[516,"line-numbers"],"lineNumbersBackground":[513,"line-numbers-background"],"lineNumbersColor":[513,"line-numbers-color"],"lineNumbersStart":[514,"line-numbers-start"],"maxWidth":[513,"max-width"],"overflow":[513],"padding":[513],"scrollbar":[516],"theme":[513],"type":[513],"whitespaceLeftTrim":[516,"whitespace-left-trim"],"whitespaceRemoveIndent":[516,"whitespace-remove-indent"],"whitespaceRemoveTrailing":[516,"whitespace-remove-trailing"],"whitespaceRightTrim":[516,"whitespace-right-trim"],"contentInner":[32],"text":[32]}]);
const SpxControlColor = /*@__PURE__*/proxyCustomElement(SpxControlColor$1, [1,"spx-control-color",{"color":[1537],"label":[513],"colorPicker":[32]}]);
const SpxControlGroup = /*@__PURE__*/proxyCustomElement(SpxControlGroup$2, [1,"spx-control-group"]);
const SpxControlLabel = /*@__PURE__*/proxyCustomElement(SpxControlGroup$1, [1,"spx-control-label",{"label":[513],"mb":[516]}]);
const SpxControlSelect = /*@__PURE__*/proxyCustomElement(SpxControlSelect$1, [1,"spx-control-select",{"delimiter":[513],"handleChange":[520,"handle-change"],"label":[513],"options":[513],"selected":[513]}]);
const SpxControlSlider = /*@__PURE__*/proxyCustomElement(SpxControlSlider$1, [1,"spx-control-slider",{"handleChange":[520,"handle-change"],"label":[513],"max":[514],"min":[514],"start":[514],"value":[32]}]);
const SpxControlSwitch = /*@__PURE__*/proxyCustomElement(SpxControlSwitch$1, [1,"spx-control-switch",{"checked":[516],"handleChange":[520,"handle-change"],"label":[513]}]);
const SpxControlText = /*@__PURE__*/proxyCustomElement(SpxControlText$1, [1,"spx-control-text",{"handleChange":[520,"handle-change"],"label":[513],"placeholder":[513],"value":[513]}]);
const SpxEdit = /*@__PURE__*/proxyCustomElement(SpxEdit$1, [4,"spx-edit",{"display":[513],"name":[513],"outline":[513],"outlineFocus":[513,"outline-focus"],"placeholder":[513],"placeholderColor":[513,"placeholder-color"],"placeholderOpacity":[513,"placeholder-opacity"],"subfield":[516],"type":[513],"editable":[516],"originalText":[32],"subfieldArray":[32]},[[0,"keydown","onClickEnter"],[4,"spxEditButtonDiscard","onClickDiscard"],[4,"spxEditButtonSave","onClickSave"],[0,"keyup","onClickKeyup"]]]);
const SpxEditButton = /*@__PURE__*/proxyCustomElement(SpxEditButton$1, [1,"spx-edit-button",{"test":[4],"background":[513],"backgroundDiscard":[513,"background-discard"],"border":[513],"borderRadius":[513,"border-radius"],"classButton":[513,"class-button"],"classButtonDiscard":[513,"class-button-discard"],"classLoader":[513,"class-loader"],"color":[513],"colorDiscard":[513,"color-discard"],"display":[513],"distanceX":[513,"distance-x"],"distanceY":[513,"distance-y"],"editId":[513,"edit-id"],"fontFamily":[513,"font-family"],"fontSize":[513,"font-size"],"fontSizeMax":[514,"font-size-max"],"fontSizeMin":[514,"font-size-min"],"gap":[513],"loaderColor":[513,"loader-color"],"loaderGap":[513,"loader-gap"],"padding":[513],"paddingXMin":[514,"padding-x-min"],"paddingXMax":[514,"padding-x-max"],"paddingYMin":[514,"padding-y-min"],"paddingYMax":[514,"padding-y-max"],"position":[513],"positionCss":[513,"position-css"],"styling":[513],"textDiscard":[513,"text-discard"],"textEdit":[513,"text-edit"],"textSave":[513,"text-save"],"textSuccess":[513,"text-success"],"zIndex":[514,"z-index"],"loading":[32],"open":[32],"positionArray":[32]}]);
const SpxEditor = /*@__PURE__*/proxyCustomElement(SpxEditor$1, [1,"spx-editor",{"active":[1537],"activeName":[1537,"active-name"],"code":[32],"controlsSelected":[32],"currentCode":[32],"currentData":[32],"currentElement":[32],"data":[32],"fullscreen":[32]}]);
const SpxGroup = /*@__PURE__*/proxyCustomElement(SpxGroup$1, [0,"spx-group",{"content":[513],"display":[513],"target":[513]}]);
const SpxIcon = /*@__PURE__*/proxyCustomElement(SpxIcon$1, [1,"spx-icon",{"color":[513],"display":[513],"icon":[513],"type":[513],"size":[513],"sizeMin":[514,"size-min"],"sizeMax":[514,"size-max"],"styling":[513]}]);
const SpxIframe = /*@__PURE__*/proxyCustomElement(SpxIframe$1, [1,"spx-iframe",{"display":[513],"documentBorder":[513,"document-border"],"documentBorderRadius":[513,"document-border-radius"],"documentHeight":[513,"document-height"],"documentWidth":[513,"document-width"],"fit":[4],"lazy":[4],"loaderBackground":[513,"loader-background"],"loaderColor":[513,"loader-color"],"loaderBorderRadius":[513,"loader-border-radius"],"minHeight":[513,"min-height"],"size":[1],"src":[1],"type":[1],"height":[32],"loaded":[32],"parent":[32],"parentHeight":[32],"width":[32]},[[9,"resize","onResize"]]]);
const SpxImageComparison = /*@__PURE__*/proxyCustomElement(SpxImageComparison$1, [1,"spx-image-comparison",{"color":[513],"display":[513],"height":[513],"iconColor":[513,"icon-color"],"lazy":[516],"srcAfter":[513,"src-after"],"srcBefore":[513,"src-before"],"steps":[514],"start":[514],"active":[32],"width":[32]},[[9,"resize","onResize"]]]);
const SpxLightbox = /*@__PURE__*/proxyCustomElement(SpxLightbox$1, [0,"spx-lightbox",{"display":[513],"height":[513],"overlayColor":[513,"overlay-color"],"width":[513]}]);
const SpxMasonry = /*@__PURE__*/proxyCustomElement(SpxMasonry$1, [1,"spx-masonry",{"bpColumns":[513,"bp-columns"],"columns":[514],"display":[513],"gap":[513],"images":[513],"imageSize":[513,"image-size"],"imageSrc":[513,"image-src"],"lazy":[516],"bpColumnsObject":[32],"content":[32],"imagesArray":[32],"macyState":[32]}]);
const SpxMockup = /*@__PURE__*/proxyCustomElement(SpxMockup$1, [1,"spx-mockup",{"colorGalaxyS8":[513,"color-galaxy-s-8"],"colorGooglePixel":[513,"color-google-pixel"],"colorIpadPro":[513,"color-ipad-pro"],"colorIphone8":[513,"color-iphone-8"],"colorMacbook":[513,"color-macbook"],"colorMacbookPro":[513,"color-macbook-pro"],"display":[513],"imagePosition":[513,"image-position"],"size":[514],"sizeMax":[514,"size-max"],"sizeMin":[514,"size-min"],"src":[513],"type":[513],"height":[32],"innerElId":[32],"mockup":[32],"outerElId":[32],"parent":[32],"parentHeight":[32],"width":[32]},[[9,"resize","onResize"]]]);
const SpxNavigation = /*@__PURE__*/proxyCustomElement(SpxNavigation$1, [1,"spx-navigation",{"childBorder":[513,"child-border"],"childBorderRadius":[513,"child-border-radius"],"childBoxShadow":[513,"child-box-shadow"],"childChildGap":[513,"child-child-gap"],"childGap":[513,"child-gap"],"childIcon":[513,"child-icon"],"childIconType":[513,"child-icon-type"],"childIndicatorGap":[513,"child-indicator-gap"],"childItemBackground":[513,"child-item-background"],"childItemBackgroundHover":[513,"child-item-background-hover"],"childItemColor":[513,"child-item-color"],"childItemColorHover":[513,"child-item-color-hover"],"childItemPadding":[513,"child-item-padding"],"childPlacement":[513,"child-placement"],"display":[513],"fontSize":[513,"font-size"],"itemTransitionDuration":[513,"item-transition-duration"],"itemTransitionTimingFunction":[513,"item-transition-timing-function"],"itemUnderline":[516,"item-underline"],"itemUnderlineHover":[516,"item-underline-hover"],"menu":[513],"mobile":[514],"mobileIcon":[513,"mobile-icon"],"mobileIconType":[513,"mobile-icon-type"],"mobileItemBackground":[513,"mobile-item-background"],"mobileItemBackgroundHover":[513,"mobile-item-background-hover"],"mobileItemColor":[513,"mobile-item-color"],"mobileItemColorHover":[513,"mobile-item-color-hover"],"mobileItemNestedMarginLeft":[513,"mobile-item-nested-margin-left"],"mobileItemPadding":[513,"mobile-item-padding"],"mobilePlacement":[513,"mobile-placement"],"parentItemBackground":[513,"parent-item-background"],"parentItemBackgroundHover":[513,"parent-item-background-hover"],"parentItemColor":[513,"parent-item-color"],"parentItemColorHover":[513,"parent-item-color-hover"],"parentItemGap":[513,"parent-item-gap"],"parentItemPadding":[513,"parent-item-padding"],"vertical":[516],"menuArray":[32],"mobileBp":[32]},[[0,"ontouchstart","onClick"],[1,"mouseenter","onClick"],[0,"focusin","onClick"],[9,"resize","onResize"]]]);
const SpxNotation = /*@__PURE__*/proxyCustomElement(SpxNotation$1, [4,"spx-notation",{"animation":[516],"animationDuration":[514,"animation-duration"],"autoplay":[516],"brackets":[513],"color":[513],"display":[513],"delay":[514],"group":[516],"iterations":[514],"multiline":[516],"padding":[514],"strokeWidth":[514,"stroke-width"],"type":[513],"annotation":[32]}]);
const SpxOffset = /*@__PURE__*/proxyCustomElement(SpxOffset$1, [1,"spx-offset",{"display":[513],"target":[513]},[[9,"resize","onResize"]]]);
const SpxScrollspy = /*@__PURE__*/proxyCustomElement(SpxScrollspy$2, [0,"spx-scrollspy",{"contentClass":[513,"content-class"],"display":[513],"navClass":[513,"nav-class"],"offset":[520],"scrolling":[514],"target":[513],"urlChange":[516,"url-change"],"myGumshoe":[32]},[[4,"gumshoeActivate","onLinkActive"],[4,"gumshoeDeactivate","onLinkDeactivate"]]]);
const SpxShare = /*@__PURE__*/proxyCustomElement(SpxShare$1, [1,"spx-share",{"classItem":[513,"class-item"],"display":[513],"fontSize":[513,"font-size"],"fontSizeMax":[514,"font-size-max"],"fontSizeMin":[514,"font-size-min"],"itemBackground":[513,"item-background"],"itemBorderRadius":[513,"item-border-radius"],"itemColor":[513,"item-color"],"itemFilterHover":[513,"item-filter-hover"],"itemGap":[513,"item-gap"],"itemGapMin":[514,"item-gap-min"],"itemGapMax":[514,"item-gap-max"],"itemPadding":[513,"item-padding"],"itemPaddingMin":[514,"item-padding-min"],"itemPaddingMax":[514,"item-padding-max"],"itemSize":[513,"item-size"],"itemSizeMin":[514,"item-size-min"],"itemSizeMax":[514,"item-size-max"],"itemTransitionDuration":[513,"item-transition-duration"],"itemTransitionTimingFunction":[513,"item-transition-timing-function"],"styling":[513],"target":[513],"theme":[513],"vertical":[516],"location":[32]}]);
const SpxSlider = /*@__PURE__*/proxyCustomElement(SpxScrollspy$1, [1,"spx-slider",{"autoheight":[516],"autoplay":[516],"autoplayDelay":[514,"autoplay-delay"],"autoplayDisableOnInteraction":[516,"autoplay-disable-on-interaction"],"centeredSlides":[516,"centered-slides"],"display":[513],"effect":[513],"imageObjectFit":[513,"image-object-fit"],"images":[513],"imageSize":[513,"image-size"],"imageSrc":[513,"image-src"],"lazy":[516],"lazyLoadPrevNext":[514,"lazy-load-prev-next"],"loop":[516],"maxHeight":[513,"max-height"],"navigation":[516],"navigationBackdropFilter":[513,"navigation-backdrop-filter"],"navigationBackground":[513,"navigation-background"],"navigationBackgroundHover":[513,"navigation-background-hover"],"navigationBorderRadius":[513,"navigation-border-radius"],"navigationColor":[513,"navigation-color"],"navigationDistanceX":[513,"navigation-distance-x"],"navigationIconNext":[513,"navigation-icon-next"],"navigationIconPrev":[513,"navigation-icon-prev"],"navigationIconType":[513,"navigation-icon-type"],"navigationPadding":[513,"navigation-padding"],"navigationSize":[513,"navigation-size"],"navigationTransitionDuration":[513,"navigation-transition-duration"],"navigationTransitionTimingFunction":[513,"navigation-transition-timing-function"],"pagination":[513],"paginationBackdropFilter":[513,"pagination-backdrop-filter"],"paginationBackground":[513,"pagination-background"],"paginationBulletsBackground":[513,"pagination-bullets-background"],"paginationBulletsBackgroundActive":[513,"pagination-bullets-background-active"],"paginationBulletsClickable":[516,"pagination-bullets-clickable"],"paginationBulletsDynamic":[516,"pagination-bullets-dynamic"],"paginationBulletsDynamicAmount":[514,"pagination-bullets-dynamic-amount"],"paginationBulletsSize":[513,"pagination-bullets-size"],"paginationBulletsSpaceBetween":[513,"pagination-bullets-space-between"],"paginationTransitionDuration":[513,"pagination-transition-duration"],"paginationTransitionTimingFunction":[513,"pagination-transition-timing-function"],"prevNextFilter":[513,"prev-next-filter"],"slideMessageFirst":[513,"slide-message-first"],"slideMessageLast":[513,"slide-message-last"],"slideMessageNext":[513,"slide-message-next"],"slideMessagePrevious":[513,"slide-message-previous"],"slidesPerView":[514,"slides-per-view"],"spaceBetween":[514,"space-between"],"speed":[514],"content":[32],"counter":[32],"imagesArray":[32],"swiperBreakpoints":[32],"swiperStyle":[32]}]);
const SpxSlideshow = /*@__PURE__*/proxyCustomElement(SpxSlideshow$1, [1,"spx-slideshow",{"display":[513],"duration":[513],"gap":[513],"images":[513],"height":[513],"imageSize":[513,"image-size"],"imageSrc":[513,"image-src"],"lazy":[516],"maxWidth":[513,"max-width"],"objectFit":[513,"object-fit"],"overflow":[513],"content":[32],"imagesArray":[32],"offsetWidth":[32]},[[9,"resize","onResize"]]]);
const SpxSnackbar = /*@__PURE__*/proxyCustomElement(SpxSnackbar$1, [1,"spx-snackbar",{"animationDelay":[513,"animation-delay"],"animationDuration":[513,"animation-duration"],"background":[513],"border":[513],"borderRadius":[513,"border-radius"],"buttonBackground":[513,"button-background"],"buttonBackgroundHover":[513,"button-background-hover"],"buttonTransitionDuration":[513,"button-transition-duration"],"buttonTransitionTimingFunction":[513,"button-transition-timing-function"],"classButton":[513,"class-button"],"classText":[513,"class-text"],"closeable":[516],"color":[513],"display":[513],"distanceX":[513,"distance-x"],"distanceY":[513,"distance-y"],"fixed":[516],"fontSize":[513,"font-size"],"fontSizeMax":[514,"font-size-max"],"fontSizeMin":[514,"font-size-min"],"identifier":[513],"padding":[513],"paddingMin":[514,"padding-min"],"paddingMax":[514,"padding-max"],"position":[513],"positionCss":[513,"position-css"],"reverse":[516],"spaceBetween":[513,"space-between"],"styling":[513],"target":[513],"text":[513],"zIndex":[514,"z-index"],"containerClass":[32],"positionArray":[32]}]);
const SpxTextPath = /*@__PURE__*/proxyCustomElement(SpxTextPath$1, [1,"spx-text-path",{"display":[513],"spaceBetween":[513,"space-between"],"startOffset":[513,"start-offset"],"text":[513],"textColor":[513,"text-color"],"textFontWeight":[513,"text-font-weight"],"textFontSize":[513,"text-font-size"],"textTransform":[513,"text-transform"]}]);
const SpxTypewriter = /*@__PURE__*/proxyCustomElement(SpxTypewriter$1, [0,"spx-typewriter",{"autoStart":[516,"auto-start"],"delay":[520],"deleteSpeed":[520,"delete-speed"],"display":[513],"loop":[516],"text":[513],"typewriter":[32]}]);
const defineCustomElements = (opts) => {
  if (typeof customElements !== 'undefined') {
    [
      IonIcon,
  SpxAccordion,
  SpxAnimate,
  SpxBlockDocs,
  SpxClassToggle,
  SpxCode,
  SpxControlColor,
  SpxControlGroup,
  SpxControlLabel,
  SpxControlSelect,
  SpxControlSlider,
  SpxControlSwitch,
  SpxControlText,
  SpxEdit,
  SpxEditButton,
  SpxEditor,
  SpxGroup,
  SpxIcon,
  SpxIframe,
  SpxImageComparison,
  SpxLightbox,
  SpxMasonry,
  SpxMockup,
  SpxNavigation,
  SpxNotation,
  SpxOffset,
  SpxScrollspy,
  SpxShare,
  SpxSlider,
  SpxSlideshow,
  SpxSnackbar,
  SpxTextPath,
  SpxTypewriter
    ].forEach(cmp => {
      if (!customElements.get(cmp.is)) {
        customElements.define(cmp.is, cmp, opts);
      }
    });
  }
};

export { IonIcon, SpxAccordion, SpxAnimate, SpxBlockDocs, SpxClassToggle, SpxCode, SpxControlColor, SpxControlGroup, SpxControlLabel, SpxControlSelect, SpxControlSlider, SpxControlSwitch, SpxControlText, SpxEdit, SpxEditButton, SpxEditor, SpxGroup, SpxIcon, SpxIframe, SpxImageComparison, SpxLightbox, SpxMasonry, SpxMockup, SpxNavigation, SpxNotation, SpxOffset, SpxScrollspy, SpxShare, SpxSlider, SpxSlideshow, SpxSnackbar, SpxTextPath, SpxTypewriter, defineCustomElements };
